type ClassLike = {
  class: Packages.java.lang.Class<any>;
  [Symbol.hasInstance](v): boolean
 }
type isAny<T> = (T extends never ? true : false) extends false ? false : true;
type CombineTypes<A> = (
  A extends [infer B, ...infer Rest] ?
    isAny<B> extends true ?
      CombineTypes<Rest>
      : CombineTypes<Rest> extends never ? B : B & CombineTypes<Rest>
    : A extends [infer B] ?
      isAny<B> extends true ? never : B
  : never
)
type char   = number & {};
type byte   = number & {};
type short  = number & {};
type int    = number & {};
type long   = number | BigInt;
type float  = number & {};
type double = number & {};
type Function$$JS = Function;
declare module Packages {
  module jdk {
    module incubator {
      module vector {
        interface _AbstractMask$$static<E> extends ClassLike {
          _allTrueHelper(bits: boolean[]): boolean;
          _anyTrueHelper(bits: boolean[]): boolean;
          _firstTrueHelper(bits: boolean[]): int;
          _lastTrueHelper(bits: boolean[]): int;
          _toLongHelper(bits: boolean[]): long;
          _trueCountHelper(bits: boolean[]): int;
          _new(bits: boolean[]): AbstractMask<E>;
        }
        let AbstractMask: _AbstractMask$$static<E>;
        interface _AbstractMask<E> {
          andNot(m: VectorMask<E>): VectorMask<E>;
          _bOp(a0: VectorMask<E>, a1: AbstractMask$MBinOp): AbstractMask<E>;
          check<F>(elementType: java.lang.Class<F>): VectorMask<F>;
          check<F>(species: VectorSpecies<F>): VectorMask<F>;
          _check<F>(maskClass: java.lang.Class<VectorMask<F>>, vector: Vector<F>): VectorMask<F>;
          _checkIndex0(offset: int, length: int, iota: Vector<E>, vlength: int): VectorMask<E>;
          _checkIndex0(offset: long, a1: long, length: Vector<E>, a3: int): VectorMask<E>;
          _checkIndexByLane(offset: int, length: int, iota: Vector<E>, esize: int): void;
          _checkIndexByLane(offset: long, a1: long, length: Vector<E>, a3: int): void;
          _checkIndexFailed(offset: long, a1: int, lane: long, length: int): java.lang.IndexOutOfBoundsException;
          eq(m: VectorMask<E>): VectorMask<E>;
          _getBits(): boolean[];
          indexInRange(offset: int, limit: int): VectorMask<E>;
          indexInRange(offset: long, a1: long): VectorMask<E>;
          _indexPartiallyInRange(offset: int, limit: int): VectorMask<E>;
          _indexPartiallyInRange(offset: long, a1: long): VectorMask<E>;
          _indexPartiallyInUpperRange(a0: long, a1: long): VectorMask<E>;
          intoArray(bits: boolean[], i: int): void;
          laneIsSet(i: int): boolean;
          _sameSpecies<F>(maskClass: java.lang.Class<VectorMask<F>>, vector: Vector<F>): boolean;
          toArray(): boolean[];
          _toVectorTemplate(): AbstractVector<E>;
          _uOp(a0: AbstractMask$MUnOp): AbstractMask<E>;
          vectorSpecies(): VectorSpecies<E>;
          _vspecies(): AbstractSpecies<E>;
        }
        interface AbstractMask<E> extends CombineTypes<[_AbstractMask<E>, VectorMask<E>]> {}
        interface _AbstractMask$MBinOp$$static extends ClassLike {
        }
        let AbstractMask$MBinOp: _AbstractMask$MBinOp$$static;
        interface _AbstractMask$MBinOp {
          apply(a0: int, a1: boolean, a2: boolean): boolean;
(a0: int, a1: boolean, a2: boolean): boolean;
        }
        interface AbstractMask$MBinOp extends CombineTypes<[_AbstractMask$MBinOp, java.lang.Object]> {}
        interface _AbstractMask$MUnOp$$static extends ClassLike {
        }
        let AbstractMask$MUnOp: _AbstractMask$MUnOp$$static;
        interface _AbstractMask$MUnOp {
          apply(a0: int, a1: boolean): boolean;
(a0: int, a1: boolean): boolean;
        }
        interface AbstractMask$MUnOp extends CombineTypes<[_AbstractMask$MUnOp, java.lang.Object]> {}
        interface _AbstractShuffle$$static<E> extends ClassLike {
          _checkIndex0(index: int, laneCount: int, mode: byte): int;
          _checkIndexFailed(index: int, laneCount: int): java.lang.IndexOutOfBoundsException;
          _indexesInRange(reorder: byte[]): boolean;
          _partiallyWrapIndex(index: int, laneCount: int): int;
          _prepare(length: int, reorder: int[], offset: int): byte[];
          _prepare(length: int, f: java.util.function.IntUnaryOperator): byte[];
          _IDENTITY: java.util.function.IntUnaryOperator;
          _new(length: int, reorder: byte[]): AbstractShuffle<E>;
          _new(length: int, reorder: int[]): AbstractShuffle<E>;
          _new(length: int, reorder: int[], offset: int): AbstractShuffle<E>;
          _new(length: int, f: java.util.function.IntUnaryOperator): AbstractShuffle<E>;
        }
        let AbstractShuffle: _AbstractShuffle$$static<E>;
        interface _AbstractShuffle<E> {
          check<F>(species: VectorSpecies<F>): VectorShuffle<F>;
          checkIndex(index: int): int;
          checkIndexes(): VectorShuffle<E>;
          intoArray(a: int[], offset: int): void;
          laneIsValid(): VectorMask<E>;
          _reorder(): byte[];
          toArray(): int[];
          _toVectorTemplate(): AbstractVector<E>;
          vectorSpecies(): VectorSpecies<E>;
          _vspecies(): AbstractSpecies<E>;
(): AbstractSpecies<E>;
          wrapAndRebuild(oldReorder: byte[]): VectorShuffle<E>;
          wrapIndex(index: int): int;
          wrapIndexes(): VectorShuffle<E>;
        }
        interface AbstractShuffle<E> extends CombineTypes<[_AbstractShuffle<E>, VectorShuffle<E>]> {}
        interface _AbstractSpecies$$static<E> extends ClassLike {
          _badArrayBits(iv: any, isInt: boolean, cv: long): java.lang.IllegalArgumentException;
          _checkFailed(what: any, required: any): java.lang.ClassCastException;
          _computeSpecies(laneType: LaneType, shape: VectorShape): AbstractSpecies<any>;
          _findSpecies<E>(elementType: java.lang.Class<E>, laneType: LaneType, shape: VectorShape): AbstractSpecies<E>;
          _findSpecies(laneType: LaneType, shape: VectorShape): AbstractSpecies<any>;
          _CACHES: AbstractSpecies<any>[][];
          _new(vectorShape: VectorShape, laneType: LaneType, vectorType: java.lang.Class<AbstractVector<E>>, maskType: java.lang.Class<AbstractMask<E>>, vectorFactory: java.util.function.Function<any,AbstractVector<E>>): AbstractSpecies<E>;
        }
        let AbstractSpecies: _AbstractSpecies$$static<E>;
        interface _AbstractSpecies<E> {
          _asFloating(): AbstractSpecies<any>;
          _asIntegral(): AbstractSpecies<any>;
          _badElementBits(iv: long, a1: any): java.lang.IllegalArgumentException;
          _broadcastBits(a0: long): AbstractVector<E>;
          _byteSpecies(): AbstractSpecies<byte>;
          check<F>(elementType: java.lang.Class<F>): VectorSpecies<F>;
          _check(laneType: LaneType): AbstractSpecies<E>;
          _check0<F>(elementType: java.lang.Class<F>): AbstractSpecies<F>;
          _checkScale(scale: int): void;
          _checkScaleFailed(scale: int): java.lang.IllegalArgumentException;
          _dummyVector(): AbstractVector<E>;
          _elementByteSize(): int;
          elementSize(): int;
          elementType(): java.lang.Class<E>;
          equals(obj: any): boolean;
          _fromIntValues(a0: int[]): Vector<E>;
          _genericElementType(): java.lang.Class<E>;
          hashCode(): int;
          indexInRange(offset: int, limit: int): VectorMask<E>;
          indexInRange(offset: long, a1: long): VectorMask<E>;
          _indexShape(): VectorShape;
          _indexSpecies(): AbstractSpecies<int>;
          _iota(): AbstractVector<E>;
          _iotaArray(): any;
          iotaShuffle(start: int, step: int, wrap: boolean): VectorShuffle<E>;
          _laneCount(): int;
          _laneCountLog2(): int;
          length(): int;
          loadMask(bits: boolean[], offset: int): VectorMask<E>;
          _longToElementBits(a0: long): long;
          loopBound(length: int): int;
          loopBound(length: long): long;
          _makeDummyVector(): AbstractVector<E>;
          _makeSwapBytesShuffle(): AbstractShuffle<byte>;
          _maskFactory(bits: boolean[]): AbstractMask<E>;
          maskType(): java.lang.Class<AbstractMask<E>>;
          _opm(f: AbstractSpecies$FOpm): AbstractMask<E>;
          partLimit(toSpecies: VectorSpecies<any>, lanewise: boolean): int;
          _rvOp(a0: AbstractSpecies$RVOp): AbstractVector<E>;
          shuffleFromArray(sourceIndexes: int[], offset: int): VectorShuffle<E>;
          shuffleFromOp(fn: java.util.function.IntUnaryOperator): VectorShuffle<E>;
          shuffleFromValues(sourceIndexes: int[]): VectorShuffle<E>;
          shuffleFromValues(...sourceIndexes: int[]): VectorShuffle<E>;
          _swapBytesShuffle(): AbstractShuffle<byte>;
          toString(): string;
          vectorBitSize(): int;
          vectorByteSize(): int;
          vectorShape(): VectorShape;
          vectorType(): java.lang.Class<AbstractVector<E>>;
          withLanes<F>(newType: java.lang.Class<F>): VectorSpecies<F>;
          _withLanes(newType: LaneType): AbstractSpecies<any>;
          withShape(newShape: VectorShape): VectorSpecies<E>;
          zero(): AbstractVector<E>;
          zero(): Vector;
          _dummyVector: AbstractVector<E>;
          _indexShape: VectorShape;
          _indexSpecies: AbstractSpecies<int>;
          _laneCount: int;
          _laneCountLog2P1: int;
          _laneType: LaneType;
          _maskType: java.lang.Class<AbstractMask<E>>;
          _maxScale: int;
          _minScale: int;
          _swapBytesShuffle: AbstractShuffle<byte>;
          _vectorBitSize: int;
          _vectorByteSize: int;
          _vectorFactory: java.util.function.Function<any,AbstractVector<E>>;
          _vectorShape: VectorShape;
          _vectorType: java.lang.Class<AbstractVector<E>>;
        }
        interface AbstractSpecies<E> extends CombineTypes<[_AbstractSpecies<E>, jdk.internal.vm.vector.VectorSupport$VectorSpecies<E>, VectorSpecies<E>]> {}
        interface _AbstractSpecies$FOpm$$static extends ClassLike {
        }
        let AbstractSpecies$FOpm: _AbstractSpecies$FOpm$$static;
        interface _AbstractSpecies$FOpm {
          apply(a0: int): boolean;
(a0: int): boolean;
        }
        interface AbstractSpecies$FOpm extends CombineTypes<[_AbstractSpecies$FOpm, java.lang.Object]> {}
        interface _AbstractSpecies$RVOp$$static extends ClassLike {
        }
        let AbstractSpecies$RVOp: _AbstractSpecies$RVOp$$static;
        interface _AbstractSpecies$RVOp {
          apply(a0: int): long;
(a0: int): long;
        }
        interface AbstractSpecies$RVOp extends CombineTypes<[_AbstractSpecies$RVOp, java.lang.Object]> {}
        interface _AbstractVector$$static<E> extends ClassLike {
          _partInRange(resSizeLog2: int, phySizeLog2: int, part: int): boolean;
          _partInRangeSlow(resSizeLog2: int, phySizeLog2: int, part: int): boolean;
          _shapeChangeOrigin(dsp: AbstractSpecies<any>, rsp: AbstractSpecies<any>, lanewise: boolean, part: int): int;
          _wrongPart(dsp: AbstractSpecies<any>, rsp: AbstractSpecies<any>, lanewise: boolean, part: int): java.lang.ArrayIndexOutOfBoundsException;
          _NATIVE_ENDIAN: java.nio.ByteOrder;
          _OFFSET_IN_RANGE: int;
          _OFFSET_OUT_OF_RANGE: int;
          _REGISTER_ENDIAN: java.nio.ByteOrder;
          _new(bits: any): AbstractVector<E>;
        }
        let AbstractVector: _AbstractVector$$static<E>;
        interface _AbstractVector<E> {
          _asByteVectorRaw(): ByteVector;
          _asByteVectorRawTemplate(): ByteVector;
          _asVectorRaw(a0: LaneType): AbstractVector<any>;
          _asVectorRawTemplate(laneType: LaneType): AbstractVector<any>;
          castShape<F>(toSpecies: VectorSpecies<F>, part: int): Vector<F>;
          check<F>(species: VectorSpecies<F>): Vector<F>;
          check<F>(elementType: java.lang.Class<F>): Vector<F>;
          _check<F>(other: Vector<F>): AbstractVector<F>;
          _check0<F>(species: VectorSpecies<F>): AbstractVector<F>;
          _check0<F>(elementType: java.lang.Class<F>): AbstractVector<F>;
          convert<F>(conv: VectorOperators$Conversion<E,F>, part: int): Vector<F>;
          _convert0<F>(kind: char, rsp: AbstractSpecies<F>): AbstractVector<F>;
          convertShape<F>(a0: VectorOperators$Conversion<E,F>, a1: VectorSpecies<F>, a2: int): Vector<F>;
          _convertShapeTemplate<F>(conv: VectorOperators$Conversion<E,F>, toSpecies: VectorSpecies<F>, part: int): AbstractVector<F>;
          _defaultCast<F>(dsp: AbstractSpecies<F>): AbstractVector<F>;
          _defaultReinterpret<F>(rsp: AbstractSpecies<F>): AbstractVector<F>;
          _defaultUCast<F>(dsp: AbstractSpecies<F>): AbstractVector<F>;
          _divZeroException(): java.lang.ArithmeticException;
          _fromMemorySegment0(a0: java.lang.foreign.MemorySegment, a1: long): AbstractVector<E>;
          _iotaShuffle(): AbstractShuffle<E>;
          _iotaShuffle(a0: int, a1: int, a2: boolean): AbstractShuffle<E>;
          maskAll(bit: boolean): VectorMask<E>;
          _maskFromArray(a0: boolean[]): AbstractMask<E>;
          _maybeSwap(a0: java.nio.ByteOrder): AbstractVector<E>;
          reinterpretAsDoubles(): DoubleVector;
          reinterpretAsFloats(): FloatVector;
          reinterpretAsInts(): IntVector;
          reinterpretAsLongs(): LongVector;
          reinterpretAsShorts(): ShortVector;
          _reinterpretShapeTemplate<F>(toSpecies: VectorSpecies<F>, part: int): AbstractVector<F>;
          _sameSpecies(other: Vector<any>): boolean;
          _sameSpecies(species: VectorSpecies<any>): boolean;
          _shuffleFromArray(a0: int[], a1: int): AbstractShuffle<E>;
          _shuffleFromBytes(a0: byte[]): AbstractShuffle<E>;
          _shuffleFromOp(a0: java.util.function.IntUnaryOperator): AbstractShuffle<E>;
          slice(a0: int, a1: Vector<E>): AbstractVector<E>;
          slice(a0: int): AbstractVector<E>;
          slice(a0: int): Vector;
          slice(a0: int, a1: Vector): Vector;
          species(): VectorSpecies<E>;
          _swapBytesShuffle(): VectorShuffle<byte>;
          _vspecies(): AbstractSpecies<E>;
        }
        interface AbstractVector<E> extends CombineTypes<[_AbstractVector<E>, Vector<E>]> {}
        interface _Byte128Vector$$static extends ClassLike {
          _ETYPE: java.lang.Class<byte>;
          _IOTA: Byte128Vector;
          _VCLASS: java.lang.Class<Byte128Vector>;
          _VLENGTH: int;
          _VSHAPE: VectorShape;
          _VSIZE: int;
          _VSPECIES: ByteVector$ByteSpecies;
          _ZERO: Byte128Vector;
          _new(v: byte[]): Byte128Vector;
          _new(v: any): Byte128Vector;
        }
        let Byte128Vector: _Byte128Vector$$static;
        interface _Byte128Vector {
          addIndex(scale: int): Byte128Vector;
          addIndex(a0: int): ByteVector;
          addIndex(a0: int): Vector;
          _asByteVectorRaw(): Byte128Vector;
          _asByteVectorRaw(): ByteVector;
          _asVectorRaw(laneType: LaneType): AbstractVector<any>;
          _bOp(v: Vector<byte>, f: ByteVector$FBinOp): Byte128Vector;
          _bOp(v: Vector<byte>, m: VectorMask<byte>, f: ByteVector$FBinOp): Byte128Vector;
          _bOp(a0: Vector, a1: VectorMask, a2: ByteVector$FBinOp): ByteVector;
          _bOp(a0: Vector, a1: ByteVector$FBinOp): ByteVector;
          bitSize(): int;
          blend(v: Vector<byte>, m: VectorMask<byte>): Byte128Vector;
          blend(a0: Vector, a1: VectorMask): ByteVector;
          blend(a0: Vector, a1: VectorMask): Vector;
          broadcast(e: byte): Byte128Vector;
          broadcast(e: long): Byte128Vector;
          broadcast(a0: long): ByteVector;
          broadcast(a0: byte): ByteVector;
          broadcast(a0: long): Vector;
          byteSize(): int;
          compare(op: VectorOperators$Comparison, v: Vector<byte>): Byte128Vector$Byte128Mask;
          compare(op: VectorOperators$Comparison, s: byte): Byte128Vector$Byte128Mask;
          compare(op: VectorOperators$Comparison, s: long): Byte128Vector$Byte128Mask;
          compare(op: VectorOperators$Comparison, v: Vector<byte>, m: VectorMask<byte>): Byte128Vector$Byte128Mask;
          compare(a0: VectorOperators$Comparison, a1: long): VectorMask;
          compare(a0: VectorOperators$Comparison, a1: byte): VectorMask;
          compare(a0: VectorOperators$Comparison, a1: Vector): VectorMask;
          compare(a0: VectorOperators$Comparison, a1: Vector, a2: VectorMask): VectorMask;
          compress(m: VectorMask<byte>): Byte128Vector;
          compress(a0: VectorMask): ByteVector;
          compress(a0: VectorMask): Vector;
          convertShape<F>(conv: VectorOperators$Conversion<byte,F>, rsp: VectorSpecies<F>, part: int): Vector<F>;
          elementSize(): int;
          elementType(): java.lang.Class<byte>;
          expand(m: VectorMask<byte>): Byte128Vector;
          expand(a0: VectorMask): ByteVector;
          expand(a0: VectorMask): Vector;
          _fromArray0(a: byte[], offset: int): ByteVector;
          _fromArray0(a: byte[], offset: int, m: VectorMask<byte>, offsetInRange: int): ByteVector;
          _fromBooleanArray0(a: boolean[], offset: int): ByteVector;
          _fromBooleanArray0(a: boolean[], offset: int, m: VectorMask<byte>, offsetInRange: int): ByteVector;
          _fromMemorySegment0(ms: java.lang.foreign.MemorySegment, offset: long): ByteVector;
          _fromMemorySegment0(ms: java.lang.foreign.MemorySegment, offset: long, a2: VectorMask<byte>, m: int): ByteVector;
          _fromMemorySegment0(a0: java.lang.foreign.MemorySegment, a1: long): AbstractVector;
          _intoArray0(a: byte[], offset: int): void;
          _intoArray0(a: byte[], offset: int, m: VectorMask<byte>): void;
          _intoBooleanArray0(a: boolean[], offset: int, m: VectorMask<byte>): void;
          _intoMemorySegment0(ms: java.lang.foreign.MemorySegment, offset: long, a2: VectorMask<byte>): void;
          _iotaShuffle(): Byte128Vector$Byte128Shuffle;
          _iotaShuffle(start: int, step: int, wrap: boolean): Byte128Vector$Byte128Shuffle;
          _iotaShuffle(a0: int, a1: int, a2: boolean): AbstractShuffle;
          _iotaShuffle(): AbstractShuffle;
          lane(i: int): byte;
          laneHelper(i: int): byte;
          lanewise(op: VectorOperators$Unary): Byte128Vector;
          lanewise(op: VectorOperators$Unary, m: VectorMask<byte>): Byte128Vector;
          lanewise(op: VectorOperators$Binary, v: Vector<byte>): Byte128Vector;
          lanewise(op: VectorOperators$Binary, v: Vector<byte>, m: VectorMask<byte>): Byte128Vector;
          lanewise(op: VectorOperators$Ternary, v1: Vector<byte>, v2: Vector<byte>): Byte128Vector;
          lanewise(op: VectorOperators$Ternary, v1: Vector<byte>, v2: Vector<byte>, m: VectorMask<byte>): Byte128Vector;
          lanewise(a0: VectorOperators$Ternary, a1: Vector, a2: Vector, a3: VectorMask): ByteVector;
          lanewise(a0: VectorOperators$Ternary, a1: Vector, a2: Vector): ByteVector;
          lanewise(a0: VectorOperators$Binary, a1: Vector, a2: VectorMask): ByteVector;
          lanewise(a0: VectorOperators$Binary, a1: Vector): ByteVector;
          lanewise(a0: VectorOperators$Unary, a1: VectorMask): ByteVector;
          lanewise(a0: VectorOperators$Unary): ByteVector;
          lanewise(a0: VectorOperators$Ternary, a1: Vector, a2: Vector, a3: VectorMask): Vector;
          lanewise(a0: VectorOperators$Ternary, a1: Vector, a2: Vector): Vector;
          lanewise(a0: VectorOperators$Binary, a1: Vector, a2: VectorMask): Vector;
          lanewise(a0: VectorOperators$Binary, a1: Vector): Vector;
          lanewise(a0: VectorOperators$Unary, a1: VectorMask): Vector;
          lanewise(a0: VectorOperators$Unary): Vector;
          _lanewiseShift(op: VectorOperators$Binary, e: int): Byte128Vector;
          _lanewiseShift(op: VectorOperators$Binary, e: int, m: VectorMask<byte>): Byte128Vector;
          _lanewiseShift(a0: VectorOperators$Binary, a1: int, a2: VectorMask): ByteVector;
          _lanewiseShift(a0: VectorOperators$Binary, a1: int): ByteVector;
          length(): int;
          _maskFromArray(bits: boolean[]): Byte128Vector$Byte128Mask;
          _maskFromArray(a0: boolean[]): AbstractMask;
          _rOp(v: byte, m: VectorMask<byte>, f: ByteVector$FBinOp): byte;
          rearrange(s: VectorShuffle<byte>): Byte128Vector;
          rearrange(shuffle: VectorShuffle<byte>, m: VectorMask<byte>): Byte128Vector;
          rearrange(s: VectorShuffle<byte>, v: Vector<byte>): Byte128Vector;
          rearrange(a0: VectorShuffle, a1: Vector): ByteVector;
          rearrange(a0: VectorShuffle, a1: VectorMask): ByteVector;
          rearrange(a0: VectorShuffle): ByteVector;
          rearrange(a0: VectorShuffle, a1: Vector): Vector;
          rearrange(a0: VectorShuffle, a1: VectorMask): Vector;
          rearrange(a0: VectorShuffle): Vector;
          reduceLanes(op: VectorOperators$Associative): byte;
          reduceLanes(op: VectorOperators$Associative, m: VectorMask<byte>): byte;
          reduceLanesToLong(op: VectorOperators$Associative): long;
          reduceLanesToLong(op: VectorOperators$Associative, m: VectorMask<byte>): long;
          reinterpretShape<F>(toSpecies: VectorSpecies<F>, part: int): Vector<F>;
          selectFrom(v: Vector<byte>): Byte128Vector;
          selectFrom(v: Vector<byte>, m: VectorMask<byte>): Byte128Vector;
          selectFrom(a0: Vector, a1: VectorMask): ByteVector;
          selectFrom(a0: Vector): ByteVector;
          selectFrom(a0: Vector, a1: VectorMask): Vector;
          selectFrom(a0: Vector): Vector;
          shape(): VectorShape;
          _shuffleFromArray(indexes: int[], i: int): Byte128Vector$Byte128Shuffle;
          _shuffleFromArray(a0: int[], a1: int): AbstractShuffle;
          _shuffleFromBytes(reorder: byte[]): Byte128Vector$Byte128Shuffle;
          _shuffleFromBytes(a0: byte[]): AbstractShuffle;
          _shuffleFromOp(fn: java.util.function.IntUnaryOperator): Byte128Vector$Byte128Shuffle;
          _shuffleFromOp(a0: java.util.function.IntUnaryOperator): AbstractShuffle;
          slice(origin: int, v: Vector<byte>): Byte128Vector;
          slice(origin: int): Byte128Vector;
          slice(a0: int): ByteVector;
          slice(a0: int, a1: Vector): ByteVector;
          slice(a0: int): AbstractVector;
          slice(a0: int, a1: Vector): AbstractVector;
          slice(a0: int): Vector;
          slice(a0: int, a1: Vector): Vector;
          _tOp(v1: Vector<byte>, v2: Vector<byte>, f: ByteVector$FTriOp): Byte128Vector;
          _tOp(v1: Vector<byte>, v2: Vector<byte>, m: VectorMask<byte>, f: ByteVector$FTriOp): Byte128Vector;
          _tOp(a0: Vector, a1: Vector, a2: VectorMask, a3: ByteVector$FTriOp): ByteVector;
          _tOp(a0: Vector, a1: Vector, a2: ByteVector$FTriOp): ByteVector;
          test(op: VectorOperators$Test): Byte128Vector$Byte128Mask;
          test(op: VectorOperators$Test, m: VectorMask<byte>): Byte128Vector$Byte128Mask;
          test(a0: VectorOperators$Test, a1: VectorMask): VectorMask;
          test(a0: VectorOperators$Test): VectorMask;
          toShuffle(): VectorShuffle<byte>;
          _uOp(f: ByteVector$FUnOp): Byte128Vector;
          _uOp(m: VectorMask<byte>, f: ByteVector$FUnOp): Byte128Vector;
          _uOp(a0: VectorMask, a1: ByteVector$FUnOp): ByteVector;
          _uOp(a0: ByteVector$FUnOp): ByteVector;
          unslice(origin: int, w: Vector<byte>, part: int): Byte128Vector;
          unslice(origin: int, w: Vector<byte>, part: int, m: VectorMask<byte>): Byte128Vector;
          unslice(origin: int): Byte128Vector;
          unslice(a0: int): ByteVector;
          unslice(a0: int, a1: Vector, a2: int, a3: VectorMask): ByteVector;
          unslice(a0: int, a1: Vector, a2: int): ByteVector;
          unslice(a0: int): Vector;
          unslice(a0: int, a1: Vector, a2: int, a3: VectorMask): Vector;
          unslice(a0: int, a1: Vector, a2: int): Vector;
          _vec(): byte[];
          _vectorFactory(vec: byte[]): Byte128Vector;
          _vectorFactory(a0: byte[]): ByteVector;
          vspecies(): ByteVector$ByteSpecies;
          vspecies(): AbstractSpecies;
          withLane(i: int, e: byte): Byte128Vector;
          withLane(a0: int, a1: byte): ByteVector;
          withLaneHelper(i: int, e: byte): Byte128Vector;
        }
        interface Byte128Vector extends CombineTypes<[_Byte128Vector, jdk.incubator.vector.ByteVector]> {}
        interface _Byte128Vector$Byte128Mask$$static extends ClassLike {
          _maskAll(bit: boolean): Byte128Vector$Byte128Mask;
          _prepare(bits: boolean[], offset: int): boolean[];
          _prepare(val: boolean): boolean[];
          _ETYPE: java.lang.Class<byte>;
          _FALSE_MASK: Byte128Vector$Byte128Mask;
          _TRUE_MASK: Byte128Vector$Byte128Mask;
          _VLENGTH: int;
          _new(bits: boolean[]): Byte128Vector$Byte128Mask;
          _new(bits: boolean[], offset: int): Byte128Vector$Byte128Mask;
          _new(val: boolean): Byte128Vector$Byte128Mask;
        }
        let Byte128Vector$Byte128Mask: _Byte128Vector$Byte128Mask$$static;
        interface _Byte128Vector$Byte128Mask {
          allTrue(): boolean;
          and(mask: VectorMask<byte>): Byte128Vector$Byte128Mask;
          and(a0: VectorMask): VectorMask;
          anyTrue(): boolean;
          _bOp(m: VectorMask<byte>, f: AbstractMask$MBinOp): Byte128Vector$Byte128Mask;
          _bOp(a0: VectorMask, a1: AbstractMask$MBinOp): AbstractMask;
          cast<E>(dsp: VectorSpecies<E>): VectorMask<E>;
          compress(): Byte128Vector$Byte128Mask;
          compress(): VectorMask;
          _defaultMaskCast<E>(dsp: AbstractSpecies<E>): VectorMask<E>;
          firstTrue(): int;
          _getBits(): boolean[];
          _indexPartiallyInUpperRange(offset: long, a1: long): Byte128Vector$Byte128Mask;
          _indexPartiallyInUpperRange(a0: long, a1: long): VectorMask;
          lastTrue(): int;
          not(): Byte128Vector$Byte128Mask;
          not(): VectorMask;
          or(mask: VectorMask<byte>): Byte128Vector$Byte128Mask;
          or(a0: VectorMask): VectorMask;
          toLong(): long;
          toVector(): Byte128Vector;
          toVector(): Vector;
          trueCount(): int;
          _uOp(f: AbstractMask$MUnOp): Byte128Vector$Byte128Mask;
          _uOp(a0: AbstractMask$MUnOp): AbstractMask;
          vspecies(): ByteVector$ByteSpecies;
          vspecies(): AbstractSpecies;
          xor(mask: VectorMask<byte>): Byte128Vector$Byte128Mask;
          xor(a0: VectorMask): VectorMask;
        }
        interface Byte128Vector$Byte128Mask extends CombineTypes<[_Byte128Vector$Byte128Mask, AbstractMask<byte>]> {}
        interface _Byte128Vector$Byte128Shuffle$$static extends ClassLike {
          _ETYPE: java.lang.Class<byte>;
          _IOTA: Byte128Vector$Byte128Shuffle;
          _VLENGTH: int;
          _new(reorder: byte[]): Byte128Vector$Byte128Shuffle;
          new(reorder: int[]): Byte128Vector$Byte128Shuffle;
          new(reorder: int[], i: int): Byte128Vector$Byte128Shuffle;
          new(fn: java.util.function.IntUnaryOperator): Byte128Vector$Byte128Shuffle;
        }
        let Byte128Vector$Byte128Shuffle: _Byte128Vector$Byte128Shuffle$$static;
        interface _Byte128Vector$Byte128Shuffle {
          cast<F>(s: VectorSpecies<F>): VectorShuffle<F>;
          rearrange(shuffle: VectorShuffle<byte>): Byte128Vector$Byte128Shuffle;
          rearrange(a0: VectorShuffle): VectorShuffle;
          toVector(): Byte128Vector;
          toVector(): Vector;
          vspecies(): ByteVector$ByteSpecies;
          vspecies(): AbstractSpecies;
        }
        interface Byte128Vector$Byte128Shuffle extends CombineTypes<[_Byte128Vector$Byte128Shuffle, AbstractShuffle<byte>]> {}
        interface _Byte256Vector$$static extends ClassLike {
          _ETYPE: java.lang.Class<byte>;
          _IOTA: Byte256Vector;
          _VCLASS: java.lang.Class<Byte256Vector>;
          _VLENGTH: int;
          _VSHAPE: VectorShape;
          _VSIZE: int;
          _VSPECIES: ByteVector$ByteSpecies;
          _ZERO: Byte256Vector;
          _new(v: byte[]): Byte256Vector;
          _new(v: any): Byte256Vector;
        }
        let Byte256Vector: _Byte256Vector$$static;
        interface _Byte256Vector {
          addIndex(scale: int): Byte256Vector;
          addIndex(a0: int): ByteVector;
          addIndex(a0: int): Vector;
          _asByteVectorRaw(): Byte256Vector;
          _asByteVectorRaw(): ByteVector;
          _asVectorRaw(laneType: LaneType): AbstractVector<any>;
          _bOp(v: Vector<byte>, f: ByteVector$FBinOp): Byte256Vector;
          _bOp(v: Vector<byte>, m: VectorMask<byte>, f: ByteVector$FBinOp): Byte256Vector;
          _bOp(a0: Vector, a1: VectorMask, a2: ByteVector$FBinOp): ByteVector;
          _bOp(a0: Vector, a1: ByteVector$FBinOp): ByteVector;
          bitSize(): int;
          blend(v: Vector<byte>, m: VectorMask<byte>): Byte256Vector;
          blend(a0: Vector, a1: VectorMask): ByteVector;
          blend(a0: Vector, a1: VectorMask): Vector;
          broadcast(e: byte): Byte256Vector;
          broadcast(e: long): Byte256Vector;
          broadcast(a0: long): ByteVector;
          broadcast(a0: byte): ByteVector;
          broadcast(a0: long): Vector;
          byteSize(): int;
          compare(op: VectorOperators$Comparison, v: Vector<byte>): Byte256Vector$Byte256Mask;
          compare(op: VectorOperators$Comparison, s: byte): Byte256Vector$Byte256Mask;
          compare(op: VectorOperators$Comparison, s: long): Byte256Vector$Byte256Mask;
          compare(op: VectorOperators$Comparison, v: Vector<byte>, m: VectorMask<byte>): Byte256Vector$Byte256Mask;
          compare(a0: VectorOperators$Comparison, a1: long): VectorMask;
          compare(a0: VectorOperators$Comparison, a1: byte): VectorMask;
          compare(a0: VectorOperators$Comparison, a1: Vector): VectorMask;
          compare(a0: VectorOperators$Comparison, a1: Vector, a2: VectorMask): VectorMask;
          compress(m: VectorMask<byte>): Byte256Vector;
          compress(a0: VectorMask): ByteVector;
          compress(a0: VectorMask): Vector;
          convertShape<F>(conv: VectorOperators$Conversion<byte,F>, rsp: VectorSpecies<F>, part: int): Vector<F>;
          elementSize(): int;
          elementType(): java.lang.Class<byte>;
          expand(m: VectorMask<byte>): Byte256Vector;
          expand(a0: VectorMask): ByteVector;
          expand(a0: VectorMask): Vector;
          _fromArray0(a: byte[], offset: int): ByteVector;
          _fromArray0(a: byte[], offset: int, m: VectorMask<byte>, offsetInRange: int): ByteVector;
          _fromBooleanArray0(a: boolean[], offset: int): ByteVector;
          _fromBooleanArray0(a: boolean[], offset: int, m: VectorMask<byte>, offsetInRange: int): ByteVector;
          _fromMemorySegment0(ms: java.lang.foreign.MemorySegment, offset: long): ByteVector;
          _fromMemorySegment0(ms: java.lang.foreign.MemorySegment, offset: long, a2: VectorMask<byte>, m: int): ByteVector;
          _fromMemorySegment0(a0: java.lang.foreign.MemorySegment, a1: long): AbstractVector;
          _intoArray0(a: byte[], offset: int): void;
          _intoArray0(a: byte[], offset: int, m: VectorMask<byte>): void;
          _intoBooleanArray0(a: boolean[], offset: int, m: VectorMask<byte>): void;
          _intoMemorySegment0(ms: java.lang.foreign.MemorySegment, offset: long, a2: VectorMask<byte>): void;
          _iotaShuffle(): Byte256Vector$Byte256Shuffle;
          _iotaShuffle(start: int, step: int, wrap: boolean): Byte256Vector$Byte256Shuffle;
          _iotaShuffle(a0: int, a1: int, a2: boolean): AbstractShuffle;
          _iotaShuffle(): AbstractShuffle;
          lane(i: int): byte;
          laneHelper(i: int): byte;
          lanewise(op: VectorOperators$Unary): Byte256Vector;
          lanewise(op: VectorOperators$Unary, m: VectorMask<byte>): Byte256Vector;
          lanewise(op: VectorOperators$Binary, v: Vector<byte>): Byte256Vector;
          lanewise(op: VectorOperators$Binary, v: Vector<byte>, m: VectorMask<byte>): Byte256Vector;
          lanewise(op: VectorOperators$Ternary, v1: Vector<byte>, v2: Vector<byte>): Byte256Vector;
          lanewise(op: VectorOperators$Ternary, v1: Vector<byte>, v2: Vector<byte>, m: VectorMask<byte>): Byte256Vector;
          lanewise(a0: VectorOperators$Ternary, a1: Vector, a2: Vector, a3: VectorMask): ByteVector;
          lanewise(a0: VectorOperators$Ternary, a1: Vector, a2: Vector): ByteVector;
          lanewise(a0: VectorOperators$Binary, a1: Vector, a2: VectorMask): ByteVector;
          lanewise(a0: VectorOperators$Binary, a1: Vector): ByteVector;
          lanewise(a0: VectorOperators$Unary, a1: VectorMask): ByteVector;
          lanewise(a0: VectorOperators$Unary): ByteVector;
          lanewise(a0: VectorOperators$Ternary, a1: Vector, a2: Vector, a3: VectorMask): Vector;
          lanewise(a0: VectorOperators$Ternary, a1: Vector, a2: Vector): Vector;
          lanewise(a0: VectorOperators$Binary, a1: Vector, a2: VectorMask): Vector;
          lanewise(a0: VectorOperators$Binary, a1: Vector): Vector;
          lanewise(a0: VectorOperators$Unary, a1: VectorMask): Vector;
          lanewise(a0: VectorOperators$Unary): Vector;
          _lanewiseShift(op: VectorOperators$Binary, e: int): Byte256Vector;
          _lanewiseShift(op: VectorOperators$Binary, e: int, m: VectorMask<byte>): Byte256Vector;
          _lanewiseShift(a0: VectorOperators$Binary, a1: int, a2: VectorMask): ByteVector;
          _lanewiseShift(a0: VectorOperators$Binary, a1: int): ByteVector;
          length(): int;
          _maskFromArray(bits: boolean[]): Byte256Vector$Byte256Mask;
          _maskFromArray(a0: boolean[]): AbstractMask;
          _rOp(v: byte, m: VectorMask<byte>, f: ByteVector$FBinOp): byte;
          rearrange(s: VectorShuffle<byte>): Byte256Vector;
          rearrange(shuffle: VectorShuffle<byte>, m: VectorMask<byte>): Byte256Vector;
          rearrange(s: VectorShuffle<byte>, v: Vector<byte>): Byte256Vector;
          rearrange(a0: VectorShuffle, a1: Vector): ByteVector;
          rearrange(a0: VectorShuffle, a1: VectorMask): ByteVector;
          rearrange(a0: VectorShuffle): ByteVector;
          rearrange(a0: VectorShuffle, a1: Vector): Vector;
          rearrange(a0: VectorShuffle, a1: VectorMask): Vector;
          rearrange(a0: VectorShuffle): Vector;
          reduceLanes(op: VectorOperators$Associative): byte;
          reduceLanes(op: VectorOperators$Associative, m: VectorMask<byte>): byte;
          reduceLanesToLong(op: VectorOperators$Associative): long;
          reduceLanesToLong(op: VectorOperators$Associative, m: VectorMask<byte>): long;
          reinterpretShape<F>(toSpecies: VectorSpecies<F>, part: int): Vector<F>;
          selectFrom(v: Vector<byte>): Byte256Vector;
          selectFrom(v: Vector<byte>, m: VectorMask<byte>): Byte256Vector;
          selectFrom(a0: Vector, a1: VectorMask): ByteVector;
          selectFrom(a0: Vector): ByteVector;
          selectFrom(a0: Vector, a1: VectorMask): Vector;
          selectFrom(a0: Vector): Vector;
          shape(): VectorShape;
          _shuffleFromArray(indexes: int[], i: int): Byte256Vector$Byte256Shuffle;
          _shuffleFromArray(a0: int[], a1: int): AbstractShuffle;
          _shuffleFromBytes(reorder: byte[]): Byte256Vector$Byte256Shuffle;
          _shuffleFromBytes(a0: byte[]): AbstractShuffle;
          _shuffleFromOp(fn: java.util.function.IntUnaryOperator): Byte256Vector$Byte256Shuffle;
          _shuffleFromOp(a0: java.util.function.IntUnaryOperator): AbstractShuffle;
          slice(origin: int, v: Vector<byte>): Byte256Vector;
          slice(origin: int): Byte256Vector;
          slice(a0: int): ByteVector;
          slice(a0: int, a1: Vector): ByteVector;
          slice(a0: int): AbstractVector;
          slice(a0: int, a1: Vector): AbstractVector;
          slice(a0: int): Vector;
          slice(a0: int, a1: Vector): Vector;
          _tOp(v1: Vector<byte>, v2: Vector<byte>, f: ByteVector$FTriOp): Byte256Vector;
          _tOp(v1: Vector<byte>, v2: Vector<byte>, m: VectorMask<byte>, f: ByteVector$FTriOp): Byte256Vector;
          _tOp(a0: Vector, a1: Vector, a2: VectorMask, a3: ByteVector$FTriOp): ByteVector;
          _tOp(a0: Vector, a1: Vector, a2: ByteVector$FTriOp): ByteVector;
          test(op: VectorOperators$Test): Byte256Vector$Byte256Mask;
          test(op: VectorOperators$Test, m: VectorMask<byte>): Byte256Vector$Byte256Mask;
          test(a0: VectorOperators$Test, a1: VectorMask): VectorMask;
          test(a0: VectorOperators$Test): VectorMask;
          toShuffle(): VectorShuffle<byte>;
          _uOp(f: ByteVector$FUnOp): Byte256Vector;
          _uOp(m: VectorMask<byte>, f: ByteVector$FUnOp): Byte256Vector;
          _uOp(a0: VectorMask, a1: ByteVector$FUnOp): ByteVector;
          _uOp(a0: ByteVector$FUnOp): ByteVector;
          unslice(origin: int, w: Vector<byte>, part: int): Byte256Vector;
          unslice(origin: int, w: Vector<byte>, part: int, m: VectorMask<byte>): Byte256Vector;
          unslice(origin: int): Byte256Vector;
          unslice(a0: int): ByteVector;
          unslice(a0: int, a1: Vector, a2: int, a3: VectorMask): ByteVector;
          unslice(a0: int, a1: Vector, a2: int): ByteVector;
          unslice(a0: int): Vector;
          unslice(a0: int, a1: Vector, a2: int, a3: VectorMask): Vector;
          unslice(a0: int, a1: Vector, a2: int): Vector;
          _vec(): byte[];
          _vectorFactory(vec: byte[]): Byte256Vector;
          _vectorFactory(a0: byte[]): ByteVector;
          vspecies(): ByteVector$ByteSpecies;
          vspecies(): AbstractSpecies;
          withLane(i: int, e: byte): Byte256Vector;
          withLane(a0: int, a1: byte): ByteVector;
          withLaneHelper(i: int, e: byte): Byte256Vector;
        }
        interface Byte256Vector extends CombineTypes<[_Byte256Vector, jdk.incubator.vector.ByteVector]> {}
        interface _Byte256Vector$Byte256Mask$$static extends ClassLike {
          _maskAll(bit: boolean): Byte256Vector$Byte256Mask;
          _prepare(bits: boolean[], offset: int): boolean[];
          _prepare(val: boolean): boolean[];
          _ETYPE: java.lang.Class<byte>;
          _FALSE_MASK: Byte256Vector$Byte256Mask;
          _TRUE_MASK: Byte256Vector$Byte256Mask;
          _VLENGTH: int;
          _new(bits: boolean[]): Byte256Vector$Byte256Mask;
          _new(bits: boolean[], offset: int): Byte256Vector$Byte256Mask;
          _new(val: boolean): Byte256Vector$Byte256Mask;
        }
        let Byte256Vector$Byte256Mask: _Byte256Vector$Byte256Mask$$static;
        interface _Byte256Vector$Byte256Mask {
          allTrue(): boolean;
          and(mask: VectorMask<byte>): Byte256Vector$Byte256Mask;
          and(a0: VectorMask): VectorMask;
          anyTrue(): boolean;
          _bOp(m: VectorMask<byte>, f: AbstractMask$MBinOp): Byte256Vector$Byte256Mask;
          _bOp(a0: VectorMask, a1: AbstractMask$MBinOp): AbstractMask;
          cast<E>(dsp: VectorSpecies<E>): VectorMask<E>;
          compress(): Byte256Vector$Byte256Mask;
          compress(): VectorMask;
          _defaultMaskCast<E>(dsp: AbstractSpecies<E>): VectorMask<E>;
          firstTrue(): int;
          _getBits(): boolean[];
          _indexPartiallyInUpperRange(offset: long, a1: long): Byte256Vector$Byte256Mask;
          _indexPartiallyInUpperRange(a0: long, a1: long): VectorMask;
          lastTrue(): int;
          not(): Byte256Vector$Byte256Mask;
          not(): VectorMask;
          or(mask: VectorMask<byte>): Byte256Vector$Byte256Mask;
          or(a0: VectorMask): VectorMask;
          toLong(): long;
          toVector(): Byte256Vector;
          toVector(): Vector;
          trueCount(): int;
          _uOp(f: AbstractMask$MUnOp): Byte256Vector$Byte256Mask;
          _uOp(a0: AbstractMask$MUnOp): AbstractMask;
          vspecies(): ByteVector$ByteSpecies;
          vspecies(): AbstractSpecies;
          xor(mask: VectorMask<byte>): Byte256Vector$Byte256Mask;
          xor(a0: VectorMask): VectorMask;
        }
        interface Byte256Vector$Byte256Mask extends CombineTypes<[_Byte256Vector$Byte256Mask, AbstractMask<byte>]> {}
        interface _Byte256Vector$Byte256Shuffle$$static extends ClassLike {
          _ETYPE: java.lang.Class<byte>;
          _IOTA: Byte256Vector$Byte256Shuffle;
          _VLENGTH: int;
          _new(reorder: byte[]): Byte256Vector$Byte256Shuffle;
          new(reorder: int[]): Byte256Vector$Byte256Shuffle;
          new(reorder: int[], i: int): Byte256Vector$Byte256Shuffle;
          new(fn: java.util.function.IntUnaryOperator): Byte256Vector$Byte256Shuffle;
        }
        let Byte256Vector$Byte256Shuffle: _Byte256Vector$Byte256Shuffle$$static;
        interface _Byte256Vector$Byte256Shuffle {
          cast<F>(s: VectorSpecies<F>): VectorShuffle<F>;
          rearrange(shuffle: VectorShuffle<byte>): Byte256Vector$Byte256Shuffle;
          rearrange(a0: VectorShuffle): VectorShuffle;
          toVector(): Byte256Vector;
          toVector(): Vector;
          vspecies(): ByteVector$ByteSpecies;
          vspecies(): AbstractSpecies;
        }
        interface Byte256Vector$Byte256Shuffle extends CombineTypes<[_Byte256Vector$Byte256Shuffle, AbstractShuffle<byte>]> {}
        interface _Byte512Vector$$static extends ClassLike {
          _ETYPE: java.lang.Class<byte>;
          _IOTA: Byte512Vector;
          _VCLASS: java.lang.Class<Byte512Vector>;
          _VLENGTH: int;
          _VSHAPE: VectorShape;
          _VSIZE: int;
          _VSPECIES: ByteVector$ByteSpecies;
          _ZERO: Byte512Vector;
          _new(v: byte[]): Byte512Vector;
          _new(v: any): Byte512Vector;
        }
        let Byte512Vector: _Byte512Vector$$static;
        interface _Byte512Vector {
          addIndex(scale: int): Byte512Vector;
          addIndex(a0: int): ByteVector;
          addIndex(a0: int): Vector;
          _asByteVectorRaw(): Byte512Vector;
          _asByteVectorRaw(): ByteVector;
          _asVectorRaw(laneType: LaneType): AbstractVector<any>;
          _bOp(v: Vector<byte>, f: ByteVector$FBinOp): Byte512Vector;
          _bOp(v: Vector<byte>, m: VectorMask<byte>, f: ByteVector$FBinOp): Byte512Vector;
          _bOp(a0: Vector, a1: VectorMask, a2: ByteVector$FBinOp): ByteVector;
          _bOp(a0: Vector, a1: ByteVector$FBinOp): ByteVector;
          bitSize(): int;
          blend(v: Vector<byte>, m: VectorMask<byte>): Byte512Vector;
          blend(a0: Vector, a1: VectorMask): ByteVector;
          blend(a0: Vector, a1: VectorMask): Vector;
          broadcast(e: byte): Byte512Vector;
          broadcast(e: long): Byte512Vector;
          broadcast(a0: long): ByteVector;
          broadcast(a0: byte): ByteVector;
          broadcast(a0: long): Vector;
          byteSize(): int;
          compare(op: VectorOperators$Comparison, v: Vector<byte>): Byte512Vector$Byte512Mask;
          compare(op: VectorOperators$Comparison, s: byte): Byte512Vector$Byte512Mask;
          compare(op: VectorOperators$Comparison, s: long): Byte512Vector$Byte512Mask;
          compare(op: VectorOperators$Comparison, v: Vector<byte>, m: VectorMask<byte>): Byte512Vector$Byte512Mask;
          compare(a0: VectorOperators$Comparison, a1: long): VectorMask;
          compare(a0: VectorOperators$Comparison, a1: byte): VectorMask;
          compare(a0: VectorOperators$Comparison, a1: Vector): VectorMask;
          compare(a0: VectorOperators$Comparison, a1: Vector, a2: VectorMask): VectorMask;
          compress(m: VectorMask<byte>): Byte512Vector;
          compress(a0: VectorMask): ByteVector;
          compress(a0: VectorMask): Vector;
          convertShape<F>(conv: VectorOperators$Conversion<byte,F>, rsp: VectorSpecies<F>, part: int): Vector<F>;
          elementSize(): int;
          elementType(): java.lang.Class<byte>;
          expand(m: VectorMask<byte>): Byte512Vector;
          expand(a0: VectorMask): ByteVector;
          expand(a0: VectorMask): Vector;
          _fromArray0(a: byte[], offset: int): ByteVector;
          _fromArray0(a: byte[], offset: int, m: VectorMask<byte>, offsetInRange: int): ByteVector;
          _fromBooleanArray0(a: boolean[], offset: int): ByteVector;
          _fromBooleanArray0(a: boolean[], offset: int, m: VectorMask<byte>, offsetInRange: int): ByteVector;
          _fromMemorySegment0(ms: java.lang.foreign.MemorySegment, offset: long): ByteVector;
          _fromMemorySegment0(ms: java.lang.foreign.MemorySegment, offset: long, a2: VectorMask<byte>, m: int): ByteVector;
          _fromMemorySegment0(a0: java.lang.foreign.MemorySegment, a1: long): AbstractVector;
          _intoArray0(a: byte[], offset: int): void;
          _intoArray0(a: byte[], offset: int, m: VectorMask<byte>): void;
          _intoBooleanArray0(a: boolean[], offset: int, m: VectorMask<byte>): void;
          _intoMemorySegment0(ms: java.lang.foreign.MemorySegment, offset: long, a2: VectorMask<byte>): void;
          _iotaShuffle(): Byte512Vector$Byte512Shuffle;
          _iotaShuffle(start: int, step: int, wrap: boolean): Byte512Vector$Byte512Shuffle;
          _iotaShuffle(a0: int, a1: int, a2: boolean): AbstractShuffle;
          _iotaShuffle(): AbstractShuffle;
          lane(i: int): byte;
          laneHelper(i: int): byte;
          lanewise(op: VectorOperators$Unary): Byte512Vector;
          lanewise(op: VectorOperators$Unary, m: VectorMask<byte>): Byte512Vector;
          lanewise(op: VectorOperators$Binary, v: Vector<byte>): Byte512Vector;
          lanewise(op: VectorOperators$Binary, v: Vector<byte>, m: VectorMask<byte>): Byte512Vector;
          lanewise(op: VectorOperators$Ternary, v1: Vector<byte>, v2: Vector<byte>): Byte512Vector;
          lanewise(op: VectorOperators$Ternary, v1: Vector<byte>, v2: Vector<byte>, m: VectorMask<byte>): Byte512Vector;
          lanewise(a0: VectorOperators$Ternary, a1: Vector, a2: Vector, a3: VectorMask): ByteVector;
          lanewise(a0: VectorOperators$Ternary, a1: Vector, a2: Vector): ByteVector;
          lanewise(a0: VectorOperators$Binary, a1: Vector, a2: VectorMask): ByteVector;
          lanewise(a0: VectorOperators$Binary, a1: Vector): ByteVector;
          lanewise(a0: VectorOperators$Unary, a1: VectorMask): ByteVector;
          lanewise(a0: VectorOperators$Unary): ByteVector;
          lanewise(a0: VectorOperators$Ternary, a1: Vector, a2: Vector, a3: VectorMask): Vector;
          lanewise(a0: VectorOperators$Ternary, a1: Vector, a2: Vector): Vector;
          lanewise(a0: VectorOperators$Binary, a1: Vector, a2: VectorMask): Vector;
          lanewise(a0: VectorOperators$Binary, a1: Vector): Vector;
          lanewise(a0: VectorOperators$Unary, a1: VectorMask): Vector;
          lanewise(a0: VectorOperators$Unary): Vector;
          _lanewiseShift(op: VectorOperators$Binary, e: int): Byte512Vector;
          _lanewiseShift(op: VectorOperators$Binary, e: int, m: VectorMask<byte>): Byte512Vector;
          _lanewiseShift(a0: VectorOperators$Binary, a1: int, a2: VectorMask): ByteVector;
          _lanewiseShift(a0: VectorOperators$Binary, a1: int): ByteVector;
          length(): int;
          _maskFromArray(bits: boolean[]): Byte512Vector$Byte512Mask;
          _maskFromArray(a0: boolean[]): AbstractMask;
          _rOp(v: byte, m: VectorMask<byte>, f: ByteVector$FBinOp): byte;
          rearrange(s: VectorShuffle<byte>): Byte512Vector;
          rearrange(shuffle: VectorShuffle<byte>, m: VectorMask<byte>): Byte512Vector;
          rearrange(s: VectorShuffle<byte>, v: Vector<byte>): Byte512Vector;
          rearrange(a0: VectorShuffle, a1: Vector): ByteVector;
          rearrange(a0: VectorShuffle, a1: VectorMask): ByteVector;
          rearrange(a0: VectorShuffle): ByteVector;
          rearrange(a0: VectorShuffle, a1: Vector): Vector;
          rearrange(a0: VectorShuffle, a1: VectorMask): Vector;
          rearrange(a0: VectorShuffle): Vector;
          reduceLanes(op: VectorOperators$Associative): byte;
          reduceLanes(op: VectorOperators$Associative, m: VectorMask<byte>): byte;
          reduceLanesToLong(op: VectorOperators$Associative): long;
          reduceLanesToLong(op: VectorOperators$Associative, m: VectorMask<byte>): long;
          reinterpretShape<F>(toSpecies: VectorSpecies<F>, part: int): Vector<F>;
          selectFrom(v: Vector<byte>): Byte512Vector;
          selectFrom(v: Vector<byte>, m: VectorMask<byte>): Byte512Vector;
          selectFrom(a0: Vector, a1: VectorMask): ByteVector;
          selectFrom(a0: Vector): ByteVector;
          selectFrom(a0: Vector, a1: VectorMask): Vector;
          selectFrom(a0: Vector): Vector;
          shape(): VectorShape;
          _shuffleFromArray(indexes: int[], i: int): Byte512Vector$Byte512Shuffle;
          _shuffleFromArray(a0: int[], a1: int): AbstractShuffle;
          _shuffleFromBytes(reorder: byte[]): Byte512Vector$Byte512Shuffle;
          _shuffleFromBytes(a0: byte[]): AbstractShuffle;
          _shuffleFromOp(fn: java.util.function.IntUnaryOperator): Byte512Vector$Byte512Shuffle;
          _shuffleFromOp(a0: java.util.function.IntUnaryOperator): AbstractShuffle;
          slice(origin: int, v: Vector<byte>): Byte512Vector;
          slice(origin: int): Byte512Vector;
          slice(a0: int): ByteVector;
          slice(a0: int, a1: Vector): ByteVector;
          slice(a0: int): AbstractVector;
          slice(a0: int, a1: Vector): AbstractVector;
          slice(a0: int): Vector;
          slice(a0: int, a1: Vector): Vector;
          _tOp(v1: Vector<byte>, v2: Vector<byte>, f: ByteVector$FTriOp): Byte512Vector;
          _tOp(v1: Vector<byte>, v2: Vector<byte>, m: VectorMask<byte>, f: ByteVector$FTriOp): Byte512Vector;
          _tOp(a0: Vector, a1: Vector, a2: VectorMask, a3: ByteVector$FTriOp): ByteVector;
          _tOp(a0: Vector, a1: Vector, a2: ByteVector$FTriOp): ByteVector;
          test(op: VectorOperators$Test): Byte512Vector$Byte512Mask;
          test(op: VectorOperators$Test, m: VectorMask<byte>): Byte512Vector$Byte512Mask;
          test(a0: VectorOperators$Test, a1: VectorMask): VectorMask;
          test(a0: VectorOperators$Test): VectorMask;
          toShuffle(): VectorShuffle<byte>;
          _uOp(f: ByteVector$FUnOp): Byte512Vector;
          _uOp(m: VectorMask<byte>, f: ByteVector$FUnOp): Byte512Vector;
          _uOp(a0: VectorMask, a1: ByteVector$FUnOp): ByteVector;
          _uOp(a0: ByteVector$FUnOp): ByteVector;
          unslice(origin: int, w: Vector<byte>, part: int): Byte512Vector;
          unslice(origin: int, w: Vector<byte>, part: int, m: VectorMask<byte>): Byte512Vector;
          unslice(origin: int): Byte512Vector;
          unslice(a0: int): ByteVector;
          unslice(a0: int, a1: Vector, a2: int, a3: VectorMask): ByteVector;
          unslice(a0: int, a1: Vector, a2: int): ByteVector;
          unslice(a0: int): Vector;
          unslice(a0: int, a1: Vector, a2: int, a3: VectorMask): Vector;
          unslice(a0: int, a1: Vector, a2: int): Vector;
          _vec(): byte[];
          _vectorFactory(vec: byte[]): Byte512Vector;
          _vectorFactory(a0: byte[]): ByteVector;
          vspecies(): ByteVector$ByteSpecies;
          vspecies(): AbstractSpecies;
          withLane(i: int, e: byte): Byte512Vector;
          withLane(a0: int, a1: byte): ByteVector;
          withLaneHelper(i: int, e: byte): Byte512Vector;
        }
        interface Byte512Vector extends CombineTypes<[_Byte512Vector, jdk.incubator.vector.ByteVector]> {}
        interface _Byte512Vector$Byte512Mask$$static extends ClassLike {
          _maskAll(bit: boolean): Byte512Vector$Byte512Mask;
          _prepare(bits: boolean[], offset: int): boolean[];
          _prepare(val: boolean): boolean[];
          _ETYPE: java.lang.Class<byte>;
          _FALSE_MASK: Byte512Vector$Byte512Mask;
          _TRUE_MASK: Byte512Vector$Byte512Mask;
          _VLENGTH: int;
          _new(bits: boolean[]): Byte512Vector$Byte512Mask;
          _new(bits: boolean[], offset: int): Byte512Vector$Byte512Mask;
          _new(val: boolean): Byte512Vector$Byte512Mask;
        }
        let Byte512Vector$Byte512Mask: _Byte512Vector$Byte512Mask$$static;
        interface _Byte512Vector$Byte512Mask {
          allTrue(): boolean;
          and(mask: VectorMask<byte>): Byte512Vector$Byte512Mask;
          and(a0: VectorMask): VectorMask;
          anyTrue(): boolean;
          _bOp(m: VectorMask<byte>, f: AbstractMask$MBinOp): Byte512Vector$Byte512Mask;
          _bOp(a0: VectorMask, a1: AbstractMask$MBinOp): AbstractMask;
          cast<E>(dsp: VectorSpecies<E>): VectorMask<E>;
          compress(): Byte512Vector$Byte512Mask;
          compress(): VectorMask;
          _defaultMaskCast<E>(dsp: AbstractSpecies<E>): VectorMask<E>;
          firstTrue(): int;
          _getBits(): boolean[];
          _indexPartiallyInUpperRange(offset: long, a1: long): Byte512Vector$Byte512Mask;
          _indexPartiallyInUpperRange(a0: long, a1: long): VectorMask;
          lastTrue(): int;
          not(): Byte512Vector$Byte512Mask;
          not(): VectorMask;
          or(mask: VectorMask<byte>): Byte512Vector$Byte512Mask;
          or(a0: VectorMask): VectorMask;
          toLong(): long;
          toVector(): Byte512Vector;
          toVector(): Vector;
          trueCount(): int;
          _uOp(f: AbstractMask$MUnOp): Byte512Vector$Byte512Mask;
          _uOp(a0: AbstractMask$MUnOp): AbstractMask;
          vspecies(): ByteVector$ByteSpecies;
          vspecies(): AbstractSpecies;
          xor(mask: VectorMask<byte>): Byte512Vector$Byte512Mask;
          xor(a0: VectorMask): VectorMask;
        }
        interface Byte512Vector$Byte512Mask extends CombineTypes<[_Byte512Vector$Byte512Mask, AbstractMask<byte>]> {}
        interface _Byte512Vector$Byte512Shuffle$$static extends ClassLike {
          _ETYPE: java.lang.Class<byte>;
          _IOTA: Byte512Vector$Byte512Shuffle;
          _VLENGTH: int;
          _new(reorder: byte[]): Byte512Vector$Byte512Shuffle;
          new(reorder: int[]): Byte512Vector$Byte512Shuffle;
          new(reorder: int[], i: int): Byte512Vector$Byte512Shuffle;
          new(fn: java.util.function.IntUnaryOperator): Byte512Vector$Byte512Shuffle;
        }
        let Byte512Vector$Byte512Shuffle: _Byte512Vector$Byte512Shuffle$$static;
        interface _Byte512Vector$Byte512Shuffle {
          cast<F>(s: VectorSpecies<F>): VectorShuffle<F>;
          rearrange(shuffle: VectorShuffle<byte>): Byte512Vector$Byte512Shuffle;
          rearrange(a0: VectorShuffle): VectorShuffle;
          toVector(): Byte512Vector;
          toVector(): Vector;
          vspecies(): ByteVector$ByteSpecies;
          vspecies(): AbstractSpecies;
        }
        interface Byte512Vector$Byte512Shuffle extends CombineTypes<[_Byte512Vector$Byte512Shuffle, AbstractShuffle<byte>]> {}
        interface _Byte64Vector$$static extends ClassLike {
          _ETYPE: java.lang.Class<byte>;
          _IOTA: Byte64Vector;
          _VCLASS: java.lang.Class<Byte64Vector>;
          _VLENGTH: int;
          _VSHAPE: VectorShape;
          _VSIZE: int;
          _VSPECIES: ByteVector$ByteSpecies;
          _ZERO: Byte64Vector;
          _new(v: byte[]): Byte64Vector;
          _new(v: any): Byte64Vector;
        }
        let Byte64Vector: _Byte64Vector$$static;
        interface _Byte64Vector {
          addIndex(scale: int): Byte64Vector;
          addIndex(a0: int): ByteVector;
          addIndex(a0: int): Vector;
          _asByteVectorRaw(): Byte64Vector;
          _asByteVectorRaw(): ByteVector;
          _asVectorRaw(laneType: LaneType): AbstractVector<any>;
          _bOp(v: Vector<byte>, f: ByteVector$FBinOp): Byte64Vector;
          _bOp(v: Vector<byte>, m: VectorMask<byte>, f: ByteVector$FBinOp): Byte64Vector;
          _bOp(a0: Vector, a1: VectorMask, a2: ByteVector$FBinOp): ByteVector;
          _bOp(a0: Vector, a1: ByteVector$FBinOp): ByteVector;
          bitSize(): int;
          blend(v: Vector<byte>, m: VectorMask<byte>): Byte64Vector;
          blend(a0: Vector, a1: VectorMask): ByteVector;
          blend(a0: Vector, a1: VectorMask): Vector;
          broadcast(e: byte): Byte64Vector;
          broadcast(e: long): Byte64Vector;
          broadcast(a0: long): ByteVector;
          broadcast(a0: byte): ByteVector;
          broadcast(a0: long): Vector;
          byteSize(): int;
          compare(op: VectorOperators$Comparison, v: Vector<byte>): Byte64Vector$Byte64Mask;
          compare(op: VectorOperators$Comparison, s: byte): Byte64Vector$Byte64Mask;
          compare(op: VectorOperators$Comparison, s: long): Byte64Vector$Byte64Mask;
          compare(op: VectorOperators$Comparison, v: Vector<byte>, m: VectorMask<byte>): Byte64Vector$Byte64Mask;
          compare(a0: VectorOperators$Comparison, a1: long): VectorMask;
          compare(a0: VectorOperators$Comparison, a1: byte): VectorMask;
          compare(a0: VectorOperators$Comparison, a1: Vector): VectorMask;
          compare(a0: VectorOperators$Comparison, a1: Vector, a2: VectorMask): VectorMask;
          compress(m: VectorMask<byte>): Byte64Vector;
          compress(a0: VectorMask): ByteVector;
          compress(a0: VectorMask): Vector;
          convertShape<F>(conv: VectorOperators$Conversion<byte,F>, rsp: VectorSpecies<F>, part: int): Vector<F>;
          elementSize(): int;
          elementType(): java.lang.Class<byte>;
          expand(m: VectorMask<byte>): Byte64Vector;
          expand(a0: VectorMask): ByteVector;
          expand(a0: VectorMask): Vector;
          _fromArray0(a: byte[], offset: int): ByteVector;
          _fromArray0(a: byte[], offset: int, m: VectorMask<byte>, offsetInRange: int): ByteVector;
          _fromBooleanArray0(a: boolean[], offset: int): ByteVector;
          _fromBooleanArray0(a: boolean[], offset: int, m: VectorMask<byte>, offsetInRange: int): ByteVector;
          _fromMemorySegment0(ms: java.lang.foreign.MemorySegment, offset: long): ByteVector;
          _fromMemorySegment0(ms: java.lang.foreign.MemorySegment, offset: long, a2: VectorMask<byte>, m: int): ByteVector;
          _fromMemorySegment0(a0: java.lang.foreign.MemorySegment, a1: long): AbstractVector;
          _intoArray0(a: byte[], offset: int): void;
          _intoArray0(a: byte[], offset: int, m: VectorMask<byte>): void;
          _intoBooleanArray0(a: boolean[], offset: int, m: VectorMask<byte>): void;
          _intoMemorySegment0(ms: java.lang.foreign.MemorySegment, offset: long, a2: VectorMask<byte>): void;
          _iotaShuffle(): Byte64Vector$Byte64Shuffle;
          _iotaShuffle(start: int, step: int, wrap: boolean): Byte64Vector$Byte64Shuffle;
          _iotaShuffle(a0: int, a1: int, a2: boolean): AbstractShuffle;
          _iotaShuffle(): AbstractShuffle;
          lane(i: int): byte;
          laneHelper(i: int): byte;
          lanewise(op: VectorOperators$Unary): Byte64Vector;
          lanewise(op: VectorOperators$Unary, m: VectorMask<byte>): Byte64Vector;
          lanewise(op: VectorOperators$Binary, v: Vector<byte>): Byte64Vector;
          lanewise(op: VectorOperators$Binary, v: Vector<byte>, m: VectorMask<byte>): Byte64Vector;
          lanewise(op: VectorOperators$Ternary, v1: Vector<byte>, v2: Vector<byte>): Byte64Vector;
          lanewise(op: VectorOperators$Ternary, v1: Vector<byte>, v2: Vector<byte>, m: VectorMask<byte>): Byte64Vector;
          lanewise(a0: VectorOperators$Ternary, a1: Vector, a2: Vector, a3: VectorMask): ByteVector;
          lanewise(a0: VectorOperators$Ternary, a1: Vector, a2: Vector): ByteVector;
          lanewise(a0: VectorOperators$Binary, a1: Vector, a2: VectorMask): ByteVector;
          lanewise(a0: VectorOperators$Binary, a1: Vector): ByteVector;
          lanewise(a0: VectorOperators$Unary, a1: VectorMask): ByteVector;
          lanewise(a0: VectorOperators$Unary): ByteVector;
          lanewise(a0: VectorOperators$Ternary, a1: Vector, a2: Vector, a3: VectorMask): Vector;
          lanewise(a0: VectorOperators$Ternary, a1: Vector, a2: Vector): Vector;
          lanewise(a0: VectorOperators$Binary, a1: Vector, a2: VectorMask): Vector;
          lanewise(a0: VectorOperators$Binary, a1: Vector): Vector;
          lanewise(a0: VectorOperators$Unary, a1: VectorMask): Vector;
          lanewise(a0: VectorOperators$Unary): Vector;
          _lanewiseShift(op: VectorOperators$Binary, e: int): Byte64Vector;
          _lanewiseShift(op: VectorOperators$Binary, e: int, m: VectorMask<byte>): Byte64Vector;
          _lanewiseShift(a0: VectorOperators$Binary, a1: int, a2: VectorMask): ByteVector;
          _lanewiseShift(a0: VectorOperators$Binary, a1: int): ByteVector;
          length(): int;
          _maskFromArray(bits: boolean[]): Byte64Vector$Byte64Mask;
          _maskFromArray(a0: boolean[]): AbstractMask;
          _rOp(v: byte, m: VectorMask<byte>, f: ByteVector$FBinOp): byte;
          rearrange(s: VectorShuffle<byte>): Byte64Vector;
          rearrange(shuffle: VectorShuffle<byte>, m: VectorMask<byte>): Byte64Vector;
          rearrange(s: VectorShuffle<byte>, v: Vector<byte>): Byte64Vector;
          rearrange(a0: VectorShuffle, a1: Vector): ByteVector;
          rearrange(a0: VectorShuffle, a1: VectorMask): ByteVector;
          rearrange(a0: VectorShuffle): ByteVector;
          rearrange(a0: VectorShuffle, a1: Vector): Vector;
          rearrange(a0: VectorShuffle, a1: VectorMask): Vector;
          rearrange(a0: VectorShuffle): Vector;
          reduceLanes(op: VectorOperators$Associative): byte;
          reduceLanes(op: VectorOperators$Associative, m: VectorMask<byte>): byte;
          reduceLanesToLong(op: VectorOperators$Associative): long;
          reduceLanesToLong(op: VectorOperators$Associative, m: VectorMask<byte>): long;
          reinterpretShape<F>(toSpecies: VectorSpecies<F>, part: int): Vector<F>;
          selectFrom(v: Vector<byte>): Byte64Vector;
          selectFrom(v: Vector<byte>, m: VectorMask<byte>): Byte64Vector;
          selectFrom(a0: Vector, a1: VectorMask): ByteVector;
          selectFrom(a0: Vector): ByteVector;
          selectFrom(a0: Vector, a1: VectorMask): Vector;
          selectFrom(a0: Vector): Vector;
          shape(): VectorShape;
          _shuffleFromArray(indexes: int[], i: int): Byte64Vector$Byte64Shuffle;
          _shuffleFromArray(a0: int[], a1: int): AbstractShuffle;
          _shuffleFromBytes(reorder: byte[]): Byte64Vector$Byte64Shuffle;
          _shuffleFromBytes(a0: byte[]): AbstractShuffle;
          _shuffleFromOp(fn: java.util.function.IntUnaryOperator): Byte64Vector$Byte64Shuffle;
          _shuffleFromOp(a0: java.util.function.IntUnaryOperator): AbstractShuffle;
          slice(origin: int, v: Vector<byte>): Byte64Vector;
          slice(origin: int): Byte64Vector;
          slice(a0: int): ByteVector;
          slice(a0: int, a1: Vector): ByteVector;
          slice(a0: int): AbstractVector;
          slice(a0: int, a1: Vector): AbstractVector;
          slice(a0: int): Vector;
          slice(a0: int, a1: Vector): Vector;
          _tOp(v1: Vector<byte>, v2: Vector<byte>, f: ByteVector$FTriOp): Byte64Vector;
          _tOp(v1: Vector<byte>, v2: Vector<byte>, m: VectorMask<byte>, f: ByteVector$FTriOp): Byte64Vector;
          _tOp(a0: Vector, a1: Vector, a2: VectorMask, a3: ByteVector$FTriOp): ByteVector;
          _tOp(a0: Vector, a1: Vector, a2: ByteVector$FTriOp): ByteVector;
          test(op: VectorOperators$Test): Byte64Vector$Byte64Mask;
          test(op: VectorOperators$Test, m: VectorMask<byte>): Byte64Vector$Byte64Mask;
          test(a0: VectorOperators$Test, a1: VectorMask): VectorMask;
          test(a0: VectorOperators$Test): VectorMask;
          toShuffle(): VectorShuffle<byte>;
          _uOp(f: ByteVector$FUnOp): Byte64Vector;
          _uOp(m: VectorMask<byte>, f: ByteVector$FUnOp): Byte64Vector;
          _uOp(a0: VectorMask, a1: ByteVector$FUnOp): ByteVector;
          _uOp(a0: ByteVector$FUnOp): ByteVector;
          unslice(origin: int, w: Vector<byte>, part: int): Byte64Vector;
          unslice(origin: int, w: Vector<byte>, part: int, m: VectorMask<byte>): Byte64Vector;
          unslice(origin: int): Byte64Vector;
          unslice(a0: int): ByteVector;
          unslice(a0: int, a1: Vector, a2: int, a3: VectorMask): ByteVector;
          unslice(a0: int, a1: Vector, a2: int): ByteVector;
          unslice(a0: int): Vector;
          unslice(a0: int, a1: Vector, a2: int, a3: VectorMask): Vector;
          unslice(a0: int, a1: Vector, a2: int): Vector;
          _vec(): byte[];
          _vectorFactory(vec: byte[]): Byte64Vector;
          _vectorFactory(a0: byte[]): ByteVector;
          vspecies(): ByteVector$ByteSpecies;
          vspecies(): AbstractSpecies;
          withLane(i: int, e: byte): Byte64Vector;
          withLane(a0: int, a1: byte): ByteVector;
          withLaneHelper(i: int, e: byte): Byte64Vector;
        }
        interface Byte64Vector extends CombineTypes<[_Byte64Vector, jdk.incubator.vector.ByteVector]> {}
        interface _Byte64Vector$Byte64Mask$$static extends ClassLike {
          _maskAll(bit: boolean): Byte64Vector$Byte64Mask;
          _prepare(bits: boolean[], offset: int): boolean[];
          _prepare(val: boolean): boolean[];
          _ETYPE: java.lang.Class<byte>;
          _FALSE_MASK: Byte64Vector$Byte64Mask;
          _TRUE_MASK: Byte64Vector$Byte64Mask;
          _VLENGTH: int;
          _new(bits: boolean[]): Byte64Vector$Byte64Mask;
          _new(bits: boolean[], offset: int): Byte64Vector$Byte64Mask;
          _new(val: boolean): Byte64Vector$Byte64Mask;
        }
        let Byte64Vector$Byte64Mask: _Byte64Vector$Byte64Mask$$static;
        interface _Byte64Vector$Byte64Mask {
          allTrue(): boolean;
          and(mask: VectorMask<byte>): Byte64Vector$Byte64Mask;
          and(a0: VectorMask): VectorMask;
          anyTrue(): boolean;
          _bOp(m: VectorMask<byte>, f: AbstractMask$MBinOp): Byte64Vector$Byte64Mask;
          _bOp(a0: VectorMask, a1: AbstractMask$MBinOp): AbstractMask;
          cast<E>(dsp: VectorSpecies<E>): VectorMask<E>;
          compress(): Byte64Vector$Byte64Mask;
          compress(): VectorMask;
          _defaultMaskCast<E>(dsp: AbstractSpecies<E>): VectorMask<E>;
          firstTrue(): int;
          _getBits(): boolean[];
          _indexPartiallyInUpperRange(offset: long, a1: long): Byte64Vector$Byte64Mask;
          _indexPartiallyInUpperRange(a0: long, a1: long): VectorMask;
          lastTrue(): int;
          not(): Byte64Vector$Byte64Mask;
          not(): VectorMask;
          or(mask: VectorMask<byte>): Byte64Vector$Byte64Mask;
          or(a0: VectorMask): VectorMask;
          toLong(): long;
          toVector(): Byte64Vector;
          toVector(): Vector;
          trueCount(): int;
          _uOp(f: AbstractMask$MUnOp): Byte64Vector$Byte64Mask;
          _uOp(a0: AbstractMask$MUnOp): AbstractMask;
          vspecies(): ByteVector$ByteSpecies;
          vspecies(): AbstractSpecies;
          xor(mask: VectorMask<byte>): Byte64Vector$Byte64Mask;
          xor(a0: VectorMask): VectorMask;
        }
        interface Byte64Vector$Byte64Mask extends CombineTypes<[_Byte64Vector$Byte64Mask, AbstractMask<byte>]> {}
        interface _Byte64Vector$Byte64Shuffle$$static extends ClassLike {
          _ETYPE: java.lang.Class<byte>;
          _IOTA: Byte64Vector$Byte64Shuffle;
          _VLENGTH: int;
          _new(reorder: byte[]): Byte64Vector$Byte64Shuffle;
          new(reorder: int[]): Byte64Vector$Byte64Shuffle;
          new(reorder: int[], i: int): Byte64Vector$Byte64Shuffle;
          new(fn: java.util.function.IntUnaryOperator): Byte64Vector$Byte64Shuffle;
        }
        let Byte64Vector$Byte64Shuffle: _Byte64Vector$Byte64Shuffle$$static;
        interface _Byte64Vector$Byte64Shuffle {
          cast<F>(s: VectorSpecies<F>): VectorShuffle<F>;
          rearrange(shuffle: VectorShuffle<byte>): Byte64Vector$Byte64Shuffle;
          rearrange(a0: VectorShuffle): VectorShuffle;
          toVector(): Byte64Vector;
          toVector(): Vector;
          vspecies(): ByteVector$ByteSpecies;
          vspecies(): AbstractSpecies;
        }
        interface Byte64Vector$Byte64Shuffle extends CombineTypes<[_Byte64Vector$Byte64Shuffle, AbstractShuffle<byte>]> {}
        interface _ByteMaxVector$$static extends ClassLike {
          _ETYPE: java.lang.Class<byte>;
          _IOTA: ByteMaxVector;
          _VCLASS: java.lang.Class<ByteMaxVector>;
          _VLENGTH: int;
          _VSHAPE: VectorShape;
          _VSIZE: int;
          _VSPECIES: ByteVector$ByteSpecies;
          _ZERO: ByteMaxVector;
          _new(v: byte[]): ByteMaxVector;
          _new(v: any): ByteMaxVector;
        }
        let ByteMaxVector: _ByteMaxVector$$static;
        interface _ByteMaxVector {
          addIndex(scale: int): ByteMaxVector;
          addIndex(a0: int): ByteVector;
          addIndex(a0: int): Vector;
          _asByteVectorRaw(): ByteMaxVector;
          _asByteVectorRaw(): ByteVector;
          _asVectorRaw(laneType: LaneType): AbstractVector<any>;
          _bOp(v: Vector<byte>, f: ByteVector$FBinOp): ByteMaxVector;
          _bOp(v: Vector<byte>, m: VectorMask<byte>, f: ByteVector$FBinOp): ByteMaxVector;
          _bOp(a0: Vector, a1: VectorMask, a2: ByteVector$FBinOp): ByteVector;
          _bOp(a0: Vector, a1: ByteVector$FBinOp): ByteVector;
          bitSize(): int;
          blend(v: Vector<byte>, m: VectorMask<byte>): ByteMaxVector;
          blend(a0: Vector, a1: VectorMask): ByteVector;
          blend(a0: Vector, a1: VectorMask): Vector;
          broadcast(e: byte): ByteMaxVector;
          broadcast(e: long): ByteMaxVector;
          broadcast(a0: long): ByteVector;
          broadcast(a0: byte): ByteVector;
          broadcast(a0: long): Vector;
          byteSize(): int;
          compare(op: VectorOperators$Comparison, v: Vector<byte>): ByteMaxVector$ByteMaxMask;
          compare(op: VectorOperators$Comparison, s: byte): ByteMaxVector$ByteMaxMask;
          compare(op: VectorOperators$Comparison, s: long): ByteMaxVector$ByteMaxMask;
          compare(op: VectorOperators$Comparison, v: Vector<byte>, m: VectorMask<byte>): ByteMaxVector$ByteMaxMask;
          compare(a0: VectorOperators$Comparison, a1: long): VectorMask;
          compare(a0: VectorOperators$Comparison, a1: byte): VectorMask;
          compare(a0: VectorOperators$Comparison, a1: Vector): VectorMask;
          compare(a0: VectorOperators$Comparison, a1: Vector, a2: VectorMask): VectorMask;
          compress(m: VectorMask<byte>): ByteMaxVector;
          compress(a0: VectorMask): ByteVector;
          compress(a0: VectorMask): Vector;
          convertShape<F>(conv: VectorOperators$Conversion<byte,F>, rsp: VectorSpecies<F>, part: int): Vector<F>;
          elementSize(): int;
          elementType(): java.lang.Class<byte>;
          expand(m: VectorMask<byte>): ByteMaxVector;
          expand(a0: VectorMask): ByteVector;
          expand(a0: VectorMask): Vector;
          _fromArray0(a: byte[], offset: int): ByteVector;
          _fromArray0(a: byte[], offset: int, m: VectorMask<byte>, offsetInRange: int): ByteVector;
          _fromBooleanArray0(a: boolean[], offset: int): ByteVector;
          _fromBooleanArray0(a: boolean[], offset: int, m: VectorMask<byte>, offsetInRange: int): ByteVector;
          _fromMemorySegment0(ms: java.lang.foreign.MemorySegment, offset: long): ByteVector;
          _fromMemorySegment0(ms: java.lang.foreign.MemorySegment, offset: long, a2: VectorMask<byte>, m: int): ByteVector;
          _fromMemorySegment0(a0: java.lang.foreign.MemorySegment, a1: long): AbstractVector;
          _intoArray0(a: byte[], offset: int): void;
          _intoArray0(a: byte[], offset: int, m: VectorMask<byte>): void;
          _intoBooleanArray0(a: boolean[], offset: int, m: VectorMask<byte>): void;
          _intoMemorySegment0(ms: java.lang.foreign.MemorySegment, offset: long, a2: VectorMask<byte>): void;
          _iotaShuffle(): ByteMaxVector$ByteMaxShuffle;
          _iotaShuffle(start: int, step: int, wrap: boolean): ByteMaxVector$ByteMaxShuffle;
          _iotaShuffle(a0: int, a1: int, a2: boolean): AbstractShuffle;
          _iotaShuffle(): AbstractShuffle;
          lane(i: int): byte;
          laneHelper(i: int): byte;
          lanewise(op: VectorOperators$Unary): ByteMaxVector;
          lanewise(op: VectorOperators$Unary, m: VectorMask<byte>): ByteMaxVector;
          lanewise(op: VectorOperators$Binary, v: Vector<byte>): ByteMaxVector;
          lanewise(op: VectorOperators$Binary, v: Vector<byte>, m: VectorMask<byte>): ByteMaxVector;
          lanewise(op: VectorOperators$Ternary, v1: Vector<byte>, v2: Vector<byte>): ByteMaxVector;
          lanewise(op: VectorOperators$Ternary, v1: Vector<byte>, v2: Vector<byte>, m: VectorMask<byte>): ByteMaxVector;
          lanewise(a0: VectorOperators$Ternary, a1: Vector, a2: Vector, a3: VectorMask): ByteVector;
          lanewise(a0: VectorOperators$Ternary, a1: Vector, a2: Vector): ByteVector;
          lanewise(a0: VectorOperators$Binary, a1: Vector, a2: VectorMask): ByteVector;
          lanewise(a0: VectorOperators$Binary, a1: Vector): ByteVector;
          lanewise(a0: VectorOperators$Unary, a1: VectorMask): ByteVector;
          lanewise(a0: VectorOperators$Unary): ByteVector;
          lanewise(a0: VectorOperators$Ternary, a1: Vector, a2: Vector, a3: VectorMask): Vector;
          lanewise(a0: VectorOperators$Ternary, a1: Vector, a2: Vector): Vector;
          lanewise(a0: VectorOperators$Binary, a1: Vector, a2: VectorMask): Vector;
          lanewise(a0: VectorOperators$Binary, a1: Vector): Vector;
          lanewise(a0: VectorOperators$Unary, a1: VectorMask): Vector;
          lanewise(a0: VectorOperators$Unary): Vector;
          _lanewiseShift(op: VectorOperators$Binary, e: int): ByteMaxVector;
          _lanewiseShift(op: VectorOperators$Binary, e: int, m: VectorMask<byte>): ByteMaxVector;
          _lanewiseShift(a0: VectorOperators$Binary, a1: int, a2: VectorMask): ByteVector;
          _lanewiseShift(a0: VectorOperators$Binary, a1: int): ByteVector;
          length(): int;
          _maskFromArray(bits: boolean[]): ByteMaxVector$ByteMaxMask;
          _maskFromArray(a0: boolean[]): AbstractMask;
          _rOp(v: byte, m: VectorMask<byte>, f: ByteVector$FBinOp): byte;
          rearrange(s: VectorShuffle<byte>): ByteMaxVector;
          rearrange(shuffle: VectorShuffle<byte>, m: VectorMask<byte>): ByteMaxVector;
          rearrange(s: VectorShuffle<byte>, v: Vector<byte>): ByteMaxVector;
          rearrange(a0: VectorShuffle, a1: Vector): ByteVector;
          rearrange(a0: VectorShuffle, a1: VectorMask): ByteVector;
          rearrange(a0: VectorShuffle): ByteVector;
          rearrange(a0: VectorShuffle, a1: Vector): Vector;
          rearrange(a0: VectorShuffle, a1: VectorMask): Vector;
          rearrange(a0: VectorShuffle): Vector;
          reduceLanes(op: VectorOperators$Associative): byte;
          reduceLanes(op: VectorOperators$Associative, m: VectorMask<byte>): byte;
          reduceLanesToLong(op: VectorOperators$Associative): long;
          reduceLanesToLong(op: VectorOperators$Associative, m: VectorMask<byte>): long;
          reinterpretShape<F>(toSpecies: VectorSpecies<F>, part: int): Vector<F>;
          selectFrom(v: Vector<byte>): ByteMaxVector;
          selectFrom(v: Vector<byte>, m: VectorMask<byte>): ByteMaxVector;
          selectFrom(a0: Vector, a1: VectorMask): ByteVector;
          selectFrom(a0: Vector): ByteVector;
          selectFrom(a0: Vector, a1: VectorMask): Vector;
          selectFrom(a0: Vector): Vector;
          shape(): VectorShape;
          _shuffleFromArray(indexes: int[], i: int): ByteMaxVector$ByteMaxShuffle;
          _shuffleFromArray(a0: int[], a1: int): AbstractShuffle;
          _shuffleFromBytes(reorder: byte[]): ByteMaxVector$ByteMaxShuffle;
          _shuffleFromBytes(a0: byte[]): AbstractShuffle;
          _shuffleFromOp(fn: java.util.function.IntUnaryOperator): ByteMaxVector$ByteMaxShuffle;
          _shuffleFromOp(a0: java.util.function.IntUnaryOperator): AbstractShuffle;
          slice(origin: int, v: Vector<byte>): ByteMaxVector;
          slice(origin: int): ByteMaxVector;
          slice(a0: int): ByteVector;
          slice(a0: int, a1: Vector): ByteVector;
          slice(a0: int): AbstractVector;
          slice(a0: int, a1: Vector): AbstractVector;
          slice(a0: int): Vector;
          slice(a0: int, a1: Vector): Vector;
          _tOp(v1: Vector<byte>, v2: Vector<byte>, f: ByteVector$FTriOp): ByteMaxVector;
          _tOp(v1: Vector<byte>, v2: Vector<byte>, m: VectorMask<byte>, f: ByteVector$FTriOp): ByteMaxVector;
          _tOp(a0: Vector, a1: Vector, a2: VectorMask, a3: ByteVector$FTriOp): ByteVector;
          _tOp(a0: Vector, a1: Vector, a2: ByteVector$FTriOp): ByteVector;
          test(op: VectorOperators$Test): ByteMaxVector$ByteMaxMask;
          test(op: VectorOperators$Test, m: VectorMask<byte>): ByteMaxVector$ByteMaxMask;
          test(a0: VectorOperators$Test, a1: VectorMask): VectorMask;
          test(a0: VectorOperators$Test): VectorMask;
          toShuffle(): VectorShuffle<byte>;
          _uOp(f: ByteVector$FUnOp): ByteMaxVector;
          _uOp(m: VectorMask<byte>, f: ByteVector$FUnOp): ByteMaxVector;
          _uOp(a0: VectorMask, a1: ByteVector$FUnOp): ByteVector;
          _uOp(a0: ByteVector$FUnOp): ByteVector;
          unslice(origin: int, w: Vector<byte>, part: int): ByteMaxVector;
          unslice(origin: int, w: Vector<byte>, part: int, m: VectorMask<byte>): ByteMaxVector;
          unslice(origin: int): ByteMaxVector;
          unslice(a0: int): ByteVector;
          unslice(a0: int, a1: Vector, a2: int, a3: VectorMask): ByteVector;
          unslice(a0: int, a1: Vector, a2: int): ByteVector;
          unslice(a0: int): Vector;
          unslice(a0: int, a1: Vector, a2: int, a3: VectorMask): Vector;
          unslice(a0: int, a1: Vector, a2: int): Vector;
          _vec(): byte[];
          _vectorFactory(vec: byte[]): ByteMaxVector;
          _vectorFactory(a0: byte[]): ByteVector;
          vspecies(): ByteVector$ByteSpecies;
          vspecies(): AbstractSpecies;
          withLane(i: int, e: byte): ByteMaxVector;
          withLane(a0: int, a1: byte): ByteVector;
          withLaneHelper(i: int, e: byte): ByteMaxVector;
        }
        interface ByteMaxVector extends CombineTypes<[_ByteMaxVector, jdk.incubator.vector.ByteVector]> {}
        interface _ByteMaxVector$ByteMaxMask$$static extends ClassLike {
          _maskAll(bit: boolean): ByteMaxVector$ByteMaxMask;
          _prepare(bits: boolean[], offset: int): boolean[];
          _prepare(val: boolean): boolean[];
          _ETYPE: java.lang.Class<byte>;
          _FALSE_MASK: ByteMaxVector$ByteMaxMask;
          _TRUE_MASK: ByteMaxVector$ByteMaxMask;
          _VLENGTH: int;
          _new(bits: boolean[]): ByteMaxVector$ByteMaxMask;
          _new(bits: boolean[], offset: int): ByteMaxVector$ByteMaxMask;
          _new(val: boolean): ByteMaxVector$ByteMaxMask;
        }
        let ByteMaxVector$ByteMaxMask: _ByteMaxVector$ByteMaxMask$$static;
        interface _ByteMaxVector$ByteMaxMask {
          allTrue(): boolean;
          and(mask: VectorMask<byte>): ByteMaxVector$ByteMaxMask;
          and(a0: VectorMask): VectorMask;
          anyTrue(): boolean;
          _bOp(m: VectorMask<byte>, f: AbstractMask$MBinOp): ByteMaxVector$ByteMaxMask;
          _bOp(a0: VectorMask, a1: AbstractMask$MBinOp): AbstractMask;
          cast<E>(dsp: VectorSpecies<E>): VectorMask<E>;
          compress(): ByteMaxVector$ByteMaxMask;
          compress(): VectorMask;
          _defaultMaskCast<E>(dsp: AbstractSpecies<E>): VectorMask<E>;
          firstTrue(): int;
          _getBits(): boolean[];
          _indexPartiallyInUpperRange(offset: long, a1: long): ByteMaxVector$ByteMaxMask;
          _indexPartiallyInUpperRange(a0: long, a1: long): VectorMask;
          lastTrue(): int;
          not(): ByteMaxVector$ByteMaxMask;
          not(): VectorMask;
          or(mask: VectorMask<byte>): ByteMaxVector$ByteMaxMask;
          or(a0: VectorMask): VectorMask;
          toLong(): long;
          toVector(): ByteMaxVector;
          toVector(): Vector;
          trueCount(): int;
          _uOp(f: AbstractMask$MUnOp): ByteMaxVector$ByteMaxMask;
          _uOp(a0: AbstractMask$MUnOp): AbstractMask;
          vspecies(): ByteVector$ByteSpecies;
          vspecies(): AbstractSpecies;
          xor(mask: VectorMask<byte>): ByteMaxVector$ByteMaxMask;
          xor(a0: VectorMask): VectorMask;
        }
        interface ByteMaxVector$ByteMaxMask extends CombineTypes<[_ByteMaxVector$ByteMaxMask, AbstractMask<byte>]> {}
        interface _ByteMaxVector$ByteMaxShuffle$$static extends ClassLike {
          _ETYPE: java.lang.Class<byte>;
          _IOTA: ByteMaxVector$ByteMaxShuffle;
          _VLENGTH: int;
          _new(reorder: byte[]): ByteMaxVector$ByteMaxShuffle;
          new(reorder: int[]): ByteMaxVector$ByteMaxShuffle;
          new(reorder: int[], i: int): ByteMaxVector$ByteMaxShuffle;
          new(fn: java.util.function.IntUnaryOperator): ByteMaxVector$ByteMaxShuffle;
        }
        let ByteMaxVector$ByteMaxShuffle: _ByteMaxVector$ByteMaxShuffle$$static;
        interface _ByteMaxVector$ByteMaxShuffle {
          cast<F>(s: VectorSpecies<F>): VectorShuffle<F>;
          rearrange(shuffle: VectorShuffle<byte>): ByteMaxVector$ByteMaxShuffle;
          rearrange(a0: VectorShuffle): VectorShuffle;
          toVector(): ByteMaxVector;
          toVector(): Vector;
          vspecies(): ByteVector$ByteSpecies;
          vspecies(): AbstractSpecies;
        }
        interface ByteMaxVector$ByteMaxShuffle extends CombineTypes<[_ByteMaxVector$ByteMaxShuffle, AbstractShuffle<byte>]> {}
        interface _ByteVector$$static extends ClassLike {
          _arrayAddress(a: byte[], index: int): long;
          _binaryOperations(opc_: int): jdk.internal.vm.vector.VectorSupport$BinaryOperation<ByteVector,VectorMask<byte>>;
          _bitCount(a: byte): int;
          _booleanArrayAddress(a: boolean[], index: int): long;
          broadcast(species: VectorSpecies<byte>, e: byte): ByteVector;
          broadcast(species: VectorSpecies<byte>, e: long): ByteVector;
          _broadcastIntOperations(opc_: int): jdk.internal.vm.vector.VectorSupport$VectorBroadcastIntOp<ByteVector,VectorMask<byte>>;
          _byteArrayAddress(a: byte[], index: int): long;
          _checkMaskFromIndexSize(offset: int, vsp: ByteVector$ByteSpecies, m: VectorMask<byte>, scale: int, limit: int): void;
          _checkMaskFromIndexSize(offset: long, a1: ByteVector$ByteSpecies, vsp: VectorMask<byte>, m: int, scale: long): void;
          _compareWithOp(cond: int, a: byte, b: byte): boolean;
          _compressHelper(v: Vector<byte>, m: VectorMask<byte>): ByteVector;
          _expandHelper(v: Vector<byte>, m: VectorMask<byte>): ByteVector;
          fromArray(species: VectorSpecies<byte>, a: byte[], offset: int): ByteVector;
          fromArray(species: VectorSpecies<byte>, a: byte[], offset: int, m: VectorMask<byte>): ByteVector;
          fromArray(species: VectorSpecies<byte>, a: byte[], offset: int, indexMap: int[], mapOffset: int): ByteVector;
          fromArray(species: VectorSpecies<byte>, a: byte[], offset: int, indexMap: int[], mapOffset: int, m: VectorMask<byte>): ByteVector;
          _fromBits(bits: long): byte;
          fromBooleanArray(species: VectorSpecies<byte>, a: boolean[], offset: int): ByteVector;
          fromBooleanArray(species: VectorSpecies<byte>, a: boolean[], offset: int, m: VectorMask<byte>): ByteVector;
          fromBooleanArray(species: VectorSpecies<byte>, a: boolean[], offset: int, indexMap: int[], mapOffset: int): ByteVector;
          fromBooleanArray(species: VectorSpecies<byte>, a: boolean[], offset: int, indexMap: int[], mapOffset: int, m: VectorMask<byte>): ByteVector;
          fromMemorySegment(species: VectorSpecies<byte>, ms: java.lang.foreign.MemorySegment, offset: long, a3: java.nio.ByteOrder): ByteVector;
          fromMemorySegment(species: VectorSpecies<byte>, ms: java.lang.foreign.MemorySegment, offset: long, a3: java.nio.ByteOrder, bo: VectorMask<byte>): ByteVector;
          _memorySegmentGet(ms: java.lang.foreign.MemorySegment, o: long, a2: int): byte;
          _memorySegmentSet(ms: java.lang.foreign.MemorySegment, o: long, a2: int, i: byte): void;
          _numberOfLeadingZeros(a: byte): int;
          _numberOfTrailingZeros(a: byte): int;
          _opCode(op: VectorOperators$Operator): int;
          _opCode(op: VectorOperators$Operator, requireKind: int): int;
          _opKind(op: VectorOperators$Operator, bit: int): boolean;
          _reductionOperations(opc_: int): jdk.internal.vm.vector.VectorSupport$ReductionOperation<ByteVector,VectorMask<byte>>;
          _reverse(a: byte): byte;
          _rotateLeft(a: byte, n: int): byte;
          _rotateRight(a: byte, n: int): byte;
          _species(s: VectorShape): ByteVector$ByteSpecies;
          _ternaryOperations(opc_: int): jdk.internal.vm.vector.VectorSupport$TernaryOperation<ByteVector,VectorMask<byte>>;
          _toBits(e: byte): long;
          _unaryOperations(opc_: int): jdk.internal.vm.vector.VectorSupport$UnaryOperation<ByteVector,VectorMask<byte>>;
          zero(species: VectorSpecies<byte>): ByteVector;
          _ARRAY_BASE: long;
          _ARRAY_BOOLEAN_BASE: long;
          _ARRAY_BOOLEAN_SHIFT: int;
          _ARRAY_SHIFT: int;
          _BIN_IMPL: VectorOperators$ImplCache<VectorOperators$Binary,jdk.internal.vm.vector.VectorSupport$BinaryOperation<ByteVector,VectorMask<byte>>>;
          _BIN_INT_IMPL: VectorOperators$ImplCache<VectorOperators$Binary,jdk.internal.vm.vector.VectorSupport$VectorBroadcastIntOp<ByteVector,VectorMask<byte>>>;
          _ELEMENT_LAYOUT: java.lang.foreign.ValueLayout$OfByte;
          _FORBID_OPCODE_KIND: int;
          _LSHR_SETUP_MASK: int;
          _MAX_OR_INF: byte;
          _MIN_OR_INF: byte;
          _REDUCE_IMPL: VectorOperators$ImplCache<VectorOperators$Associative,jdk.internal.vm.vector.VectorSupport$ReductionOperation<ByteVector,VectorMask<byte>>>;
          _SHIFT_MASK: int;
          readonly SPECIES_128: VectorSpecies<byte>;
          readonly SPECIES_256: VectorSpecies<byte>;
          readonly SPECIES_512: VectorSpecies<byte>;
          readonly SPECIES_64: VectorSpecies<byte>;
          readonly SPECIES_MAX: VectorSpecies<byte>;
          readonly SPECIES_PREFERRED: VectorSpecies<byte>;
          _TERN_IMPL: VectorOperators$ImplCache<VectorOperators$Ternary,jdk.internal.vm.vector.VectorSupport$TernaryOperation<ByteVector,VectorMask<byte>>>;
          _UN_IMPL: VectorOperators$ImplCache<VectorOperators$Unary,jdk.internal.vm.vector.VectorSupport$UnaryOperation<ByteVector,VectorMask<byte>>>;
          _new(vec: byte[]): ByteVector;
        }
        let ByteVector: _ByteVector$$static;
        interface _ByteVector {
          abs(): ByteVector;
          abs(): Vector;
          add(v: Vector<byte>): ByteVector;
          add(e: byte): ByteVector;
          add(v: Vector<byte>, m: VectorMask<byte>): ByteVector;
          add(e: byte, m: VectorMask<byte>): ByteVector;
          add(a0: Vector, a1: VectorMask): Vector;
          add(a0: Vector): Vector;
          addIndex(a0: int): ByteVector;
          addIndex(a0: int): Vector;
          _addIndexTemplate(scale: int): ByteVector;
          and(v: Vector<byte>): ByteVector;
          and(e: byte): ByteVector;
          _bOp(a0: Vector<byte>, a1: ByteVector$FBinOp): ByteVector;
          _bOp(a0: Vector<byte>, a1: VectorMask<byte>, a2: ByteVector$FBinOp): ByteVector;
          _bOpTemplate(o: Vector<byte>, f: ByteVector$FBinOp): ByteVector;
          _bOpTemplate(o: Vector<byte>, m: VectorMask<byte>, f: ByteVector$FBinOp): ByteVector;
          _bTest(cond: int, o: Vector<byte>, f: ByteVector$FBinTest): AbstractMask<byte>;
          bitwiseBlend(bits: Vector<byte>, mask: Vector<byte>): ByteVector;
          bitwiseBlend(bits: byte, mask: byte): ByteVector;
          bitwiseBlend(bits: byte, mask: Vector<byte>): ByteVector;
          bitwiseBlend(bits: Vector<byte>, mask: byte): ByteVector;
          blend(a0: Vector<byte>, a1: VectorMask<byte>): ByteVector;
          blend(e: byte, m: VectorMask<byte>): ByteVector;
          blend(e: long, a1: VectorMask<byte>): ByteVector;
          blend(a0: long, a1: VectorMask): Vector;
          blend(a0: Vector, a1: VectorMask): Vector;
          _blendTemplate<M>(maskType: java.lang.Class<M>, v: ByteVector, m: M): ByteVector;
          broadcast(a0: byte): ByteVector;
          broadcast(a0: long): ByteVector;
          broadcast(a0: long): Vector;
          _broadcastTemplate(e: byte): ByteVector;
          _broadcastTemplate(e: long): ByteVector;
          compare(a0: VectorOperators$Comparison, a1: Vector<byte>): VectorMask<byte>;
          compare(a0: VectorOperators$Comparison, a1: byte): VectorMask<byte>;
          compare(op: VectorOperators$Comparison, e: byte, m: VectorMask<byte>): VectorMask<byte>;
          compare(a0: VectorOperators$Comparison, a1: long): VectorMask<byte>;
          compare(op: VectorOperators$Comparison, e: long, a2: VectorMask<byte>): VectorMask<byte>;
          _compareTemplate<M>(maskType: java.lang.Class<M>, op: VectorOperators$Comparison, v: Vector<byte>): M;
          _compareTemplate<M>(maskType: java.lang.Class<M>, op: VectorOperators$Comparison, v: Vector<byte>, m: M): M;
          _compareTemplate<M>(maskType: java.lang.Class<M>, op: VectorOperators$Comparison, e: byte): M;
          _compareTemplate<M>(maskType: java.lang.Class<M>, op: VectorOperators$Comparison, e: long): M;
          compress(a0: VectorMask<byte>): ByteVector;
          compress(a0: VectorMask): Vector;
          _compressTemplate<M>(masktype: java.lang.Class<M>, m: M): ByteVector;
          _conditionalStoreNYI(offset: int, vsp: ByteVector$ByteSpecies, m: VectorMask<byte>, scale: int, limit: int): void;
          div(v: Vector<byte>): ByteVector;
          div(e: byte): ByteVector;
          div(v: Vector<byte>, m: VectorMask<byte>): ByteVector;
          div(e: byte, m: VectorMask<byte>): ByteVector;
          div(a0: Vector, a1: VectorMask): Vector;
          div(a0: Vector): Vector;
          eq(v: Vector<byte>): VectorMask<byte>;
          eq(e: byte): VectorMask<byte>;
          equals(obj: any): boolean;
          expand(a0: VectorMask<byte>): ByteVector;
          expand(a0: VectorMask): Vector;
          _expandTemplate<M>(masktype: java.lang.Class<M>, m: M): ByteVector;
          _fromArray0(a0: byte[], a1: int): ByteVector;
          _fromArray0(a0: byte[], a1: int, a2: VectorMask<byte>, a3: int): ByteVector;
          _fromArray0Template(a: byte[], offset: int): ByteVector;
          _fromArray0Template<M>(maskClass: java.lang.Class<M>, a: byte[], offset: int, m: M, offsetInRange: int): ByteVector;
          _fromBooleanArray0(a0: boolean[], a1: int): ByteVector;
          _fromBooleanArray0(a0: boolean[], a1: int, a2: VectorMask<byte>, a3: int): ByteVector;
          _fromBooleanArray0Template(a: boolean[], offset: int): ByteVector;
          _fromBooleanArray0Template<M>(maskClass: java.lang.Class<M>, a: boolean[], offset: int, m: M, offsetInRange: int): ByteVector;
          _fromMemorySegment0(a0: java.lang.foreign.MemorySegment, a1: long): ByteVector;
          _fromMemorySegment0(a0: java.lang.foreign.MemorySegment, a1: long, a2: VectorMask<byte>, a3: int): ByteVector;
          _fromMemorySegment0(a0: java.lang.foreign.MemorySegment, a1: long): AbstractVector;
          _fromMemorySegment0Template(ms: java.lang.foreign.MemorySegment, offset: long): ByteVector;
          _fromMemorySegment0Template<M>(maskClass: java.lang.Class<M>, ms: java.lang.foreign.MemorySegment, offset: long, a3: M, m: int): ByteVector;
          hashCode(): int;
          intoArray(a: byte[], offset: int): void;
          intoArray(a: byte[], offset: int, m: VectorMask<byte>): void;
          intoArray(a: byte[], offset: int, indexMap: int[], mapOffset: int): void;
          intoArray(a: byte[], offset: int, indexMap: int[], mapOffset: int, m: VectorMask<byte>): void;
          _intoArray0(a0: byte[], a1: int): void;
          _intoArray0(a0: byte[], a1: int, a2: VectorMask<byte>): void;
          _intoArray0Template(a: byte[], offset: int): void;
          _intoArray0Template<M>(maskClass: java.lang.Class<M>, a: byte[], offset: int, m: M): void;
          intoBooleanArray(a: boolean[], offset: int): void;
          intoBooleanArray(a: boolean[], offset: int, m: VectorMask<byte>): void;
          intoBooleanArray(a: boolean[], offset: int, indexMap: int[], mapOffset: int): void;
          intoBooleanArray(a: boolean[], offset: int, indexMap: int[], mapOffset: int, m: VectorMask<byte>): void;
          _intoBooleanArray0(a0: boolean[], a1: int, a2: VectorMask<byte>): void;
          _intoBooleanArray0Template<M>(maskClass: java.lang.Class<M>, a: boolean[], offset: int, m: M): void;
          intoMemorySegment(ms: java.lang.foreign.MemorySegment, offset: long, a2: java.nio.ByteOrder): void;
          intoMemorySegment(ms: java.lang.foreign.MemorySegment, offset: long, a2: java.nio.ByteOrder, bo: VectorMask<byte>): void;
          _intoMemorySegment0(ms: java.lang.foreign.MemorySegment, offset: long): void;
          _intoMemorySegment0(a0: java.lang.foreign.MemorySegment, a1: long, a2: VectorMask<byte>): void;
          _intoMemorySegment0Template<M>(maskClass: java.lang.Class<M>, ms: java.lang.foreign.MemorySegment, offset: long, a3: M): void;
          lane(a0: int): byte;
          lanewise(a0: VectorOperators$Unary): ByteVector;
          lanewise(a0: VectorOperators$Unary, a1: VectorMask<byte>): ByteVector;
          lanewise(a0: VectorOperators$Binary, a1: Vector<byte>): ByteVector;
          lanewise(a0: VectorOperators$Binary, a1: Vector<byte>, a2: VectorMask<byte>): ByteVector;
          lanewise(op: VectorOperators$Binary, e: byte): ByteVector;
          lanewise(op: VectorOperators$Binary, e: byte, m: VectorMask<byte>): ByteVector;
          lanewise(op: VectorOperators$Binary, e: long): ByteVector;
          lanewise(op: VectorOperators$Binary, e: long, a2: VectorMask<byte>): ByteVector;
          lanewise(a0: VectorOperators$Ternary, a1: Vector<byte>, a2: Vector<byte>): ByteVector;
          lanewise(a0: VectorOperators$Ternary, a1: Vector<byte>, a2: Vector<byte>, a3: VectorMask<byte>): ByteVector;
          lanewise(op: VectorOperators$Ternary, e1: byte, e2: byte): ByteVector;
          lanewise(op: VectorOperators$Ternary, e1: byte, e2: byte, m: VectorMask<byte>): ByteVector;
          lanewise(op: VectorOperators$Ternary, v1: Vector<byte>, e2: byte): ByteVector;
          lanewise(op: VectorOperators$Ternary, v1: Vector<byte>, e2: byte, m: VectorMask<byte>): ByteVector;
          lanewise(op: VectorOperators$Ternary, e1: byte, v2: Vector<byte>): ByteVector;
          lanewise(op: VectorOperators$Ternary, e1: byte, v2: Vector<byte>, m: VectorMask<byte>): ByteVector;
          lanewise(a0: VectorOperators$Ternary, a1: Vector, a2: Vector, a3: VectorMask): Vector;
          lanewise(a0: VectorOperators$Ternary, a1: Vector, a2: Vector): Vector;
          lanewise(a0: VectorOperators$Binary, a1: long, a2: VectorMask): Vector;
          lanewise(a0: VectorOperators$Binary, a1: long): Vector;
          lanewise(a0: VectorOperators$Binary, a1: Vector, a2: VectorMask): Vector;
          lanewise(a0: VectorOperators$Binary, a1: Vector): Vector;
          lanewise(a0: VectorOperators$Unary, a1: VectorMask): Vector;
          lanewise(a0: VectorOperators$Unary): Vector;
          _lanewiseShift(a0: VectorOperators$Binary, a1: int): ByteVector;
          _lanewiseShift(a0: VectorOperators$Binary, a1: int, a2: VectorMask<byte>): ByteVector;
          _lanewiseShiftTemplate(op: VectorOperators$Binary, e: int): ByteVector;
          _lanewiseShiftTemplate(op: VectorOperators$Binary, maskClass: java.lang.Class<VectorMask<byte>>, e: int, m: VectorMask<byte>): ByteVector;
          _lanewiseTemplate(op: VectorOperators$Unary): ByteVector;
          _lanewiseTemplate(op: VectorOperators$Unary, maskClass: java.lang.Class<VectorMask<byte>>, m: VectorMask<byte>): ByteVector;
          _lanewiseTemplate(op: VectorOperators$Binary, v: Vector<byte>): ByteVector;
          _lanewiseTemplate(op: VectorOperators$Binary, maskClass: java.lang.Class<VectorMask<byte>>, v: Vector<byte>, m: VectorMask<byte>): ByteVector;
          _lanewiseTemplate(op: VectorOperators$Ternary, v1: Vector<byte>, v2: Vector<byte>): ByteVector;
          _lanewiseTemplate(op: VectorOperators$Ternary, maskClass: java.lang.Class<VectorMask<byte>>, v1: Vector<byte>, v2: Vector<byte>, m: VectorMask<byte>): ByteVector;
          _ldLongOp(memory: java.lang.foreign.MemorySegment, offset: long, a2: ByteVector$FLdLongOp): ByteVector;
          _ldLongOp(memory: java.lang.foreign.MemorySegment, offset: long, a2: VectorMask<byte>, m: ByteVector$FLdLongOp): ByteVector;
          _ldOp<M>(memory: M, offset: int, f: ByteVector$FLdOp<M>): ByteVector;
          _ldOp<M>(memory: M, offset: int, m: VectorMask<byte>, f: ByteVector$FLdOp<M>): ByteVector;
          lt(v: Vector<byte>): VectorMask<byte>;
          lt(e: byte): VectorMask<byte>;
          _maskFactory(bits: boolean[]): AbstractMask<byte>;
          max(v: Vector<byte>): ByteVector;
          max(e: byte): ByteVector;
          max(a0: Vector): Vector;
          _maybeSwap(bo: java.nio.ByteOrder): ByteVector;
          _maybeSwap(a0: java.nio.ByteOrder): AbstractVector;
          min(v: Vector<byte>): ByteVector;
          min(e: byte): ByteVector;
          min(a0: Vector): Vector;
          mul(v: Vector<byte>): ByteVector;
          mul(e: byte): ByteVector;
          mul(v: Vector<byte>, m: VectorMask<byte>): ByteVector;
          mul(e: byte, m: VectorMask<byte>): ByteVector;
          mul(a0: Vector, a1: VectorMask): Vector;
          mul(a0: Vector): Vector;
          neg(): ByteVector;
          neg(): Vector;
          not(): ByteVector;
          or(v: Vector<byte>): ByteVector;
          or(e: byte): ByteVector;
          _rOp(a0: byte, a1: VectorMask<byte>, a2: ByteVector$FBinOp): byte;
          _rOpTemplate(v: byte, m: VectorMask<byte>, f: ByteVector$FBinOp): byte;
          _rOpTemplate(v: byte, f: ByteVector$FBinOp): byte;
          rearrange(a0: VectorShuffle<byte>): ByteVector;
          rearrange(a0: VectorShuffle<byte>, a1: VectorMask<byte>): ByteVector;
          rearrange(a0: VectorShuffle<byte>, a1: Vector<byte>): ByteVector;
          rearrange(a0: VectorShuffle, a1: Vector): Vector;
          rearrange(a0: VectorShuffle, a1: VectorMask): Vector;
          rearrange(a0: VectorShuffle): Vector;
          _rearrangeTemplate<S>(shuffletype: java.lang.Class<S>, shuffle: S): ByteVector;
          _rearrangeTemplate<S, M>(shuffletype: java.lang.Class<S>, masktype: java.lang.Class<M>, shuffle: S, m: M): ByteVector;
          _rearrangeTemplate<S>(shuffletype: java.lang.Class<S>, shuffle: S, v: ByteVector): ByteVector;
          reduceLanes(a0: VectorOperators$Associative): byte;
          reduceLanes(a0: VectorOperators$Associative, a1: VectorMask<byte>): byte;
          _reduceLanesTemplate(op: VectorOperators$Associative, maskClass: java.lang.Class<VectorMask<byte>>, m: VectorMask<byte>): byte;
          _reduceLanesTemplate(op: VectorOperators$Associative): byte;
          reduceLanesToLong(a0: VectorOperators$Associative): long;
          reduceLanesToLong(a0: VectorOperators$Associative, a1: VectorMask<byte>): long;
          reinterpretAsBytes(): ByteVector;
          reinterpretAsDoubles(): DoubleVector;
          reinterpretAsFloats(): FloatVector;
          reinterpretAsInts(): IntVector;
          reinterpretAsLongs(): LongVector;
          reinterpretAsShorts(): ShortVector;
          selectFrom(a0: Vector<byte>): ByteVector;
          selectFrom(a0: Vector<byte>, a1: VectorMask<byte>): ByteVector;
          selectFrom(a0: Vector, a1: VectorMask): Vector;
          selectFrom(a0: Vector): Vector;
          _selectFromTemplate(v: ByteVector): ByteVector;
          _selectFromTemplate(v: ByteVector, m: AbstractMask<byte>): ByteVector;
          slice(a0: int, a1: Vector<byte>): ByteVector;
          slice(origin: int, w: Vector<byte>, m: VectorMask<byte>): ByteVector;
          slice(a0: int): ByteVector;
          slice(a0: int): AbstractVector;
          slice(a0: int, a1: Vector): AbstractVector;
          slice(a0: int): Vector;
          slice(a0: int, a1: Vector, a2: VectorMask): Vector;
          slice(a0: int, a1: Vector): Vector;
          _sliceTemplate(origin: int, v1: Vector<byte>): ByteVector;
          _sliceTemplate(origin: int): ByteVector;
          _stLongOp(memory: java.lang.foreign.MemorySegment, offset: long, a2: ByteVector$FStLongOp): void;
          _stLongOp(memory: java.lang.foreign.MemorySegment, offset: long, a2: VectorMask<byte>, m: ByteVector$FStLongOp): void;
          _stOp<M>(memory: M, offset: int, f: ByteVector$FStOp<M>): void;
          _stOp<M>(memory: M, offset: int, m: VectorMask<byte>, f: ByteVector$FStOp<M>): void;
          sub(v: Vector<byte>): ByteVector;
          sub(e: byte): ByteVector;
          sub(v: Vector<byte>, m: VectorMask<byte>): ByteVector;
          sub(e: byte, m: VectorMask<byte>): ByteVector;
          sub(a0: Vector, a1: VectorMask): Vector;
          sub(a0: Vector): Vector;
          _tOp(a0: Vector<byte>, a1: Vector<byte>, a2: ByteVector$FTriOp): ByteVector;
          _tOp(a0: Vector<byte>, a1: Vector<byte>, a2: VectorMask<byte>, a3: ByteVector$FTriOp): ByteVector;
          _tOpTemplate(o1: Vector<byte>, o2: Vector<byte>, f: ByteVector$FTriOp): ByteVector;
          _tOpTemplate(o1: Vector<byte>, o2: Vector<byte>, m: VectorMask<byte>, f: ByteVector$FTriOp): ByteVector;
          test(a0: VectorOperators$Test): VectorMask<byte>;
          test(a0: VectorOperators$Test, a1: VectorMask<byte>): VectorMask<byte>;
          _testTemplate<M>(maskType: java.lang.Class<M>, op: VectorOperators$Test): M;
          _testTemplate<M>(maskType: java.lang.Class<M>, op: VectorOperators$Test, mask: M): M;
          toArray(): byte[];
          toArray(): any;
          toDoubleArray(): double[];
          toIntArray(): int[];
          toLongArray(): long[];
          _toShuffle0(dsp: ByteVector$ByteSpecies): VectorShuffle<byte>;
          _toShuffleTemplate(shuffleType: java.lang.Class<any>): VectorShuffle<byte>;
          toString(): string;
          _uOp(a0: ByteVector$FUnOp): ByteVector;
          _uOp(a0: VectorMask<byte>, a1: ByteVector$FUnOp): ByteVector;
          _uOpTemplate(f: ByteVector$FUnOp): ByteVector;
          _uOpTemplate(m: VectorMask<byte>, f: ByteVector$FUnOp): ByteVector;
          unslice(a0: int, a1: Vector<byte>, a2: int): ByteVector;
          unslice(a0: int, a1: Vector<byte>, a2: int, a3: VectorMask<byte>): ByteVector;
          unslice(a0: int): ByteVector;
          unslice(a0: int): Vector;
          unslice(a0: int, a1: Vector, a2: int, a3: VectorMask): Vector;
          unslice(a0: int, a1: Vector, a2: int): Vector;
          _unsliceTemplate(origin: int, w: Vector<byte>, part: int): ByteVector;
          _unsliceTemplate<M>(maskType: java.lang.Class<M>, origin: int, w: Vector<byte>, part: int, m: M): ByteVector;
          _unsliceTemplate(origin: int): ByteVector;
          _vOp(f: ByteVector$FVOp): ByteVector;
          _vOp(m: VectorMask<byte>, f: ByteVector$FVOp): ByteVector;
          _vec(): byte[];
          _vectorFactory(a0: byte[]): ByteVector;
          viewAsFloatingLanes(): Vector<any>;
          viewAsIntegralLanes(): ByteVector;
          viewAsIntegralLanes(): Vector;
          _vspecies(): ByteVector$ByteSpecies;
          _vspecies(): AbstractSpecies;
          withLane(a0: int, a1: byte): ByteVector;
          _wrongPartForSlice(part: int): java.lang.ArrayIndexOutOfBoundsException;
        }
        interface ByteVector extends CombineTypes<[_ByteVector, AbstractVector<byte>]> {}
        interface _ByteVector$ByteSpecies$$static extends ClassLike {
          _toIntegralChecked(e: byte, convertToInt: boolean): long;
        }
        let ByteVector$ByteSpecies: _ByteVector$ByteSpecies$$static;
        interface _ByteVector$ByteSpecies {
          _broadcast(e: byte): ByteVector;
          broadcast(e: long): ByteVector;
          broadcast(a0: long): Vector;
          _broadcastBits(bits: long): ByteVector;
          _broadcastBits(a0: long): AbstractVector;
          checkValue(e: long): long;
          _dummyVector(): ByteVector;
          _dummyVector(): AbstractVector;
          elementType(): java.lang.Class<byte>;
          fromArray(a: any, offset: int): ByteVector;
          fromArray(a0: any, a1: int): Vector;
          _fromIntValues(values: int[]): ByteVector;
          _fromIntValues(a0: int[]): Vector;
          fromMemorySegment(ms: java.lang.foreign.MemorySegment, offset: long, a2: java.nio.ByteOrder): ByteVector;
          fromMemorySegment(a0: java.lang.foreign.MemorySegment, a1: long, a2: java.nio.ByteOrder): Vector;
          _genericElementType(): java.lang.Class<byte>;
          iota(): ByteVector;
          iota(): AbstractVector;
          _ldLongOp(memory: java.lang.foreign.MemorySegment, offset: long, a2: ByteVector$FLdLongOp): ByteVector;
          _ldLongOp(memory: java.lang.foreign.MemorySegment, offset: long, a2: VectorMask<byte>, m: ByteVector$FLdLongOp): ByteVector;
          _ldOp<M>(memory: M, offset: int, f: ByteVector$FLdOp<M>): ByteVector;
          _ldOp<M>(memory: M, offset: int, m: VectorMask<byte>, f: ByteVector$FLdOp<M>): ByteVector;
          _longToElementBits(value: long): long;
          maskAll(bit: boolean): VectorMask<byte>;
          _rvOp(f: AbstractSpecies$RVOp): ByteVector;
          _rvOp(a0: AbstractSpecies$RVOp): AbstractVector;
          _stLongOp(memory: java.lang.foreign.MemorySegment, offset: long, a2: ByteVector$FStLongOp): void;
          _stLongOp(memory: java.lang.foreign.MemorySegment, offset: long, a2: AbstractMask<byte>, m: ByteVector$FStLongOp): void;
          _stOp<M>(memory: M, offset: int, f: ByteVector$FStOp<M>): void;
          _stOp<M>(memory: M, offset: int, m: AbstractMask<byte>, f: ByteVector$FStOp<M>): void;
          _vOp(f: ByteVector$FVOp): ByteVector;
          _vOp(m: VectorMask<byte>, f: ByteVector$FVOp): ByteVector;
          vectorType(): java.lang.Class<ByteVector>;
          zero(): ByteVector;
          zero(): AbstractVector;
          zero(): Vector;
        }
        interface ByteVector$ByteSpecies extends CombineTypes<[_ByteVector$ByteSpecies, AbstractSpecies<byte>]> {}
        interface _ByteVector$FBinOp$$static extends ClassLike {
        }
        let ByteVector$FBinOp: _ByteVector$FBinOp$$static;
        interface _ByteVector$FBinOp {
          apply(a0: int, a1: byte, a2: byte): byte;
(a0: int, a1: byte, a2: byte): byte;
        }
        interface ByteVector$FBinOp extends CombineTypes<[_ByteVector$FBinOp, java.lang.Object]> {}
        interface _ByteVector$FBinTest$$static extends ClassLike {
        }
        let ByteVector$FBinTest: _ByteVector$FBinTest$$static;
        interface _ByteVector$FBinTest {
          apply(a0: int, a1: int, a2: byte, a3: byte): boolean;
(a0: int, a1: int, a2: byte, a3: byte): boolean;
        }
        interface ByteVector$FBinTest extends CombineTypes<[_ByteVector$FBinTest, java.lang.Object]> {}
        interface _ByteVector$FLdLongOp$$static extends ClassLike {
        }
        let ByteVector$FLdLongOp: _ByteVector$FLdLongOp$$static;
        interface _ByteVector$FLdLongOp {
          apply(a0: java.lang.foreign.MemorySegment, a1: long, a2: int): byte;
(a0: java.lang.foreign.MemorySegment, a1: long, a2: int): byte;
        }
        interface ByteVector$FLdLongOp extends CombineTypes<[_ByteVector$FLdLongOp, java.lang.Object]> {}
        interface _ByteVector$FLdOp$$static<M> extends ClassLike {
        }
        let ByteVector$FLdOp: _ByteVector$FLdOp$$static<M>;
        interface _ByteVector$FLdOp<M> {
          apply(a0: M, a1: int, a2: int): byte;
(a0: M, a1: int, a2: int): byte;
        }
        interface ByteVector$FLdOp<M> extends CombineTypes<[_ByteVector$FLdOp<M>, java.lang.Object]> {}
        interface _ByteVector$FStLongOp$$static extends ClassLike {
        }
        let ByteVector$FStLongOp: _ByteVector$FStLongOp$$static;
        interface _ByteVector$FStLongOp {
          apply(a0: java.lang.foreign.MemorySegment, a1: long, a2: int, a3: byte): void;
(a0: java.lang.foreign.MemorySegment, a1: long, a2: int, a3: byte): void;
        }
        interface ByteVector$FStLongOp extends CombineTypes<[_ByteVector$FStLongOp, java.lang.Object]> {}
        interface _ByteVector$FStOp$$static<M> extends ClassLike {
        }
        let ByteVector$FStOp: _ByteVector$FStOp$$static<M>;
        interface _ByteVector$FStOp<M> {
          apply(a0: M, a1: int, a2: int, a3: byte): void;
(a0: M, a1: int, a2: int, a3: byte): void;
        }
        interface ByteVector$FStOp<M> extends CombineTypes<[_ByteVector$FStOp<M>, java.lang.Object]> {}
        interface _ByteVector$FTriOp$$static extends ClassLike {
        }
        let ByteVector$FTriOp: _ByteVector$FTriOp$$static;
        interface _ByteVector$FTriOp {
          apply(a0: int, a1: byte, a2: byte, a3: byte): byte;
(a0: int, a1: byte, a2: byte, a3: byte): byte;
        }
        interface ByteVector$FTriOp extends CombineTypes<[_ByteVector$FTriOp, java.lang.Object]> {}
        interface _ByteVector$FUnOp$$static extends ClassLike {
        }
        let ByteVector$FUnOp: _ByteVector$FUnOp$$static;
        interface _ByteVector$FUnOp {
          apply(a0: int, a1: byte): byte;
(a0: int, a1: byte): byte;
        }
        interface ByteVector$FUnOp extends CombineTypes<[_ByteVector$FUnOp, java.lang.Object]> {}
        interface _ByteVector$FVOp$$static extends ClassLike {
        }
        let ByteVector$FVOp: _ByteVector$FVOp$$static;
        interface _ByteVector$FVOp {
          apply(a0: int): byte;
(a0: int): byte;
        }
        interface ByteVector$FVOp extends CombineTypes<[_ByteVector$FVOp, java.lang.Object]> {}
        interface _Double128Vector$$static extends ClassLike {
          _ETYPE: java.lang.Class<double>;
          _IOTA: Double128Vector;
          _VCLASS: java.lang.Class<Double128Vector>;
          _VLENGTH: int;
          _VSHAPE: VectorShape;
          _VSIZE: int;
          _VSPECIES: DoubleVector$DoubleSpecies;
          _ZERO: Double128Vector;
          _new(v: double[]): Double128Vector;
          _new(v: any): Double128Vector;
        }
        let Double128Vector: _Double128Vector$$static;
        interface _Double128Vector {
          addIndex(scale: int): Double128Vector;
          addIndex(a0: int): DoubleVector;
          addIndex(a0: int): Vector;
          _asByteVectorRaw(): Byte128Vector;
          _asByteVectorRaw(): ByteVector;
          _asVectorRaw(laneType: LaneType): AbstractVector<any>;
          _bOp(v: Vector<double>, f: DoubleVector$FBinOp): Double128Vector;
          _bOp(v: Vector<double>, m: VectorMask<double>, f: DoubleVector$FBinOp): Double128Vector;
          _bOp(a0: Vector, a1: VectorMask, a2: DoubleVector$FBinOp): DoubleVector;
          _bOp(a0: Vector, a1: DoubleVector$FBinOp): DoubleVector;
          bitSize(): int;
          blend(v: Vector<double>, m: VectorMask<double>): Double128Vector;
          blend(a0: Vector, a1: VectorMask): DoubleVector;
          blend(a0: Vector, a1: VectorMask): Vector;
          broadcast(e: double): Double128Vector;
          broadcast(e: long): Double128Vector;
          broadcast(a0: long): DoubleVector;
          broadcast(a0: double): DoubleVector;
          broadcast(a0: long): Vector;
          byteSize(): int;
          compare(op: VectorOperators$Comparison, v: Vector<double>): Double128Vector$Double128Mask;
          compare(op: VectorOperators$Comparison, s: double): Double128Vector$Double128Mask;
          compare(op: VectorOperators$Comparison, s: long): Double128Vector$Double128Mask;
          compare(op: VectorOperators$Comparison, v: Vector<double>, m: VectorMask<double>): Double128Vector$Double128Mask;
          compare(a0: VectorOperators$Comparison, a1: long): VectorMask;
          compare(a0: VectorOperators$Comparison, a1: double): VectorMask;
          compare(a0: VectorOperators$Comparison, a1: Vector): VectorMask;
          compare(a0: VectorOperators$Comparison, a1: Vector, a2: VectorMask): VectorMask;
          compress(m: VectorMask<double>): Double128Vector;
          compress(a0: VectorMask): DoubleVector;
          compress(a0: VectorMask): Vector;
          convertShape<F>(conv: VectorOperators$Conversion<double,F>, rsp: VectorSpecies<F>, part: int): Vector<F>;
          elementSize(): int;
          elementType(): java.lang.Class<double>;
          expand(m: VectorMask<double>): Double128Vector;
          expand(a0: VectorMask): DoubleVector;
          expand(a0: VectorMask): Vector;
          _fromArray0(a: double[], offset: int): DoubleVector;
          _fromArray0(a: double[], offset: int, m: VectorMask<double>, offsetInRange: int): DoubleVector;
          _fromArray0(a: double[], offset: int, indexMap: int[], mapOffset: int, m: VectorMask<double>): DoubleVector;
          _fromMemorySegment0(ms: java.lang.foreign.MemorySegment, offset: long): DoubleVector;
          _fromMemorySegment0(ms: java.lang.foreign.MemorySegment, offset: long, a2: VectorMask<double>, m: int): DoubleVector;
          _fromMemorySegment0(a0: java.lang.foreign.MemorySegment, a1: long): AbstractVector;
          _intoArray0(a: double[], offset: int): void;
          _intoArray0(a: double[], offset: int, m: VectorMask<double>): void;
          _intoArray0(a: double[], offset: int, indexMap: int[], mapOffset: int, m: VectorMask<double>): void;
          _intoMemorySegment0(ms: java.lang.foreign.MemorySegment, offset: long, a2: VectorMask<double>): void;
          _iotaShuffle(): Double128Vector$Double128Shuffle;
          _iotaShuffle(start: int, step: int, wrap: boolean): Double128Vector$Double128Shuffle;
          _iotaShuffle(a0: int, a1: int, a2: boolean): AbstractShuffle;
          _iotaShuffle(): AbstractShuffle;
          lane(i: int): double;
          laneHelper(i: int): long;
          lanewise(op: VectorOperators$Unary): Double128Vector;
          lanewise(op: VectorOperators$Unary, m: VectorMask<double>): Double128Vector;
          lanewise(op: VectorOperators$Binary, v: Vector<double>): Double128Vector;
          lanewise(op: VectorOperators$Binary, v: Vector<double>, m: VectorMask<double>): Double128Vector;
          lanewise(op: VectorOperators$Ternary, v1: Vector<double>, v2: Vector<double>): Double128Vector;
          lanewise(op: VectorOperators$Ternary, v1: Vector<double>, v2: Vector<double>, m: VectorMask<double>): Double128Vector;
          lanewise(a0: VectorOperators$Ternary, a1: Vector, a2: Vector, a3: VectorMask): DoubleVector;
          lanewise(a0: VectorOperators$Ternary, a1: Vector, a2: Vector): DoubleVector;
          lanewise(a0: VectorOperators$Binary, a1: Vector, a2: VectorMask): DoubleVector;
          lanewise(a0: VectorOperators$Binary, a1: Vector): DoubleVector;
          lanewise(a0: VectorOperators$Unary, a1: VectorMask): DoubleVector;
          lanewise(a0: VectorOperators$Unary): DoubleVector;
          lanewise(a0: VectorOperators$Ternary, a1: Vector, a2: Vector, a3: VectorMask): Vector;
          lanewise(a0: VectorOperators$Ternary, a1: Vector, a2: Vector): Vector;
          lanewise(a0: VectorOperators$Binary, a1: Vector, a2: VectorMask): Vector;
          lanewise(a0: VectorOperators$Binary, a1: Vector): Vector;
          lanewise(a0: VectorOperators$Unary, a1: VectorMask): Vector;
          lanewise(a0: VectorOperators$Unary): Vector;
          length(): int;
          _maskFromArray(bits: boolean[]): Double128Vector$Double128Mask;
          _maskFromArray(a0: boolean[]): AbstractMask;
          _rOp(v: double, a1: VectorMask<double>, m: DoubleVector$FBinOp): double;
          rearrange(s: VectorShuffle<double>): Double128Vector;
          rearrange(shuffle: VectorShuffle<double>, m: VectorMask<double>): Double128Vector;
          rearrange(s: VectorShuffle<double>, v: Vector<double>): Double128Vector;
          rearrange(a0: VectorShuffle, a1: Vector): DoubleVector;
          rearrange(a0: VectorShuffle, a1: VectorMask): DoubleVector;
          rearrange(a0: VectorShuffle): DoubleVector;
          rearrange(a0: VectorShuffle, a1: Vector): Vector;
          rearrange(a0: VectorShuffle, a1: VectorMask): Vector;
          rearrange(a0: VectorShuffle): Vector;
          reduceLanes(op: VectorOperators$Associative): double;
          reduceLanes(op: VectorOperators$Associative, m: VectorMask<double>): double;
          reduceLanesToLong(op: VectorOperators$Associative): long;
          reduceLanesToLong(op: VectorOperators$Associative, m: VectorMask<double>): long;
          reinterpretShape<F>(toSpecies: VectorSpecies<F>, part: int): Vector<F>;
          selectFrom(v: Vector<double>): Double128Vector;
          selectFrom(v: Vector<double>, m: VectorMask<double>): Double128Vector;
          selectFrom(a0: Vector, a1: VectorMask): DoubleVector;
          selectFrom(a0: Vector): DoubleVector;
          selectFrom(a0: Vector, a1: VectorMask): Vector;
          selectFrom(a0: Vector): Vector;
          shape(): VectorShape;
          _shuffleFromArray(indexes: int[], i: int): Double128Vector$Double128Shuffle;
          _shuffleFromArray(a0: int[], a1: int): AbstractShuffle;
          _shuffleFromBytes(reorder: byte[]): Double128Vector$Double128Shuffle;
          _shuffleFromBytes(a0: byte[]): AbstractShuffle;
          _shuffleFromOp(fn: java.util.function.IntUnaryOperator): Double128Vector$Double128Shuffle;
          _shuffleFromOp(a0: java.util.function.IntUnaryOperator): AbstractShuffle;
          slice(origin: int, v: Vector<double>): Double128Vector;
          slice(origin: int): Double128Vector;
          slice(a0: int): DoubleVector;
          slice(a0: int, a1: Vector): DoubleVector;
          slice(a0: int): AbstractVector;
          slice(a0: int, a1: Vector): AbstractVector;
          slice(a0: int): Vector;
          slice(a0: int, a1: Vector): Vector;
          _tOp(v1: Vector<double>, v2: Vector<double>, f: DoubleVector$FTriOp): Double128Vector;
          _tOp(v1: Vector<double>, v2: Vector<double>, m: VectorMask<double>, f: DoubleVector$FTriOp): Double128Vector;
          _tOp(a0: Vector, a1: Vector, a2: VectorMask, a3: DoubleVector$FTriOp): DoubleVector;
          _tOp(a0: Vector, a1: Vector, a2: DoubleVector$FTriOp): DoubleVector;
          test(op: VectorOperators$Test): Double128Vector$Double128Mask;
          test(op: VectorOperators$Test, m: VectorMask<double>): Double128Vector$Double128Mask;
          test(a0: VectorOperators$Test, a1: VectorMask): VectorMask;
          test(a0: VectorOperators$Test): VectorMask;
          toShuffle(): VectorShuffle<double>;
          _uOp(f: DoubleVector$FUnOp): Double128Vector;
          _uOp(m: VectorMask<double>, f: DoubleVector$FUnOp): Double128Vector;
          _uOp(a0: VectorMask, a1: DoubleVector$FUnOp): DoubleVector;
          _uOp(a0: DoubleVector$FUnOp): DoubleVector;
          unslice(origin: int, w: Vector<double>, part: int): Double128Vector;
          unslice(origin: int, w: Vector<double>, part: int, m: VectorMask<double>): Double128Vector;
          unslice(origin: int): Double128Vector;
          unslice(a0: int): DoubleVector;
          unslice(a0: int, a1: Vector, a2: int, a3: VectorMask): DoubleVector;
          unslice(a0: int, a1: Vector, a2: int): DoubleVector;
          unslice(a0: int): Vector;
          unslice(a0: int, a1: Vector, a2: int, a3: VectorMask): Vector;
          unslice(a0: int, a1: Vector, a2: int): Vector;
          _vec(): double[];
          _vectorFactory(vec: double[]): Double128Vector;
          _vectorFactory(a0: double[]): DoubleVector;
          vspecies(): DoubleVector$DoubleSpecies;
          vspecies(): AbstractSpecies;
          withLane(i: int, e: double): Double128Vector;
          withLane(a0: int, a1: double): DoubleVector;
          withLaneHelper(i: int, e: double): Double128Vector;
        }
        interface Double128Vector extends CombineTypes<[_Double128Vector, jdk.incubator.vector.DoubleVector]> {}
        interface _Double128Vector$Double128Mask$$static extends ClassLike {
          _maskAll(bit: boolean): Double128Vector$Double128Mask;
          _prepare(bits: boolean[], offset: int): boolean[];
          _prepare(val: boolean): boolean[];
          _ETYPE: java.lang.Class<double>;
          _FALSE_MASK: Double128Vector$Double128Mask;
          _TRUE_MASK: Double128Vector$Double128Mask;
          _VLENGTH: int;
          _new(bits: boolean[]): Double128Vector$Double128Mask;
          _new(bits: boolean[], offset: int): Double128Vector$Double128Mask;
          _new(val: boolean): Double128Vector$Double128Mask;
        }
        let Double128Vector$Double128Mask: _Double128Vector$Double128Mask$$static;
        interface _Double128Vector$Double128Mask {
          allTrue(): boolean;
          and(mask: VectorMask<double>): Double128Vector$Double128Mask;
          and(a0: VectorMask): VectorMask;
          anyTrue(): boolean;
          _bOp(m: VectorMask<double>, f: AbstractMask$MBinOp): Double128Vector$Double128Mask;
          _bOp(a0: VectorMask, a1: AbstractMask$MBinOp): AbstractMask;
          cast<E>(dsp: VectorSpecies<E>): VectorMask<E>;
          compress(): Double128Vector$Double128Mask;
          compress(): VectorMask;
          _defaultMaskCast<E>(dsp: AbstractSpecies<E>): VectorMask<E>;
          firstTrue(): int;
          _getBits(): boolean[];
          _indexPartiallyInUpperRange(offset: long, a1: long): Double128Vector$Double128Mask;
          _indexPartiallyInUpperRange(a0: long, a1: long): VectorMask;
          lastTrue(): int;
          not(): Double128Vector$Double128Mask;
          not(): VectorMask;
          or(mask: VectorMask<double>): Double128Vector$Double128Mask;
          or(a0: VectorMask): VectorMask;
          toLong(): long;
          toVector(): Double128Vector;
          toVector(): Vector;
          trueCount(): int;
          _uOp(f: AbstractMask$MUnOp): Double128Vector$Double128Mask;
          _uOp(a0: AbstractMask$MUnOp): AbstractMask;
          vspecies(): DoubleVector$DoubleSpecies;
          vspecies(): AbstractSpecies;
          xor(mask: VectorMask<double>): Double128Vector$Double128Mask;
          xor(a0: VectorMask): VectorMask;
        }
        interface Double128Vector$Double128Mask extends CombineTypes<[_Double128Vector$Double128Mask, AbstractMask<double>]> {}
        interface _Double128Vector$Double128Shuffle$$static extends ClassLike {
          _ETYPE: java.lang.Class<double>;
          _IOTA: Double128Vector$Double128Shuffle;
          _VLENGTH: int;
          _new(reorder: byte[]): Double128Vector$Double128Shuffle;
          new(reorder: int[]): Double128Vector$Double128Shuffle;
          new(reorder: int[], i: int): Double128Vector$Double128Shuffle;
          new(fn: java.util.function.IntUnaryOperator): Double128Vector$Double128Shuffle;
        }
        let Double128Vector$Double128Shuffle: _Double128Vector$Double128Shuffle$$static;
        interface _Double128Vector$Double128Shuffle {
          cast<F>(s: VectorSpecies<F>): VectorShuffle<F>;
          rearrange(shuffle: VectorShuffle<double>): Double128Vector$Double128Shuffle;
          rearrange(a0: VectorShuffle): VectorShuffle;
          toVector(): Double128Vector;
          toVector(): Vector;
          vspecies(): DoubleVector$DoubleSpecies;
          vspecies(): AbstractSpecies;
        }
        interface Double128Vector$Double128Shuffle extends CombineTypes<[_Double128Vector$Double128Shuffle, AbstractShuffle<double>]> {}
        interface _Double256Vector$$static extends ClassLike {
          _ETYPE: java.lang.Class<double>;
          _IOTA: Double256Vector;
          _VCLASS: java.lang.Class<Double256Vector>;
          _VLENGTH: int;
          _VSHAPE: VectorShape;
          _VSIZE: int;
          _VSPECIES: DoubleVector$DoubleSpecies;
          _ZERO: Double256Vector;
          _new(v: double[]): Double256Vector;
          _new(v: any): Double256Vector;
        }
        let Double256Vector: _Double256Vector$$static;
        interface _Double256Vector {
          addIndex(scale: int): Double256Vector;
          addIndex(a0: int): DoubleVector;
          addIndex(a0: int): Vector;
          _asByteVectorRaw(): Byte256Vector;
          _asByteVectorRaw(): ByteVector;
          _asVectorRaw(laneType: LaneType): AbstractVector<any>;
          _bOp(v: Vector<double>, f: DoubleVector$FBinOp): Double256Vector;
          _bOp(v: Vector<double>, m: VectorMask<double>, f: DoubleVector$FBinOp): Double256Vector;
          _bOp(a0: Vector, a1: VectorMask, a2: DoubleVector$FBinOp): DoubleVector;
          _bOp(a0: Vector, a1: DoubleVector$FBinOp): DoubleVector;
          bitSize(): int;
          blend(v: Vector<double>, m: VectorMask<double>): Double256Vector;
          blend(a0: Vector, a1: VectorMask): DoubleVector;
          blend(a0: Vector, a1: VectorMask): Vector;
          broadcast(e: double): Double256Vector;
          broadcast(e: long): Double256Vector;
          broadcast(a0: long): DoubleVector;
          broadcast(a0: double): DoubleVector;
          broadcast(a0: long): Vector;
          byteSize(): int;
          compare(op: VectorOperators$Comparison, v: Vector<double>): Double256Vector$Double256Mask;
          compare(op: VectorOperators$Comparison, s: double): Double256Vector$Double256Mask;
          compare(op: VectorOperators$Comparison, s: long): Double256Vector$Double256Mask;
          compare(op: VectorOperators$Comparison, v: Vector<double>, m: VectorMask<double>): Double256Vector$Double256Mask;
          compare(a0: VectorOperators$Comparison, a1: long): VectorMask;
          compare(a0: VectorOperators$Comparison, a1: double): VectorMask;
          compare(a0: VectorOperators$Comparison, a1: Vector): VectorMask;
          compare(a0: VectorOperators$Comparison, a1: Vector, a2: VectorMask): VectorMask;
          compress(m: VectorMask<double>): Double256Vector;
          compress(a0: VectorMask): DoubleVector;
          compress(a0: VectorMask): Vector;
          convertShape<F>(conv: VectorOperators$Conversion<double,F>, rsp: VectorSpecies<F>, part: int): Vector<F>;
          elementSize(): int;
          elementType(): java.lang.Class<double>;
          expand(m: VectorMask<double>): Double256Vector;
          expand(a0: VectorMask): DoubleVector;
          expand(a0: VectorMask): Vector;
          _fromArray0(a: double[], offset: int): DoubleVector;
          _fromArray0(a: double[], offset: int, m: VectorMask<double>, offsetInRange: int): DoubleVector;
          _fromArray0(a: double[], offset: int, indexMap: int[], mapOffset: int, m: VectorMask<double>): DoubleVector;
          _fromMemorySegment0(ms: java.lang.foreign.MemorySegment, offset: long): DoubleVector;
          _fromMemorySegment0(ms: java.lang.foreign.MemorySegment, offset: long, a2: VectorMask<double>, m: int): DoubleVector;
          _fromMemorySegment0(a0: java.lang.foreign.MemorySegment, a1: long): AbstractVector;
          _intoArray0(a: double[], offset: int): void;
          _intoArray0(a: double[], offset: int, m: VectorMask<double>): void;
          _intoArray0(a: double[], offset: int, indexMap: int[], mapOffset: int, m: VectorMask<double>): void;
          _intoMemorySegment0(ms: java.lang.foreign.MemorySegment, offset: long, a2: VectorMask<double>): void;
          _iotaShuffle(): Double256Vector$Double256Shuffle;
          _iotaShuffle(start: int, step: int, wrap: boolean): Double256Vector$Double256Shuffle;
          _iotaShuffle(a0: int, a1: int, a2: boolean): AbstractShuffle;
          _iotaShuffle(): AbstractShuffle;
          lane(i: int): double;
          laneHelper(i: int): long;
          lanewise(op: VectorOperators$Unary): Double256Vector;
          lanewise(op: VectorOperators$Unary, m: VectorMask<double>): Double256Vector;
          lanewise(op: VectorOperators$Binary, v: Vector<double>): Double256Vector;
          lanewise(op: VectorOperators$Binary, v: Vector<double>, m: VectorMask<double>): Double256Vector;
          lanewise(op: VectorOperators$Ternary, v1: Vector<double>, v2: Vector<double>): Double256Vector;
          lanewise(op: VectorOperators$Ternary, v1: Vector<double>, v2: Vector<double>, m: VectorMask<double>): Double256Vector;
          lanewise(a0: VectorOperators$Ternary, a1: Vector, a2: Vector, a3: VectorMask): DoubleVector;
          lanewise(a0: VectorOperators$Ternary, a1: Vector, a2: Vector): DoubleVector;
          lanewise(a0: VectorOperators$Binary, a1: Vector, a2: VectorMask): DoubleVector;
          lanewise(a0: VectorOperators$Binary, a1: Vector): DoubleVector;
          lanewise(a0: VectorOperators$Unary, a1: VectorMask): DoubleVector;
          lanewise(a0: VectorOperators$Unary): DoubleVector;
          lanewise(a0: VectorOperators$Ternary, a1: Vector, a2: Vector, a3: VectorMask): Vector;
          lanewise(a0: VectorOperators$Ternary, a1: Vector, a2: Vector): Vector;
          lanewise(a0: VectorOperators$Binary, a1: Vector, a2: VectorMask): Vector;
          lanewise(a0: VectorOperators$Binary, a1: Vector): Vector;
          lanewise(a0: VectorOperators$Unary, a1: VectorMask): Vector;
          lanewise(a0: VectorOperators$Unary): Vector;
          length(): int;
          _maskFromArray(bits: boolean[]): Double256Vector$Double256Mask;
          _maskFromArray(a0: boolean[]): AbstractMask;
          _rOp(v: double, a1: VectorMask<double>, m: DoubleVector$FBinOp): double;
          rearrange(s: VectorShuffle<double>): Double256Vector;
          rearrange(shuffle: VectorShuffle<double>, m: VectorMask<double>): Double256Vector;
          rearrange(s: VectorShuffle<double>, v: Vector<double>): Double256Vector;
          rearrange(a0: VectorShuffle, a1: Vector): DoubleVector;
          rearrange(a0: VectorShuffle, a1: VectorMask): DoubleVector;
          rearrange(a0: VectorShuffle): DoubleVector;
          rearrange(a0: VectorShuffle, a1: Vector): Vector;
          rearrange(a0: VectorShuffle, a1: VectorMask): Vector;
          rearrange(a0: VectorShuffle): Vector;
          reduceLanes(op: VectorOperators$Associative): double;
          reduceLanes(op: VectorOperators$Associative, m: VectorMask<double>): double;
          reduceLanesToLong(op: VectorOperators$Associative): long;
          reduceLanesToLong(op: VectorOperators$Associative, m: VectorMask<double>): long;
          reinterpretShape<F>(toSpecies: VectorSpecies<F>, part: int): Vector<F>;
          selectFrom(v: Vector<double>): Double256Vector;
          selectFrom(v: Vector<double>, m: VectorMask<double>): Double256Vector;
          selectFrom(a0: Vector, a1: VectorMask): DoubleVector;
          selectFrom(a0: Vector): DoubleVector;
          selectFrom(a0: Vector, a1: VectorMask): Vector;
          selectFrom(a0: Vector): Vector;
          shape(): VectorShape;
          _shuffleFromArray(indexes: int[], i: int): Double256Vector$Double256Shuffle;
          _shuffleFromArray(a0: int[], a1: int): AbstractShuffle;
          _shuffleFromBytes(reorder: byte[]): Double256Vector$Double256Shuffle;
          _shuffleFromBytes(a0: byte[]): AbstractShuffle;
          _shuffleFromOp(fn: java.util.function.IntUnaryOperator): Double256Vector$Double256Shuffle;
          _shuffleFromOp(a0: java.util.function.IntUnaryOperator): AbstractShuffle;
          slice(origin: int, v: Vector<double>): Double256Vector;
          slice(origin: int): Double256Vector;
          slice(a0: int): DoubleVector;
          slice(a0: int, a1: Vector): DoubleVector;
          slice(a0: int): AbstractVector;
          slice(a0: int, a1: Vector): AbstractVector;
          slice(a0: int): Vector;
          slice(a0: int, a1: Vector): Vector;
          _tOp(v1: Vector<double>, v2: Vector<double>, f: DoubleVector$FTriOp): Double256Vector;
          _tOp(v1: Vector<double>, v2: Vector<double>, m: VectorMask<double>, f: DoubleVector$FTriOp): Double256Vector;
          _tOp(a0: Vector, a1: Vector, a2: VectorMask, a3: DoubleVector$FTriOp): DoubleVector;
          _tOp(a0: Vector, a1: Vector, a2: DoubleVector$FTriOp): DoubleVector;
          test(op: VectorOperators$Test): Double256Vector$Double256Mask;
          test(op: VectorOperators$Test, m: VectorMask<double>): Double256Vector$Double256Mask;
          test(a0: VectorOperators$Test, a1: VectorMask): VectorMask;
          test(a0: VectorOperators$Test): VectorMask;
          toShuffle(): VectorShuffle<double>;
          _uOp(f: DoubleVector$FUnOp): Double256Vector;
          _uOp(m: VectorMask<double>, f: DoubleVector$FUnOp): Double256Vector;
          _uOp(a0: VectorMask, a1: DoubleVector$FUnOp): DoubleVector;
          _uOp(a0: DoubleVector$FUnOp): DoubleVector;
          unslice(origin: int, w: Vector<double>, part: int): Double256Vector;
          unslice(origin: int, w: Vector<double>, part: int, m: VectorMask<double>): Double256Vector;
          unslice(origin: int): Double256Vector;
          unslice(a0: int): DoubleVector;
          unslice(a0: int, a1: Vector, a2: int, a3: VectorMask): DoubleVector;
          unslice(a0: int, a1: Vector, a2: int): DoubleVector;
          unslice(a0: int): Vector;
          unslice(a0: int, a1: Vector, a2: int, a3: VectorMask): Vector;
          unslice(a0: int, a1: Vector, a2: int): Vector;
          _vec(): double[];
          _vectorFactory(vec: double[]): Double256Vector;
          _vectorFactory(a0: double[]): DoubleVector;
          vspecies(): DoubleVector$DoubleSpecies;
          vspecies(): AbstractSpecies;
          withLane(i: int, e: double): Double256Vector;
          withLane(a0: int, a1: double): DoubleVector;
          withLaneHelper(i: int, e: double): Double256Vector;
        }
        interface Double256Vector extends CombineTypes<[_Double256Vector, jdk.incubator.vector.DoubleVector]> {}
        interface _Double256Vector$Double256Mask$$static extends ClassLike {
          _maskAll(bit: boolean): Double256Vector$Double256Mask;
          _prepare(bits: boolean[], offset: int): boolean[];
          _prepare(val: boolean): boolean[];
          _ETYPE: java.lang.Class<double>;
          _FALSE_MASK: Double256Vector$Double256Mask;
          _TRUE_MASK: Double256Vector$Double256Mask;
          _VLENGTH: int;
          _new(bits: boolean[]): Double256Vector$Double256Mask;
          _new(bits: boolean[], offset: int): Double256Vector$Double256Mask;
          _new(val: boolean): Double256Vector$Double256Mask;
        }
        let Double256Vector$Double256Mask: _Double256Vector$Double256Mask$$static;
        interface _Double256Vector$Double256Mask {
          allTrue(): boolean;
          and(mask: VectorMask<double>): Double256Vector$Double256Mask;
          and(a0: VectorMask): VectorMask;
          anyTrue(): boolean;
          _bOp(m: VectorMask<double>, f: AbstractMask$MBinOp): Double256Vector$Double256Mask;
          _bOp(a0: VectorMask, a1: AbstractMask$MBinOp): AbstractMask;
          cast<E>(dsp: VectorSpecies<E>): VectorMask<E>;
          compress(): Double256Vector$Double256Mask;
          compress(): VectorMask;
          _defaultMaskCast<E>(dsp: AbstractSpecies<E>): VectorMask<E>;
          firstTrue(): int;
          _getBits(): boolean[];
          _indexPartiallyInUpperRange(offset: long, a1: long): Double256Vector$Double256Mask;
          _indexPartiallyInUpperRange(a0: long, a1: long): VectorMask;
          lastTrue(): int;
          not(): Double256Vector$Double256Mask;
          not(): VectorMask;
          or(mask: VectorMask<double>): Double256Vector$Double256Mask;
          or(a0: VectorMask): VectorMask;
          toLong(): long;
          toVector(): Double256Vector;
          toVector(): Vector;
          trueCount(): int;
          _uOp(f: AbstractMask$MUnOp): Double256Vector$Double256Mask;
          _uOp(a0: AbstractMask$MUnOp): AbstractMask;
          vspecies(): DoubleVector$DoubleSpecies;
          vspecies(): AbstractSpecies;
          xor(mask: VectorMask<double>): Double256Vector$Double256Mask;
          xor(a0: VectorMask): VectorMask;
        }
        interface Double256Vector$Double256Mask extends CombineTypes<[_Double256Vector$Double256Mask, AbstractMask<double>]> {}
        interface _Double256Vector$Double256Shuffle$$static extends ClassLike {
          _ETYPE: java.lang.Class<double>;
          _IOTA: Double256Vector$Double256Shuffle;
          _VLENGTH: int;
          _new(reorder: byte[]): Double256Vector$Double256Shuffle;
          new(reorder: int[]): Double256Vector$Double256Shuffle;
          new(reorder: int[], i: int): Double256Vector$Double256Shuffle;
          new(fn: java.util.function.IntUnaryOperator): Double256Vector$Double256Shuffle;
        }
        let Double256Vector$Double256Shuffle: _Double256Vector$Double256Shuffle$$static;
        interface _Double256Vector$Double256Shuffle {
          cast<F>(s: VectorSpecies<F>): VectorShuffle<F>;
          rearrange(shuffle: VectorShuffle<double>): Double256Vector$Double256Shuffle;
          rearrange(a0: VectorShuffle): VectorShuffle;
          toVector(): Double256Vector;
          toVector(): Vector;
          vspecies(): DoubleVector$DoubleSpecies;
          vspecies(): AbstractSpecies;
        }
        interface Double256Vector$Double256Shuffle extends CombineTypes<[_Double256Vector$Double256Shuffle, AbstractShuffle<double>]> {}
        interface _Double512Vector$$static extends ClassLike {
          _ETYPE: java.lang.Class<double>;
          _IOTA: Double512Vector;
          _VCLASS: java.lang.Class<Double512Vector>;
          _VLENGTH: int;
          _VSHAPE: VectorShape;
          _VSIZE: int;
          _VSPECIES: DoubleVector$DoubleSpecies;
          _ZERO: Double512Vector;
          _new(v: double[]): Double512Vector;
          _new(v: any): Double512Vector;
        }
        let Double512Vector: _Double512Vector$$static;
        interface _Double512Vector {
          addIndex(scale: int): Double512Vector;
          addIndex(a0: int): DoubleVector;
          addIndex(a0: int): Vector;
          _asByteVectorRaw(): Byte512Vector;
          _asByteVectorRaw(): ByteVector;
          _asVectorRaw(laneType: LaneType): AbstractVector<any>;
          _bOp(v: Vector<double>, f: DoubleVector$FBinOp): Double512Vector;
          _bOp(v: Vector<double>, m: VectorMask<double>, f: DoubleVector$FBinOp): Double512Vector;
          _bOp(a0: Vector, a1: VectorMask, a2: DoubleVector$FBinOp): DoubleVector;
          _bOp(a0: Vector, a1: DoubleVector$FBinOp): DoubleVector;
          bitSize(): int;
          blend(v: Vector<double>, m: VectorMask<double>): Double512Vector;
          blend(a0: Vector, a1: VectorMask): DoubleVector;
          blend(a0: Vector, a1: VectorMask): Vector;
          broadcast(e: double): Double512Vector;
          broadcast(e: long): Double512Vector;
          broadcast(a0: long): DoubleVector;
          broadcast(a0: double): DoubleVector;
          broadcast(a0: long): Vector;
          byteSize(): int;
          compare(op: VectorOperators$Comparison, v: Vector<double>): Double512Vector$Double512Mask;
          compare(op: VectorOperators$Comparison, s: double): Double512Vector$Double512Mask;
          compare(op: VectorOperators$Comparison, s: long): Double512Vector$Double512Mask;
          compare(op: VectorOperators$Comparison, v: Vector<double>, m: VectorMask<double>): Double512Vector$Double512Mask;
          compare(a0: VectorOperators$Comparison, a1: long): VectorMask;
          compare(a0: VectorOperators$Comparison, a1: double): VectorMask;
          compare(a0: VectorOperators$Comparison, a1: Vector): VectorMask;
          compare(a0: VectorOperators$Comparison, a1: Vector, a2: VectorMask): VectorMask;
          compress(m: VectorMask<double>): Double512Vector;
          compress(a0: VectorMask): DoubleVector;
          compress(a0: VectorMask): Vector;
          convertShape<F>(conv: VectorOperators$Conversion<double,F>, rsp: VectorSpecies<F>, part: int): Vector<F>;
          elementSize(): int;
          elementType(): java.lang.Class<double>;
          expand(m: VectorMask<double>): Double512Vector;
          expand(a0: VectorMask): DoubleVector;
          expand(a0: VectorMask): Vector;
          _fromArray0(a: double[], offset: int): DoubleVector;
          _fromArray0(a: double[], offset: int, m: VectorMask<double>, offsetInRange: int): DoubleVector;
          _fromArray0(a: double[], offset: int, indexMap: int[], mapOffset: int, m: VectorMask<double>): DoubleVector;
          _fromMemorySegment0(ms: java.lang.foreign.MemorySegment, offset: long): DoubleVector;
          _fromMemorySegment0(ms: java.lang.foreign.MemorySegment, offset: long, a2: VectorMask<double>, m: int): DoubleVector;
          _fromMemorySegment0(a0: java.lang.foreign.MemorySegment, a1: long): AbstractVector;
          _intoArray0(a: double[], offset: int): void;
          _intoArray0(a: double[], offset: int, m: VectorMask<double>): void;
          _intoArray0(a: double[], offset: int, indexMap: int[], mapOffset: int, m: VectorMask<double>): void;
          _intoMemorySegment0(ms: java.lang.foreign.MemorySegment, offset: long, a2: VectorMask<double>): void;
          _iotaShuffle(): Double512Vector$Double512Shuffle;
          _iotaShuffle(start: int, step: int, wrap: boolean): Double512Vector$Double512Shuffle;
          _iotaShuffle(a0: int, a1: int, a2: boolean): AbstractShuffle;
          _iotaShuffle(): AbstractShuffle;
          lane(i: int): double;
          laneHelper(i: int): long;
          lanewise(op: VectorOperators$Unary): Double512Vector;
          lanewise(op: VectorOperators$Unary, m: VectorMask<double>): Double512Vector;
          lanewise(op: VectorOperators$Binary, v: Vector<double>): Double512Vector;
          lanewise(op: VectorOperators$Binary, v: Vector<double>, m: VectorMask<double>): Double512Vector;
          lanewise(op: VectorOperators$Ternary, v1: Vector<double>, v2: Vector<double>): Double512Vector;
          lanewise(op: VectorOperators$Ternary, v1: Vector<double>, v2: Vector<double>, m: VectorMask<double>): Double512Vector;
          lanewise(a0: VectorOperators$Ternary, a1: Vector, a2: Vector, a3: VectorMask): DoubleVector;
          lanewise(a0: VectorOperators$Ternary, a1: Vector, a2: Vector): DoubleVector;
          lanewise(a0: VectorOperators$Binary, a1: Vector, a2: VectorMask): DoubleVector;
          lanewise(a0: VectorOperators$Binary, a1: Vector): DoubleVector;
          lanewise(a0: VectorOperators$Unary, a1: VectorMask): DoubleVector;
          lanewise(a0: VectorOperators$Unary): DoubleVector;
          lanewise(a0: VectorOperators$Ternary, a1: Vector, a2: Vector, a3: VectorMask): Vector;
          lanewise(a0: VectorOperators$Ternary, a1: Vector, a2: Vector): Vector;
          lanewise(a0: VectorOperators$Binary, a1: Vector, a2: VectorMask): Vector;
          lanewise(a0: VectorOperators$Binary, a1: Vector): Vector;
          lanewise(a0: VectorOperators$Unary, a1: VectorMask): Vector;
          lanewise(a0: VectorOperators$Unary): Vector;
          length(): int;
          _maskFromArray(bits: boolean[]): Double512Vector$Double512Mask;
          _maskFromArray(a0: boolean[]): AbstractMask;
          _rOp(v: double, a1: VectorMask<double>, m: DoubleVector$FBinOp): double;
          rearrange(s: VectorShuffle<double>): Double512Vector;
          rearrange(shuffle: VectorShuffle<double>, m: VectorMask<double>): Double512Vector;
          rearrange(s: VectorShuffle<double>, v: Vector<double>): Double512Vector;
          rearrange(a0: VectorShuffle, a1: Vector): DoubleVector;
          rearrange(a0: VectorShuffle, a1: VectorMask): DoubleVector;
          rearrange(a0: VectorShuffle): DoubleVector;
          rearrange(a0: VectorShuffle, a1: Vector): Vector;
          rearrange(a0: VectorShuffle, a1: VectorMask): Vector;
          rearrange(a0: VectorShuffle): Vector;
          reduceLanes(op: VectorOperators$Associative): double;
          reduceLanes(op: VectorOperators$Associative, m: VectorMask<double>): double;
          reduceLanesToLong(op: VectorOperators$Associative): long;
          reduceLanesToLong(op: VectorOperators$Associative, m: VectorMask<double>): long;
          reinterpretShape<F>(toSpecies: VectorSpecies<F>, part: int): Vector<F>;
          selectFrom(v: Vector<double>): Double512Vector;
          selectFrom(v: Vector<double>, m: VectorMask<double>): Double512Vector;
          selectFrom(a0: Vector, a1: VectorMask): DoubleVector;
          selectFrom(a0: Vector): DoubleVector;
          selectFrom(a0: Vector, a1: VectorMask): Vector;
          selectFrom(a0: Vector): Vector;
          shape(): VectorShape;
          _shuffleFromArray(indexes: int[], i: int): Double512Vector$Double512Shuffle;
          _shuffleFromArray(a0: int[], a1: int): AbstractShuffle;
          _shuffleFromBytes(reorder: byte[]): Double512Vector$Double512Shuffle;
          _shuffleFromBytes(a0: byte[]): AbstractShuffle;
          _shuffleFromOp(fn: java.util.function.IntUnaryOperator): Double512Vector$Double512Shuffle;
          _shuffleFromOp(a0: java.util.function.IntUnaryOperator): AbstractShuffle;
          slice(origin: int, v: Vector<double>): Double512Vector;
          slice(origin: int): Double512Vector;
          slice(a0: int): DoubleVector;
          slice(a0: int, a1: Vector): DoubleVector;
          slice(a0: int): AbstractVector;
          slice(a0: int, a1: Vector): AbstractVector;
          slice(a0: int): Vector;
          slice(a0: int, a1: Vector): Vector;
          _tOp(v1: Vector<double>, v2: Vector<double>, f: DoubleVector$FTriOp): Double512Vector;
          _tOp(v1: Vector<double>, v2: Vector<double>, m: VectorMask<double>, f: DoubleVector$FTriOp): Double512Vector;
          _tOp(a0: Vector, a1: Vector, a2: VectorMask, a3: DoubleVector$FTriOp): DoubleVector;
          _tOp(a0: Vector, a1: Vector, a2: DoubleVector$FTriOp): DoubleVector;
          test(op: VectorOperators$Test): Double512Vector$Double512Mask;
          test(op: VectorOperators$Test, m: VectorMask<double>): Double512Vector$Double512Mask;
          test(a0: VectorOperators$Test, a1: VectorMask): VectorMask;
          test(a0: VectorOperators$Test): VectorMask;
          toShuffle(): VectorShuffle<double>;
          _uOp(f: DoubleVector$FUnOp): Double512Vector;
          _uOp(m: VectorMask<double>, f: DoubleVector$FUnOp): Double512Vector;
          _uOp(a0: VectorMask, a1: DoubleVector$FUnOp): DoubleVector;
          _uOp(a0: DoubleVector$FUnOp): DoubleVector;
          unslice(origin: int, w: Vector<double>, part: int): Double512Vector;
          unslice(origin: int, w: Vector<double>, part: int, m: VectorMask<double>): Double512Vector;
          unslice(origin: int): Double512Vector;
          unslice(a0: int): DoubleVector;
          unslice(a0: int, a1: Vector, a2: int, a3: VectorMask): DoubleVector;
          unslice(a0: int, a1: Vector, a2: int): DoubleVector;
          unslice(a0: int): Vector;
          unslice(a0: int, a1: Vector, a2: int, a3: VectorMask): Vector;
          unslice(a0: int, a1: Vector, a2: int): Vector;
          _vec(): double[];
          _vectorFactory(vec: double[]): Double512Vector;
          _vectorFactory(a0: double[]): DoubleVector;
          vspecies(): DoubleVector$DoubleSpecies;
          vspecies(): AbstractSpecies;
          withLane(i: int, e: double): Double512Vector;
          withLane(a0: int, a1: double): DoubleVector;
          withLaneHelper(i: int, e: double): Double512Vector;
        }
        interface Double512Vector extends CombineTypes<[_Double512Vector, jdk.incubator.vector.DoubleVector]> {}
        interface _Double512Vector$Double512Mask$$static extends ClassLike {
          _maskAll(bit: boolean): Double512Vector$Double512Mask;
          _prepare(bits: boolean[], offset: int): boolean[];
          _prepare(val: boolean): boolean[];
          _ETYPE: java.lang.Class<double>;
          _FALSE_MASK: Double512Vector$Double512Mask;
          _TRUE_MASK: Double512Vector$Double512Mask;
          _VLENGTH: int;
          _new(bits: boolean[]): Double512Vector$Double512Mask;
          _new(bits: boolean[], offset: int): Double512Vector$Double512Mask;
          _new(val: boolean): Double512Vector$Double512Mask;
        }
        let Double512Vector$Double512Mask: _Double512Vector$Double512Mask$$static;
        interface _Double512Vector$Double512Mask {
          allTrue(): boolean;
          and(mask: VectorMask<double>): Double512Vector$Double512Mask;
          and(a0: VectorMask): VectorMask;
          anyTrue(): boolean;
          _bOp(m: VectorMask<double>, f: AbstractMask$MBinOp): Double512Vector$Double512Mask;
          _bOp(a0: VectorMask, a1: AbstractMask$MBinOp): AbstractMask;
          cast<E>(dsp: VectorSpecies<E>): VectorMask<E>;
          compress(): Double512Vector$Double512Mask;
          compress(): VectorMask;
          _defaultMaskCast<E>(dsp: AbstractSpecies<E>): VectorMask<E>;
          firstTrue(): int;
          _getBits(): boolean[];
          _indexPartiallyInUpperRange(offset: long, a1: long): Double512Vector$Double512Mask;
          _indexPartiallyInUpperRange(a0: long, a1: long): VectorMask;
          lastTrue(): int;
          not(): Double512Vector$Double512Mask;
          not(): VectorMask;
          or(mask: VectorMask<double>): Double512Vector$Double512Mask;
          or(a0: VectorMask): VectorMask;
          toLong(): long;
          toVector(): Double512Vector;
          toVector(): Vector;
          trueCount(): int;
          _uOp(f: AbstractMask$MUnOp): Double512Vector$Double512Mask;
          _uOp(a0: AbstractMask$MUnOp): AbstractMask;
          vspecies(): DoubleVector$DoubleSpecies;
          vspecies(): AbstractSpecies;
          xor(mask: VectorMask<double>): Double512Vector$Double512Mask;
          xor(a0: VectorMask): VectorMask;
        }
        interface Double512Vector$Double512Mask extends CombineTypes<[_Double512Vector$Double512Mask, AbstractMask<double>]> {}
        interface _Double512Vector$Double512Shuffle$$static extends ClassLike {
          _ETYPE: java.lang.Class<double>;
          _IOTA: Double512Vector$Double512Shuffle;
          _VLENGTH: int;
          _new(reorder: byte[]): Double512Vector$Double512Shuffle;
          new(reorder: int[]): Double512Vector$Double512Shuffle;
          new(reorder: int[], i: int): Double512Vector$Double512Shuffle;
          new(fn: java.util.function.IntUnaryOperator): Double512Vector$Double512Shuffle;
        }
        let Double512Vector$Double512Shuffle: _Double512Vector$Double512Shuffle$$static;
        interface _Double512Vector$Double512Shuffle {
          cast<F>(s: VectorSpecies<F>): VectorShuffle<F>;
          rearrange(shuffle: VectorShuffle<double>): Double512Vector$Double512Shuffle;
          rearrange(a0: VectorShuffle): VectorShuffle;
          toVector(): Double512Vector;
          toVector(): Vector;
          vspecies(): DoubleVector$DoubleSpecies;
          vspecies(): AbstractSpecies;
        }
        interface Double512Vector$Double512Shuffle extends CombineTypes<[_Double512Vector$Double512Shuffle, AbstractShuffle<double>]> {}
        interface _Double64Vector$$static extends ClassLike {
          _ETYPE: java.lang.Class<double>;
          _IOTA: Double64Vector;
          _VCLASS: java.lang.Class<Double64Vector>;
          _VLENGTH: int;
          _VSHAPE: VectorShape;
          _VSIZE: int;
          _VSPECIES: DoubleVector$DoubleSpecies;
          _ZERO: Double64Vector;
          _new(v: double[]): Double64Vector;
          _new(v: any): Double64Vector;
        }
        let Double64Vector: _Double64Vector$$static;
        interface _Double64Vector {
          addIndex(scale: int): Double64Vector;
          addIndex(a0: int): DoubleVector;
          addIndex(a0: int): Vector;
          _asByteVectorRaw(): Byte64Vector;
          _asByteVectorRaw(): ByteVector;
          _asVectorRaw(laneType: LaneType): AbstractVector<any>;
          _bOp(v: Vector<double>, f: DoubleVector$FBinOp): Double64Vector;
          _bOp(v: Vector<double>, m: VectorMask<double>, f: DoubleVector$FBinOp): Double64Vector;
          _bOp(a0: Vector, a1: VectorMask, a2: DoubleVector$FBinOp): DoubleVector;
          _bOp(a0: Vector, a1: DoubleVector$FBinOp): DoubleVector;
          bitSize(): int;
          blend(v: Vector<double>, m: VectorMask<double>): Double64Vector;
          blend(a0: Vector, a1: VectorMask): DoubleVector;
          blend(a0: Vector, a1: VectorMask): Vector;
          broadcast(e: double): Double64Vector;
          broadcast(e: long): Double64Vector;
          broadcast(a0: long): DoubleVector;
          broadcast(a0: double): DoubleVector;
          broadcast(a0: long): Vector;
          byteSize(): int;
          compare(op: VectorOperators$Comparison, v: Vector<double>): Double64Vector$Double64Mask;
          compare(op: VectorOperators$Comparison, s: double): Double64Vector$Double64Mask;
          compare(op: VectorOperators$Comparison, s: long): Double64Vector$Double64Mask;
          compare(op: VectorOperators$Comparison, v: Vector<double>, m: VectorMask<double>): Double64Vector$Double64Mask;
          compare(a0: VectorOperators$Comparison, a1: long): VectorMask;
          compare(a0: VectorOperators$Comparison, a1: double): VectorMask;
          compare(a0: VectorOperators$Comparison, a1: Vector): VectorMask;
          compare(a0: VectorOperators$Comparison, a1: Vector, a2: VectorMask): VectorMask;
          compress(m: VectorMask<double>): Double64Vector;
          compress(a0: VectorMask): DoubleVector;
          compress(a0: VectorMask): Vector;
          convertShape<F>(conv: VectorOperators$Conversion<double,F>, rsp: VectorSpecies<F>, part: int): Vector<F>;
          elementSize(): int;
          elementType(): java.lang.Class<double>;
          expand(m: VectorMask<double>): Double64Vector;
          expand(a0: VectorMask): DoubleVector;
          expand(a0: VectorMask): Vector;
          _fromArray0(a: double[], offset: int): DoubleVector;
          _fromArray0(a: double[], offset: int, m: VectorMask<double>, offsetInRange: int): DoubleVector;
          _fromArray0(a: double[], offset: int, indexMap: int[], mapOffset: int, m: VectorMask<double>): DoubleVector;
          _fromMemorySegment0(ms: java.lang.foreign.MemorySegment, offset: long): DoubleVector;
          _fromMemorySegment0(ms: java.lang.foreign.MemorySegment, offset: long, a2: VectorMask<double>, m: int): DoubleVector;
          _fromMemorySegment0(a0: java.lang.foreign.MemorySegment, a1: long): AbstractVector;
          _intoArray0(a: double[], offset: int): void;
          _intoArray0(a: double[], offset: int, m: VectorMask<double>): void;
          _intoArray0(a: double[], offset: int, indexMap: int[], mapOffset: int, m: VectorMask<double>): void;
          _intoMemorySegment0(ms: java.lang.foreign.MemorySegment, offset: long, a2: VectorMask<double>): void;
          _iotaShuffle(): Double64Vector$Double64Shuffle;
          _iotaShuffle(start: int, step: int, wrap: boolean): Double64Vector$Double64Shuffle;
          _iotaShuffle(a0: int, a1: int, a2: boolean): AbstractShuffle;
          _iotaShuffle(): AbstractShuffle;
          lane(i: int): double;
          laneHelper(i: int): long;
          lanewise(op: VectorOperators$Unary): Double64Vector;
          lanewise(op: VectorOperators$Unary, m: VectorMask<double>): Double64Vector;
          lanewise(op: VectorOperators$Binary, v: Vector<double>): Double64Vector;
          lanewise(op: VectorOperators$Binary, v: Vector<double>, m: VectorMask<double>): Double64Vector;
          lanewise(op: VectorOperators$Ternary, v1: Vector<double>, v2: Vector<double>): Double64Vector;
          lanewise(op: VectorOperators$Ternary, v1: Vector<double>, v2: Vector<double>, m: VectorMask<double>): Double64Vector;
          lanewise(a0: VectorOperators$Ternary, a1: Vector, a2: Vector, a3: VectorMask): DoubleVector;
          lanewise(a0: VectorOperators$Ternary, a1: Vector, a2: Vector): DoubleVector;
          lanewise(a0: VectorOperators$Binary, a1: Vector, a2: VectorMask): DoubleVector;
          lanewise(a0: VectorOperators$Binary, a1: Vector): DoubleVector;
          lanewise(a0: VectorOperators$Unary, a1: VectorMask): DoubleVector;
          lanewise(a0: VectorOperators$Unary): DoubleVector;
          lanewise(a0: VectorOperators$Ternary, a1: Vector, a2: Vector, a3: VectorMask): Vector;
          lanewise(a0: VectorOperators$Ternary, a1: Vector, a2: Vector): Vector;
          lanewise(a0: VectorOperators$Binary, a1: Vector, a2: VectorMask): Vector;
          lanewise(a0: VectorOperators$Binary, a1: Vector): Vector;
          lanewise(a0: VectorOperators$Unary, a1: VectorMask): Vector;
          lanewise(a0: VectorOperators$Unary): Vector;
          length(): int;
          _maskFromArray(bits: boolean[]): Double64Vector$Double64Mask;
          _maskFromArray(a0: boolean[]): AbstractMask;
          _rOp(v: double, a1: VectorMask<double>, m: DoubleVector$FBinOp): double;
          rearrange(s: VectorShuffle<double>): Double64Vector;
          rearrange(shuffle: VectorShuffle<double>, m: VectorMask<double>): Double64Vector;
          rearrange(s: VectorShuffle<double>, v: Vector<double>): Double64Vector;
          rearrange(a0: VectorShuffle, a1: Vector): DoubleVector;
          rearrange(a0: VectorShuffle, a1: VectorMask): DoubleVector;
          rearrange(a0: VectorShuffle): DoubleVector;
          rearrange(a0: VectorShuffle, a1: Vector): Vector;
          rearrange(a0: VectorShuffle, a1: VectorMask): Vector;
          rearrange(a0: VectorShuffle): Vector;
          reduceLanes(op: VectorOperators$Associative): double;
          reduceLanes(op: VectorOperators$Associative, m: VectorMask<double>): double;
          reduceLanesToLong(op: VectorOperators$Associative): long;
          reduceLanesToLong(op: VectorOperators$Associative, m: VectorMask<double>): long;
          reinterpretShape<F>(toSpecies: VectorSpecies<F>, part: int): Vector<F>;
          selectFrom(v: Vector<double>): Double64Vector;
          selectFrom(v: Vector<double>, m: VectorMask<double>): Double64Vector;
          selectFrom(a0: Vector, a1: VectorMask): DoubleVector;
          selectFrom(a0: Vector): DoubleVector;
          selectFrom(a0: Vector, a1: VectorMask): Vector;
          selectFrom(a0: Vector): Vector;
          shape(): VectorShape;
          _shuffleFromArray(indexes: int[], i: int): Double64Vector$Double64Shuffle;
          _shuffleFromArray(a0: int[], a1: int): AbstractShuffle;
          _shuffleFromBytes(reorder: byte[]): Double64Vector$Double64Shuffle;
          _shuffleFromBytes(a0: byte[]): AbstractShuffle;
          _shuffleFromOp(fn: java.util.function.IntUnaryOperator): Double64Vector$Double64Shuffle;
          _shuffleFromOp(a0: java.util.function.IntUnaryOperator): AbstractShuffle;
          slice(origin: int, v: Vector<double>): Double64Vector;
          slice(origin: int): Double64Vector;
          slice(a0: int): DoubleVector;
          slice(a0: int, a1: Vector): DoubleVector;
          slice(a0: int): AbstractVector;
          slice(a0: int, a1: Vector): AbstractVector;
          slice(a0: int): Vector;
          slice(a0: int, a1: Vector): Vector;
          _tOp(v1: Vector<double>, v2: Vector<double>, f: DoubleVector$FTriOp): Double64Vector;
          _tOp(v1: Vector<double>, v2: Vector<double>, m: VectorMask<double>, f: DoubleVector$FTriOp): Double64Vector;
          _tOp(a0: Vector, a1: Vector, a2: VectorMask, a3: DoubleVector$FTriOp): DoubleVector;
          _tOp(a0: Vector, a1: Vector, a2: DoubleVector$FTriOp): DoubleVector;
          test(op: VectorOperators$Test): Double64Vector$Double64Mask;
          test(op: VectorOperators$Test, m: VectorMask<double>): Double64Vector$Double64Mask;
          test(a0: VectorOperators$Test, a1: VectorMask): VectorMask;
          test(a0: VectorOperators$Test): VectorMask;
          toShuffle(): VectorShuffle<double>;
          _uOp(f: DoubleVector$FUnOp): Double64Vector;
          _uOp(m: VectorMask<double>, f: DoubleVector$FUnOp): Double64Vector;
          _uOp(a0: VectorMask, a1: DoubleVector$FUnOp): DoubleVector;
          _uOp(a0: DoubleVector$FUnOp): DoubleVector;
          unslice(origin: int, w: Vector<double>, part: int): Double64Vector;
          unslice(origin: int, w: Vector<double>, part: int, m: VectorMask<double>): Double64Vector;
          unslice(origin: int): Double64Vector;
          unslice(a0: int): DoubleVector;
          unslice(a0: int, a1: Vector, a2: int, a3: VectorMask): DoubleVector;
          unslice(a0: int, a1: Vector, a2: int): DoubleVector;
          unslice(a0: int): Vector;
          unslice(a0: int, a1: Vector, a2: int, a3: VectorMask): Vector;
          unslice(a0: int, a1: Vector, a2: int): Vector;
          _vec(): double[];
          _vectorFactory(vec: double[]): Double64Vector;
          _vectorFactory(a0: double[]): DoubleVector;
          vspecies(): DoubleVector$DoubleSpecies;
          vspecies(): AbstractSpecies;
          withLane(i: int, e: double): Double64Vector;
          withLane(a0: int, a1: double): DoubleVector;
          withLaneHelper(i: int, e: double): Double64Vector;
        }
        interface Double64Vector extends CombineTypes<[_Double64Vector, jdk.incubator.vector.DoubleVector]> {}
        interface _Double64Vector$Double64Mask$$static extends ClassLike {
          _maskAll(bit: boolean): Double64Vector$Double64Mask;
          _prepare(bits: boolean[], offset: int): boolean[];
          _prepare(val: boolean): boolean[];
          _ETYPE: java.lang.Class<double>;
          _FALSE_MASK: Double64Vector$Double64Mask;
          _TRUE_MASK: Double64Vector$Double64Mask;
          _VLENGTH: int;
          _new(bits: boolean[]): Double64Vector$Double64Mask;
          _new(bits: boolean[], offset: int): Double64Vector$Double64Mask;
          _new(val: boolean): Double64Vector$Double64Mask;
        }
        let Double64Vector$Double64Mask: _Double64Vector$Double64Mask$$static;
        interface _Double64Vector$Double64Mask {
          allTrue(): boolean;
          and(mask: VectorMask<double>): Double64Vector$Double64Mask;
          and(a0: VectorMask): VectorMask;
          anyTrue(): boolean;
          _bOp(m: VectorMask<double>, f: AbstractMask$MBinOp): Double64Vector$Double64Mask;
          _bOp(a0: VectorMask, a1: AbstractMask$MBinOp): AbstractMask;
          cast<E>(dsp: VectorSpecies<E>): VectorMask<E>;
          compress(): Double64Vector$Double64Mask;
          compress(): VectorMask;
          _defaultMaskCast<E>(dsp: AbstractSpecies<E>): VectorMask<E>;
          firstTrue(): int;
          _getBits(): boolean[];
          _indexPartiallyInUpperRange(offset: long, a1: long): Double64Vector$Double64Mask;
          _indexPartiallyInUpperRange(a0: long, a1: long): VectorMask;
          lastTrue(): int;
          not(): Double64Vector$Double64Mask;
          not(): VectorMask;
          or(mask: VectorMask<double>): Double64Vector$Double64Mask;
          or(a0: VectorMask): VectorMask;
          toLong(): long;
          toVector(): Double64Vector;
          toVector(): Vector;
          trueCount(): int;
          _uOp(f: AbstractMask$MUnOp): Double64Vector$Double64Mask;
          _uOp(a0: AbstractMask$MUnOp): AbstractMask;
          vspecies(): DoubleVector$DoubleSpecies;
          vspecies(): AbstractSpecies;
          xor(mask: VectorMask<double>): Double64Vector$Double64Mask;
          xor(a0: VectorMask): VectorMask;
        }
        interface Double64Vector$Double64Mask extends CombineTypes<[_Double64Vector$Double64Mask, AbstractMask<double>]> {}
        interface _Double64Vector$Double64Shuffle$$static extends ClassLike {
          _ETYPE: java.lang.Class<double>;
          _IOTA: Double64Vector$Double64Shuffle;
          _VLENGTH: int;
          _new(reorder: byte[]): Double64Vector$Double64Shuffle;
          new(reorder: int[]): Double64Vector$Double64Shuffle;
          new(reorder: int[], i: int): Double64Vector$Double64Shuffle;
          new(fn: java.util.function.IntUnaryOperator): Double64Vector$Double64Shuffle;
        }
        let Double64Vector$Double64Shuffle: _Double64Vector$Double64Shuffle$$static;
        interface _Double64Vector$Double64Shuffle {
          cast<F>(s: VectorSpecies<F>): VectorShuffle<F>;
          rearrange(shuffle: VectorShuffle<double>): Double64Vector$Double64Shuffle;
          rearrange(a0: VectorShuffle): VectorShuffle;
          toVector(): Double64Vector;
          toVector(): Vector;
          vspecies(): DoubleVector$DoubleSpecies;
          vspecies(): AbstractSpecies;
        }
        interface Double64Vector$Double64Shuffle extends CombineTypes<[_Double64Vector$Double64Shuffle, AbstractShuffle<double>]> {}
        interface _DoubleMaxVector$$static extends ClassLike {
          _ETYPE: java.lang.Class<double>;
          _IOTA: DoubleMaxVector;
          _VCLASS: java.lang.Class<DoubleMaxVector>;
          _VLENGTH: int;
          _VSHAPE: VectorShape;
          _VSIZE: int;
          _VSPECIES: DoubleVector$DoubleSpecies;
          _ZERO: DoubleMaxVector;
          _new(v: double[]): DoubleMaxVector;
          _new(v: any): DoubleMaxVector;
        }
        let DoubleMaxVector: _DoubleMaxVector$$static;
        interface _DoubleMaxVector {
          addIndex(scale: int): DoubleMaxVector;
          addIndex(a0: int): DoubleVector;
          addIndex(a0: int): Vector;
          _asByteVectorRaw(): ByteMaxVector;
          _asByteVectorRaw(): ByteVector;
          _asVectorRaw(laneType: LaneType): AbstractVector<any>;
          _bOp(v: Vector<double>, f: DoubleVector$FBinOp): DoubleMaxVector;
          _bOp(v: Vector<double>, m: VectorMask<double>, f: DoubleVector$FBinOp): DoubleMaxVector;
          _bOp(a0: Vector, a1: VectorMask, a2: DoubleVector$FBinOp): DoubleVector;
          _bOp(a0: Vector, a1: DoubleVector$FBinOp): DoubleVector;
          bitSize(): int;
          blend(v: Vector<double>, m: VectorMask<double>): DoubleMaxVector;
          blend(a0: Vector, a1: VectorMask): DoubleVector;
          blend(a0: Vector, a1: VectorMask): Vector;
          broadcast(e: double): DoubleMaxVector;
          broadcast(e: long): DoubleMaxVector;
          broadcast(a0: long): DoubleVector;
          broadcast(a0: double): DoubleVector;
          broadcast(a0: long): Vector;
          byteSize(): int;
          compare(op: VectorOperators$Comparison, v: Vector<double>): DoubleMaxVector$DoubleMaxMask;
          compare(op: VectorOperators$Comparison, s: double): DoubleMaxVector$DoubleMaxMask;
          compare(op: VectorOperators$Comparison, s: long): DoubleMaxVector$DoubleMaxMask;
          compare(op: VectorOperators$Comparison, v: Vector<double>, m: VectorMask<double>): DoubleMaxVector$DoubleMaxMask;
          compare(a0: VectorOperators$Comparison, a1: long): VectorMask;
          compare(a0: VectorOperators$Comparison, a1: double): VectorMask;
          compare(a0: VectorOperators$Comparison, a1: Vector): VectorMask;
          compare(a0: VectorOperators$Comparison, a1: Vector, a2: VectorMask): VectorMask;
          compress(m: VectorMask<double>): DoubleMaxVector;
          compress(a0: VectorMask): DoubleVector;
          compress(a0: VectorMask): Vector;
          convertShape<F>(conv: VectorOperators$Conversion<double,F>, rsp: VectorSpecies<F>, part: int): Vector<F>;
          elementSize(): int;
          elementType(): java.lang.Class<double>;
          expand(m: VectorMask<double>): DoubleMaxVector;
          expand(a0: VectorMask): DoubleVector;
          expand(a0: VectorMask): Vector;
          _fromArray0(a: double[], offset: int): DoubleVector;
          _fromArray0(a: double[], offset: int, m: VectorMask<double>, offsetInRange: int): DoubleVector;
          _fromArray0(a: double[], offset: int, indexMap: int[], mapOffset: int, m: VectorMask<double>): DoubleVector;
          _fromMemorySegment0(ms: java.lang.foreign.MemorySegment, offset: long): DoubleVector;
          _fromMemorySegment0(ms: java.lang.foreign.MemorySegment, offset: long, a2: VectorMask<double>, m: int): DoubleVector;
          _fromMemorySegment0(a0: java.lang.foreign.MemorySegment, a1: long): AbstractVector;
          _intoArray0(a: double[], offset: int): void;
          _intoArray0(a: double[], offset: int, m: VectorMask<double>): void;
          _intoArray0(a: double[], offset: int, indexMap: int[], mapOffset: int, m: VectorMask<double>): void;
          _intoMemorySegment0(ms: java.lang.foreign.MemorySegment, offset: long, a2: VectorMask<double>): void;
          _iotaShuffle(): DoubleMaxVector$DoubleMaxShuffle;
          _iotaShuffle(start: int, step: int, wrap: boolean): DoubleMaxVector$DoubleMaxShuffle;
          _iotaShuffle(a0: int, a1: int, a2: boolean): AbstractShuffle;
          _iotaShuffle(): AbstractShuffle;
          lane(i: int): double;
          laneHelper(i: int): long;
          lanewise(op: VectorOperators$Unary): DoubleMaxVector;
          lanewise(op: VectorOperators$Unary, m: VectorMask<double>): DoubleMaxVector;
          lanewise(op: VectorOperators$Binary, v: Vector<double>): DoubleMaxVector;
          lanewise(op: VectorOperators$Binary, v: Vector<double>, m: VectorMask<double>): DoubleMaxVector;
          lanewise(op: VectorOperators$Ternary, v1: Vector<double>, v2: Vector<double>): DoubleMaxVector;
          lanewise(op: VectorOperators$Ternary, v1: Vector<double>, v2: Vector<double>, m: VectorMask<double>): DoubleMaxVector;
          lanewise(a0: VectorOperators$Ternary, a1: Vector, a2: Vector, a3: VectorMask): DoubleVector;
          lanewise(a0: VectorOperators$Ternary, a1: Vector, a2: Vector): DoubleVector;
          lanewise(a0: VectorOperators$Binary, a1: Vector, a2: VectorMask): DoubleVector;
          lanewise(a0: VectorOperators$Binary, a1: Vector): DoubleVector;
          lanewise(a0: VectorOperators$Unary, a1: VectorMask): DoubleVector;
          lanewise(a0: VectorOperators$Unary): DoubleVector;
          lanewise(a0: VectorOperators$Ternary, a1: Vector, a2: Vector, a3: VectorMask): Vector;
          lanewise(a0: VectorOperators$Ternary, a1: Vector, a2: Vector): Vector;
          lanewise(a0: VectorOperators$Binary, a1: Vector, a2: VectorMask): Vector;
          lanewise(a0: VectorOperators$Binary, a1: Vector): Vector;
          lanewise(a0: VectorOperators$Unary, a1: VectorMask): Vector;
          lanewise(a0: VectorOperators$Unary): Vector;
          length(): int;
          _maskFromArray(bits: boolean[]): DoubleMaxVector$DoubleMaxMask;
          _maskFromArray(a0: boolean[]): AbstractMask;
          _rOp(v: double, a1: VectorMask<double>, m: DoubleVector$FBinOp): double;
          rearrange(s: VectorShuffle<double>): DoubleMaxVector;
          rearrange(shuffle: VectorShuffle<double>, m: VectorMask<double>): DoubleMaxVector;
          rearrange(s: VectorShuffle<double>, v: Vector<double>): DoubleMaxVector;
          rearrange(a0: VectorShuffle, a1: Vector): DoubleVector;
          rearrange(a0: VectorShuffle, a1: VectorMask): DoubleVector;
          rearrange(a0: VectorShuffle): DoubleVector;
          rearrange(a0: VectorShuffle, a1: Vector): Vector;
          rearrange(a0: VectorShuffle, a1: VectorMask): Vector;
          rearrange(a0: VectorShuffle): Vector;
          reduceLanes(op: VectorOperators$Associative): double;
          reduceLanes(op: VectorOperators$Associative, m: VectorMask<double>): double;
          reduceLanesToLong(op: VectorOperators$Associative): long;
          reduceLanesToLong(op: VectorOperators$Associative, m: VectorMask<double>): long;
          reinterpretShape<F>(toSpecies: VectorSpecies<F>, part: int): Vector<F>;
          selectFrom(v: Vector<double>): DoubleMaxVector;
          selectFrom(v: Vector<double>, m: VectorMask<double>): DoubleMaxVector;
          selectFrom(a0: Vector, a1: VectorMask): DoubleVector;
          selectFrom(a0: Vector): DoubleVector;
          selectFrom(a0: Vector, a1: VectorMask): Vector;
          selectFrom(a0: Vector): Vector;
          shape(): VectorShape;
          _shuffleFromArray(indexes: int[], i: int): DoubleMaxVector$DoubleMaxShuffle;
          _shuffleFromArray(a0: int[], a1: int): AbstractShuffle;
          _shuffleFromBytes(reorder: byte[]): DoubleMaxVector$DoubleMaxShuffle;
          _shuffleFromBytes(a0: byte[]): AbstractShuffle;
          _shuffleFromOp(fn: java.util.function.IntUnaryOperator): DoubleMaxVector$DoubleMaxShuffle;
          _shuffleFromOp(a0: java.util.function.IntUnaryOperator): AbstractShuffle;
          slice(origin: int, v: Vector<double>): DoubleMaxVector;
          slice(origin: int): DoubleMaxVector;
          slice(a0: int): DoubleVector;
          slice(a0: int, a1: Vector): DoubleVector;
          slice(a0: int): AbstractVector;
          slice(a0: int, a1: Vector): AbstractVector;
          slice(a0: int): Vector;
          slice(a0: int, a1: Vector): Vector;
          _tOp(v1: Vector<double>, v2: Vector<double>, f: DoubleVector$FTriOp): DoubleMaxVector;
          _tOp(v1: Vector<double>, v2: Vector<double>, m: VectorMask<double>, f: DoubleVector$FTriOp): DoubleMaxVector;
          _tOp(a0: Vector, a1: Vector, a2: VectorMask, a3: DoubleVector$FTriOp): DoubleVector;
          _tOp(a0: Vector, a1: Vector, a2: DoubleVector$FTriOp): DoubleVector;
          test(op: VectorOperators$Test): DoubleMaxVector$DoubleMaxMask;
          test(op: VectorOperators$Test, m: VectorMask<double>): DoubleMaxVector$DoubleMaxMask;
          test(a0: VectorOperators$Test, a1: VectorMask): VectorMask;
          test(a0: VectorOperators$Test): VectorMask;
          toShuffle(): VectorShuffle<double>;
          _uOp(f: DoubleVector$FUnOp): DoubleMaxVector;
          _uOp(m: VectorMask<double>, f: DoubleVector$FUnOp): DoubleMaxVector;
          _uOp(a0: VectorMask, a1: DoubleVector$FUnOp): DoubleVector;
          _uOp(a0: DoubleVector$FUnOp): DoubleVector;
          unslice(origin: int, w: Vector<double>, part: int): DoubleMaxVector;
          unslice(origin: int, w: Vector<double>, part: int, m: VectorMask<double>): DoubleMaxVector;
          unslice(origin: int): DoubleMaxVector;
          unslice(a0: int): DoubleVector;
          unslice(a0: int, a1: Vector, a2: int, a3: VectorMask): DoubleVector;
          unslice(a0: int, a1: Vector, a2: int): DoubleVector;
          unslice(a0: int): Vector;
          unslice(a0: int, a1: Vector, a2: int, a3: VectorMask): Vector;
          unslice(a0: int, a1: Vector, a2: int): Vector;
          _vec(): double[];
          _vectorFactory(vec: double[]): DoubleMaxVector;
          _vectorFactory(a0: double[]): DoubleVector;
          vspecies(): DoubleVector$DoubleSpecies;
          vspecies(): AbstractSpecies;
          withLane(i: int, e: double): DoubleMaxVector;
          withLane(a0: int, a1: double): DoubleVector;
          withLaneHelper(i: int, e: double): DoubleMaxVector;
        }
        interface DoubleMaxVector extends CombineTypes<[_DoubleMaxVector, jdk.incubator.vector.DoubleVector]> {}
        interface _DoubleMaxVector$DoubleMaxMask$$static extends ClassLike {
          _maskAll(bit: boolean): DoubleMaxVector$DoubleMaxMask;
          _prepare(bits: boolean[], offset: int): boolean[];
          _prepare(val: boolean): boolean[];
          _ETYPE: java.lang.Class<double>;
          _FALSE_MASK: DoubleMaxVector$DoubleMaxMask;
          _TRUE_MASK: DoubleMaxVector$DoubleMaxMask;
          _VLENGTH: int;
          _new(bits: boolean[]): DoubleMaxVector$DoubleMaxMask;
          _new(bits: boolean[], offset: int): DoubleMaxVector$DoubleMaxMask;
          _new(val: boolean): DoubleMaxVector$DoubleMaxMask;
        }
        let DoubleMaxVector$DoubleMaxMask: _DoubleMaxVector$DoubleMaxMask$$static;
        interface _DoubleMaxVector$DoubleMaxMask {
          allTrue(): boolean;
          and(mask: VectorMask<double>): DoubleMaxVector$DoubleMaxMask;
          and(a0: VectorMask): VectorMask;
          anyTrue(): boolean;
          _bOp(m: VectorMask<double>, f: AbstractMask$MBinOp): DoubleMaxVector$DoubleMaxMask;
          _bOp(a0: VectorMask, a1: AbstractMask$MBinOp): AbstractMask;
          cast<E>(dsp: VectorSpecies<E>): VectorMask<E>;
          compress(): DoubleMaxVector$DoubleMaxMask;
          compress(): VectorMask;
          _defaultMaskCast<E>(dsp: AbstractSpecies<E>): VectorMask<E>;
          firstTrue(): int;
          _getBits(): boolean[];
          _indexPartiallyInUpperRange(offset: long, a1: long): DoubleMaxVector$DoubleMaxMask;
          _indexPartiallyInUpperRange(a0: long, a1: long): VectorMask;
          lastTrue(): int;
          not(): DoubleMaxVector$DoubleMaxMask;
          not(): VectorMask;
          or(mask: VectorMask<double>): DoubleMaxVector$DoubleMaxMask;
          or(a0: VectorMask): VectorMask;
          toLong(): long;
          toVector(): DoubleMaxVector;
          toVector(): Vector;
          trueCount(): int;
          _uOp(f: AbstractMask$MUnOp): DoubleMaxVector$DoubleMaxMask;
          _uOp(a0: AbstractMask$MUnOp): AbstractMask;
          vspecies(): DoubleVector$DoubleSpecies;
          vspecies(): AbstractSpecies;
          xor(mask: VectorMask<double>): DoubleMaxVector$DoubleMaxMask;
          xor(a0: VectorMask): VectorMask;
        }
        interface DoubleMaxVector$DoubleMaxMask extends CombineTypes<[_DoubleMaxVector$DoubleMaxMask, AbstractMask<double>]> {}
        interface _DoubleMaxVector$DoubleMaxShuffle$$static extends ClassLike {
          _ETYPE: java.lang.Class<double>;
          _IOTA: DoubleMaxVector$DoubleMaxShuffle;
          _VLENGTH: int;
          _new(reorder: byte[]): DoubleMaxVector$DoubleMaxShuffle;
          new(reorder: int[]): DoubleMaxVector$DoubleMaxShuffle;
          new(reorder: int[], i: int): DoubleMaxVector$DoubleMaxShuffle;
          new(fn: java.util.function.IntUnaryOperator): DoubleMaxVector$DoubleMaxShuffle;
        }
        let DoubleMaxVector$DoubleMaxShuffle: _DoubleMaxVector$DoubleMaxShuffle$$static;
        interface _DoubleMaxVector$DoubleMaxShuffle {
          cast<F>(s: VectorSpecies<F>): VectorShuffle<F>;
          rearrange(shuffle: VectorShuffle<double>): DoubleMaxVector$DoubleMaxShuffle;
          rearrange(a0: VectorShuffle): VectorShuffle;
          toVector(): DoubleMaxVector;
          toVector(): Vector;
          vspecies(): DoubleVector$DoubleSpecies;
          vspecies(): AbstractSpecies;
        }
        interface DoubleMaxVector$DoubleMaxShuffle extends CombineTypes<[_DoubleMaxVector$DoubleMaxShuffle, AbstractShuffle<double>]> {}
        interface _DoubleVector$$static extends ClassLike {
          _arrayAddress(a: double[], index: int): long;
          _binaryOperations(opc_: int): jdk.internal.vm.vector.VectorSupport$BinaryOperation<DoubleVector,VectorMask<double>>;
          broadcast(species: VectorSpecies<double>, e: double): DoubleVector;
          broadcast(species: VectorSpecies<double>, e: long): DoubleVector;
          _byteArrayAddress(a: byte[], index: int): long;
          _checkMaskFromIndexSize(offset: int, vsp: DoubleVector$DoubleSpecies, m: VectorMask<double>, scale: int, limit: int): void;
          _checkMaskFromIndexSize(offset: long, a1: DoubleVector$DoubleSpecies, vsp: VectorMask<double>, m: int, scale: long): void;
          _compareWithOp(cond: int, a: double, a2: double): boolean;
          _compressHelper(v: Vector<double>, m: VectorMask<double>): DoubleVector;
          _expandHelper(v: Vector<double>, m: VectorMask<double>): DoubleVector;
          fromArray(species: VectorSpecies<double>, a: double[], offset: int): DoubleVector;
          fromArray(species: VectorSpecies<double>, a: double[], offset: int, m: VectorMask<double>): DoubleVector;
          fromArray(species: VectorSpecies<double>, a: double[], offset: int, indexMap: int[], mapOffset: int): DoubleVector;
          fromArray(species: VectorSpecies<double>, a: double[], offset: int, indexMap: int[], mapOffset: int, m: VectorMask<double>): DoubleVector;
          _fromBits(bits: long): double;
          fromMemorySegment(species: VectorSpecies<double>, ms: java.lang.foreign.MemorySegment, offset: long, a3: java.nio.ByteOrder): DoubleVector;
          fromMemorySegment(species: VectorSpecies<double>, ms: java.lang.foreign.MemorySegment, offset: long, a3: java.nio.ByteOrder, bo: VectorMask<double>): DoubleVector;
          _memorySegmentGet(ms: java.lang.foreign.MemorySegment, o: long, a2: int): double;
          _memorySegmentSet(ms: java.lang.foreign.MemorySegment, o: long, a2: int, i: double): void;
          _opCode(op: VectorOperators$Operator): int;
          _opCode(op: VectorOperators$Operator, requireKind: int): int;
          _opKind(op: VectorOperators$Operator, bit: int): boolean;
          _reductionOperations(opc_: int): jdk.internal.vm.vector.VectorSupport$ReductionOperation<DoubleVector,VectorMask<double>>;
          _species(s: VectorShape): DoubleVector$DoubleSpecies;
          _ternaryOperations(opc_: int): jdk.internal.vm.vector.VectorSupport$TernaryOperation<DoubleVector,VectorMask<double>>;
          _toBits(e: double): long;
          _unaryOperations(opc_: int): jdk.internal.vm.vector.VectorSupport$UnaryOperation<DoubleVector,VectorMask<double>>;
          zero(species: VectorSpecies<double>): DoubleVector;
          _ARRAY_BASE: long;
          _ARRAY_SHIFT: int;
          _BIN_IMPL: VectorOperators$ImplCache<VectorOperators$Binary,jdk.internal.vm.vector.VectorSupport$BinaryOperation<DoubleVector,VectorMask<double>>>;
          _ELEMENT_LAYOUT: java.lang.foreign.ValueLayout$OfDouble;
          _FORBID_OPCODE_KIND: int;
          _MAX_OR_INF: double;
          _MIN_OR_INF: double;
          _REDUCE_IMPL: VectorOperators$ImplCache<VectorOperators$Associative,jdk.internal.vm.vector.VectorSupport$ReductionOperation<DoubleVector,VectorMask<double>>>;
          readonly SPECIES_128: VectorSpecies<double>;
          readonly SPECIES_256: VectorSpecies<double>;
          readonly SPECIES_512: VectorSpecies<double>;
          readonly SPECIES_64: VectorSpecies<double>;
          readonly SPECIES_MAX: VectorSpecies<double>;
          readonly SPECIES_PREFERRED: VectorSpecies<double>;
          _TERN_IMPL: VectorOperators$ImplCache<VectorOperators$Ternary,jdk.internal.vm.vector.VectorSupport$TernaryOperation<DoubleVector,VectorMask<double>>>;
          _UN_IMPL: VectorOperators$ImplCache<VectorOperators$Unary,jdk.internal.vm.vector.VectorSupport$UnaryOperation<DoubleVector,VectorMask<double>>>;
          _new(vec: double[]): DoubleVector;
        }
        let DoubleVector: _DoubleVector$$static;
        interface _DoubleVector {
          abs(): DoubleVector;
          abs(): Vector;
          add(v: Vector<double>): DoubleVector;
          add(e: double): DoubleVector;
          add(v: Vector<double>, m: VectorMask<double>): DoubleVector;
          add(e: double, a1: VectorMask<double>): DoubleVector;
          add(a0: Vector, a1: VectorMask): Vector;
          add(a0: Vector): Vector;
          addIndex(a0: int): DoubleVector;
          addIndex(a0: int): Vector;
          _addIndexTemplate(scale: int): DoubleVector;
          _bOp(a0: Vector<double>, a1: DoubleVector$FBinOp): DoubleVector;
          _bOp(a0: Vector<double>, a1: VectorMask<double>, a2: DoubleVector$FBinOp): DoubleVector;
          _bOpTemplate(o: Vector<double>, f: DoubleVector$FBinOp): DoubleVector;
          _bOpTemplate(o: Vector<double>, m: VectorMask<double>, f: DoubleVector$FBinOp): DoubleVector;
          _bTest(cond: int, o: Vector<double>, f: DoubleVector$FBinTest): AbstractMask<double>;
          blend(a0: Vector<double>, a1: VectorMask<double>): DoubleVector;
          blend(e: double, a1: VectorMask<double>): DoubleVector;
          blend(e: long, a1: VectorMask<double>): DoubleVector;
          blend(a0: long, a1: VectorMask): Vector;
          blend(a0: Vector, a1: VectorMask): Vector;
          _blendTemplate<M>(maskType: java.lang.Class<M>, v: DoubleVector, m: M): DoubleVector;
          broadcast(a0: double): DoubleVector;
          broadcast(a0: long): DoubleVector;
          broadcast(a0: long): Vector;
          _broadcastTemplate(e: double): DoubleVector;
          _broadcastTemplate(e: long): DoubleVector;
          compare(a0: VectorOperators$Comparison, a1: Vector<double>): VectorMask<double>;
          compare(a0: VectorOperators$Comparison, a1: double): VectorMask<double>;
          compare(op: VectorOperators$Comparison, e: double, a2: VectorMask<double>): VectorMask<double>;
          compare(a0: VectorOperators$Comparison, a1: long): VectorMask<double>;
          compare(op: VectorOperators$Comparison, e: long, a2: VectorMask<double>): VectorMask<double>;
          _compareTemplate<M>(maskType: java.lang.Class<M>, op: VectorOperators$Comparison, v: Vector<double>): M;
          _compareTemplate<M>(maskType: java.lang.Class<M>, op: VectorOperators$Comparison, v: Vector<double>, m: M): M;
          _compareTemplate<M>(maskType: java.lang.Class<M>, op: VectorOperators$Comparison, e: double): M;
          _compareTemplate<M>(maskType: java.lang.Class<M>, op: VectorOperators$Comparison, e: long): M;
          compress(a0: VectorMask<double>): DoubleVector;
          compress(a0: VectorMask): Vector;
          _compressTemplate<M>(masktype: java.lang.Class<M>, m: M): DoubleVector;
          _conditionalStoreNYI(offset: int, vsp: DoubleVector$DoubleSpecies, m: VectorMask<double>, scale: int, limit: int): void;
          div(v: Vector<double>): DoubleVector;
          div(e: double): DoubleVector;
          div(v: Vector<double>, m: VectorMask<double>): DoubleVector;
          div(e: double, a1: VectorMask<double>): DoubleVector;
          div(a0: Vector, a1: VectorMask): Vector;
          div(a0: Vector): Vector;
          eq(v: Vector<double>): VectorMask<double>;
          eq(e: double): VectorMask<double>;
          equals(obj: any): boolean;
          expand(a0: VectorMask<double>): DoubleVector;
          expand(a0: VectorMask): Vector;
          _expandTemplate<M>(masktype: java.lang.Class<M>, m: M): DoubleVector;
          fma(b: Vector<double>, c: Vector<double>): DoubleVector;
          fma(b: double, a1: double): DoubleVector;
          _fromArray0(a0: double[], a1: int): DoubleVector;
          _fromArray0(a0: double[], a1: int, a2: VectorMask<double>, a3: int): DoubleVector;
          _fromArray0(a0: double[], a1: int, a2: int[], a3: int, a4: VectorMask<double>): DoubleVector;
          _fromArray0Template(a: double[], offset: int): DoubleVector;
          _fromArray0Template<M>(maskClass: java.lang.Class<M>, a: double[], offset: int, m: M, offsetInRange: int): DoubleVector;
          _fromArray0Template<M>(maskClass: java.lang.Class<M>, a: double[], offset: int, indexMap: int[], mapOffset: int, m: M): DoubleVector;
          _fromMemorySegment0(a0: java.lang.foreign.MemorySegment, a1: long): DoubleVector;
          _fromMemorySegment0(a0: java.lang.foreign.MemorySegment, a1: long, a2: VectorMask<double>, a3: int): DoubleVector;
          _fromMemorySegment0(a0: java.lang.foreign.MemorySegment, a1: long): AbstractVector;
          _fromMemorySegment0Template(ms: java.lang.foreign.MemorySegment, offset: long): DoubleVector;
          _fromMemorySegment0Template<M>(maskClass: java.lang.Class<M>, ms: java.lang.foreign.MemorySegment, offset: long, a3: M, m: int): DoubleVector;
          hashCode(): int;
          intoArray(a: double[], offset: int): void;
          intoArray(a: double[], offset: int, m: VectorMask<double>): void;
          intoArray(a: double[], offset: int, indexMap: int[], mapOffset: int): void;
          intoArray(a: double[], offset: int, indexMap: int[], mapOffset: int, m: VectorMask<double>): void;
          _intoArray0(a0: double[], a1: int): void;
          _intoArray0(a0: double[], a1: int, a2: VectorMask<double>): void;
          _intoArray0(a0: double[], a1: int, a2: int[], a3: int, a4: VectorMask<double>): void;
          _intoArray0Template(a: double[], offset: int): void;
          _intoArray0Template<M>(maskClass: java.lang.Class<M>, a: double[], offset: int, m: M): void;
          _intoArray0Template<M>(maskClass: java.lang.Class<M>, a: double[], offset: int, indexMap: int[], mapOffset: int, m: M): void;
          intoMemorySegment(ms: java.lang.foreign.MemorySegment, offset: long, a2: java.nio.ByteOrder): void;
          intoMemorySegment(ms: java.lang.foreign.MemorySegment, offset: long, a2: java.nio.ByteOrder, bo: VectorMask<double>): void;
          _intoMemorySegment0(ms: java.lang.foreign.MemorySegment, offset: long): void;
          _intoMemorySegment0(a0: java.lang.foreign.MemorySegment, a1: long, a2: VectorMask<double>): void;
          _intoMemorySegment0Template<M>(maskClass: java.lang.Class<M>, ms: java.lang.foreign.MemorySegment, offset: long, a3: M): void;
          lane(a0: int): double;
          lanewise(a0: VectorOperators$Unary): DoubleVector;
          lanewise(a0: VectorOperators$Unary, a1: VectorMask<double>): DoubleVector;
          lanewise(a0: VectorOperators$Binary, a1: Vector<double>): DoubleVector;
          lanewise(a0: VectorOperators$Binary, a1: Vector<double>, a2: VectorMask<double>): DoubleVector;
          lanewise(op: VectorOperators$Binary, e: double): DoubleVector;
          lanewise(op: VectorOperators$Binary, e: double, a2: VectorMask<double>): DoubleVector;
          lanewise(op: VectorOperators$Binary, e: long): DoubleVector;
          lanewise(op: VectorOperators$Binary, e: long, a2: VectorMask<double>): DoubleVector;
          lanewise(a0: VectorOperators$Ternary, a1: Vector<double>, a2: Vector<double>): DoubleVector;
          lanewise(a0: VectorOperators$Ternary, a1: Vector<double>, a2: Vector<double>, a3: VectorMask<double>): DoubleVector;
          lanewise(op: VectorOperators$Ternary, e1: double, a2: double): DoubleVector;
          lanewise(op: VectorOperators$Ternary, e1: double, a2: double, e2: VectorMask<double>): DoubleVector;
          lanewise(op: VectorOperators$Ternary, v1: Vector<double>, e2: double): DoubleVector;
          lanewise(op: VectorOperators$Ternary, v1: Vector<double>, e2: double, a3: VectorMask<double>): DoubleVector;
          lanewise(op: VectorOperators$Ternary, e1: double, a2: Vector<double>): DoubleVector;
          lanewise(op: VectorOperators$Ternary, e1: double, a2: Vector<double>, v2: VectorMask<double>): DoubleVector;
          lanewise(a0: VectorOperators$Ternary, a1: Vector, a2: Vector, a3: VectorMask): Vector;
          lanewise(a0: VectorOperators$Ternary, a1: Vector, a2: Vector): Vector;
          lanewise(a0: VectorOperators$Binary, a1: long, a2: VectorMask): Vector;
          lanewise(a0: VectorOperators$Binary, a1: long): Vector;
          lanewise(a0: VectorOperators$Binary, a1: Vector, a2: VectorMask): Vector;
          lanewise(a0: VectorOperators$Binary, a1: Vector): Vector;
          lanewise(a0: VectorOperators$Unary, a1: VectorMask): Vector;
          lanewise(a0: VectorOperators$Unary): Vector;
          _lanewiseTemplate(op: VectorOperators$Unary): DoubleVector;
          _lanewiseTemplate(op: VectorOperators$Unary, maskClass: java.lang.Class<VectorMask<double>>, m: VectorMask<double>): DoubleVector;
          _lanewiseTemplate(op: VectorOperators$Binary, v: Vector<double>): DoubleVector;
          _lanewiseTemplate(op: VectorOperators$Binary, maskClass: java.lang.Class<VectorMask<double>>, v: Vector<double>, m: VectorMask<double>): DoubleVector;
          _lanewiseTemplate(op: VectorOperators$Ternary, v1: Vector<double>, v2: Vector<double>): DoubleVector;
          _lanewiseTemplate(op: VectorOperators$Ternary, maskClass: java.lang.Class<VectorMask<double>>, v1: Vector<double>, v2: Vector<double>, m: VectorMask<double>): DoubleVector;
          _ldLongOp(memory: java.lang.foreign.MemorySegment, offset: long, a2: DoubleVector$FLdLongOp): DoubleVector;
          _ldLongOp(memory: java.lang.foreign.MemorySegment, offset: long, a2: VectorMask<double>, m: DoubleVector$FLdLongOp): DoubleVector;
          _ldOp<M>(memory: M, offset: int, f: DoubleVector$FLdOp<M>): DoubleVector;
          _ldOp<M>(memory: M, offset: int, m: VectorMask<double>, f: DoubleVector$FLdOp<M>): DoubleVector;
          lt(v: Vector<double>): VectorMask<double>;
          lt(e: double): VectorMask<double>;
          _maskFactory(bits: boolean[]): AbstractMask<double>;
          max(v: Vector<double>): DoubleVector;
          max(e: double): DoubleVector;
          max(a0: Vector): Vector;
          _maybeSwap(bo: java.nio.ByteOrder): DoubleVector;
          _maybeSwap(a0: java.nio.ByteOrder): AbstractVector;
          min(v: Vector<double>): DoubleVector;
          min(e: double): DoubleVector;
          min(a0: Vector): Vector;
          mul(v: Vector<double>): DoubleVector;
          mul(e: double): DoubleVector;
          mul(v: Vector<double>, m: VectorMask<double>): DoubleVector;
          mul(e: double, a1: VectorMask<double>): DoubleVector;
          mul(a0: Vector, a1: VectorMask): Vector;
          mul(a0: Vector): Vector;
          neg(): DoubleVector;
          neg(): Vector;
          pow(b: Vector<double>): DoubleVector;
          pow(b: double): DoubleVector;
          _rOp(a0: double, a1: VectorMask<double>, a2: DoubleVector$FBinOp): double;
          _rOpTemplate(v: double, a1: VectorMask<double>, m: DoubleVector$FBinOp): double;
          _rOpTemplate(v: double, a1: DoubleVector$FBinOp): double;
          rearrange(a0: VectorShuffle<double>): DoubleVector;
          rearrange(a0: VectorShuffle<double>, a1: VectorMask<double>): DoubleVector;
          rearrange(a0: VectorShuffle<double>, a1: Vector<double>): DoubleVector;
          rearrange(a0: VectorShuffle, a1: Vector): Vector;
          rearrange(a0: VectorShuffle, a1: VectorMask): Vector;
          rearrange(a0: VectorShuffle): Vector;
          _rearrangeTemplate<S>(shuffletype: java.lang.Class<S>, shuffle: S): DoubleVector;
          _rearrangeTemplate<S, M>(shuffletype: java.lang.Class<S>, masktype: java.lang.Class<M>, shuffle: S, m: M): DoubleVector;
          _rearrangeTemplate<S>(shuffletype: java.lang.Class<S>, shuffle: S, v: DoubleVector): DoubleVector;
          reduceLanes(a0: VectorOperators$Associative): double;
          reduceLanes(a0: VectorOperators$Associative, a1: VectorMask<double>): double;
          _reduceLanesTemplate(op: VectorOperators$Associative, maskClass: java.lang.Class<VectorMask<double>>, m: VectorMask<double>): double;
          _reduceLanesTemplate(op: VectorOperators$Associative): double;
          reduceLanesToLong(a0: VectorOperators$Associative): long;
          reduceLanesToLong(a0: VectorOperators$Associative, a1: VectorMask<double>): long;
          reinterpretAsBytes(): ByteVector;
          reinterpretAsDoubles(): DoubleVector;
          reinterpretAsFloats(): FloatVector;
          reinterpretAsInts(): IntVector;
          reinterpretAsLongs(): LongVector;
          reinterpretAsShorts(): ShortVector;
          selectFrom(a0: Vector<double>): DoubleVector;
          selectFrom(a0: Vector<double>, a1: VectorMask<double>): DoubleVector;
          selectFrom(a0: Vector, a1: VectorMask): Vector;
          selectFrom(a0: Vector): Vector;
          _selectFromTemplate(v: DoubleVector): DoubleVector;
          _selectFromTemplate(v: DoubleVector, m: AbstractMask<double>): DoubleVector;
          slice(a0: int, a1: Vector<double>): DoubleVector;
          slice(origin: int, w: Vector<double>, m: VectorMask<double>): DoubleVector;
          slice(a0: int): DoubleVector;
          slice(a0: int): AbstractVector;
          slice(a0: int, a1: Vector): AbstractVector;
          slice(a0: int): Vector;
          slice(a0: int, a1: Vector, a2: VectorMask): Vector;
          slice(a0: int, a1: Vector): Vector;
          _sliceTemplate(origin: int, v1: Vector<double>): DoubleVector;
          _sliceTemplate(origin: int): DoubleVector;
          sqrt(): DoubleVector;
          _stLongOp(memory: java.lang.foreign.MemorySegment, offset: long, a2: DoubleVector$FStLongOp): void;
          _stLongOp(memory: java.lang.foreign.MemorySegment, offset: long, a2: VectorMask<double>, m: DoubleVector$FStLongOp): void;
          _stOp<M>(memory: M, offset: int, f: DoubleVector$FStOp<M>): void;
          _stOp<M>(memory: M, offset: int, m: VectorMask<double>, f: DoubleVector$FStOp<M>): void;
          sub(v: Vector<double>): DoubleVector;
          sub(e: double): DoubleVector;
          sub(v: Vector<double>, m: VectorMask<double>): DoubleVector;
          sub(e: double, a1: VectorMask<double>): DoubleVector;
          sub(a0: Vector, a1: VectorMask): Vector;
          sub(a0: Vector): Vector;
          _tOp(a0: Vector<double>, a1: Vector<double>, a2: DoubleVector$FTriOp): DoubleVector;
          _tOp(a0: Vector<double>, a1: Vector<double>, a2: VectorMask<double>, a3: DoubleVector$FTriOp): DoubleVector;
          _tOpTemplate(o1: Vector<double>, o2: Vector<double>, f: DoubleVector$FTriOp): DoubleVector;
          _tOpTemplate(o1: Vector<double>, o2: Vector<double>, m: VectorMask<double>, f: DoubleVector$FTriOp): DoubleVector;
          test(a0: VectorOperators$Test): VectorMask<double>;
          test(a0: VectorOperators$Test, a1: VectorMask<double>): VectorMask<double>;
          _testTemplate<M>(maskType: java.lang.Class<M>, op: VectorOperators$Test): M;
          _testTemplate<M>(maskType: java.lang.Class<M>, op: VectorOperators$Test, mask: M): M;
          toArray(): double[];
          toArray(): any;
          toDoubleArray(): double[];
          toIntArray(): int[];
          toLongArray(): long[];
          _toShuffle0(dsp: DoubleVector$DoubleSpecies): VectorShuffle<double>;
          _toShuffleTemplate(shuffleType: java.lang.Class<any>): VectorShuffle<double>;
          toString(): string;
          _uOp(a0: DoubleVector$FUnOp): DoubleVector;
          _uOp(a0: VectorMask<double>, a1: DoubleVector$FUnOp): DoubleVector;
          _uOpTemplate(f: DoubleVector$FUnOp): DoubleVector;
          _uOpTemplate(m: VectorMask<double>, f: DoubleVector$FUnOp): DoubleVector;
          unslice(a0: int, a1: Vector<double>, a2: int): DoubleVector;
          unslice(a0: int, a1: Vector<double>, a2: int, a3: VectorMask<double>): DoubleVector;
          unslice(a0: int): DoubleVector;
          unslice(a0: int): Vector;
          unslice(a0: int, a1: Vector, a2: int, a3: VectorMask): Vector;
          unslice(a0: int, a1: Vector, a2: int): Vector;
          _unsliceTemplate(origin: int, w: Vector<double>, part: int): DoubleVector;
          _unsliceTemplate<M>(maskType: java.lang.Class<M>, origin: int, w: Vector<double>, part: int, m: M): DoubleVector;
          _unsliceTemplate(origin: int): DoubleVector;
          _vOp(f: DoubleVector$FVOp): DoubleVector;
          _vOp(m: VectorMask<double>, f: DoubleVector$FVOp): DoubleVector;
          _vec(): double[];
          _vectorFactory(a0: double[]): DoubleVector;
          viewAsFloatingLanes(): DoubleVector;
          viewAsFloatingLanes(): Vector;
          viewAsIntegralLanes(): LongVector;
          viewAsIntegralLanes(): Vector;
          _vspecies(): DoubleVector$DoubleSpecies;
          _vspecies(): AbstractSpecies;
          withLane(a0: int, a1: double): DoubleVector;
          _wrongPartForSlice(part: int): java.lang.ArrayIndexOutOfBoundsException;
        }
        interface DoubleVector extends CombineTypes<[_DoubleVector, AbstractVector<double>]> {}
        interface _DoubleVector$DoubleSpecies$$static extends ClassLike {
          _toIntegralChecked(e: double, a1: boolean): long;
        }
        let DoubleVector$DoubleSpecies: _DoubleVector$DoubleSpecies$$static;
        interface _DoubleVector$DoubleSpecies {
          _broadcast(e: double): DoubleVector;
          broadcast(e: long): DoubleVector;
          broadcast(a0: long): Vector;
          _broadcastBits(bits: long): DoubleVector;
          _broadcastBits(a0: long): AbstractVector;
          checkValue(e: long): long;
          _dummyVector(): DoubleVector;
          _dummyVector(): AbstractVector;
          elementType(): java.lang.Class<double>;
          fromArray(a: any, offset: int): DoubleVector;
          fromArray(a0: any, a1: int): Vector;
          _fromIntValues(values: int[]): DoubleVector;
          _fromIntValues(a0: int[]): Vector;
          fromMemorySegment(ms: java.lang.foreign.MemorySegment, offset: long, a2: java.nio.ByteOrder): DoubleVector;
          fromMemorySegment(a0: java.lang.foreign.MemorySegment, a1: long, a2: java.nio.ByteOrder): Vector;
          _genericElementType(): java.lang.Class<double>;
          iota(): DoubleVector;
          iota(): AbstractVector;
          _ldLongOp(memory: java.lang.foreign.MemorySegment, offset: long, a2: DoubleVector$FLdLongOp): DoubleVector;
          _ldLongOp(memory: java.lang.foreign.MemorySegment, offset: long, a2: VectorMask<double>, m: DoubleVector$FLdLongOp): DoubleVector;
          _ldOp<M>(memory: M, offset: int, f: DoubleVector$FLdOp<M>): DoubleVector;
          _ldOp<M>(memory: M, offset: int, m: VectorMask<double>, f: DoubleVector$FLdOp<M>): DoubleVector;
          _longToElementBits(value: long): long;
          maskAll(bit: boolean): VectorMask<double>;
          _rvOp(f: AbstractSpecies$RVOp): DoubleVector;
          _rvOp(a0: AbstractSpecies$RVOp): AbstractVector;
          _stLongOp(memory: java.lang.foreign.MemorySegment, offset: long, a2: DoubleVector$FStLongOp): void;
          _stLongOp(memory: java.lang.foreign.MemorySegment, offset: long, a2: AbstractMask<double>, m: DoubleVector$FStLongOp): void;
          _stOp<M>(memory: M, offset: int, f: DoubleVector$FStOp<M>): void;
          _stOp<M>(memory: M, offset: int, m: AbstractMask<double>, f: DoubleVector$FStOp<M>): void;
          _vOp(f: DoubleVector$FVOp): DoubleVector;
          _vOp(m: VectorMask<double>, f: DoubleVector$FVOp): DoubleVector;
          vectorType(): java.lang.Class<DoubleVector>;
          zero(): DoubleVector;
          zero(): AbstractVector;
          zero(): Vector;
        }
        interface DoubleVector$DoubleSpecies extends CombineTypes<[_DoubleVector$DoubleSpecies, AbstractSpecies<double>]> {}
        interface _DoubleVector$FBinOp$$static extends ClassLike {
        }
        let DoubleVector$FBinOp: _DoubleVector$FBinOp$$static;
        interface _DoubleVector$FBinOp {
          apply(a0: int, a1: double, a2: double): double;
(a0: int, a1: double, a2: double): double;
        }
        interface DoubleVector$FBinOp extends CombineTypes<[_DoubleVector$FBinOp, java.lang.Object]> {}
        interface _DoubleVector$FBinTest$$static extends ClassLike {
        }
        let DoubleVector$FBinTest: _DoubleVector$FBinTest$$static;
        interface _DoubleVector$FBinTest {
          apply(a0: int, a1: int, a2: double, a3: double): boolean;
(a0: int, a1: int, a2: double, a3: double): boolean;
        }
        interface DoubleVector$FBinTest extends CombineTypes<[_DoubleVector$FBinTest, java.lang.Object]> {}
        interface _DoubleVector$FLdLongOp$$static extends ClassLike {
        }
        let DoubleVector$FLdLongOp: _DoubleVector$FLdLongOp$$static;
        interface _DoubleVector$FLdLongOp {
          apply(a0: java.lang.foreign.MemorySegment, a1: long, a2: int): double;
(a0: java.lang.foreign.MemorySegment, a1: long, a2: int): double;
        }
        interface DoubleVector$FLdLongOp extends CombineTypes<[_DoubleVector$FLdLongOp, java.lang.Object]> {}
        interface _DoubleVector$FLdOp$$static<M> extends ClassLike {
        }
        let DoubleVector$FLdOp: _DoubleVector$FLdOp$$static<M>;
        interface _DoubleVector$FLdOp<M> {
          apply(a0: M, a1: int, a2: int): double;
(a0: M, a1: int, a2: int): double;
        }
        interface DoubleVector$FLdOp<M> extends CombineTypes<[_DoubleVector$FLdOp<M>, java.lang.Object]> {}
        interface _DoubleVector$FStLongOp$$static extends ClassLike {
        }
        let DoubleVector$FStLongOp: _DoubleVector$FStLongOp$$static;
        interface _DoubleVector$FStLongOp {
          apply(a0: java.lang.foreign.MemorySegment, a1: long, a2: int, a3: double): void;
(a0: java.lang.foreign.MemorySegment, a1: long, a2: int, a3: double): void;
        }
        interface DoubleVector$FStLongOp extends CombineTypes<[_DoubleVector$FStLongOp, java.lang.Object]> {}
        interface _DoubleVector$FStOp$$static<M> extends ClassLike {
        }
        let DoubleVector$FStOp: _DoubleVector$FStOp$$static<M>;
        interface _DoubleVector$FStOp<M> {
          apply(a0: M, a1: int, a2: int, a3: double): void;
(a0: M, a1: int, a2: int, a3: double): void;
        }
        interface DoubleVector$FStOp<M> extends CombineTypes<[_DoubleVector$FStOp<M>, java.lang.Object]> {}
        interface _DoubleVector$FTriOp$$static extends ClassLike {
        }
        let DoubleVector$FTriOp: _DoubleVector$FTriOp$$static;
        interface _DoubleVector$FTriOp {
          apply(a0: int, a1: double, a2: double, a3: double): double;
(a0: int, a1: double, a2: double, a3: double): double;
        }
        interface DoubleVector$FTriOp extends CombineTypes<[_DoubleVector$FTriOp, java.lang.Object]> {}
        interface _DoubleVector$FUnOp$$static extends ClassLike {
        }
        let DoubleVector$FUnOp: _DoubleVector$FUnOp$$static;
        interface _DoubleVector$FUnOp {
          apply(a0: int, a1: double): double;
(a0: int, a1: double): double;
        }
        interface DoubleVector$FUnOp extends CombineTypes<[_DoubleVector$FUnOp, java.lang.Object]> {}
        interface _DoubleVector$FVOp$$static extends ClassLike {
        }
        let DoubleVector$FVOp: _DoubleVector$FVOp$$static;
        interface _DoubleVector$FVOp {
          apply(a0: int): double;
(a0: int): double;
        }
        interface DoubleVector$FVOp extends CombineTypes<[_DoubleVector$FVOp, java.lang.Object]> {}
        interface _Float128Vector$$static extends ClassLike {
          _ETYPE: java.lang.Class<float>;
          _IOTA: Float128Vector;
          _VCLASS: java.lang.Class<Float128Vector>;
          _VLENGTH: int;
          _VSHAPE: VectorShape;
          _VSIZE: int;
          _VSPECIES: FloatVector$FloatSpecies;
          _ZERO: Float128Vector;
          _new(v: float[]): Float128Vector;
          _new(v: any): Float128Vector;
        }
        let Float128Vector: _Float128Vector$$static;
        interface _Float128Vector {
          addIndex(scale: int): Float128Vector;
          addIndex(a0: int): FloatVector;
          addIndex(a0: int): Vector;
          _asByteVectorRaw(): Byte128Vector;
          _asByteVectorRaw(): ByteVector;
          _asVectorRaw(laneType: LaneType): AbstractVector<any>;
          _bOp(v: Vector<float>, f: FloatVector$FBinOp): Float128Vector;
          _bOp(v: Vector<float>, m: VectorMask<float>, f: FloatVector$FBinOp): Float128Vector;
          _bOp(a0: Vector, a1: VectorMask, a2: FloatVector$FBinOp): FloatVector;
          _bOp(a0: Vector, a1: FloatVector$FBinOp): FloatVector;
          bitSize(): int;
          blend(v: Vector<float>, m: VectorMask<float>): Float128Vector;
          blend(a0: Vector, a1: VectorMask): FloatVector;
          blend(a0: Vector, a1: VectorMask): Vector;
          broadcast(e: float): Float128Vector;
          broadcast(e: long): Float128Vector;
          broadcast(a0: long): FloatVector;
          broadcast(a0: float): FloatVector;
          broadcast(a0: long): Vector;
          byteSize(): int;
          compare(op: VectorOperators$Comparison, v: Vector<float>): Float128Vector$Float128Mask;
          compare(op: VectorOperators$Comparison, s: float): Float128Vector$Float128Mask;
          compare(op: VectorOperators$Comparison, s: long): Float128Vector$Float128Mask;
          compare(op: VectorOperators$Comparison, v: Vector<float>, m: VectorMask<float>): Float128Vector$Float128Mask;
          compare(a0: VectorOperators$Comparison, a1: long): VectorMask;
          compare(a0: VectorOperators$Comparison, a1: float): VectorMask;
          compare(a0: VectorOperators$Comparison, a1: Vector): VectorMask;
          compare(a0: VectorOperators$Comparison, a1: Vector, a2: VectorMask): VectorMask;
          compress(m: VectorMask<float>): Float128Vector;
          compress(a0: VectorMask): FloatVector;
          compress(a0: VectorMask): Vector;
          convertShape<F>(conv: VectorOperators$Conversion<float,F>, rsp: VectorSpecies<F>, part: int): Vector<F>;
          elementSize(): int;
          elementType(): java.lang.Class<float>;
          expand(m: VectorMask<float>): Float128Vector;
          expand(a0: VectorMask): FloatVector;
          expand(a0: VectorMask): Vector;
          _fromArray0(a: float[], offset: int): FloatVector;
          _fromArray0(a: float[], offset: int, m: VectorMask<float>, offsetInRange: int): FloatVector;
          _fromArray0(a: float[], offset: int, indexMap: int[], mapOffset: int, m: VectorMask<float>): FloatVector;
          _fromMemorySegment0(ms: java.lang.foreign.MemorySegment, offset: long): FloatVector;
          _fromMemorySegment0(ms: java.lang.foreign.MemorySegment, offset: long, a2: VectorMask<float>, m: int): FloatVector;
          _fromMemorySegment0(a0: java.lang.foreign.MemorySegment, a1: long): AbstractVector;
          _intoArray0(a: float[], offset: int): void;
          _intoArray0(a: float[], offset: int, m: VectorMask<float>): void;
          _intoArray0(a: float[], offset: int, indexMap: int[], mapOffset: int, m: VectorMask<float>): void;
          _intoMemorySegment0(ms: java.lang.foreign.MemorySegment, offset: long, a2: VectorMask<float>): void;
          _iotaShuffle(): Float128Vector$Float128Shuffle;
          _iotaShuffle(start: int, step: int, wrap: boolean): Float128Vector$Float128Shuffle;
          _iotaShuffle(a0: int, a1: int, a2: boolean): AbstractShuffle;
          _iotaShuffle(): AbstractShuffle;
          lane(i: int): float;
          laneHelper(i: int): int;
          lanewise(op: VectorOperators$Unary): Float128Vector;
          lanewise(op: VectorOperators$Unary, m: VectorMask<float>): Float128Vector;
          lanewise(op: VectorOperators$Binary, v: Vector<float>): Float128Vector;
          lanewise(op: VectorOperators$Binary, v: Vector<float>, m: VectorMask<float>): Float128Vector;
          lanewise(op: VectorOperators$Ternary, v1: Vector<float>, v2: Vector<float>): Float128Vector;
          lanewise(op: VectorOperators$Ternary, v1: Vector<float>, v2: Vector<float>, m: VectorMask<float>): Float128Vector;
          lanewise(a0: VectorOperators$Ternary, a1: Vector, a2: Vector, a3: VectorMask): FloatVector;
          lanewise(a0: VectorOperators$Ternary, a1: Vector, a2: Vector): FloatVector;
          lanewise(a0: VectorOperators$Binary, a1: Vector, a2: VectorMask): FloatVector;
          lanewise(a0: VectorOperators$Binary, a1: Vector): FloatVector;
          lanewise(a0: VectorOperators$Unary, a1: VectorMask): FloatVector;
          lanewise(a0: VectorOperators$Unary): FloatVector;
          lanewise(a0: VectorOperators$Ternary, a1: Vector, a2: Vector, a3: VectorMask): Vector;
          lanewise(a0: VectorOperators$Ternary, a1: Vector, a2: Vector): Vector;
          lanewise(a0: VectorOperators$Binary, a1: Vector, a2: VectorMask): Vector;
          lanewise(a0: VectorOperators$Binary, a1: Vector): Vector;
          lanewise(a0: VectorOperators$Unary, a1: VectorMask): Vector;
          lanewise(a0: VectorOperators$Unary): Vector;
          length(): int;
          _maskFromArray(bits: boolean[]): Float128Vector$Float128Mask;
          _maskFromArray(a0: boolean[]): AbstractMask;
          _rOp(v: float, m: VectorMask<float>, f: FloatVector$FBinOp): float;
          rearrange(s: VectorShuffle<float>): Float128Vector;
          rearrange(shuffle: VectorShuffle<float>, m: VectorMask<float>): Float128Vector;
          rearrange(s: VectorShuffle<float>, v: Vector<float>): Float128Vector;
          rearrange(a0: VectorShuffle, a1: Vector): FloatVector;
          rearrange(a0: VectorShuffle, a1: VectorMask): FloatVector;
          rearrange(a0: VectorShuffle): FloatVector;
          rearrange(a0: VectorShuffle, a1: Vector): Vector;
          rearrange(a0: VectorShuffle, a1: VectorMask): Vector;
          rearrange(a0: VectorShuffle): Vector;
          reduceLanes(op: VectorOperators$Associative): float;
          reduceLanes(op: VectorOperators$Associative, m: VectorMask<float>): float;
          reduceLanesToLong(op: VectorOperators$Associative): long;
          reduceLanesToLong(op: VectorOperators$Associative, m: VectorMask<float>): long;
          reinterpretShape<F>(toSpecies: VectorSpecies<F>, part: int): Vector<F>;
          selectFrom(v: Vector<float>): Float128Vector;
          selectFrom(v: Vector<float>, m: VectorMask<float>): Float128Vector;
          selectFrom(a0: Vector, a1: VectorMask): FloatVector;
          selectFrom(a0: Vector): FloatVector;
          selectFrom(a0: Vector, a1: VectorMask): Vector;
          selectFrom(a0: Vector): Vector;
          shape(): VectorShape;
          _shuffleFromArray(indexes: int[], i: int): Float128Vector$Float128Shuffle;
          _shuffleFromArray(a0: int[], a1: int): AbstractShuffle;
          _shuffleFromBytes(reorder: byte[]): Float128Vector$Float128Shuffle;
          _shuffleFromBytes(a0: byte[]): AbstractShuffle;
          _shuffleFromOp(fn: java.util.function.IntUnaryOperator): Float128Vector$Float128Shuffle;
          _shuffleFromOp(a0: java.util.function.IntUnaryOperator): AbstractShuffle;
          slice(origin: int, v: Vector<float>): Float128Vector;
          slice(origin: int): Float128Vector;
          slice(a0: int): FloatVector;
          slice(a0: int, a1: Vector): FloatVector;
          slice(a0: int): AbstractVector;
          slice(a0: int, a1: Vector): AbstractVector;
          slice(a0: int): Vector;
          slice(a0: int, a1: Vector): Vector;
          _tOp(v1: Vector<float>, v2: Vector<float>, f: FloatVector$FTriOp): Float128Vector;
          _tOp(v1: Vector<float>, v2: Vector<float>, m: VectorMask<float>, f: FloatVector$FTriOp): Float128Vector;
          _tOp(a0: Vector, a1: Vector, a2: VectorMask, a3: FloatVector$FTriOp): FloatVector;
          _tOp(a0: Vector, a1: Vector, a2: FloatVector$FTriOp): FloatVector;
          test(op: VectorOperators$Test): Float128Vector$Float128Mask;
          test(op: VectorOperators$Test, m: VectorMask<float>): Float128Vector$Float128Mask;
          test(a0: VectorOperators$Test, a1: VectorMask): VectorMask;
          test(a0: VectorOperators$Test): VectorMask;
          toShuffle(): VectorShuffle<float>;
          _uOp(f: FloatVector$FUnOp): Float128Vector;
          _uOp(m: VectorMask<float>, f: FloatVector$FUnOp): Float128Vector;
          _uOp(a0: VectorMask, a1: FloatVector$FUnOp): FloatVector;
          _uOp(a0: FloatVector$FUnOp): FloatVector;
          unslice(origin: int, w: Vector<float>, part: int): Float128Vector;
          unslice(origin: int, w: Vector<float>, part: int, m: VectorMask<float>): Float128Vector;
          unslice(origin: int): Float128Vector;
          unslice(a0: int): FloatVector;
          unslice(a0: int, a1: Vector, a2: int, a3: VectorMask): FloatVector;
          unslice(a0: int, a1: Vector, a2: int): FloatVector;
          unslice(a0: int): Vector;
          unslice(a0: int, a1: Vector, a2: int, a3: VectorMask): Vector;
          unslice(a0: int, a1: Vector, a2: int): Vector;
          _vec(): float[];
          _vectorFactory(vec: float[]): Float128Vector;
          _vectorFactory(a0: float[]): FloatVector;
          vspecies(): FloatVector$FloatSpecies;
          vspecies(): AbstractSpecies;
          withLane(i: int, e: float): Float128Vector;
          withLane(a0: int, a1: float): FloatVector;
          withLaneHelper(i: int, e: float): Float128Vector;
        }
        interface Float128Vector extends CombineTypes<[_Float128Vector, jdk.incubator.vector.FloatVector]> {}
        interface _Float128Vector$Float128Mask$$static extends ClassLike {
          _maskAll(bit: boolean): Float128Vector$Float128Mask;
          _prepare(bits: boolean[], offset: int): boolean[];
          _prepare(val: boolean): boolean[];
          _ETYPE: java.lang.Class<float>;
          _FALSE_MASK: Float128Vector$Float128Mask;
          _TRUE_MASK: Float128Vector$Float128Mask;
          _VLENGTH: int;
          _new(bits: boolean[]): Float128Vector$Float128Mask;
          _new(bits: boolean[], offset: int): Float128Vector$Float128Mask;
          _new(val: boolean): Float128Vector$Float128Mask;
        }
        let Float128Vector$Float128Mask: _Float128Vector$Float128Mask$$static;
        interface _Float128Vector$Float128Mask {
          allTrue(): boolean;
          and(mask: VectorMask<float>): Float128Vector$Float128Mask;
          and(a0: VectorMask): VectorMask;
          anyTrue(): boolean;
          _bOp(m: VectorMask<float>, f: AbstractMask$MBinOp): Float128Vector$Float128Mask;
          _bOp(a0: VectorMask, a1: AbstractMask$MBinOp): AbstractMask;
          cast<E>(dsp: VectorSpecies<E>): VectorMask<E>;
          compress(): Float128Vector$Float128Mask;
          compress(): VectorMask;
          _defaultMaskCast<E>(dsp: AbstractSpecies<E>): VectorMask<E>;
          firstTrue(): int;
          _getBits(): boolean[];
          _indexPartiallyInUpperRange(offset: long, a1: long): Float128Vector$Float128Mask;
          _indexPartiallyInUpperRange(a0: long, a1: long): VectorMask;
          lastTrue(): int;
          not(): Float128Vector$Float128Mask;
          not(): VectorMask;
          or(mask: VectorMask<float>): Float128Vector$Float128Mask;
          or(a0: VectorMask): VectorMask;
          toLong(): long;
          toVector(): Float128Vector;
          toVector(): Vector;
          trueCount(): int;
          _uOp(f: AbstractMask$MUnOp): Float128Vector$Float128Mask;
          _uOp(a0: AbstractMask$MUnOp): AbstractMask;
          vspecies(): FloatVector$FloatSpecies;
          vspecies(): AbstractSpecies;
          xor(mask: VectorMask<float>): Float128Vector$Float128Mask;
          xor(a0: VectorMask): VectorMask;
        }
        interface Float128Vector$Float128Mask extends CombineTypes<[_Float128Vector$Float128Mask, AbstractMask<float>]> {}
        interface _Float128Vector$Float128Shuffle$$static extends ClassLike {
          _ETYPE: java.lang.Class<float>;
          _IOTA: Float128Vector$Float128Shuffle;
          _VLENGTH: int;
          _new(reorder: byte[]): Float128Vector$Float128Shuffle;
          new(reorder: int[]): Float128Vector$Float128Shuffle;
          new(reorder: int[], i: int): Float128Vector$Float128Shuffle;
          new(fn: java.util.function.IntUnaryOperator): Float128Vector$Float128Shuffle;
        }
        let Float128Vector$Float128Shuffle: _Float128Vector$Float128Shuffle$$static;
        interface _Float128Vector$Float128Shuffle {
          cast<F>(s: VectorSpecies<F>): VectorShuffle<F>;
          rearrange(shuffle: VectorShuffle<float>): Float128Vector$Float128Shuffle;
          rearrange(a0: VectorShuffle): VectorShuffle;
          toVector(): Float128Vector;
          toVector(): Vector;
          vspecies(): FloatVector$FloatSpecies;
          vspecies(): AbstractSpecies;
        }
        interface Float128Vector$Float128Shuffle extends CombineTypes<[_Float128Vector$Float128Shuffle, AbstractShuffle<float>]> {}
        interface _Float256Vector$$static extends ClassLike {
          _ETYPE: java.lang.Class<float>;
          _IOTA: Float256Vector;
          _VCLASS: java.lang.Class<Float256Vector>;
          _VLENGTH: int;
          _VSHAPE: VectorShape;
          _VSIZE: int;
          _VSPECIES: FloatVector$FloatSpecies;
          _ZERO: Float256Vector;
          _new(v: float[]): Float256Vector;
          _new(v: any): Float256Vector;
        }
        let Float256Vector: _Float256Vector$$static;
        interface _Float256Vector {
          addIndex(scale: int): Float256Vector;
          addIndex(a0: int): FloatVector;
          addIndex(a0: int): Vector;
          _asByteVectorRaw(): Byte256Vector;
          _asByteVectorRaw(): ByteVector;
          _asVectorRaw(laneType: LaneType): AbstractVector<any>;
          _bOp(v: Vector<float>, f: FloatVector$FBinOp): Float256Vector;
          _bOp(v: Vector<float>, m: VectorMask<float>, f: FloatVector$FBinOp): Float256Vector;
          _bOp(a0: Vector, a1: VectorMask, a2: FloatVector$FBinOp): FloatVector;
          _bOp(a0: Vector, a1: FloatVector$FBinOp): FloatVector;
          bitSize(): int;
          blend(v: Vector<float>, m: VectorMask<float>): Float256Vector;
          blend(a0: Vector, a1: VectorMask): FloatVector;
          blend(a0: Vector, a1: VectorMask): Vector;
          broadcast(e: float): Float256Vector;
          broadcast(e: long): Float256Vector;
          broadcast(a0: long): FloatVector;
          broadcast(a0: float): FloatVector;
          broadcast(a0: long): Vector;
          byteSize(): int;
          compare(op: VectorOperators$Comparison, v: Vector<float>): Float256Vector$Float256Mask;
          compare(op: VectorOperators$Comparison, s: float): Float256Vector$Float256Mask;
          compare(op: VectorOperators$Comparison, s: long): Float256Vector$Float256Mask;
          compare(op: VectorOperators$Comparison, v: Vector<float>, m: VectorMask<float>): Float256Vector$Float256Mask;
          compare(a0: VectorOperators$Comparison, a1: long): VectorMask;
          compare(a0: VectorOperators$Comparison, a1: float): VectorMask;
          compare(a0: VectorOperators$Comparison, a1: Vector): VectorMask;
          compare(a0: VectorOperators$Comparison, a1: Vector, a2: VectorMask): VectorMask;
          compress(m: VectorMask<float>): Float256Vector;
          compress(a0: VectorMask): FloatVector;
          compress(a0: VectorMask): Vector;
          convertShape<F>(conv: VectorOperators$Conversion<float,F>, rsp: VectorSpecies<F>, part: int): Vector<F>;
          elementSize(): int;
          elementType(): java.lang.Class<float>;
          expand(m: VectorMask<float>): Float256Vector;
          expand(a0: VectorMask): FloatVector;
          expand(a0: VectorMask): Vector;
          _fromArray0(a: float[], offset: int): FloatVector;
          _fromArray0(a: float[], offset: int, m: VectorMask<float>, offsetInRange: int): FloatVector;
          _fromArray0(a: float[], offset: int, indexMap: int[], mapOffset: int, m: VectorMask<float>): FloatVector;
          _fromMemorySegment0(ms: java.lang.foreign.MemorySegment, offset: long): FloatVector;
          _fromMemorySegment0(ms: java.lang.foreign.MemorySegment, offset: long, a2: VectorMask<float>, m: int): FloatVector;
          _fromMemorySegment0(a0: java.lang.foreign.MemorySegment, a1: long): AbstractVector;
          _intoArray0(a: float[], offset: int): void;
          _intoArray0(a: float[], offset: int, m: VectorMask<float>): void;
          _intoArray0(a: float[], offset: int, indexMap: int[], mapOffset: int, m: VectorMask<float>): void;
          _intoMemorySegment0(ms: java.lang.foreign.MemorySegment, offset: long, a2: VectorMask<float>): void;
          _iotaShuffle(): Float256Vector$Float256Shuffle;
          _iotaShuffle(start: int, step: int, wrap: boolean): Float256Vector$Float256Shuffle;
          _iotaShuffle(a0: int, a1: int, a2: boolean): AbstractShuffle;
          _iotaShuffle(): AbstractShuffle;
          lane(i: int): float;
          laneHelper(i: int): int;
          lanewise(op: VectorOperators$Unary): Float256Vector;
          lanewise(op: VectorOperators$Unary, m: VectorMask<float>): Float256Vector;
          lanewise(op: VectorOperators$Binary, v: Vector<float>): Float256Vector;
          lanewise(op: VectorOperators$Binary, v: Vector<float>, m: VectorMask<float>): Float256Vector;
          lanewise(op: VectorOperators$Ternary, v1: Vector<float>, v2: Vector<float>): Float256Vector;
          lanewise(op: VectorOperators$Ternary, v1: Vector<float>, v2: Vector<float>, m: VectorMask<float>): Float256Vector;
          lanewise(a0: VectorOperators$Ternary, a1: Vector, a2: Vector, a3: VectorMask): FloatVector;
          lanewise(a0: VectorOperators$Ternary, a1: Vector, a2: Vector): FloatVector;
          lanewise(a0: VectorOperators$Binary, a1: Vector, a2: VectorMask): FloatVector;
          lanewise(a0: VectorOperators$Binary, a1: Vector): FloatVector;
          lanewise(a0: VectorOperators$Unary, a1: VectorMask): FloatVector;
          lanewise(a0: VectorOperators$Unary): FloatVector;
          lanewise(a0: VectorOperators$Ternary, a1: Vector, a2: Vector, a3: VectorMask): Vector;
          lanewise(a0: VectorOperators$Ternary, a1: Vector, a2: Vector): Vector;
          lanewise(a0: VectorOperators$Binary, a1: Vector, a2: VectorMask): Vector;
          lanewise(a0: VectorOperators$Binary, a1: Vector): Vector;
          lanewise(a0: VectorOperators$Unary, a1: VectorMask): Vector;
          lanewise(a0: VectorOperators$Unary): Vector;
          length(): int;
          _maskFromArray(bits: boolean[]): Float256Vector$Float256Mask;
          _maskFromArray(a0: boolean[]): AbstractMask;
          _rOp(v: float, m: VectorMask<float>, f: FloatVector$FBinOp): float;
          rearrange(s: VectorShuffle<float>): Float256Vector;
          rearrange(shuffle: VectorShuffle<float>, m: VectorMask<float>): Float256Vector;
          rearrange(s: VectorShuffle<float>, v: Vector<float>): Float256Vector;
          rearrange(a0: VectorShuffle, a1: Vector): FloatVector;
          rearrange(a0: VectorShuffle, a1: VectorMask): FloatVector;
          rearrange(a0: VectorShuffle): FloatVector;
          rearrange(a0: VectorShuffle, a1: Vector): Vector;
          rearrange(a0: VectorShuffle, a1: VectorMask): Vector;
          rearrange(a0: VectorShuffle): Vector;
          reduceLanes(op: VectorOperators$Associative): float;
          reduceLanes(op: VectorOperators$Associative, m: VectorMask<float>): float;
          reduceLanesToLong(op: VectorOperators$Associative): long;
          reduceLanesToLong(op: VectorOperators$Associative, m: VectorMask<float>): long;
          reinterpretShape<F>(toSpecies: VectorSpecies<F>, part: int): Vector<F>;
          selectFrom(v: Vector<float>): Float256Vector;
          selectFrom(v: Vector<float>, m: VectorMask<float>): Float256Vector;
          selectFrom(a0: Vector, a1: VectorMask): FloatVector;
          selectFrom(a0: Vector): FloatVector;
          selectFrom(a0: Vector, a1: VectorMask): Vector;
          selectFrom(a0: Vector): Vector;
          shape(): VectorShape;
          _shuffleFromArray(indexes: int[], i: int): Float256Vector$Float256Shuffle;
          _shuffleFromArray(a0: int[], a1: int): AbstractShuffle;
          _shuffleFromBytes(reorder: byte[]): Float256Vector$Float256Shuffle;
          _shuffleFromBytes(a0: byte[]): AbstractShuffle;
          _shuffleFromOp(fn: java.util.function.IntUnaryOperator): Float256Vector$Float256Shuffle;
          _shuffleFromOp(a0: java.util.function.IntUnaryOperator): AbstractShuffle;
          slice(origin: int, v: Vector<float>): Float256Vector;
          slice(origin: int): Float256Vector;
          slice(a0: int): FloatVector;
          slice(a0: int, a1: Vector): FloatVector;
          slice(a0: int): AbstractVector;
          slice(a0: int, a1: Vector): AbstractVector;
          slice(a0: int): Vector;
          slice(a0: int, a1: Vector): Vector;
          _tOp(v1: Vector<float>, v2: Vector<float>, f: FloatVector$FTriOp): Float256Vector;
          _tOp(v1: Vector<float>, v2: Vector<float>, m: VectorMask<float>, f: FloatVector$FTriOp): Float256Vector;
          _tOp(a0: Vector, a1: Vector, a2: VectorMask, a3: FloatVector$FTriOp): FloatVector;
          _tOp(a0: Vector, a1: Vector, a2: FloatVector$FTriOp): FloatVector;
          test(op: VectorOperators$Test): Float256Vector$Float256Mask;
          test(op: VectorOperators$Test, m: VectorMask<float>): Float256Vector$Float256Mask;
          test(a0: VectorOperators$Test, a1: VectorMask): VectorMask;
          test(a0: VectorOperators$Test): VectorMask;
          toShuffle(): VectorShuffle<float>;
          _uOp(f: FloatVector$FUnOp): Float256Vector;
          _uOp(m: VectorMask<float>, f: FloatVector$FUnOp): Float256Vector;
          _uOp(a0: VectorMask, a1: FloatVector$FUnOp): FloatVector;
          _uOp(a0: FloatVector$FUnOp): FloatVector;
          unslice(origin: int, w: Vector<float>, part: int): Float256Vector;
          unslice(origin: int, w: Vector<float>, part: int, m: VectorMask<float>): Float256Vector;
          unslice(origin: int): Float256Vector;
          unslice(a0: int): FloatVector;
          unslice(a0: int, a1: Vector, a2: int, a3: VectorMask): FloatVector;
          unslice(a0: int, a1: Vector, a2: int): FloatVector;
          unslice(a0: int): Vector;
          unslice(a0: int, a1: Vector, a2: int, a3: VectorMask): Vector;
          unslice(a0: int, a1: Vector, a2: int): Vector;
          _vec(): float[];
          _vectorFactory(vec: float[]): Float256Vector;
          _vectorFactory(a0: float[]): FloatVector;
          vspecies(): FloatVector$FloatSpecies;
          vspecies(): AbstractSpecies;
          withLane(i: int, e: float): Float256Vector;
          withLane(a0: int, a1: float): FloatVector;
          withLaneHelper(i: int, e: float): Float256Vector;
        }
        interface Float256Vector extends CombineTypes<[_Float256Vector, jdk.incubator.vector.FloatVector]> {}
        interface _Float256Vector$Float256Mask$$static extends ClassLike {
          _maskAll(bit: boolean): Float256Vector$Float256Mask;
          _prepare(bits: boolean[], offset: int): boolean[];
          _prepare(val: boolean): boolean[];
          _ETYPE: java.lang.Class<float>;
          _FALSE_MASK: Float256Vector$Float256Mask;
          _TRUE_MASK: Float256Vector$Float256Mask;
          _VLENGTH: int;
          _new(bits: boolean[]): Float256Vector$Float256Mask;
          _new(bits: boolean[], offset: int): Float256Vector$Float256Mask;
          _new(val: boolean): Float256Vector$Float256Mask;
        }
        let Float256Vector$Float256Mask: _Float256Vector$Float256Mask$$static;
        interface _Float256Vector$Float256Mask {
          allTrue(): boolean;
          and(mask: VectorMask<float>): Float256Vector$Float256Mask;
          and(a0: VectorMask): VectorMask;
          anyTrue(): boolean;
          _bOp(m: VectorMask<float>, f: AbstractMask$MBinOp): Float256Vector$Float256Mask;
          _bOp(a0: VectorMask, a1: AbstractMask$MBinOp): AbstractMask;
          cast<E>(dsp: VectorSpecies<E>): VectorMask<E>;
          compress(): Float256Vector$Float256Mask;
          compress(): VectorMask;
          _defaultMaskCast<E>(dsp: AbstractSpecies<E>): VectorMask<E>;
          firstTrue(): int;
          _getBits(): boolean[];
          _indexPartiallyInUpperRange(offset: long, a1: long): Float256Vector$Float256Mask;
          _indexPartiallyInUpperRange(a0: long, a1: long): VectorMask;
          lastTrue(): int;
          not(): Float256Vector$Float256Mask;
          not(): VectorMask;
          or(mask: VectorMask<float>): Float256Vector$Float256Mask;
          or(a0: VectorMask): VectorMask;
          toLong(): long;
          toVector(): Float256Vector;
          toVector(): Vector;
          trueCount(): int;
          _uOp(f: AbstractMask$MUnOp): Float256Vector$Float256Mask;
          _uOp(a0: AbstractMask$MUnOp): AbstractMask;
          vspecies(): FloatVector$FloatSpecies;
          vspecies(): AbstractSpecies;
          xor(mask: VectorMask<float>): Float256Vector$Float256Mask;
          xor(a0: VectorMask): VectorMask;
        }
        interface Float256Vector$Float256Mask extends CombineTypes<[_Float256Vector$Float256Mask, AbstractMask<float>]> {}
        interface _Float256Vector$Float256Shuffle$$static extends ClassLike {
          _ETYPE: java.lang.Class<float>;
          _IOTA: Float256Vector$Float256Shuffle;
          _VLENGTH: int;
          _new(reorder: byte[]): Float256Vector$Float256Shuffle;
          new(reorder: int[]): Float256Vector$Float256Shuffle;
          new(reorder: int[], i: int): Float256Vector$Float256Shuffle;
          new(fn: java.util.function.IntUnaryOperator): Float256Vector$Float256Shuffle;
        }
        let Float256Vector$Float256Shuffle: _Float256Vector$Float256Shuffle$$static;
        interface _Float256Vector$Float256Shuffle {
          cast<F>(s: VectorSpecies<F>): VectorShuffle<F>;
          rearrange(shuffle: VectorShuffle<float>): Float256Vector$Float256Shuffle;
          rearrange(a0: VectorShuffle): VectorShuffle;
          toVector(): Float256Vector;
          toVector(): Vector;
          vspecies(): FloatVector$FloatSpecies;
          vspecies(): AbstractSpecies;
        }
        interface Float256Vector$Float256Shuffle extends CombineTypes<[_Float256Vector$Float256Shuffle, AbstractShuffle<float>]> {}
        interface _Float512Vector$$static extends ClassLike {
          _ETYPE: java.lang.Class<float>;
          _IOTA: Float512Vector;
          _VCLASS: java.lang.Class<Float512Vector>;
          _VLENGTH: int;
          _VSHAPE: VectorShape;
          _VSIZE: int;
          _VSPECIES: FloatVector$FloatSpecies;
          _ZERO: Float512Vector;
          _new(v: float[]): Float512Vector;
          _new(v: any): Float512Vector;
        }
        let Float512Vector: _Float512Vector$$static;
        interface _Float512Vector {
          addIndex(scale: int): Float512Vector;
          addIndex(a0: int): FloatVector;
          addIndex(a0: int): Vector;
          _asByteVectorRaw(): Byte512Vector;
          _asByteVectorRaw(): ByteVector;
          _asVectorRaw(laneType: LaneType): AbstractVector<any>;
          _bOp(v: Vector<float>, f: FloatVector$FBinOp): Float512Vector;
          _bOp(v: Vector<float>, m: VectorMask<float>, f: FloatVector$FBinOp): Float512Vector;
          _bOp(a0: Vector, a1: VectorMask, a2: FloatVector$FBinOp): FloatVector;
          _bOp(a0: Vector, a1: FloatVector$FBinOp): FloatVector;
          bitSize(): int;
          blend(v: Vector<float>, m: VectorMask<float>): Float512Vector;
          blend(a0: Vector, a1: VectorMask): FloatVector;
          blend(a0: Vector, a1: VectorMask): Vector;
          broadcast(e: float): Float512Vector;
          broadcast(e: long): Float512Vector;
          broadcast(a0: long): FloatVector;
          broadcast(a0: float): FloatVector;
          broadcast(a0: long): Vector;
          byteSize(): int;
          compare(op: VectorOperators$Comparison, v: Vector<float>): Float512Vector$Float512Mask;
          compare(op: VectorOperators$Comparison, s: float): Float512Vector$Float512Mask;
          compare(op: VectorOperators$Comparison, s: long): Float512Vector$Float512Mask;
          compare(op: VectorOperators$Comparison, v: Vector<float>, m: VectorMask<float>): Float512Vector$Float512Mask;
          compare(a0: VectorOperators$Comparison, a1: long): VectorMask;
          compare(a0: VectorOperators$Comparison, a1: float): VectorMask;
          compare(a0: VectorOperators$Comparison, a1: Vector): VectorMask;
          compare(a0: VectorOperators$Comparison, a1: Vector, a2: VectorMask): VectorMask;
          compress(m: VectorMask<float>): Float512Vector;
          compress(a0: VectorMask): FloatVector;
          compress(a0: VectorMask): Vector;
          convertShape<F>(conv: VectorOperators$Conversion<float,F>, rsp: VectorSpecies<F>, part: int): Vector<F>;
          elementSize(): int;
          elementType(): java.lang.Class<float>;
          expand(m: VectorMask<float>): Float512Vector;
          expand(a0: VectorMask): FloatVector;
          expand(a0: VectorMask): Vector;
          _fromArray0(a: float[], offset: int): FloatVector;
          _fromArray0(a: float[], offset: int, m: VectorMask<float>, offsetInRange: int): FloatVector;
          _fromArray0(a: float[], offset: int, indexMap: int[], mapOffset: int, m: VectorMask<float>): FloatVector;
          _fromMemorySegment0(ms: java.lang.foreign.MemorySegment, offset: long): FloatVector;
          _fromMemorySegment0(ms: java.lang.foreign.MemorySegment, offset: long, a2: VectorMask<float>, m: int): FloatVector;
          _fromMemorySegment0(a0: java.lang.foreign.MemorySegment, a1: long): AbstractVector;
          _intoArray0(a: float[], offset: int): void;
          _intoArray0(a: float[], offset: int, m: VectorMask<float>): void;
          _intoArray0(a: float[], offset: int, indexMap: int[], mapOffset: int, m: VectorMask<float>): void;
          _intoMemorySegment0(ms: java.lang.foreign.MemorySegment, offset: long, a2: VectorMask<float>): void;
          _iotaShuffle(): Float512Vector$Float512Shuffle;
          _iotaShuffle(start: int, step: int, wrap: boolean): Float512Vector$Float512Shuffle;
          _iotaShuffle(a0: int, a1: int, a2: boolean): AbstractShuffle;
          _iotaShuffle(): AbstractShuffle;
          lane(i: int): float;
          laneHelper(i: int): int;
          lanewise(op: VectorOperators$Unary): Float512Vector;
          lanewise(op: VectorOperators$Unary, m: VectorMask<float>): Float512Vector;
          lanewise(op: VectorOperators$Binary, v: Vector<float>): Float512Vector;
          lanewise(op: VectorOperators$Binary, v: Vector<float>, m: VectorMask<float>): Float512Vector;
          lanewise(op: VectorOperators$Ternary, v1: Vector<float>, v2: Vector<float>): Float512Vector;
          lanewise(op: VectorOperators$Ternary, v1: Vector<float>, v2: Vector<float>, m: VectorMask<float>): Float512Vector;
          lanewise(a0: VectorOperators$Ternary, a1: Vector, a2: Vector, a3: VectorMask): FloatVector;
          lanewise(a0: VectorOperators$Ternary, a1: Vector, a2: Vector): FloatVector;
          lanewise(a0: VectorOperators$Binary, a1: Vector, a2: VectorMask): FloatVector;
          lanewise(a0: VectorOperators$Binary, a1: Vector): FloatVector;
          lanewise(a0: VectorOperators$Unary, a1: VectorMask): FloatVector;
          lanewise(a0: VectorOperators$Unary): FloatVector;
          lanewise(a0: VectorOperators$Ternary, a1: Vector, a2: Vector, a3: VectorMask): Vector;
          lanewise(a0: VectorOperators$Ternary, a1: Vector, a2: Vector): Vector;
          lanewise(a0: VectorOperators$Binary, a1: Vector, a2: VectorMask): Vector;
          lanewise(a0: VectorOperators$Binary, a1: Vector): Vector;
          lanewise(a0: VectorOperators$Unary, a1: VectorMask): Vector;
          lanewise(a0: VectorOperators$Unary): Vector;
          length(): int;
          _maskFromArray(bits: boolean[]): Float512Vector$Float512Mask;
          _maskFromArray(a0: boolean[]): AbstractMask;
          _rOp(v: float, m: VectorMask<float>, f: FloatVector$FBinOp): float;
          rearrange(s: VectorShuffle<float>): Float512Vector;
          rearrange(shuffle: VectorShuffle<float>, m: VectorMask<float>): Float512Vector;
          rearrange(s: VectorShuffle<float>, v: Vector<float>): Float512Vector;
          rearrange(a0: VectorShuffle, a1: Vector): FloatVector;
          rearrange(a0: VectorShuffle, a1: VectorMask): FloatVector;
          rearrange(a0: VectorShuffle): FloatVector;
          rearrange(a0: VectorShuffle, a1: Vector): Vector;
          rearrange(a0: VectorShuffle, a1: VectorMask): Vector;
          rearrange(a0: VectorShuffle): Vector;
          reduceLanes(op: VectorOperators$Associative): float;
          reduceLanes(op: VectorOperators$Associative, m: VectorMask<float>): float;
          reduceLanesToLong(op: VectorOperators$Associative): long;
          reduceLanesToLong(op: VectorOperators$Associative, m: VectorMask<float>): long;
          reinterpretShape<F>(toSpecies: VectorSpecies<F>, part: int): Vector<F>;
          selectFrom(v: Vector<float>): Float512Vector;
          selectFrom(v: Vector<float>, m: VectorMask<float>): Float512Vector;
          selectFrom(a0: Vector, a1: VectorMask): FloatVector;
          selectFrom(a0: Vector): FloatVector;
          selectFrom(a0: Vector, a1: VectorMask): Vector;
          selectFrom(a0: Vector): Vector;
          shape(): VectorShape;
          _shuffleFromArray(indexes: int[], i: int): Float512Vector$Float512Shuffle;
          _shuffleFromArray(a0: int[], a1: int): AbstractShuffle;
          _shuffleFromBytes(reorder: byte[]): Float512Vector$Float512Shuffle;
          _shuffleFromBytes(a0: byte[]): AbstractShuffle;
          _shuffleFromOp(fn: java.util.function.IntUnaryOperator): Float512Vector$Float512Shuffle;
          _shuffleFromOp(a0: java.util.function.IntUnaryOperator): AbstractShuffle;
          slice(origin: int, v: Vector<float>): Float512Vector;
          slice(origin: int): Float512Vector;
          slice(a0: int): FloatVector;
          slice(a0: int, a1: Vector): FloatVector;
          slice(a0: int): AbstractVector;
          slice(a0: int, a1: Vector): AbstractVector;
          slice(a0: int): Vector;
          slice(a0: int, a1: Vector): Vector;
          _tOp(v1: Vector<float>, v2: Vector<float>, f: FloatVector$FTriOp): Float512Vector;
          _tOp(v1: Vector<float>, v2: Vector<float>, m: VectorMask<float>, f: FloatVector$FTriOp): Float512Vector;
          _tOp(a0: Vector, a1: Vector, a2: VectorMask, a3: FloatVector$FTriOp): FloatVector;
          _tOp(a0: Vector, a1: Vector, a2: FloatVector$FTriOp): FloatVector;
          test(op: VectorOperators$Test): Float512Vector$Float512Mask;
          test(op: VectorOperators$Test, m: VectorMask<float>): Float512Vector$Float512Mask;
          test(a0: VectorOperators$Test, a1: VectorMask): VectorMask;
          test(a0: VectorOperators$Test): VectorMask;
          toShuffle(): VectorShuffle<float>;
          _uOp(f: FloatVector$FUnOp): Float512Vector;
          _uOp(m: VectorMask<float>, f: FloatVector$FUnOp): Float512Vector;
          _uOp(a0: VectorMask, a1: FloatVector$FUnOp): FloatVector;
          _uOp(a0: FloatVector$FUnOp): FloatVector;
          unslice(origin: int, w: Vector<float>, part: int): Float512Vector;
          unslice(origin: int, w: Vector<float>, part: int, m: VectorMask<float>): Float512Vector;
          unslice(origin: int): Float512Vector;
          unslice(a0: int): FloatVector;
          unslice(a0: int, a1: Vector, a2: int, a3: VectorMask): FloatVector;
          unslice(a0: int, a1: Vector, a2: int): FloatVector;
          unslice(a0: int): Vector;
          unslice(a0: int, a1: Vector, a2: int, a3: VectorMask): Vector;
          unslice(a0: int, a1: Vector, a2: int): Vector;
          _vec(): float[];
          _vectorFactory(vec: float[]): Float512Vector;
          _vectorFactory(a0: float[]): FloatVector;
          vspecies(): FloatVector$FloatSpecies;
          vspecies(): AbstractSpecies;
          withLane(i: int, e: float): Float512Vector;
          withLane(a0: int, a1: float): FloatVector;
          withLaneHelper(i: int, e: float): Float512Vector;
        }
        interface Float512Vector extends CombineTypes<[_Float512Vector, jdk.incubator.vector.FloatVector]> {}
        interface _Float512Vector$Float512Mask$$static extends ClassLike {
          _maskAll(bit: boolean): Float512Vector$Float512Mask;
          _prepare(bits: boolean[], offset: int): boolean[];
          _prepare(val: boolean): boolean[];
          _ETYPE: java.lang.Class<float>;
          _FALSE_MASK: Float512Vector$Float512Mask;
          _TRUE_MASK: Float512Vector$Float512Mask;
          _VLENGTH: int;
          _new(bits: boolean[]): Float512Vector$Float512Mask;
          _new(bits: boolean[], offset: int): Float512Vector$Float512Mask;
          _new(val: boolean): Float512Vector$Float512Mask;
        }
        let Float512Vector$Float512Mask: _Float512Vector$Float512Mask$$static;
        interface _Float512Vector$Float512Mask {
          allTrue(): boolean;
          and(mask: VectorMask<float>): Float512Vector$Float512Mask;
          and(a0: VectorMask): VectorMask;
          anyTrue(): boolean;
          _bOp(m: VectorMask<float>, f: AbstractMask$MBinOp): Float512Vector$Float512Mask;
          _bOp(a0: VectorMask, a1: AbstractMask$MBinOp): AbstractMask;
          cast<E>(dsp: VectorSpecies<E>): VectorMask<E>;
          compress(): Float512Vector$Float512Mask;
          compress(): VectorMask;
          _defaultMaskCast<E>(dsp: AbstractSpecies<E>): VectorMask<E>;
          firstTrue(): int;
          _getBits(): boolean[];
          _indexPartiallyInUpperRange(offset: long, a1: long): Float512Vector$Float512Mask;
          _indexPartiallyInUpperRange(a0: long, a1: long): VectorMask;
          lastTrue(): int;
          not(): Float512Vector$Float512Mask;
          not(): VectorMask;
          or(mask: VectorMask<float>): Float512Vector$Float512Mask;
          or(a0: VectorMask): VectorMask;
          toLong(): long;
          toVector(): Float512Vector;
          toVector(): Vector;
          trueCount(): int;
          _uOp(f: AbstractMask$MUnOp): Float512Vector$Float512Mask;
          _uOp(a0: AbstractMask$MUnOp): AbstractMask;
          vspecies(): FloatVector$FloatSpecies;
          vspecies(): AbstractSpecies;
          xor(mask: VectorMask<float>): Float512Vector$Float512Mask;
          xor(a0: VectorMask): VectorMask;
        }
        interface Float512Vector$Float512Mask extends CombineTypes<[_Float512Vector$Float512Mask, AbstractMask<float>]> {}
        interface _Float512Vector$Float512Shuffle$$static extends ClassLike {
          _ETYPE: java.lang.Class<float>;
          _IOTA: Float512Vector$Float512Shuffle;
          _VLENGTH: int;
          _new(reorder: byte[]): Float512Vector$Float512Shuffle;
          new(reorder: int[]): Float512Vector$Float512Shuffle;
          new(reorder: int[], i: int): Float512Vector$Float512Shuffle;
          new(fn: java.util.function.IntUnaryOperator): Float512Vector$Float512Shuffle;
        }
        let Float512Vector$Float512Shuffle: _Float512Vector$Float512Shuffle$$static;
        interface _Float512Vector$Float512Shuffle {
          cast<F>(s: VectorSpecies<F>): VectorShuffle<F>;
          rearrange(shuffle: VectorShuffle<float>): Float512Vector$Float512Shuffle;
          rearrange(a0: VectorShuffle): VectorShuffle;
          toVector(): Float512Vector;
          toVector(): Vector;
          vspecies(): FloatVector$FloatSpecies;
          vspecies(): AbstractSpecies;
        }
        interface Float512Vector$Float512Shuffle extends CombineTypes<[_Float512Vector$Float512Shuffle, AbstractShuffle<float>]> {}
        interface _Float64Vector$$static extends ClassLike {
          _ETYPE: java.lang.Class<float>;
          _IOTA: Float64Vector;
          _VCLASS: java.lang.Class<Float64Vector>;
          _VLENGTH: int;
          _VSHAPE: VectorShape;
          _VSIZE: int;
          _VSPECIES: FloatVector$FloatSpecies;
          _ZERO: Float64Vector;
          _new(v: float[]): Float64Vector;
          _new(v: any): Float64Vector;
        }
        let Float64Vector: _Float64Vector$$static;
        interface _Float64Vector {
          addIndex(scale: int): Float64Vector;
          addIndex(a0: int): FloatVector;
          addIndex(a0: int): Vector;
          _asByteVectorRaw(): Byte64Vector;
          _asByteVectorRaw(): ByteVector;
          _asVectorRaw(laneType: LaneType): AbstractVector<any>;
          _bOp(v: Vector<float>, f: FloatVector$FBinOp): Float64Vector;
          _bOp(v: Vector<float>, m: VectorMask<float>, f: FloatVector$FBinOp): Float64Vector;
          _bOp(a0: Vector, a1: VectorMask, a2: FloatVector$FBinOp): FloatVector;
          _bOp(a0: Vector, a1: FloatVector$FBinOp): FloatVector;
          bitSize(): int;
          blend(v: Vector<float>, m: VectorMask<float>): Float64Vector;
          blend(a0: Vector, a1: VectorMask): FloatVector;
          blend(a0: Vector, a1: VectorMask): Vector;
          broadcast(e: float): Float64Vector;
          broadcast(e: long): Float64Vector;
          broadcast(a0: long): FloatVector;
          broadcast(a0: float): FloatVector;
          broadcast(a0: long): Vector;
          byteSize(): int;
          compare(op: VectorOperators$Comparison, v: Vector<float>): Float64Vector$Float64Mask;
          compare(op: VectorOperators$Comparison, s: float): Float64Vector$Float64Mask;
          compare(op: VectorOperators$Comparison, s: long): Float64Vector$Float64Mask;
          compare(op: VectorOperators$Comparison, v: Vector<float>, m: VectorMask<float>): Float64Vector$Float64Mask;
          compare(a0: VectorOperators$Comparison, a1: long): VectorMask;
          compare(a0: VectorOperators$Comparison, a1: float): VectorMask;
          compare(a0: VectorOperators$Comparison, a1: Vector): VectorMask;
          compare(a0: VectorOperators$Comparison, a1: Vector, a2: VectorMask): VectorMask;
          compress(m: VectorMask<float>): Float64Vector;
          compress(a0: VectorMask): FloatVector;
          compress(a0: VectorMask): Vector;
          convertShape<F>(conv: VectorOperators$Conversion<float,F>, rsp: VectorSpecies<F>, part: int): Vector<F>;
          elementSize(): int;
          elementType(): java.lang.Class<float>;
          expand(m: VectorMask<float>): Float64Vector;
          expand(a0: VectorMask): FloatVector;
          expand(a0: VectorMask): Vector;
          _fromArray0(a: float[], offset: int): FloatVector;
          _fromArray0(a: float[], offset: int, m: VectorMask<float>, offsetInRange: int): FloatVector;
          _fromArray0(a: float[], offset: int, indexMap: int[], mapOffset: int, m: VectorMask<float>): FloatVector;
          _fromMemorySegment0(ms: java.lang.foreign.MemorySegment, offset: long): FloatVector;
          _fromMemorySegment0(ms: java.lang.foreign.MemorySegment, offset: long, a2: VectorMask<float>, m: int): FloatVector;
          _fromMemorySegment0(a0: java.lang.foreign.MemorySegment, a1: long): AbstractVector;
          _intoArray0(a: float[], offset: int): void;
          _intoArray0(a: float[], offset: int, m: VectorMask<float>): void;
          _intoArray0(a: float[], offset: int, indexMap: int[], mapOffset: int, m: VectorMask<float>): void;
          _intoMemorySegment0(ms: java.lang.foreign.MemorySegment, offset: long, a2: VectorMask<float>): void;
          _iotaShuffle(): Float64Vector$Float64Shuffle;
          _iotaShuffle(start: int, step: int, wrap: boolean): Float64Vector$Float64Shuffle;
          _iotaShuffle(a0: int, a1: int, a2: boolean): AbstractShuffle;
          _iotaShuffle(): AbstractShuffle;
          lane(i: int): float;
          laneHelper(i: int): int;
          lanewise(op: VectorOperators$Unary): Float64Vector;
          lanewise(op: VectorOperators$Unary, m: VectorMask<float>): Float64Vector;
          lanewise(op: VectorOperators$Binary, v: Vector<float>): Float64Vector;
          lanewise(op: VectorOperators$Binary, v: Vector<float>, m: VectorMask<float>): Float64Vector;
          lanewise(op: VectorOperators$Ternary, v1: Vector<float>, v2: Vector<float>): Float64Vector;
          lanewise(op: VectorOperators$Ternary, v1: Vector<float>, v2: Vector<float>, m: VectorMask<float>): Float64Vector;
          lanewise(a0: VectorOperators$Ternary, a1: Vector, a2: Vector, a3: VectorMask): FloatVector;
          lanewise(a0: VectorOperators$Ternary, a1: Vector, a2: Vector): FloatVector;
          lanewise(a0: VectorOperators$Binary, a1: Vector, a2: VectorMask): FloatVector;
          lanewise(a0: VectorOperators$Binary, a1: Vector): FloatVector;
          lanewise(a0: VectorOperators$Unary, a1: VectorMask): FloatVector;
          lanewise(a0: VectorOperators$Unary): FloatVector;
          lanewise(a0: VectorOperators$Ternary, a1: Vector, a2: Vector, a3: VectorMask): Vector;
          lanewise(a0: VectorOperators$Ternary, a1: Vector, a2: Vector): Vector;
          lanewise(a0: VectorOperators$Binary, a1: Vector, a2: VectorMask): Vector;
          lanewise(a0: VectorOperators$Binary, a1: Vector): Vector;
          lanewise(a0: VectorOperators$Unary, a1: VectorMask): Vector;
          lanewise(a0: VectorOperators$Unary): Vector;
          length(): int;
          _maskFromArray(bits: boolean[]): Float64Vector$Float64Mask;
          _maskFromArray(a0: boolean[]): AbstractMask;
          _rOp(v: float, m: VectorMask<float>, f: FloatVector$FBinOp): float;
          rearrange(s: VectorShuffle<float>): Float64Vector;
          rearrange(shuffle: VectorShuffle<float>, m: VectorMask<float>): Float64Vector;
          rearrange(s: VectorShuffle<float>, v: Vector<float>): Float64Vector;
          rearrange(a0: VectorShuffle, a1: Vector): FloatVector;
          rearrange(a0: VectorShuffle, a1: VectorMask): FloatVector;
          rearrange(a0: VectorShuffle): FloatVector;
          rearrange(a0: VectorShuffle, a1: Vector): Vector;
          rearrange(a0: VectorShuffle, a1: VectorMask): Vector;
          rearrange(a0: VectorShuffle): Vector;
          reduceLanes(op: VectorOperators$Associative): float;
          reduceLanes(op: VectorOperators$Associative, m: VectorMask<float>): float;
          reduceLanesToLong(op: VectorOperators$Associative): long;
          reduceLanesToLong(op: VectorOperators$Associative, m: VectorMask<float>): long;
          reinterpretShape<F>(toSpecies: VectorSpecies<F>, part: int): Vector<F>;
          selectFrom(v: Vector<float>): Float64Vector;
          selectFrom(v: Vector<float>, m: VectorMask<float>): Float64Vector;
          selectFrom(a0: Vector, a1: VectorMask): FloatVector;
          selectFrom(a0: Vector): FloatVector;
          selectFrom(a0: Vector, a1: VectorMask): Vector;
          selectFrom(a0: Vector): Vector;
          shape(): VectorShape;
          _shuffleFromArray(indexes: int[], i: int): Float64Vector$Float64Shuffle;
          _shuffleFromArray(a0: int[], a1: int): AbstractShuffle;
          _shuffleFromBytes(reorder: byte[]): Float64Vector$Float64Shuffle;
          _shuffleFromBytes(a0: byte[]): AbstractShuffle;
          _shuffleFromOp(fn: java.util.function.IntUnaryOperator): Float64Vector$Float64Shuffle;
          _shuffleFromOp(a0: java.util.function.IntUnaryOperator): AbstractShuffle;
          slice(origin: int, v: Vector<float>): Float64Vector;
          slice(origin: int): Float64Vector;
          slice(a0: int): FloatVector;
          slice(a0: int, a1: Vector): FloatVector;
          slice(a0: int): AbstractVector;
          slice(a0: int, a1: Vector): AbstractVector;
          slice(a0: int): Vector;
          slice(a0: int, a1: Vector): Vector;
          _tOp(v1: Vector<float>, v2: Vector<float>, f: FloatVector$FTriOp): Float64Vector;
          _tOp(v1: Vector<float>, v2: Vector<float>, m: VectorMask<float>, f: FloatVector$FTriOp): Float64Vector;
          _tOp(a0: Vector, a1: Vector, a2: VectorMask, a3: FloatVector$FTriOp): FloatVector;
          _tOp(a0: Vector, a1: Vector, a2: FloatVector$FTriOp): FloatVector;
          test(op: VectorOperators$Test): Float64Vector$Float64Mask;
          test(op: VectorOperators$Test, m: VectorMask<float>): Float64Vector$Float64Mask;
          test(a0: VectorOperators$Test, a1: VectorMask): VectorMask;
          test(a0: VectorOperators$Test): VectorMask;
          toShuffle(): VectorShuffle<float>;
          _uOp(f: FloatVector$FUnOp): Float64Vector;
          _uOp(m: VectorMask<float>, f: FloatVector$FUnOp): Float64Vector;
          _uOp(a0: VectorMask, a1: FloatVector$FUnOp): FloatVector;
          _uOp(a0: FloatVector$FUnOp): FloatVector;
          unslice(origin: int, w: Vector<float>, part: int): Float64Vector;
          unslice(origin: int, w: Vector<float>, part: int, m: VectorMask<float>): Float64Vector;
          unslice(origin: int): Float64Vector;
          unslice(a0: int): FloatVector;
          unslice(a0: int, a1: Vector, a2: int, a3: VectorMask): FloatVector;
          unslice(a0: int, a1: Vector, a2: int): FloatVector;
          unslice(a0: int): Vector;
          unslice(a0: int, a1: Vector, a2: int, a3: VectorMask): Vector;
          unslice(a0: int, a1: Vector, a2: int): Vector;
          _vec(): float[];
          _vectorFactory(vec: float[]): Float64Vector;
          _vectorFactory(a0: float[]): FloatVector;
          vspecies(): FloatVector$FloatSpecies;
          vspecies(): AbstractSpecies;
          withLane(i: int, e: float): Float64Vector;
          withLane(a0: int, a1: float): FloatVector;
          withLaneHelper(i: int, e: float): Float64Vector;
        }
        interface Float64Vector extends CombineTypes<[_Float64Vector, jdk.incubator.vector.FloatVector]> {}
        interface _Float64Vector$Float64Mask$$static extends ClassLike {
          _maskAll(bit: boolean): Float64Vector$Float64Mask;
          _prepare(bits: boolean[], offset: int): boolean[];
          _prepare(val: boolean): boolean[];
          _ETYPE: java.lang.Class<float>;
          _FALSE_MASK: Float64Vector$Float64Mask;
          _TRUE_MASK: Float64Vector$Float64Mask;
          _VLENGTH: int;
          _new(bits: boolean[]): Float64Vector$Float64Mask;
          _new(bits: boolean[], offset: int): Float64Vector$Float64Mask;
          _new(val: boolean): Float64Vector$Float64Mask;
        }
        let Float64Vector$Float64Mask: _Float64Vector$Float64Mask$$static;
        interface _Float64Vector$Float64Mask {
          allTrue(): boolean;
          and(mask: VectorMask<float>): Float64Vector$Float64Mask;
          and(a0: VectorMask): VectorMask;
          anyTrue(): boolean;
          _bOp(m: VectorMask<float>, f: AbstractMask$MBinOp): Float64Vector$Float64Mask;
          _bOp(a0: VectorMask, a1: AbstractMask$MBinOp): AbstractMask;
          cast<E>(dsp: VectorSpecies<E>): VectorMask<E>;
          compress(): Float64Vector$Float64Mask;
          compress(): VectorMask;
          _defaultMaskCast<E>(dsp: AbstractSpecies<E>): VectorMask<E>;
          firstTrue(): int;
          _getBits(): boolean[];
          _indexPartiallyInUpperRange(offset: long, a1: long): Float64Vector$Float64Mask;
          _indexPartiallyInUpperRange(a0: long, a1: long): VectorMask;
          lastTrue(): int;
          not(): Float64Vector$Float64Mask;
          not(): VectorMask;
          or(mask: VectorMask<float>): Float64Vector$Float64Mask;
          or(a0: VectorMask): VectorMask;
          toLong(): long;
          toVector(): Float64Vector;
          toVector(): Vector;
          trueCount(): int;
          _uOp(f: AbstractMask$MUnOp): Float64Vector$Float64Mask;
          _uOp(a0: AbstractMask$MUnOp): AbstractMask;
          vspecies(): FloatVector$FloatSpecies;
          vspecies(): AbstractSpecies;
          xor(mask: VectorMask<float>): Float64Vector$Float64Mask;
          xor(a0: VectorMask): VectorMask;
        }
        interface Float64Vector$Float64Mask extends CombineTypes<[_Float64Vector$Float64Mask, AbstractMask<float>]> {}
        interface _Float64Vector$Float64Shuffle$$static extends ClassLike {
          _ETYPE: java.lang.Class<float>;
          _IOTA: Float64Vector$Float64Shuffle;
          _VLENGTH: int;
          _new(reorder: byte[]): Float64Vector$Float64Shuffle;
          new(reorder: int[]): Float64Vector$Float64Shuffle;
          new(reorder: int[], i: int): Float64Vector$Float64Shuffle;
          new(fn: java.util.function.IntUnaryOperator): Float64Vector$Float64Shuffle;
        }
        let Float64Vector$Float64Shuffle: _Float64Vector$Float64Shuffle$$static;
        interface _Float64Vector$Float64Shuffle {
          cast<F>(s: VectorSpecies<F>): VectorShuffle<F>;
          rearrange(shuffle: VectorShuffle<float>): Float64Vector$Float64Shuffle;
          rearrange(a0: VectorShuffle): VectorShuffle;
          toVector(): Float64Vector;
          toVector(): Vector;
          vspecies(): FloatVector$FloatSpecies;
          vspecies(): AbstractSpecies;
        }
        interface Float64Vector$Float64Shuffle extends CombineTypes<[_Float64Vector$Float64Shuffle, AbstractShuffle<float>]> {}
        interface _FloatMaxVector$$static extends ClassLike {
          _ETYPE: java.lang.Class<float>;
          _IOTA: FloatMaxVector;
          _VCLASS: java.lang.Class<FloatMaxVector>;
          _VLENGTH: int;
          _VSHAPE: VectorShape;
          _VSIZE: int;
          _VSPECIES: FloatVector$FloatSpecies;
          _ZERO: FloatMaxVector;
          _new(v: float[]): FloatMaxVector;
          _new(v: any): FloatMaxVector;
        }
        let FloatMaxVector: _FloatMaxVector$$static;
        interface _FloatMaxVector {
          addIndex(scale: int): FloatMaxVector;
          addIndex(a0: int): FloatVector;
          addIndex(a0: int): Vector;
          _asByteVectorRaw(): ByteMaxVector;
          _asByteVectorRaw(): ByteVector;
          _asVectorRaw(laneType: LaneType): AbstractVector<any>;
          _bOp(v: Vector<float>, f: FloatVector$FBinOp): FloatMaxVector;
          _bOp(v: Vector<float>, m: VectorMask<float>, f: FloatVector$FBinOp): FloatMaxVector;
          _bOp(a0: Vector, a1: VectorMask, a2: FloatVector$FBinOp): FloatVector;
          _bOp(a0: Vector, a1: FloatVector$FBinOp): FloatVector;
          bitSize(): int;
          blend(v: Vector<float>, m: VectorMask<float>): FloatMaxVector;
          blend(a0: Vector, a1: VectorMask): FloatVector;
          blend(a0: Vector, a1: VectorMask): Vector;
          broadcast(e: float): FloatMaxVector;
          broadcast(e: long): FloatMaxVector;
          broadcast(a0: long): FloatVector;
          broadcast(a0: float): FloatVector;
          broadcast(a0: long): Vector;
          byteSize(): int;
          compare(op: VectorOperators$Comparison, v: Vector<float>): FloatMaxVector$FloatMaxMask;
          compare(op: VectorOperators$Comparison, s: float): FloatMaxVector$FloatMaxMask;
          compare(op: VectorOperators$Comparison, s: long): FloatMaxVector$FloatMaxMask;
          compare(op: VectorOperators$Comparison, v: Vector<float>, m: VectorMask<float>): FloatMaxVector$FloatMaxMask;
          compare(a0: VectorOperators$Comparison, a1: long): VectorMask;
          compare(a0: VectorOperators$Comparison, a1: float): VectorMask;
          compare(a0: VectorOperators$Comparison, a1: Vector): VectorMask;
          compare(a0: VectorOperators$Comparison, a1: Vector, a2: VectorMask): VectorMask;
          compress(m: VectorMask<float>): FloatMaxVector;
          compress(a0: VectorMask): FloatVector;
          compress(a0: VectorMask): Vector;
          convertShape<F>(conv: VectorOperators$Conversion<float,F>, rsp: VectorSpecies<F>, part: int): Vector<F>;
          elementSize(): int;
          elementType(): java.lang.Class<float>;
          expand(m: VectorMask<float>): FloatMaxVector;
          expand(a0: VectorMask): FloatVector;
          expand(a0: VectorMask): Vector;
          _fromArray0(a: float[], offset: int): FloatVector;
          _fromArray0(a: float[], offset: int, m: VectorMask<float>, offsetInRange: int): FloatVector;
          _fromArray0(a: float[], offset: int, indexMap: int[], mapOffset: int, m: VectorMask<float>): FloatVector;
          _fromMemorySegment0(ms: java.lang.foreign.MemorySegment, offset: long): FloatVector;
          _fromMemorySegment0(ms: java.lang.foreign.MemorySegment, offset: long, a2: VectorMask<float>, m: int): FloatVector;
          _fromMemorySegment0(a0: java.lang.foreign.MemorySegment, a1: long): AbstractVector;
          _intoArray0(a: float[], offset: int): void;
          _intoArray0(a: float[], offset: int, m: VectorMask<float>): void;
          _intoArray0(a: float[], offset: int, indexMap: int[], mapOffset: int, m: VectorMask<float>): void;
          _intoMemorySegment0(ms: java.lang.foreign.MemorySegment, offset: long, a2: VectorMask<float>): void;
          _iotaShuffle(): FloatMaxVector$FloatMaxShuffle;
          _iotaShuffle(start: int, step: int, wrap: boolean): FloatMaxVector$FloatMaxShuffle;
          _iotaShuffle(a0: int, a1: int, a2: boolean): AbstractShuffle;
          _iotaShuffle(): AbstractShuffle;
          lane(i: int): float;
          laneHelper(i: int): int;
          lanewise(op: VectorOperators$Unary): FloatMaxVector;
          lanewise(op: VectorOperators$Unary, m: VectorMask<float>): FloatMaxVector;
          lanewise(op: VectorOperators$Binary, v: Vector<float>): FloatMaxVector;
          lanewise(op: VectorOperators$Binary, v: Vector<float>, m: VectorMask<float>): FloatMaxVector;
          lanewise(op: VectorOperators$Ternary, v1: Vector<float>, v2: Vector<float>): FloatMaxVector;
          lanewise(op: VectorOperators$Ternary, v1: Vector<float>, v2: Vector<float>, m: VectorMask<float>): FloatMaxVector;
          lanewise(a0: VectorOperators$Ternary, a1: Vector, a2: Vector, a3: VectorMask): FloatVector;
          lanewise(a0: VectorOperators$Ternary, a1: Vector, a2: Vector): FloatVector;
          lanewise(a0: VectorOperators$Binary, a1: Vector, a2: VectorMask): FloatVector;
          lanewise(a0: VectorOperators$Binary, a1: Vector): FloatVector;
          lanewise(a0: VectorOperators$Unary, a1: VectorMask): FloatVector;
          lanewise(a0: VectorOperators$Unary): FloatVector;
          lanewise(a0: VectorOperators$Ternary, a1: Vector, a2: Vector, a3: VectorMask): Vector;
          lanewise(a0: VectorOperators$Ternary, a1: Vector, a2: Vector): Vector;
          lanewise(a0: VectorOperators$Binary, a1: Vector, a2: VectorMask): Vector;
          lanewise(a0: VectorOperators$Binary, a1: Vector): Vector;
          lanewise(a0: VectorOperators$Unary, a1: VectorMask): Vector;
          lanewise(a0: VectorOperators$Unary): Vector;
          length(): int;
          _maskFromArray(bits: boolean[]): FloatMaxVector$FloatMaxMask;
          _maskFromArray(a0: boolean[]): AbstractMask;
          _rOp(v: float, m: VectorMask<float>, f: FloatVector$FBinOp): float;
          rearrange(s: VectorShuffle<float>): FloatMaxVector;
          rearrange(shuffle: VectorShuffle<float>, m: VectorMask<float>): FloatMaxVector;
          rearrange(s: VectorShuffle<float>, v: Vector<float>): FloatMaxVector;
          rearrange(a0: VectorShuffle, a1: Vector): FloatVector;
          rearrange(a0: VectorShuffle, a1: VectorMask): FloatVector;
          rearrange(a0: VectorShuffle): FloatVector;
          rearrange(a0: VectorShuffle, a1: Vector): Vector;
          rearrange(a0: VectorShuffle, a1: VectorMask): Vector;
          rearrange(a0: VectorShuffle): Vector;
          reduceLanes(op: VectorOperators$Associative): float;
          reduceLanes(op: VectorOperators$Associative, m: VectorMask<float>): float;
          reduceLanesToLong(op: VectorOperators$Associative): long;
          reduceLanesToLong(op: VectorOperators$Associative, m: VectorMask<float>): long;
          reinterpretShape<F>(toSpecies: VectorSpecies<F>, part: int): Vector<F>;
          selectFrom(v: Vector<float>): FloatMaxVector;
          selectFrom(v: Vector<float>, m: VectorMask<float>): FloatMaxVector;
          selectFrom(a0: Vector, a1: VectorMask): FloatVector;
          selectFrom(a0: Vector): FloatVector;
          selectFrom(a0: Vector, a1: VectorMask): Vector;
          selectFrom(a0: Vector): Vector;
          shape(): VectorShape;
          _shuffleFromArray(indexes: int[], i: int): FloatMaxVector$FloatMaxShuffle;
          _shuffleFromArray(a0: int[], a1: int): AbstractShuffle;
          _shuffleFromBytes(reorder: byte[]): FloatMaxVector$FloatMaxShuffle;
          _shuffleFromBytes(a0: byte[]): AbstractShuffle;
          _shuffleFromOp(fn: java.util.function.IntUnaryOperator): FloatMaxVector$FloatMaxShuffle;
          _shuffleFromOp(a0: java.util.function.IntUnaryOperator): AbstractShuffle;
          slice(origin: int, v: Vector<float>): FloatMaxVector;
          slice(origin: int): FloatMaxVector;
          slice(a0: int): FloatVector;
          slice(a0: int, a1: Vector): FloatVector;
          slice(a0: int): AbstractVector;
          slice(a0: int, a1: Vector): AbstractVector;
          slice(a0: int): Vector;
          slice(a0: int, a1: Vector): Vector;
          _tOp(v1: Vector<float>, v2: Vector<float>, f: FloatVector$FTriOp): FloatMaxVector;
          _tOp(v1: Vector<float>, v2: Vector<float>, m: VectorMask<float>, f: FloatVector$FTriOp): FloatMaxVector;
          _tOp(a0: Vector, a1: Vector, a2: VectorMask, a3: FloatVector$FTriOp): FloatVector;
          _tOp(a0: Vector, a1: Vector, a2: FloatVector$FTriOp): FloatVector;
          test(op: VectorOperators$Test): FloatMaxVector$FloatMaxMask;
          test(op: VectorOperators$Test, m: VectorMask<float>): FloatMaxVector$FloatMaxMask;
          test(a0: VectorOperators$Test, a1: VectorMask): VectorMask;
          test(a0: VectorOperators$Test): VectorMask;
          toShuffle(): VectorShuffle<float>;
          _uOp(f: FloatVector$FUnOp): FloatMaxVector;
          _uOp(m: VectorMask<float>, f: FloatVector$FUnOp): FloatMaxVector;
          _uOp(a0: VectorMask, a1: FloatVector$FUnOp): FloatVector;
          _uOp(a0: FloatVector$FUnOp): FloatVector;
          unslice(origin: int, w: Vector<float>, part: int): FloatMaxVector;
          unslice(origin: int, w: Vector<float>, part: int, m: VectorMask<float>): FloatMaxVector;
          unslice(origin: int): FloatMaxVector;
          unslice(a0: int): FloatVector;
          unslice(a0: int, a1: Vector, a2: int, a3: VectorMask): FloatVector;
          unslice(a0: int, a1: Vector, a2: int): FloatVector;
          unslice(a0: int): Vector;
          unslice(a0: int, a1: Vector, a2: int, a3: VectorMask): Vector;
          unslice(a0: int, a1: Vector, a2: int): Vector;
          _vec(): float[];
          _vectorFactory(vec: float[]): FloatMaxVector;
          _vectorFactory(a0: float[]): FloatVector;
          vspecies(): FloatVector$FloatSpecies;
          vspecies(): AbstractSpecies;
          withLane(i: int, e: float): FloatMaxVector;
          withLane(a0: int, a1: float): FloatVector;
          withLaneHelper(i: int, e: float): FloatMaxVector;
        }
        interface FloatMaxVector extends CombineTypes<[_FloatMaxVector, jdk.incubator.vector.FloatVector]> {}
        interface _FloatMaxVector$FloatMaxMask$$static extends ClassLike {
          _maskAll(bit: boolean): FloatMaxVector$FloatMaxMask;
          _prepare(bits: boolean[], offset: int): boolean[];
          _prepare(val: boolean): boolean[];
          _ETYPE: java.lang.Class<float>;
          _FALSE_MASK: FloatMaxVector$FloatMaxMask;
          _TRUE_MASK: FloatMaxVector$FloatMaxMask;
          _VLENGTH: int;
          _new(bits: boolean[]): FloatMaxVector$FloatMaxMask;
          _new(bits: boolean[], offset: int): FloatMaxVector$FloatMaxMask;
          _new(val: boolean): FloatMaxVector$FloatMaxMask;
        }
        let FloatMaxVector$FloatMaxMask: _FloatMaxVector$FloatMaxMask$$static;
        interface _FloatMaxVector$FloatMaxMask {
          allTrue(): boolean;
          and(mask: VectorMask<float>): FloatMaxVector$FloatMaxMask;
          and(a0: VectorMask): VectorMask;
          anyTrue(): boolean;
          _bOp(m: VectorMask<float>, f: AbstractMask$MBinOp): FloatMaxVector$FloatMaxMask;
          _bOp(a0: VectorMask, a1: AbstractMask$MBinOp): AbstractMask;
          cast<E>(dsp: VectorSpecies<E>): VectorMask<E>;
          compress(): FloatMaxVector$FloatMaxMask;
          compress(): VectorMask;
          _defaultMaskCast<E>(dsp: AbstractSpecies<E>): VectorMask<E>;
          firstTrue(): int;
          _getBits(): boolean[];
          _indexPartiallyInUpperRange(offset: long, a1: long): FloatMaxVector$FloatMaxMask;
          _indexPartiallyInUpperRange(a0: long, a1: long): VectorMask;
          lastTrue(): int;
          not(): FloatMaxVector$FloatMaxMask;
          not(): VectorMask;
          or(mask: VectorMask<float>): FloatMaxVector$FloatMaxMask;
          or(a0: VectorMask): VectorMask;
          toLong(): long;
          toVector(): FloatMaxVector;
          toVector(): Vector;
          trueCount(): int;
          _uOp(f: AbstractMask$MUnOp): FloatMaxVector$FloatMaxMask;
          _uOp(a0: AbstractMask$MUnOp): AbstractMask;
          vspecies(): FloatVector$FloatSpecies;
          vspecies(): AbstractSpecies;
          xor(mask: VectorMask<float>): FloatMaxVector$FloatMaxMask;
          xor(a0: VectorMask): VectorMask;
        }
        interface FloatMaxVector$FloatMaxMask extends CombineTypes<[_FloatMaxVector$FloatMaxMask, AbstractMask<float>]> {}
        interface _FloatMaxVector$FloatMaxShuffle$$static extends ClassLike {
          _ETYPE: java.lang.Class<float>;
          _IOTA: FloatMaxVector$FloatMaxShuffle;
          _VLENGTH: int;
          _new(reorder: byte[]): FloatMaxVector$FloatMaxShuffle;
          new(reorder: int[]): FloatMaxVector$FloatMaxShuffle;
          new(reorder: int[], i: int): FloatMaxVector$FloatMaxShuffle;
          new(fn: java.util.function.IntUnaryOperator): FloatMaxVector$FloatMaxShuffle;
        }
        let FloatMaxVector$FloatMaxShuffle: _FloatMaxVector$FloatMaxShuffle$$static;
        interface _FloatMaxVector$FloatMaxShuffle {
          cast<F>(s: VectorSpecies<F>): VectorShuffle<F>;
          rearrange(shuffle: VectorShuffle<float>): FloatMaxVector$FloatMaxShuffle;
          rearrange(a0: VectorShuffle): VectorShuffle;
          toVector(): FloatMaxVector;
          toVector(): Vector;
          vspecies(): FloatVector$FloatSpecies;
          vspecies(): AbstractSpecies;
        }
        interface FloatMaxVector$FloatMaxShuffle extends CombineTypes<[_FloatMaxVector$FloatMaxShuffle, AbstractShuffle<float>]> {}
        interface _FloatVector$$static extends ClassLike {
          _arrayAddress(a: float[], index: int): long;
          _binaryOperations(opc_: int): jdk.internal.vm.vector.VectorSupport$BinaryOperation<FloatVector,VectorMask<float>>;
          broadcast(species: VectorSpecies<float>, e: float): FloatVector;
          broadcast(species: VectorSpecies<float>, e: long): FloatVector;
          _byteArrayAddress(a: byte[], index: int): long;
          _checkMaskFromIndexSize(offset: int, vsp: FloatVector$FloatSpecies, m: VectorMask<float>, scale: int, limit: int): void;
          _checkMaskFromIndexSize(offset: long, a1: FloatVector$FloatSpecies, vsp: VectorMask<float>, m: int, scale: long): void;
          _compareWithOp(cond: int, a: float, b: float): boolean;
          _compressHelper(v: Vector<float>, m: VectorMask<float>): FloatVector;
          _expandHelper(v: Vector<float>, m: VectorMask<float>): FloatVector;
          fromArray(species: VectorSpecies<float>, a: float[], offset: int): FloatVector;
          fromArray(species: VectorSpecies<float>, a: float[], offset: int, m: VectorMask<float>): FloatVector;
          fromArray(species: VectorSpecies<float>, a: float[], offset: int, indexMap: int[], mapOffset: int): FloatVector;
          fromArray(species: VectorSpecies<float>, a: float[], offset: int, indexMap: int[], mapOffset: int, m: VectorMask<float>): FloatVector;
          _fromBits(bits: long): float;
          fromMemorySegment(species: VectorSpecies<float>, ms: java.lang.foreign.MemorySegment, offset: long, a3: java.nio.ByteOrder): FloatVector;
          fromMemorySegment(species: VectorSpecies<float>, ms: java.lang.foreign.MemorySegment, offset: long, a3: java.nio.ByteOrder, bo: VectorMask<float>): FloatVector;
          _memorySegmentGet(ms: java.lang.foreign.MemorySegment, o: long, a2: int): float;
          _memorySegmentSet(ms: java.lang.foreign.MemorySegment, o: long, a2: int, i: float): void;
          _opCode(op: VectorOperators$Operator): int;
          _opCode(op: VectorOperators$Operator, requireKind: int): int;
          _opKind(op: VectorOperators$Operator, bit: int): boolean;
          _reductionOperations(opc_: int): jdk.internal.vm.vector.VectorSupport$ReductionOperation<FloatVector,VectorMask<float>>;
          _species(s: VectorShape): FloatVector$FloatSpecies;
          _ternaryOperations(opc_: int): jdk.internal.vm.vector.VectorSupport$TernaryOperation<FloatVector,VectorMask<float>>;
          _toBits(e: float): long;
          _unaryOperations(opc_: int): jdk.internal.vm.vector.VectorSupport$UnaryOperation<FloatVector,VectorMask<float>>;
          zero(species: VectorSpecies<float>): FloatVector;
          _ARRAY_BASE: long;
          _ARRAY_SHIFT: int;
          _BIN_IMPL: VectorOperators$ImplCache<VectorOperators$Binary,jdk.internal.vm.vector.VectorSupport$BinaryOperation<FloatVector,VectorMask<float>>>;
          _ELEMENT_LAYOUT: java.lang.foreign.ValueLayout$OfFloat;
          _FORBID_OPCODE_KIND: int;
          _MAX_OR_INF: float;
          _MIN_OR_INF: float;
          _REDUCE_IMPL: VectorOperators$ImplCache<VectorOperators$Associative,jdk.internal.vm.vector.VectorSupport$ReductionOperation<FloatVector,VectorMask<float>>>;
          readonly SPECIES_128: VectorSpecies<float>;
          readonly SPECIES_256: VectorSpecies<float>;
          readonly SPECIES_512: VectorSpecies<float>;
          readonly SPECIES_64: VectorSpecies<float>;
          readonly SPECIES_MAX: VectorSpecies<float>;
          readonly SPECIES_PREFERRED: VectorSpecies<float>;
          _TERN_IMPL: VectorOperators$ImplCache<VectorOperators$Ternary,jdk.internal.vm.vector.VectorSupport$TernaryOperation<FloatVector,VectorMask<float>>>;
          _UN_IMPL: VectorOperators$ImplCache<VectorOperators$Unary,jdk.internal.vm.vector.VectorSupport$UnaryOperation<FloatVector,VectorMask<float>>>;
          _new(vec: float[]): FloatVector;
        }
        let FloatVector: _FloatVector$$static;
        interface _FloatVector {
          abs(): FloatVector;
          abs(): Vector;
          add(v: Vector<float>): FloatVector;
          add(e: float): FloatVector;
          add(v: Vector<float>, m: VectorMask<float>): FloatVector;
          add(e: float, m: VectorMask<float>): FloatVector;
          add(a0: Vector, a1: VectorMask): Vector;
          add(a0: Vector): Vector;
          addIndex(a0: int): FloatVector;
          addIndex(a0: int): Vector;
          _addIndexTemplate(scale: int): FloatVector;
          _bOp(a0: Vector<float>, a1: FloatVector$FBinOp): FloatVector;
          _bOp(a0: Vector<float>, a1: VectorMask<float>, a2: FloatVector$FBinOp): FloatVector;
          _bOpTemplate(o: Vector<float>, f: FloatVector$FBinOp): FloatVector;
          _bOpTemplate(o: Vector<float>, m: VectorMask<float>, f: FloatVector$FBinOp): FloatVector;
          _bTest(cond: int, o: Vector<float>, f: FloatVector$FBinTest): AbstractMask<float>;
          blend(a0: Vector<float>, a1: VectorMask<float>): FloatVector;
          blend(e: float, m: VectorMask<float>): FloatVector;
          blend(e: long, a1: VectorMask<float>): FloatVector;
          blend(a0: long, a1: VectorMask): Vector;
          blend(a0: Vector, a1: VectorMask): Vector;
          _blendTemplate<M>(maskType: java.lang.Class<M>, v: FloatVector, m: M): FloatVector;
          broadcast(a0: float): FloatVector;
          broadcast(a0: long): FloatVector;
          broadcast(a0: long): Vector;
          _broadcastTemplate(e: float): FloatVector;
          _broadcastTemplate(e: long): FloatVector;
          compare(a0: VectorOperators$Comparison, a1: Vector<float>): VectorMask<float>;
          compare(a0: VectorOperators$Comparison, a1: float): VectorMask<float>;
          compare(op: VectorOperators$Comparison, e: float, m: VectorMask<float>): VectorMask<float>;
          compare(a0: VectorOperators$Comparison, a1: long): VectorMask<float>;
          compare(op: VectorOperators$Comparison, e: long, a2: VectorMask<float>): VectorMask<float>;
          _compareTemplate<M>(maskType: java.lang.Class<M>, op: VectorOperators$Comparison, v: Vector<float>): M;
          _compareTemplate<M>(maskType: java.lang.Class<M>, op: VectorOperators$Comparison, v: Vector<float>, m: M): M;
          _compareTemplate<M>(maskType: java.lang.Class<M>, op: VectorOperators$Comparison, e: float): M;
          _compareTemplate<M>(maskType: java.lang.Class<M>, op: VectorOperators$Comparison, e: long): M;
          compress(a0: VectorMask<float>): FloatVector;
          compress(a0: VectorMask): Vector;
          _compressTemplate<M>(masktype: java.lang.Class<M>, m: M): FloatVector;
          _conditionalStoreNYI(offset: int, vsp: FloatVector$FloatSpecies, m: VectorMask<float>, scale: int, limit: int): void;
          div(v: Vector<float>): FloatVector;
          div(e: float): FloatVector;
          div(v: Vector<float>, m: VectorMask<float>): FloatVector;
          div(e: float, m: VectorMask<float>): FloatVector;
          div(a0: Vector, a1: VectorMask): Vector;
          div(a0: Vector): Vector;
          eq(v: Vector<float>): VectorMask<float>;
          eq(e: float): VectorMask<float>;
          equals(obj: any): boolean;
          expand(a0: VectorMask<float>): FloatVector;
          expand(a0: VectorMask): Vector;
          _expandTemplate<M>(masktype: java.lang.Class<M>, m: M): FloatVector;
          fma(b: Vector<float>, c: Vector<float>): FloatVector;
          fma(b: float, c: float): FloatVector;
          _fromArray0(a0: float[], a1: int): FloatVector;
          _fromArray0(a0: float[], a1: int, a2: VectorMask<float>, a3: int): FloatVector;
          _fromArray0(a0: float[], a1: int, a2: int[], a3: int, a4: VectorMask<float>): FloatVector;
          _fromArray0Template(a: float[], offset: int): FloatVector;
          _fromArray0Template<M>(maskClass: java.lang.Class<M>, a: float[], offset: int, m: M, offsetInRange: int): FloatVector;
          _fromArray0Template<M>(maskClass: java.lang.Class<M>, a: float[], offset: int, indexMap: int[], mapOffset: int, m: M): FloatVector;
          _fromMemorySegment0(a0: java.lang.foreign.MemorySegment, a1: long): FloatVector;
          _fromMemorySegment0(a0: java.lang.foreign.MemorySegment, a1: long, a2: VectorMask<float>, a3: int): FloatVector;
          _fromMemorySegment0(a0: java.lang.foreign.MemorySegment, a1: long): AbstractVector;
          _fromMemorySegment0Template(ms: java.lang.foreign.MemorySegment, offset: long): FloatVector;
          _fromMemorySegment0Template<M>(maskClass: java.lang.Class<M>, ms: java.lang.foreign.MemorySegment, offset: long, a3: M, m: int): FloatVector;
          hashCode(): int;
          intoArray(a: float[], offset: int): void;
          intoArray(a: float[], offset: int, m: VectorMask<float>): void;
          intoArray(a: float[], offset: int, indexMap: int[], mapOffset: int): void;
          intoArray(a: float[], offset: int, indexMap: int[], mapOffset: int, m: VectorMask<float>): void;
          _intoArray0(a0: float[], a1: int): void;
          _intoArray0(a0: float[], a1: int, a2: VectorMask<float>): void;
          _intoArray0(a0: float[], a1: int, a2: int[], a3: int, a4: VectorMask<float>): void;
          _intoArray0Template(a: float[], offset: int): void;
          _intoArray0Template<M>(maskClass: java.lang.Class<M>, a: float[], offset: int, m: M): void;
          _intoArray0Template<M>(maskClass: java.lang.Class<M>, a: float[], offset: int, indexMap: int[], mapOffset: int, m: M): void;
          intoMemorySegment(ms: java.lang.foreign.MemorySegment, offset: long, a2: java.nio.ByteOrder): void;
          intoMemorySegment(ms: java.lang.foreign.MemorySegment, offset: long, a2: java.nio.ByteOrder, bo: VectorMask<float>): void;
          _intoMemorySegment0(ms: java.lang.foreign.MemorySegment, offset: long): void;
          _intoMemorySegment0(a0: java.lang.foreign.MemorySegment, a1: long, a2: VectorMask<float>): void;
          _intoMemorySegment0Template<M>(maskClass: java.lang.Class<M>, ms: java.lang.foreign.MemorySegment, offset: long, a3: M): void;
          lane(a0: int): float;
          lanewise(a0: VectorOperators$Unary): FloatVector;
          lanewise(a0: VectorOperators$Unary, a1: VectorMask<float>): FloatVector;
          lanewise(a0: VectorOperators$Binary, a1: Vector<float>): FloatVector;
          lanewise(a0: VectorOperators$Binary, a1: Vector<float>, a2: VectorMask<float>): FloatVector;
          lanewise(op: VectorOperators$Binary, e: float): FloatVector;
          lanewise(op: VectorOperators$Binary, e: float, m: VectorMask<float>): FloatVector;
          lanewise(op: VectorOperators$Binary, e: long): FloatVector;
          lanewise(op: VectorOperators$Binary, e: long, a2: VectorMask<float>): FloatVector;
          lanewise(a0: VectorOperators$Ternary, a1: Vector<float>, a2: Vector<float>): FloatVector;
          lanewise(a0: VectorOperators$Ternary, a1: Vector<float>, a2: Vector<float>, a3: VectorMask<float>): FloatVector;
          lanewise(op: VectorOperators$Ternary, e1: float, e2: float): FloatVector;
          lanewise(op: VectorOperators$Ternary, e1: float, e2: float, m: VectorMask<float>): FloatVector;
          lanewise(op: VectorOperators$Ternary, v1: Vector<float>, e2: float): FloatVector;
          lanewise(op: VectorOperators$Ternary, v1: Vector<float>, e2: float, m: VectorMask<float>): FloatVector;
          lanewise(op: VectorOperators$Ternary, e1: float, v2: Vector<float>): FloatVector;
          lanewise(op: VectorOperators$Ternary, e1: float, v2: Vector<float>, m: VectorMask<float>): FloatVector;
          lanewise(a0: VectorOperators$Ternary, a1: Vector, a2: Vector, a3: VectorMask): Vector;
          lanewise(a0: VectorOperators$Ternary, a1: Vector, a2: Vector): Vector;
          lanewise(a0: VectorOperators$Binary, a1: long, a2: VectorMask): Vector;
          lanewise(a0: VectorOperators$Binary, a1: long): Vector;
          lanewise(a0: VectorOperators$Binary, a1: Vector, a2: VectorMask): Vector;
          lanewise(a0: VectorOperators$Binary, a1: Vector): Vector;
          lanewise(a0: VectorOperators$Unary, a1: VectorMask): Vector;
          lanewise(a0: VectorOperators$Unary): Vector;
          _lanewiseTemplate(op: VectorOperators$Unary): FloatVector;
          _lanewiseTemplate(op: VectorOperators$Unary, maskClass: java.lang.Class<VectorMask<float>>, m: VectorMask<float>): FloatVector;
          _lanewiseTemplate(op: VectorOperators$Binary, v: Vector<float>): FloatVector;
          _lanewiseTemplate(op: VectorOperators$Binary, maskClass: java.lang.Class<VectorMask<float>>, v: Vector<float>, m: VectorMask<float>): FloatVector;
          _lanewiseTemplate(op: VectorOperators$Ternary, v1: Vector<float>, v2: Vector<float>): FloatVector;
          _lanewiseTemplate(op: VectorOperators$Ternary, maskClass: java.lang.Class<VectorMask<float>>, v1: Vector<float>, v2: Vector<float>, m: VectorMask<float>): FloatVector;
          _ldLongOp(memory: java.lang.foreign.MemorySegment, offset: long, a2: FloatVector$FLdLongOp): FloatVector;
          _ldLongOp(memory: java.lang.foreign.MemorySegment, offset: long, a2: VectorMask<float>, m: FloatVector$FLdLongOp): FloatVector;
          _ldOp<M>(memory: M, offset: int, f: FloatVector$FLdOp<M>): FloatVector;
          _ldOp<M>(memory: M, offset: int, m: VectorMask<float>, f: FloatVector$FLdOp<M>): FloatVector;
          lt(v: Vector<float>): VectorMask<float>;
          lt(e: float): VectorMask<float>;
          _maskFactory(bits: boolean[]): AbstractMask<float>;
          max(v: Vector<float>): FloatVector;
          max(e: float): FloatVector;
          max(a0: Vector): Vector;
          _maybeSwap(bo: java.nio.ByteOrder): FloatVector;
          _maybeSwap(a0: java.nio.ByteOrder): AbstractVector;
          min(v: Vector<float>): FloatVector;
          min(e: float): FloatVector;
          min(a0: Vector): Vector;
          mul(v: Vector<float>): FloatVector;
          mul(e: float): FloatVector;
          mul(v: Vector<float>, m: VectorMask<float>): FloatVector;
          mul(e: float, m: VectorMask<float>): FloatVector;
          mul(a0: Vector, a1: VectorMask): Vector;
          mul(a0: Vector): Vector;
          neg(): FloatVector;
          neg(): Vector;
          pow(b: Vector<float>): FloatVector;
          pow(b: float): FloatVector;
          _rOp(a0: float, a1: VectorMask<float>, a2: FloatVector$FBinOp): float;
          _rOpTemplate(v: float, m: VectorMask<float>, f: FloatVector$FBinOp): float;
          _rOpTemplate(v: float, f: FloatVector$FBinOp): float;
          rearrange(a0: VectorShuffle<float>): FloatVector;
          rearrange(a0: VectorShuffle<float>, a1: VectorMask<float>): FloatVector;
          rearrange(a0: VectorShuffle<float>, a1: Vector<float>): FloatVector;
          rearrange(a0: VectorShuffle, a1: Vector): Vector;
          rearrange(a0: VectorShuffle, a1: VectorMask): Vector;
          rearrange(a0: VectorShuffle): Vector;
          _rearrangeTemplate<S>(shuffletype: java.lang.Class<S>, shuffle: S): FloatVector;
          _rearrangeTemplate<S, M>(shuffletype: java.lang.Class<S>, masktype: java.lang.Class<M>, shuffle: S, m: M): FloatVector;
          _rearrangeTemplate<S>(shuffletype: java.lang.Class<S>, shuffle: S, v: FloatVector): FloatVector;
          reduceLanes(a0: VectorOperators$Associative): float;
          reduceLanes(a0: VectorOperators$Associative, a1: VectorMask<float>): float;
          _reduceLanesTemplate(op: VectorOperators$Associative, maskClass: java.lang.Class<VectorMask<float>>, m: VectorMask<float>): float;
          _reduceLanesTemplate(op: VectorOperators$Associative): float;
          reduceLanesToLong(a0: VectorOperators$Associative): long;
          reduceLanesToLong(a0: VectorOperators$Associative, a1: VectorMask<float>): long;
          reinterpretAsBytes(): ByteVector;
          reinterpretAsDoubles(): DoubleVector;
          reinterpretAsFloats(): FloatVector;
          reinterpretAsInts(): IntVector;
          reinterpretAsLongs(): LongVector;
          reinterpretAsShorts(): ShortVector;
          selectFrom(a0: Vector<float>): FloatVector;
          selectFrom(a0: Vector<float>, a1: VectorMask<float>): FloatVector;
          selectFrom(a0: Vector, a1: VectorMask): Vector;
          selectFrom(a0: Vector): Vector;
          _selectFromTemplate(v: FloatVector): FloatVector;
          _selectFromTemplate(v: FloatVector, m: AbstractMask<float>): FloatVector;
          slice(a0: int, a1: Vector<float>): FloatVector;
          slice(origin: int, w: Vector<float>, m: VectorMask<float>): FloatVector;
          slice(a0: int): FloatVector;
          slice(a0: int): AbstractVector;
          slice(a0: int, a1: Vector): AbstractVector;
          slice(a0: int): Vector;
          slice(a0: int, a1: Vector, a2: VectorMask): Vector;
          slice(a0: int, a1: Vector): Vector;
          _sliceTemplate(origin: int, v1: Vector<float>): FloatVector;
          _sliceTemplate(origin: int): FloatVector;
          sqrt(): FloatVector;
          _stLongOp(memory: java.lang.foreign.MemorySegment, offset: long, a2: FloatVector$FStLongOp): void;
          _stLongOp(memory: java.lang.foreign.MemorySegment, offset: long, a2: VectorMask<float>, m: FloatVector$FStLongOp): void;
          _stOp<M>(memory: M, offset: int, f: FloatVector$FStOp<M>): void;
          _stOp<M>(memory: M, offset: int, m: VectorMask<float>, f: FloatVector$FStOp<M>): void;
          sub(v: Vector<float>): FloatVector;
          sub(e: float): FloatVector;
          sub(v: Vector<float>, m: VectorMask<float>): FloatVector;
          sub(e: float, m: VectorMask<float>): FloatVector;
          sub(a0: Vector, a1: VectorMask): Vector;
          sub(a0: Vector): Vector;
          _tOp(a0: Vector<float>, a1: Vector<float>, a2: FloatVector$FTriOp): FloatVector;
          _tOp(a0: Vector<float>, a1: Vector<float>, a2: VectorMask<float>, a3: FloatVector$FTriOp): FloatVector;
          _tOpTemplate(o1: Vector<float>, o2: Vector<float>, f: FloatVector$FTriOp): FloatVector;
          _tOpTemplate(o1: Vector<float>, o2: Vector<float>, m: VectorMask<float>, f: FloatVector$FTriOp): FloatVector;
          test(a0: VectorOperators$Test): VectorMask<float>;
          test(a0: VectorOperators$Test, a1: VectorMask<float>): VectorMask<float>;
          _testTemplate<M>(maskType: java.lang.Class<M>, op: VectorOperators$Test): M;
          _testTemplate<M>(maskType: java.lang.Class<M>, op: VectorOperators$Test, mask: M): M;
          toArray(): float[];
          toArray(): any;
          toDoubleArray(): double[];
          toIntArray(): int[];
          toLongArray(): long[];
          _toShuffle0(dsp: FloatVector$FloatSpecies): VectorShuffle<float>;
          _toShuffleTemplate(shuffleType: java.lang.Class<any>): VectorShuffle<float>;
          toString(): string;
          _uOp(a0: FloatVector$FUnOp): FloatVector;
          _uOp(a0: VectorMask<float>, a1: FloatVector$FUnOp): FloatVector;
          _uOpTemplate(f: FloatVector$FUnOp): FloatVector;
          _uOpTemplate(m: VectorMask<float>, f: FloatVector$FUnOp): FloatVector;
          unslice(a0: int, a1: Vector<float>, a2: int): FloatVector;
          unslice(a0: int, a1: Vector<float>, a2: int, a3: VectorMask<float>): FloatVector;
          unslice(a0: int): FloatVector;
          unslice(a0: int): Vector;
          unslice(a0: int, a1: Vector, a2: int, a3: VectorMask): Vector;
          unslice(a0: int, a1: Vector, a2: int): Vector;
          _unsliceTemplate(origin: int, w: Vector<float>, part: int): FloatVector;
          _unsliceTemplate<M>(maskType: java.lang.Class<M>, origin: int, w: Vector<float>, part: int, m: M): FloatVector;
          _unsliceTemplate(origin: int): FloatVector;
          _vOp(f: FloatVector$FVOp): FloatVector;
          _vOp(m: VectorMask<float>, f: FloatVector$FVOp): FloatVector;
          _vec(): float[];
          _vectorFactory(a0: float[]): FloatVector;
          viewAsFloatingLanes(): FloatVector;
          viewAsFloatingLanes(): Vector;
          viewAsIntegralLanes(): IntVector;
          viewAsIntegralLanes(): Vector;
          _vspecies(): FloatVector$FloatSpecies;
          _vspecies(): AbstractSpecies;
          withLane(a0: int, a1: float): FloatVector;
          _wrongPartForSlice(part: int): java.lang.ArrayIndexOutOfBoundsException;
        }
        interface FloatVector extends CombineTypes<[_FloatVector, AbstractVector<float>]> {}
        interface _FloatVector$FBinOp$$static extends ClassLike {
        }
        let FloatVector$FBinOp: _FloatVector$FBinOp$$static;
        interface _FloatVector$FBinOp {
          apply(a0: int, a1: float, a2: float): float;
(a0: int, a1: float, a2: float): float;
        }
        interface FloatVector$FBinOp extends CombineTypes<[_FloatVector$FBinOp, java.lang.Object]> {}
        interface _FloatVector$FBinTest$$static extends ClassLike {
        }
        let FloatVector$FBinTest: _FloatVector$FBinTest$$static;
        interface _FloatVector$FBinTest {
          apply(a0: int, a1: int, a2: float, a3: float): boolean;
(a0: int, a1: int, a2: float, a3: float): boolean;
        }
        interface FloatVector$FBinTest extends CombineTypes<[_FloatVector$FBinTest, java.lang.Object]> {}
        interface _FloatVector$FLdLongOp$$static extends ClassLike {
        }
        let FloatVector$FLdLongOp: _FloatVector$FLdLongOp$$static;
        interface _FloatVector$FLdLongOp {
          apply(a0: java.lang.foreign.MemorySegment, a1: long, a2: int): float;
(a0: java.lang.foreign.MemorySegment, a1: long, a2: int): float;
        }
        interface FloatVector$FLdLongOp extends CombineTypes<[_FloatVector$FLdLongOp, java.lang.Object]> {}
        interface _FloatVector$FLdOp$$static<M> extends ClassLike {
        }
        let FloatVector$FLdOp: _FloatVector$FLdOp$$static<M>;
        interface _FloatVector$FLdOp<M> {
          apply(a0: M, a1: int, a2: int): float;
(a0: M, a1: int, a2: int): float;
        }
        interface FloatVector$FLdOp<M> extends CombineTypes<[_FloatVector$FLdOp<M>, java.lang.Object]> {}
        interface _FloatVector$FStLongOp$$static extends ClassLike {
        }
        let FloatVector$FStLongOp: _FloatVector$FStLongOp$$static;
        interface _FloatVector$FStLongOp {
          apply(a0: java.lang.foreign.MemorySegment, a1: long, a2: int, a3: float): void;
(a0: java.lang.foreign.MemorySegment, a1: long, a2: int, a3: float): void;
        }
        interface FloatVector$FStLongOp extends CombineTypes<[_FloatVector$FStLongOp, java.lang.Object]> {}
        interface _FloatVector$FStOp$$static<M> extends ClassLike {
        }
        let FloatVector$FStOp: _FloatVector$FStOp$$static<M>;
        interface _FloatVector$FStOp<M> {
          apply(a0: M, a1: int, a2: int, a3: float): void;
(a0: M, a1: int, a2: int, a3: float): void;
        }
        interface FloatVector$FStOp<M> extends CombineTypes<[_FloatVector$FStOp<M>, java.lang.Object]> {}
        interface _FloatVector$FTriOp$$static extends ClassLike {
        }
        let FloatVector$FTriOp: _FloatVector$FTriOp$$static;
        interface _FloatVector$FTriOp {
          apply(a0: int, a1: float, a2: float, a3: float): float;
(a0: int, a1: float, a2: float, a3: float): float;
        }
        interface FloatVector$FTriOp extends CombineTypes<[_FloatVector$FTriOp, java.lang.Object]> {}
        interface _FloatVector$FUnOp$$static extends ClassLike {
        }
        let FloatVector$FUnOp: _FloatVector$FUnOp$$static;
        interface _FloatVector$FUnOp {
          apply(a0: int, a1: float): float;
(a0: int, a1: float): float;
        }
        interface FloatVector$FUnOp extends CombineTypes<[_FloatVector$FUnOp, java.lang.Object]> {}
        interface _FloatVector$FVOp$$static extends ClassLike {
        }
        let FloatVector$FVOp: _FloatVector$FVOp$$static;
        interface _FloatVector$FVOp {
          apply(a0: int): float;
(a0: int): float;
        }
        interface FloatVector$FVOp extends CombineTypes<[_FloatVector$FVOp, java.lang.Object]> {}
        interface _FloatVector$FloatSpecies$$static extends ClassLike {
          _toIntegralChecked(e: float, convertToInt: boolean): long;
        }
        let FloatVector$FloatSpecies: _FloatVector$FloatSpecies$$static;
        interface _FloatVector$FloatSpecies {
          _broadcast(e: float): FloatVector;
          broadcast(e: long): FloatVector;
          broadcast(a0: long): Vector;
          _broadcastBits(bits: long): FloatVector;
          _broadcastBits(a0: long): AbstractVector;
          checkValue(e: long): long;
          _dummyVector(): FloatVector;
          _dummyVector(): AbstractVector;
          elementType(): java.lang.Class<float>;
          fromArray(a: any, offset: int): FloatVector;
          fromArray(a0: any, a1: int): Vector;
          _fromIntValues(values: int[]): FloatVector;
          _fromIntValues(a0: int[]): Vector;
          fromMemorySegment(ms: java.lang.foreign.MemorySegment, offset: long, a2: java.nio.ByteOrder): FloatVector;
          fromMemorySegment(a0: java.lang.foreign.MemorySegment, a1: long, a2: java.nio.ByteOrder): Vector;
          _genericElementType(): java.lang.Class<float>;
          iota(): FloatVector;
          iota(): AbstractVector;
          _ldLongOp(memory: java.lang.foreign.MemorySegment, offset: long, a2: FloatVector$FLdLongOp): FloatVector;
          _ldLongOp(memory: java.lang.foreign.MemorySegment, offset: long, a2: VectorMask<float>, m: FloatVector$FLdLongOp): FloatVector;
          _ldOp<M>(memory: M, offset: int, f: FloatVector$FLdOp<M>): FloatVector;
          _ldOp<M>(memory: M, offset: int, m: VectorMask<float>, f: FloatVector$FLdOp<M>): FloatVector;
          _longToElementBits(value: long): long;
          maskAll(bit: boolean): VectorMask<float>;
          _rvOp(f: AbstractSpecies$RVOp): FloatVector;
          _rvOp(a0: AbstractSpecies$RVOp): AbstractVector;
          _stLongOp(memory: java.lang.foreign.MemorySegment, offset: long, a2: FloatVector$FStLongOp): void;
          _stLongOp(memory: java.lang.foreign.MemorySegment, offset: long, a2: AbstractMask<float>, m: FloatVector$FStLongOp): void;
          _stOp<M>(memory: M, offset: int, f: FloatVector$FStOp<M>): void;
          _stOp<M>(memory: M, offset: int, m: AbstractMask<float>, f: FloatVector$FStOp<M>): void;
          _vOp(f: FloatVector$FVOp): FloatVector;
          _vOp(m: VectorMask<float>, f: FloatVector$FVOp): FloatVector;
          vectorType(): java.lang.Class<FloatVector>;
          zero(): FloatVector;
          zero(): AbstractVector;
          zero(): Vector;
        }
        interface FloatVector$FloatSpecies extends CombineTypes<[_FloatVector$FloatSpecies, AbstractSpecies<float>]> {}
        interface _Int128Vector$$static extends ClassLike {
          _ETYPE: java.lang.Class<int>;
          _IOTA: Int128Vector;
          _VCLASS: java.lang.Class<Int128Vector>;
          _VLENGTH: int;
          _VSHAPE: VectorShape;
          _VSIZE: int;
          _VSPECIES: IntVector$IntSpecies;
          _ZERO: Int128Vector;
          _new(v: int[]): Int128Vector;
          _new(v: any): Int128Vector;
        }
        let Int128Vector: _Int128Vector$$static;
        interface _Int128Vector {
          addIndex(scale: int): Int128Vector;
          addIndex(a0: int): IntVector;
          addIndex(a0: int): Vector;
          _asByteVectorRaw(): Byte128Vector;
          _asByteVectorRaw(): ByteVector;
          _asVectorRaw(laneType: LaneType): AbstractVector<any>;
          _bOp(v: Vector<int>, f: IntVector$FBinOp): Int128Vector;
          _bOp(v: Vector<int>, m: VectorMask<int>, f: IntVector$FBinOp): Int128Vector;
          _bOp(a0: Vector, a1: VectorMask, a2: IntVector$FBinOp): IntVector;
          _bOp(a0: Vector, a1: IntVector$FBinOp): IntVector;
          bitSize(): int;
          blend(v: Vector<int>, m: VectorMask<int>): Int128Vector;
          blend(a0: Vector, a1: VectorMask): IntVector;
          blend(a0: Vector, a1: VectorMask): Vector;
          broadcast(e: int): Int128Vector;
          broadcast(e: long): Int128Vector;
          broadcast(a0: long): IntVector;
          broadcast(a0: int): IntVector;
          broadcast(a0: long): Vector;
          byteSize(): int;
          compare(op: VectorOperators$Comparison, v: Vector<int>): Int128Vector$Int128Mask;
          compare(op: VectorOperators$Comparison, s: int): Int128Vector$Int128Mask;
          compare(op: VectorOperators$Comparison, s: long): Int128Vector$Int128Mask;
          compare(op: VectorOperators$Comparison, v: Vector<int>, m: VectorMask<int>): Int128Vector$Int128Mask;
          compare(a0: VectorOperators$Comparison, a1: long): VectorMask;
          compare(a0: VectorOperators$Comparison, a1: int): VectorMask;
          compare(a0: VectorOperators$Comparison, a1: Vector): VectorMask;
          compare(a0: VectorOperators$Comparison, a1: Vector, a2: VectorMask): VectorMask;
          compress(m: VectorMask<int>): Int128Vector;
          compress(a0: VectorMask): IntVector;
          compress(a0: VectorMask): Vector;
          convertShape<F>(conv: VectorOperators$Conversion<int,F>, rsp: VectorSpecies<F>, part: int): Vector<F>;
          elementSize(): int;
          elementType(): java.lang.Class<int>;
          expand(m: VectorMask<int>): Int128Vector;
          expand(a0: VectorMask): IntVector;
          expand(a0: VectorMask): Vector;
          _fromArray0(a: int[], offset: int): IntVector;
          _fromArray0(a: int[], offset: int, m: VectorMask<int>, offsetInRange: int): IntVector;
          _fromArray0(a: int[], offset: int, indexMap: int[], mapOffset: int, m: VectorMask<int>): IntVector;
          _fromMemorySegment0(ms: java.lang.foreign.MemorySegment, offset: long): IntVector;
          _fromMemorySegment0(ms: java.lang.foreign.MemorySegment, offset: long, a2: VectorMask<int>, m: int): IntVector;
          _fromMemorySegment0(a0: java.lang.foreign.MemorySegment, a1: long): AbstractVector;
          _intoArray0(a: int[], offset: int): void;
          _intoArray0(a: int[], offset: int, m: VectorMask<int>): void;
          _intoArray0(a: int[], offset: int, indexMap: int[], mapOffset: int, m: VectorMask<int>): void;
          _intoMemorySegment0(ms: java.lang.foreign.MemorySegment, offset: long, a2: VectorMask<int>): void;
          _iotaShuffle(): Int128Vector$Int128Shuffle;
          _iotaShuffle(start: int, step: int, wrap: boolean): Int128Vector$Int128Shuffle;
          _iotaShuffle(a0: int, a1: int, a2: boolean): AbstractShuffle;
          _iotaShuffle(): AbstractShuffle;
          lane(i: int): int;
          laneHelper(i: int): int;
          lanewise(op: VectorOperators$Unary): Int128Vector;
          lanewise(op: VectorOperators$Unary, m: VectorMask<int>): Int128Vector;
          lanewise(op: VectorOperators$Binary, v: Vector<int>): Int128Vector;
          lanewise(op: VectorOperators$Binary, v: Vector<int>, m: VectorMask<int>): Int128Vector;
          lanewise(op: VectorOperators$Ternary, v1: Vector<int>, v2: Vector<int>): Int128Vector;
          lanewise(op: VectorOperators$Ternary, v1: Vector<int>, v2: Vector<int>, m: VectorMask<int>): Int128Vector;
          lanewise(a0: VectorOperators$Ternary, a1: Vector, a2: Vector, a3: VectorMask): IntVector;
          lanewise(a0: VectorOperators$Ternary, a1: Vector, a2: Vector): IntVector;
          lanewise(a0: VectorOperators$Binary, a1: Vector, a2: VectorMask): IntVector;
          lanewise(a0: VectorOperators$Binary, a1: Vector): IntVector;
          lanewise(a0: VectorOperators$Unary, a1: VectorMask): IntVector;
          lanewise(a0: VectorOperators$Unary): IntVector;
          lanewise(a0: VectorOperators$Ternary, a1: Vector, a2: Vector, a3: VectorMask): Vector;
          lanewise(a0: VectorOperators$Ternary, a1: Vector, a2: Vector): Vector;
          lanewise(a0: VectorOperators$Binary, a1: Vector, a2: VectorMask): Vector;
          lanewise(a0: VectorOperators$Binary, a1: Vector): Vector;
          lanewise(a0: VectorOperators$Unary, a1: VectorMask): Vector;
          lanewise(a0: VectorOperators$Unary): Vector;
          _lanewiseShift(op: VectorOperators$Binary, e: int): Int128Vector;
          _lanewiseShift(op: VectorOperators$Binary, e: int, m: VectorMask<int>): Int128Vector;
          _lanewiseShift(a0: VectorOperators$Binary, a1: int, a2: VectorMask): IntVector;
          _lanewiseShift(a0: VectorOperators$Binary, a1: int): IntVector;
          length(): int;
          _maskFromArray(bits: boolean[]): Int128Vector$Int128Mask;
          _maskFromArray(a0: boolean[]): AbstractMask;
          _rOp(v: int, m: VectorMask<int>, f: IntVector$FBinOp): int;
          rearrange(s: VectorShuffle<int>): Int128Vector;
          rearrange(shuffle: VectorShuffle<int>, m: VectorMask<int>): Int128Vector;
          rearrange(s: VectorShuffle<int>, v: Vector<int>): Int128Vector;
          rearrange(a0: VectorShuffle, a1: Vector): IntVector;
          rearrange(a0: VectorShuffle, a1: VectorMask): IntVector;
          rearrange(a0: VectorShuffle): IntVector;
          rearrange(a0: VectorShuffle, a1: Vector): Vector;
          rearrange(a0: VectorShuffle, a1: VectorMask): Vector;
          rearrange(a0: VectorShuffle): Vector;
          reduceLanes(op: VectorOperators$Associative): int;
          reduceLanes(op: VectorOperators$Associative, m: VectorMask<int>): int;
          reduceLanesToLong(op: VectorOperators$Associative): long;
          reduceLanesToLong(op: VectorOperators$Associative, m: VectorMask<int>): long;
          reinterpretShape<F>(toSpecies: VectorSpecies<F>, part: int): Vector<F>;
          selectFrom(v: Vector<int>): Int128Vector;
          selectFrom(v: Vector<int>, m: VectorMask<int>): Int128Vector;
          selectFrom(a0: Vector, a1: VectorMask): IntVector;
          selectFrom(a0: Vector): IntVector;
          selectFrom(a0: Vector, a1: VectorMask): Vector;
          selectFrom(a0: Vector): Vector;
          shape(): VectorShape;
          _shuffleFromArray(indexes: int[], i: int): Int128Vector$Int128Shuffle;
          _shuffleFromArray(a0: int[], a1: int): AbstractShuffle;
          _shuffleFromBytes(reorder: byte[]): Int128Vector$Int128Shuffle;
          _shuffleFromBytes(a0: byte[]): AbstractShuffle;
          _shuffleFromOp(fn: java.util.function.IntUnaryOperator): Int128Vector$Int128Shuffle;
          _shuffleFromOp(a0: java.util.function.IntUnaryOperator): AbstractShuffle;
          slice(origin: int, v: Vector<int>): Int128Vector;
          slice(origin: int): Int128Vector;
          slice(a0: int): IntVector;
          slice(a0: int, a1: Vector): IntVector;
          slice(a0: int): AbstractVector;
          slice(a0: int, a1: Vector): AbstractVector;
          slice(a0: int): Vector;
          slice(a0: int, a1: Vector): Vector;
          _tOp(v1: Vector<int>, v2: Vector<int>, f: IntVector$FTriOp): Int128Vector;
          _tOp(v1: Vector<int>, v2: Vector<int>, m: VectorMask<int>, f: IntVector$FTriOp): Int128Vector;
          _tOp(a0: Vector, a1: Vector, a2: VectorMask, a3: IntVector$FTriOp): IntVector;
          _tOp(a0: Vector, a1: Vector, a2: IntVector$FTriOp): IntVector;
          test(op: VectorOperators$Test): Int128Vector$Int128Mask;
          test(op: VectorOperators$Test, m: VectorMask<int>): Int128Vector$Int128Mask;
          test(a0: VectorOperators$Test, a1: VectorMask): VectorMask;
          test(a0: VectorOperators$Test): VectorMask;
          toShuffle(): VectorShuffle<int>;
          _uOp(f: IntVector$FUnOp): Int128Vector;
          _uOp(m: VectorMask<int>, f: IntVector$FUnOp): Int128Vector;
          _uOp(a0: VectorMask, a1: IntVector$FUnOp): IntVector;
          _uOp(a0: IntVector$FUnOp): IntVector;
          unslice(origin: int, w: Vector<int>, part: int): Int128Vector;
          unslice(origin: int, w: Vector<int>, part: int, m: VectorMask<int>): Int128Vector;
          unslice(origin: int): Int128Vector;
          unslice(a0: int): IntVector;
          unslice(a0: int, a1: Vector, a2: int, a3: VectorMask): IntVector;
          unslice(a0: int, a1: Vector, a2: int): IntVector;
          unslice(a0: int): Vector;
          unslice(a0: int, a1: Vector, a2: int, a3: VectorMask): Vector;
          unslice(a0: int, a1: Vector, a2: int): Vector;
          _vec(): int[];
          _vectorFactory(vec: int[]): Int128Vector;
          _vectorFactory(a0: int[]): IntVector;
          vspecies(): IntVector$IntSpecies;
          vspecies(): AbstractSpecies;
          withLane(i: int, e: int): Int128Vector;
          withLane(a0: int, a1: int): IntVector;
          withLaneHelper(i: int, e: int): Int128Vector;
        }
        interface Int128Vector extends CombineTypes<[_Int128Vector, jdk.incubator.vector.IntVector]> {}
        interface _Int128Vector$Int128Mask$$static extends ClassLike {
          _maskAll(bit: boolean): Int128Vector$Int128Mask;
          _prepare(bits: boolean[], offset: int): boolean[];
          _prepare(val: boolean): boolean[];
          _ETYPE: java.lang.Class<int>;
          _FALSE_MASK: Int128Vector$Int128Mask;
          _TRUE_MASK: Int128Vector$Int128Mask;
          _VLENGTH: int;
          _new(bits: boolean[]): Int128Vector$Int128Mask;
          _new(bits: boolean[], offset: int): Int128Vector$Int128Mask;
          _new(val: boolean): Int128Vector$Int128Mask;
        }
        let Int128Vector$Int128Mask: _Int128Vector$Int128Mask$$static;
        interface _Int128Vector$Int128Mask {
          allTrue(): boolean;
          and(mask: VectorMask<int>): Int128Vector$Int128Mask;
          and(a0: VectorMask): VectorMask;
          anyTrue(): boolean;
          _bOp(m: VectorMask<int>, f: AbstractMask$MBinOp): Int128Vector$Int128Mask;
          _bOp(a0: VectorMask, a1: AbstractMask$MBinOp): AbstractMask;
          cast<E>(dsp: VectorSpecies<E>): VectorMask<E>;
          compress(): Int128Vector$Int128Mask;
          compress(): VectorMask;
          _defaultMaskCast<E>(dsp: AbstractSpecies<E>): VectorMask<E>;
          firstTrue(): int;
          _getBits(): boolean[];
          _indexPartiallyInUpperRange(offset: long, a1: long): Int128Vector$Int128Mask;
          _indexPartiallyInUpperRange(a0: long, a1: long): VectorMask;
          lastTrue(): int;
          not(): Int128Vector$Int128Mask;
          not(): VectorMask;
          or(mask: VectorMask<int>): Int128Vector$Int128Mask;
          or(a0: VectorMask): VectorMask;
          toLong(): long;
          toVector(): Int128Vector;
          toVector(): Vector;
          trueCount(): int;
          _uOp(f: AbstractMask$MUnOp): Int128Vector$Int128Mask;
          _uOp(a0: AbstractMask$MUnOp): AbstractMask;
          vspecies(): IntVector$IntSpecies;
          vspecies(): AbstractSpecies;
          xor(mask: VectorMask<int>): Int128Vector$Int128Mask;
          xor(a0: VectorMask): VectorMask;
        }
        interface Int128Vector$Int128Mask extends CombineTypes<[_Int128Vector$Int128Mask, AbstractMask<int>]> {}
        interface _Int128Vector$Int128Shuffle$$static extends ClassLike {
          _ETYPE: java.lang.Class<int>;
          _IOTA: Int128Vector$Int128Shuffle;
          _VLENGTH: int;
          _new(reorder: byte[]): Int128Vector$Int128Shuffle;
          new(reorder: int[]): Int128Vector$Int128Shuffle;
          new(reorder: int[], i: int): Int128Vector$Int128Shuffle;
          new(fn: java.util.function.IntUnaryOperator): Int128Vector$Int128Shuffle;
        }
        let Int128Vector$Int128Shuffle: _Int128Vector$Int128Shuffle$$static;
        interface _Int128Vector$Int128Shuffle {
          cast<F>(s: VectorSpecies<F>): VectorShuffle<F>;
          rearrange(shuffle: VectorShuffle<int>): Int128Vector$Int128Shuffle;
          rearrange(a0: VectorShuffle): VectorShuffle;
          toVector(): Int128Vector;
          toVector(): Vector;
          vspecies(): IntVector$IntSpecies;
          vspecies(): AbstractSpecies;
        }
        interface Int128Vector$Int128Shuffle extends CombineTypes<[_Int128Vector$Int128Shuffle, AbstractShuffle<int>]> {}
        interface _Int256Vector$$static extends ClassLike {
          _ETYPE: java.lang.Class<int>;
          _IOTA: Int256Vector;
          _VCLASS: java.lang.Class<Int256Vector>;
          _VLENGTH: int;
          _VSHAPE: VectorShape;
          _VSIZE: int;
          _VSPECIES: IntVector$IntSpecies;
          _ZERO: Int256Vector;
          _new(v: int[]): Int256Vector;
          _new(v: any): Int256Vector;
        }
        let Int256Vector: _Int256Vector$$static;
        interface _Int256Vector {
          addIndex(scale: int): Int256Vector;
          addIndex(a0: int): IntVector;
          addIndex(a0: int): Vector;
          _asByteVectorRaw(): Byte256Vector;
          _asByteVectorRaw(): ByteVector;
          _asVectorRaw(laneType: LaneType): AbstractVector<any>;
          _bOp(v: Vector<int>, f: IntVector$FBinOp): Int256Vector;
          _bOp(v: Vector<int>, m: VectorMask<int>, f: IntVector$FBinOp): Int256Vector;
          _bOp(a0: Vector, a1: VectorMask, a2: IntVector$FBinOp): IntVector;
          _bOp(a0: Vector, a1: IntVector$FBinOp): IntVector;
          bitSize(): int;
          blend(v: Vector<int>, m: VectorMask<int>): Int256Vector;
          blend(a0: Vector, a1: VectorMask): IntVector;
          blend(a0: Vector, a1: VectorMask): Vector;
          broadcast(e: int): Int256Vector;
          broadcast(e: long): Int256Vector;
          broadcast(a0: long): IntVector;
          broadcast(a0: int): IntVector;
          broadcast(a0: long): Vector;
          byteSize(): int;
          compare(op: VectorOperators$Comparison, v: Vector<int>): Int256Vector$Int256Mask;
          compare(op: VectorOperators$Comparison, s: int): Int256Vector$Int256Mask;
          compare(op: VectorOperators$Comparison, s: long): Int256Vector$Int256Mask;
          compare(op: VectorOperators$Comparison, v: Vector<int>, m: VectorMask<int>): Int256Vector$Int256Mask;
          compare(a0: VectorOperators$Comparison, a1: long): VectorMask;
          compare(a0: VectorOperators$Comparison, a1: int): VectorMask;
          compare(a0: VectorOperators$Comparison, a1: Vector): VectorMask;
          compare(a0: VectorOperators$Comparison, a1: Vector, a2: VectorMask): VectorMask;
          compress(m: VectorMask<int>): Int256Vector;
          compress(a0: VectorMask): IntVector;
          compress(a0: VectorMask): Vector;
          convertShape<F>(conv: VectorOperators$Conversion<int,F>, rsp: VectorSpecies<F>, part: int): Vector<F>;
          elementSize(): int;
          elementType(): java.lang.Class<int>;
          expand(m: VectorMask<int>): Int256Vector;
          expand(a0: VectorMask): IntVector;
          expand(a0: VectorMask): Vector;
          _fromArray0(a: int[], offset: int): IntVector;
          _fromArray0(a: int[], offset: int, m: VectorMask<int>, offsetInRange: int): IntVector;
          _fromArray0(a: int[], offset: int, indexMap: int[], mapOffset: int, m: VectorMask<int>): IntVector;
          _fromMemorySegment0(ms: java.lang.foreign.MemorySegment, offset: long): IntVector;
          _fromMemorySegment0(ms: java.lang.foreign.MemorySegment, offset: long, a2: VectorMask<int>, m: int): IntVector;
          _fromMemorySegment0(a0: java.lang.foreign.MemorySegment, a1: long): AbstractVector;
          _intoArray0(a: int[], offset: int): void;
          _intoArray0(a: int[], offset: int, m: VectorMask<int>): void;
          _intoArray0(a: int[], offset: int, indexMap: int[], mapOffset: int, m: VectorMask<int>): void;
          _intoMemorySegment0(ms: java.lang.foreign.MemorySegment, offset: long, a2: VectorMask<int>): void;
          _iotaShuffle(): Int256Vector$Int256Shuffle;
          _iotaShuffle(start: int, step: int, wrap: boolean): Int256Vector$Int256Shuffle;
          _iotaShuffle(a0: int, a1: int, a2: boolean): AbstractShuffle;
          _iotaShuffle(): AbstractShuffle;
          lane(i: int): int;
          laneHelper(i: int): int;
          lanewise(op: VectorOperators$Unary): Int256Vector;
          lanewise(op: VectorOperators$Unary, m: VectorMask<int>): Int256Vector;
          lanewise(op: VectorOperators$Binary, v: Vector<int>): Int256Vector;
          lanewise(op: VectorOperators$Binary, v: Vector<int>, m: VectorMask<int>): Int256Vector;
          lanewise(op: VectorOperators$Ternary, v1: Vector<int>, v2: Vector<int>): Int256Vector;
          lanewise(op: VectorOperators$Ternary, v1: Vector<int>, v2: Vector<int>, m: VectorMask<int>): Int256Vector;
          lanewise(a0: VectorOperators$Ternary, a1: Vector, a2: Vector, a3: VectorMask): IntVector;
          lanewise(a0: VectorOperators$Ternary, a1: Vector, a2: Vector): IntVector;
          lanewise(a0: VectorOperators$Binary, a1: Vector, a2: VectorMask): IntVector;
          lanewise(a0: VectorOperators$Binary, a1: Vector): IntVector;
          lanewise(a0: VectorOperators$Unary, a1: VectorMask): IntVector;
          lanewise(a0: VectorOperators$Unary): IntVector;
          lanewise(a0: VectorOperators$Ternary, a1: Vector, a2: Vector, a3: VectorMask): Vector;
          lanewise(a0: VectorOperators$Ternary, a1: Vector, a2: Vector): Vector;
          lanewise(a0: VectorOperators$Binary, a1: Vector, a2: VectorMask): Vector;
          lanewise(a0: VectorOperators$Binary, a1: Vector): Vector;
          lanewise(a0: VectorOperators$Unary, a1: VectorMask): Vector;
          lanewise(a0: VectorOperators$Unary): Vector;
          _lanewiseShift(op: VectorOperators$Binary, e: int): Int256Vector;
          _lanewiseShift(op: VectorOperators$Binary, e: int, m: VectorMask<int>): Int256Vector;
          _lanewiseShift(a0: VectorOperators$Binary, a1: int, a2: VectorMask): IntVector;
          _lanewiseShift(a0: VectorOperators$Binary, a1: int): IntVector;
          length(): int;
          _maskFromArray(bits: boolean[]): Int256Vector$Int256Mask;
          _maskFromArray(a0: boolean[]): AbstractMask;
          _rOp(v: int, m: VectorMask<int>, f: IntVector$FBinOp): int;
          rearrange(s: VectorShuffle<int>): Int256Vector;
          rearrange(shuffle: VectorShuffle<int>, m: VectorMask<int>): Int256Vector;
          rearrange(s: VectorShuffle<int>, v: Vector<int>): Int256Vector;
          rearrange(a0: VectorShuffle, a1: Vector): IntVector;
          rearrange(a0: VectorShuffle, a1: VectorMask): IntVector;
          rearrange(a0: VectorShuffle): IntVector;
          rearrange(a0: VectorShuffle, a1: Vector): Vector;
          rearrange(a0: VectorShuffle, a1: VectorMask): Vector;
          rearrange(a0: VectorShuffle): Vector;
          reduceLanes(op: VectorOperators$Associative): int;
          reduceLanes(op: VectorOperators$Associative, m: VectorMask<int>): int;
          reduceLanesToLong(op: VectorOperators$Associative): long;
          reduceLanesToLong(op: VectorOperators$Associative, m: VectorMask<int>): long;
          reinterpretShape<F>(toSpecies: VectorSpecies<F>, part: int): Vector<F>;
          selectFrom(v: Vector<int>): Int256Vector;
          selectFrom(v: Vector<int>, m: VectorMask<int>): Int256Vector;
          selectFrom(a0: Vector, a1: VectorMask): IntVector;
          selectFrom(a0: Vector): IntVector;
          selectFrom(a0: Vector, a1: VectorMask): Vector;
          selectFrom(a0: Vector): Vector;
          shape(): VectorShape;
          _shuffleFromArray(indexes: int[], i: int): Int256Vector$Int256Shuffle;
          _shuffleFromArray(a0: int[], a1: int): AbstractShuffle;
          _shuffleFromBytes(reorder: byte[]): Int256Vector$Int256Shuffle;
          _shuffleFromBytes(a0: byte[]): AbstractShuffle;
          _shuffleFromOp(fn: java.util.function.IntUnaryOperator): Int256Vector$Int256Shuffle;
          _shuffleFromOp(a0: java.util.function.IntUnaryOperator): AbstractShuffle;
          slice(origin: int, v: Vector<int>): Int256Vector;
          slice(origin: int): Int256Vector;
          slice(a0: int): IntVector;
          slice(a0: int, a1: Vector): IntVector;
          slice(a0: int): AbstractVector;
          slice(a0: int, a1: Vector): AbstractVector;
          slice(a0: int): Vector;
          slice(a0: int, a1: Vector): Vector;
          _tOp(v1: Vector<int>, v2: Vector<int>, f: IntVector$FTriOp): Int256Vector;
          _tOp(v1: Vector<int>, v2: Vector<int>, m: VectorMask<int>, f: IntVector$FTriOp): Int256Vector;
          _tOp(a0: Vector, a1: Vector, a2: VectorMask, a3: IntVector$FTriOp): IntVector;
          _tOp(a0: Vector, a1: Vector, a2: IntVector$FTriOp): IntVector;
          test(op: VectorOperators$Test): Int256Vector$Int256Mask;
          test(op: VectorOperators$Test, m: VectorMask<int>): Int256Vector$Int256Mask;
          test(a0: VectorOperators$Test, a1: VectorMask): VectorMask;
          test(a0: VectorOperators$Test): VectorMask;
          toShuffle(): VectorShuffle<int>;
          _uOp(f: IntVector$FUnOp): Int256Vector;
          _uOp(m: VectorMask<int>, f: IntVector$FUnOp): Int256Vector;
          _uOp(a0: VectorMask, a1: IntVector$FUnOp): IntVector;
          _uOp(a0: IntVector$FUnOp): IntVector;
          unslice(origin: int, w: Vector<int>, part: int): Int256Vector;
          unslice(origin: int, w: Vector<int>, part: int, m: VectorMask<int>): Int256Vector;
          unslice(origin: int): Int256Vector;
          unslice(a0: int): IntVector;
          unslice(a0: int, a1: Vector, a2: int, a3: VectorMask): IntVector;
          unslice(a0: int, a1: Vector, a2: int): IntVector;
          unslice(a0: int): Vector;
          unslice(a0: int, a1: Vector, a2: int, a3: VectorMask): Vector;
          unslice(a0: int, a1: Vector, a2: int): Vector;
          _vec(): int[];
          _vectorFactory(vec: int[]): Int256Vector;
          _vectorFactory(a0: int[]): IntVector;
          vspecies(): IntVector$IntSpecies;
          vspecies(): AbstractSpecies;
          withLane(i: int, e: int): Int256Vector;
          withLane(a0: int, a1: int): IntVector;
          withLaneHelper(i: int, e: int): Int256Vector;
        }
        interface Int256Vector extends CombineTypes<[_Int256Vector, jdk.incubator.vector.IntVector]> {}
        interface _Int256Vector$Int256Mask$$static extends ClassLike {
          _maskAll(bit: boolean): Int256Vector$Int256Mask;
          _prepare(bits: boolean[], offset: int): boolean[];
          _prepare(val: boolean): boolean[];
          _ETYPE: java.lang.Class<int>;
          _FALSE_MASK: Int256Vector$Int256Mask;
          _TRUE_MASK: Int256Vector$Int256Mask;
          _VLENGTH: int;
          _new(bits: boolean[]): Int256Vector$Int256Mask;
          _new(bits: boolean[], offset: int): Int256Vector$Int256Mask;
          _new(val: boolean): Int256Vector$Int256Mask;
        }
        let Int256Vector$Int256Mask: _Int256Vector$Int256Mask$$static;
        interface _Int256Vector$Int256Mask {
          allTrue(): boolean;
          and(mask: VectorMask<int>): Int256Vector$Int256Mask;
          and(a0: VectorMask): VectorMask;
          anyTrue(): boolean;
          _bOp(m: VectorMask<int>, f: AbstractMask$MBinOp): Int256Vector$Int256Mask;
          _bOp(a0: VectorMask, a1: AbstractMask$MBinOp): AbstractMask;
          cast<E>(dsp: VectorSpecies<E>): VectorMask<E>;
          compress(): Int256Vector$Int256Mask;
          compress(): VectorMask;
          _defaultMaskCast<E>(dsp: AbstractSpecies<E>): VectorMask<E>;
          firstTrue(): int;
          _getBits(): boolean[];
          _indexPartiallyInUpperRange(offset: long, a1: long): Int256Vector$Int256Mask;
          _indexPartiallyInUpperRange(a0: long, a1: long): VectorMask;
          lastTrue(): int;
          not(): Int256Vector$Int256Mask;
          not(): VectorMask;
          or(mask: VectorMask<int>): Int256Vector$Int256Mask;
          or(a0: VectorMask): VectorMask;
          toLong(): long;
          toVector(): Int256Vector;
          toVector(): Vector;
          trueCount(): int;
          _uOp(f: AbstractMask$MUnOp): Int256Vector$Int256Mask;
          _uOp(a0: AbstractMask$MUnOp): AbstractMask;
          vspecies(): IntVector$IntSpecies;
          vspecies(): AbstractSpecies;
          xor(mask: VectorMask<int>): Int256Vector$Int256Mask;
          xor(a0: VectorMask): VectorMask;
        }
        interface Int256Vector$Int256Mask extends CombineTypes<[_Int256Vector$Int256Mask, AbstractMask<int>]> {}
        interface _Int256Vector$Int256Shuffle$$static extends ClassLike {
          _ETYPE: java.lang.Class<int>;
          _IOTA: Int256Vector$Int256Shuffle;
          _VLENGTH: int;
          _new(reorder: byte[]): Int256Vector$Int256Shuffle;
          new(reorder: int[]): Int256Vector$Int256Shuffle;
          new(reorder: int[], i: int): Int256Vector$Int256Shuffle;
          new(fn: java.util.function.IntUnaryOperator): Int256Vector$Int256Shuffle;
        }
        let Int256Vector$Int256Shuffle: _Int256Vector$Int256Shuffle$$static;
        interface _Int256Vector$Int256Shuffle {
          cast<F>(s: VectorSpecies<F>): VectorShuffle<F>;
          rearrange(shuffle: VectorShuffle<int>): Int256Vector$Int256Shuffle;
          rearrange(a0: VectorShuffle): VectorShuffle;
          toVector(): Int256Vector;
          toVector(): Vector;
          vspecies(): IntVector$IntSpecies;
          vspecies(): AbstractSpecies;
        }
        interface Int256Vector$Int256Shuffle extends CombineTypes<[_Int256Vector$Int256Shuffle, AbstractShuffle<int>]> {}
        interface _Int512Vector$$static extends ClassLike {
          _ETYPE: java.lang.Class<int>;
          _IOTA: Int512Vector;
          _VCLASS: java.lang.Class<Int512Vector>;
          _VLENGTH: int;
          _VSHAPE: VectorShape;
          _VSIZE: int;
          _VSPECIES: IntVector$IntSpecies;
          _ZERO: Int512Vector;
          _new(v: int[]): Int512Vector;
          _new(v: any): Int512Vector;
        }
        let Int512Vector: _Int512Vector$$static;
        interface _Int512Vector {
          addIndex(scale: int): Int512Vector;
          addIndex(a0: int): IntVector;
          addIndex(a0: int): Vector;
          _asByteVectorRaw(): Byte512Vector;
          _asByteVectorRaw(): ByteVector;
          _asVectorRaw(laneType: LaneType): AbstractVector<any>;
          _bOp(v: Vector<int>, f: IntVector$FBinOp): Int512Vector;
          _bOp(v: Vector<int>, m: VectorMask<int>, f: IntVector$FBinOp): Int512Vector;
          _bOp(a0: Vector, a1: VectorMask, a2: IntVector$FBinOp): IntVector;
          _bOp(a0: Vector, a1: IntVector$FBinOp): IntVector;
          bitSize(): int;
          blend(v: Vector<int>, m: VectorMask<int>): Int512Vector;
          blend(a0: Vector, a1: VectorMask): IntVector;
          blend(a0: Vector, a1: VectorMask): Vector;
          broadcast(e: int): Int512Vector;
          broadcast(e: long): Int512Vector;
          broadcast(a0: long): IntVector;
          broadcast(a0: int): IntVector;
          broadcast(a0: long): Vector;
          byteSize(): int;
          compare(op: VectorOperators$Comparison, v: Vector<int>): Int512Vector$Int512Mask;
          compare(op: VectorOperators$Comparison, s: int): Int512Vector$Int512Mask;
          compare(op: VectorOperators$Comparison, s: long): Int512Vector$Int512Mask;
          compare(op: VectorOperators$Comparison, v: Vector<int>, m: VectorMask<int>): Int512Vector$Int512Mask;
          compare(a0: VectorOperators$Comparison, a1: long): VectorMask;
          compare(a0: VectorOperators$Comparison, a1: int): VectorMask;
          compare(a0: VectorOperators$Comparison, a1: Vector): VectorMask;
          compare(a0: VectorOperators$Comparison, a1: Vector, a2: VectorMask): VectorMask;
          compress(m: VectorMask<int>): Int512Vector;
          compress(a0: VectorMask): IntVector;
          compress(a0: VectorMask): Vector;
          convertShape<F>(conv: VectorOperators$Conversion<int,F>, rsp: VectorSpecies<F>, part: int): Vector<F>;
          elementSize(): int;
          elementType(): java.lang.Class<int>;
          expand(m: VectorMask<int>): Int512Vector;
          expand(a0: VectorMask): IntVector;
          expand(a0: VectorMask): Vector;
          _fromArray0(a: int[], offset: int): IntVector;
          _fromArray0(a: int[], offset: int, m: VectorMask<int>, offsetInRange: int): IntVector;
          _fromArray0(a: int[], offset: int, indexMap: int[], mapOffset: int, m: VectorMask<int>): IntVector;
          _fromMemorySegment0(ms: java.lang.foreign.MemorySegment, offset: long): IntVector;
          _fromMemorySegment0(ms: java.lang.foreign.MemorySegment, offset: long, a2: VectorMask<int>, m: int): IntVector;
          _fromMemorySegment0(a0: java.lang.foreign.MemorySegment, a1: long): AbstractVector;
          _intoArray0(a: int[], offset: int): void;
          _intoArray0(a: int[], offset: int, m: VectorMask<int>): void;
          _intoArray0(a: int[], offset: int, indexMap: int[], mapOffset: int, m: VectorMask<int>): void;
          _intoMemorySegment0(ms: java.lang.foreign.MemorySegment, offset: long, a2: VectorMask<int>): void;
          _iotaShuffle(): Int512Vector$Int512Shuffle;
          _iotaShuffle(start: int, step: int, wrap: boolean): Int512Vector$Int512Shuffle;
          _iotaShuffle(a0: int, a1: int, a2: boolean): AbstractShuffle;
          _iotaShuffle(): AbstractShuffle;
          lane(i: int): int;
          laneHelper(i: int): int;
          lanewise(op: VectorOperators$Unary): Int512Vector;
          lanewise(op: VectorOperators$Unary, m: VectorMask<int>): Int512Vector;
          lanewise(op: VectorOperators$Binary, v: Vector<int>): Int512Vector;
          lanewise(op: VectorOperators$Binary, v: Vector<int>, m: VectorMask<int>): Int512Vector;
          lanewise(op: VectorOperators$Ternary, v1: Vector<int>, v2: Vector<int>): Int512Vector;
          lanewise(op: VectorOperators$Ternary, v1: Vector<int>, v2: Vector<int>, m: VectorMask<int>): Int512Vector;
          lanewise(a0: VectorOperators$Ternary, a1: Vector, a2: Vector, a3: VectorMask): IntVector;
          lanewise(a0: VectorOperators$Ternary, a1: Vector, a2: Vector): IntVector;
          lanewise(a0: VectorOperators$Binary, a1: Vector, a2: VectorMask): IntVector;
          lanewise(a0: VectorOperators$Binary, a1: Vector): IntVector;
          lanewise(a0: VectorOperators$Unary, a1: VectorMask): IntVector;
          lanewise(a0: VectorOperators$Unary): IntVector;
          lanewise(a0: VectorOperators$Ternary, a1: Vector, a2: Vector, a3: VectorMask): Vector;
          lanewise(a0: VectorOperators$Ternary, a1: Vector, a2: Vector): Vector;
          lanewise(a0: VectorOperators$Binary, a1: Vector, a2: VectorMask): Vector;
          lanewise(a0: VectorOperators$Binary, a1: Vector): Vector;
          lanewise(a0: VectorOperators$Unary, a1: VectorMask): Vector;
          lanewise(a0: VectorOperators$Unary): Vector;
          _lanewiseShift(op: VectorOperators$Binary, e: int): Int512Vector;
          _lanewiseShift(op: VectorOperators$Binary, e: int, m: VectorMask<int>): Int512Vector;
          _lanewiseShift(a0: VectorOperators$Binary, a1: int, a2: VectorMask): IntVector;
          _lanewiseShift(a0: VectorOperators$Binary, a1: int): IntVector;
          length(): int;
          _maskFromArray(bits: boolean[]): Int512Vector$Int512Mask;
          _maskFromArray(a0: boolean[]): AbstractMask;
          _rOp(v: int, m: VectorMask<int>, f: IntVector$FBinOp): int;
          rearrange(s: VectorShuffle<int>): Int512Vector;
          rearrange(shuffle: VectorShuffle<int>, m: VectorMask<int>): Int512Vector;
          rearrange(s: VectorShuffle<int>, v: Vector<int>): Int512Vector;
          rearrange(a0: VectorShuffle, a1: Vector): IntVector;
          rearrange(a0: VectorShuffle, a1: VectorMask): IntVector;
          rearrange(a0: VectorShuffle): IntVector;
          rearrange(a0: VectorShuffle, a1: Vector): Vector;
          rearrange(a0: VectorShuffle, a1: VectorMask): Vector;
          rearrange(a0: VectorShuffle): Vector;
          reduceLanes(op: VectorOperators$Associative): int;
          reduceLanes(op: VectorOperators$Associative, m: VectorMask<int>): int;
          reduceLanesToLong(op: VectorOperators$Associative): long;
          reduceLanesToLong(op: VectorOperators$Associative, m: VectorMask<int>): long;
          reinterpretShape<F>(toSpecies: VectorSpecies<F>, part: int): Vector<F>;
          selectFrom(v: Vector<int>): Int512Vector;
          selectFrom(v: Vector<int>, m: VectorMask<int>): Int512Vector;
          selectFrom(a0: Vector, a1: VectorMask): IntVector;
          selectFrom(a0: Vector): IntVector;
          selectFrom(a0: Vector, a1: VectorMask): Vector;
          selectFrom(a0: Vector): Vector;
          shape(): VectorShape;
          _shuffleFromArray(indexes: int[], i: int): Int512Vector$Int512Shuffle;
          _shuffleFromArray(a0: int[], a1: int): AbstractShuffle;
          _shuffleFromBytes(reorder: byte[]): Int512Vector$Int512Shuffle;
          _shuffleFromBytes(a0: byte[]): AbstractShuffle;
          _shuffleFromOp(fn: java.util.function.IntUnaryOperator): Int512Vector$Int512Shuffle;
          _shuffleFromOp(a0: java.util.function.IntUnaryOperator): AbstractShuffle;
          slice(origin: int, v: Vector<int>): Int512Vector;
          slice(origin: int): Int512Vector;
          slice(a0: int): IntVector;
          slice(a0: int, a1: Vector): IntVector;
          slice(a0: int): AbstractVector;
          slice(a0: int, a1: Vector): AbstractVector;
          slice(a0: int): Vector;
          slice(a0: int, a1: Vector): Vector;
          _tOp(v1: Vector<int>, v2: Vector<int>, f: IntVector$FTriOp): Int512Vector;
          _tOp(v1: Vector<int>, v2: Vector<int>, m: VectorMask<int>, f: IntVector$FTriOp): Int512Vector;
          _tOp(a0: Vector, a1: Vector, a2: VectorMask, a3: IntVector$FTriOp): IntVector;
          _tOp(a0: Vector, a1: Vector, a2: IntVector$FTriOp): IntVector;
          test(op: VectorOperators$Test): Int512Vector$Int512Mask;
          test(op: VectorOperators$Test, m: VectorMask<int>): Int512Vector$Int512Mask;
          test(a0: VectorOperators$Test, a1: VectorMask): VectorMask;
          test(a0: VectorOperators$Test): VectorMask;
          toShuffle(): VectorShuffle<int>;
          _uOp(f: IntVector$FUnOp): Int512Vector;
          _uOp(m: VectorMask<int>, f: IntVector$FUnOp): Int512Vector;
          _uOp(a0: VectorMask, a1: IntVector$FUnOp): IntVector;
          _uOp(a0: IntVector$FUnOp): IntVector;
          unslice(origin: int, w: Vector<int>, part: int): Int512Vector;
          unslice(origin: int, w: Vector<int>, part: int, m: VectorMask<int>): Int512Vector;
          unslice(origin: int): Int512Vector;
          unslice(a0: int): IntVector;
          unslice(a0: int, a1: Vector, a2: int, a3: VectorMask): IntVector;
          unslice(a0: int, a1: Vector, a2: int): IntVector;
          unslice(a0: int): Vector;
          unslice(a0: int, a1: Vector, a2: int, a3: VectorMask): Vector;
          unslice(a0: int, a1: Vector, a2: int): Vector;
          _vec(): int[];
          _vectorFactory(vec: int[]): Int512Vector;
          _vectorFactory(a0: int[]): IntVector;
          vspecies(): IntVector$IntSpecies;
          vspecies(): AbstractSpecies;
          withLane(i: int, e: int): Int512Vector;
          withLane(a0: int, a1: int): IntVector;
          withLaneHelper(i: int, e: int): Int512Vector;
        }
        interface Int512Vector extends CombineTypes<[_Int512Vector, jdk.incubator.vector.IntVector]> {}
        interface _Int512Vector$Int512Mask$$static extends ClassLike {
          _maskAll(bit: boolean): Int512Vector$Int512Mask;
          _prepare(bits: boolean[], offset: int): boolean[];
          _prepare(val: boolean): boolean[];
          _ETYPE: java.lang.Class<int>;
          _FALSE_MASK: Int512Vector$Int512Mask;
          _TRUE_MASK: Int512Vector$Int512Mask;
          _VLENGTH: int;
          _new(bits: boolean[]): Int512Vector$Int512Mask;
          _new(bits: boolean[], offset: int): Int512Vector$Int512Mask;
          _new(val: boolean): Int512Vector$Int512Mask;
        }
        let Int512Vector$Int512Mask: _Int512Vector$Int512Mask$$static;
        interface _Int512Vector$Int512Mask {
          allTrue(): boolean;
          and(mask: VectorMask<int>): Int512Vector$Int512Mask;
          and(a0: VectorMask): VectorMask;
          anyTrue(): boolean;
          _bOp(m: VectorMask<int>, f: AbstractMask$MBinOp): Int512Vector$Int512Mask;
          _bOp(a0: VectorMask, a1: AbstractMask$MBinOp): AbstractMask;
          cast<E>(dsp: VectorSpecies<E>): VectorMask<E>;
          compress(): Int512Vector$Int512Mask;
          compress(): VectorMask;
          _defaultMaskCast<E>(dsp: AbstractSpecies<E>): VectorMask<E>;
          firstTrue(): int;
          _getBits(): boolean[];
          _indexPartiallyInUpperRange(offset: long, a1: long): Int512Vector$Int512Mask;
          _indexPartiallyInUpperRange(a0: long, a1: long): VectorMask;
          lastTrue(): int;
          not(): Int512Vector$Int512Mask;
          not(): VectorMask;
          or(mask: VectorMask<int>): Int512Vector$Int512Mask;
          or(a0: VectorMask): VectorMask;
          toLong(): long;
          toVector(): Int512Vector;
          toVector(): Vector;
          trueCount(): int;
          _uOp(f: AbstractMask$MUnOp): Int512Vector$Int512Mask;
          _uOp(a0: AbstractMask$MUnOp): AbstractMask;
          vspecies(): IntVector$IntSpecies;
          vspecies(): AbstractSpecies;
          xor(mask: VectorMask<int>): Int512Vector$Int512Mask;
          xor(a0: VectorMask): VectorMask;
        }
        interface Int512Vector$Int512Mask extends CombineTypes<[_Int512Vector$Int512Mask, AbstractMask<int>]> {}
        interface _Int512Vector$Int512Shuffle$$static extends ClassLike {
          _ETYPE: java.lang.Class<int>;
          _IOTA: Int512Vector$Int512Shuffle;
          _VLENGTH: int;
          _new(reorder: byte[]): Int512Vector$Int512Shuffle;
          new(reorder: int[]): Int512Vector$Int512Shuffle;
          new(reorder: int[], i: int): Int512Vector$Int512Shuffle;
          new(fn: java.util.function.IntUnaryOperator): Int512Vector$Int512Shuffle;
        }
        let Int512Vector$Int512Shuffle: _Int512Vector$Int512Shuffle$$static;
        interface _Int512Vector$Int512Shuffle {
          cast<F>(s: VectorSpecies<F>): VectorShuffle<F>;
          rearrange(shuffle: VectorShuffle<int>): Int512Vector$Int512Shuffle;
          rearrange(a0: VectorShuffle): VectorShuffle;
          toVector(): Int512Vector;
          toVector(): Vector;
          vspecies(): IntVector$IntSpecies;
          vspecies(): AbstractSpecies;
        }
        interface Int512Vector$Int512Shuffle extends CombineTypes<[_Int512Vector$Int512Shuffle, AbstractShuffle<int>]> {}
        interface _Int64Vector$$static extends ClassLike {
          _ETYPE: java.lang.Class<int>;
          _IOTA: Int64Vector;
          _VCLASS: java.lang.Class<Int64Vector>;
          _VLENGTH: int;
          _VSHAPE: VectorShape;
          _VSIZE: int;
          _VSPECIES: IntVector$IntSpecies;
          _ZERO: Int64Vector;
          _new(v: int[]): Int64Vector;
          _new(v: any): Int64Vector;
        }
        let Int64Vector: _Int64Vector$$static;
        interface _Int64Vector {
          addIndex(scale: int): Int64Vector;
          addIndex(a0: int): IntVector;
          addIndex(a0: int): Vector;
          _asByteVectorRaw(): Byte64Vector;
          _asByteVectorRaw(): ByteVector;
          _asVectorRaw(laneType: LaneType): AbstractVector<any>;
          _bOp(v: Vector<int>, f: IntVector$FBinOp): Int64Vector;
          _bOp(v: Vector<int>, m: VectorMask<int>, f: IntVector$FBinOp): Int64Vector;
          _bOp(a0: Vector, a1: VectorMask, a2: IntVector$FBinOp): IntVector;
          _bOp(a0: Vector, a1: IntVector$FBinOp): IntVector;
          bitSize(): int;
          blend(v: Vector<int>, m: VectorMask<int>): Int64Vector;
          blend(a0: Vector, a1: VectorMask): IntVector;
          blend(a0: Vector, a1: VectorMask): Vector;
          broadcast(e: int): Int64Vector;
          broadcast(e: long): Int64Vector;
          broadcast(a0: long): IntVector;
          broadcast(a0: int): IntVector;
          broadcast(a0: long): Vector;
          byteSize(): int;
          compare(op: VectorOperators$Comparison, v: Vector<int>): Int64Vector$Int64Mask;
          compare(op: VectorOperators$Comparison, s: int): Int64Vector$Int64Mask;
          compare(op: VectorOperators$Comparison, s: long): Int64Vector$Int64Mask;
          compare(op: VectorOperators$Comparison, v: Vector<int>, m: VectorMask<int>): Int64Vector$Int64Mask;
          compare(a0: VectorOperators$Comparison, a1: long): VectorMask;
          compare(a0: VectorOperators$Comparison, a1: int): VectorMask;
          compare(a0: VectorOperators$Comparison, a1: Vector): VectorMask;
          compare(a0: VectorOperators$Comparison, a1: Vector, a2: VectorMask): VectorMask;
          compress(m: VectorMask<int>): Int64Vector;
          compress(a0: VectorMask): IntVector;
          compress(a0: VectorMask): Vector;
          convertShape<F>(conv: VectorOperators$Conversion<int,F>, rsp: VectorSpecies<F>, part: int): Vector<F>;
          elementSize(): int;
          elementType(): java.lang.Class<int>;
          expand(m: VectorMask<int>): Int64Vector;
          expand(a0: VectorMask): IntVector;
          expand(a0: VectorMask): Vector;
          _fromArray0(a: int[], offset: int): IntVector;
          _fromArray0(a: int[], offset: int, m: VectorMask<int>, offsetInRange: int): IntVector;
          _fromArray0(a: int[], offset: int, indexMap: int[], mapOffset: int, m: VectorMask<int>): IntVector;
          _fromMemorySegment0(ms: java.lang.foreign.MemorySegment, offset: long): IntVector;
          _fromMemorySegment0(ms: java.lang.foreign.MemorySegment, offset: long, a2: VectorMask<int>, m: int): IntVector;
          _fromMemorySegment0(a0: java.lang.foreign.MemorySegment, a1: long): AbstractVector;
          _intoArray0(a: int[], offset: int): void;
          _intoArray0(a: int[], offset: int, m: VectorMask<int>): void;
          _intoArray0(a: int[], offset: int, indexMap: int[], mapOffset: int, m: VectorMask<int>): void;
          _intoMemorySegment0(ms: java.lang.foreign.MemorySegment, offset: long, a2: VectorMask<int>): void;
          _iotaShuffle(): Int64Vector$Int64Shuffle;
          _iotaShuffle(start: int, step: int, wrap: boolean): Int64Vector$Int64Shuffle;
          _iotaShuffle(a0: int, a1: int, a2: boolean): AbstractShuffle;
          _iotaShuffle(): AbstractShuffle;
          lane(i: int): int;
          laneHelper(i: int): int;
          lanewise(op: VectorOperators$Unary): Int64Vector;
          lanewise(op: VectorOperators$Unary, m: VectorMask<int>): Int64Vector;
          lanewise(op: VectorOperators$Binary, v: Vector<int>): Int64Vector;
          lanewise(op: VectorOperators$Binary, v: Vector<int>, m: VectorMask<int>): Int64Vector;
          lanewise(op: VectorOperators$Ternary, v1: Vector<int>, v2: Vector<int>): Int64Vector;
          lanewise(op: VectorOperators$Ternary, v1: Vector<int>, v2: Vector<int>, m: VectorMask<int>): Int64Vector;
          lanewise(a0: VectorOperators$Ternary, a1: Vector, a2: Vector, a3: VectorMask): IntVector;
          lanewise(a0: VectorOperators$Ternary, a1: Vector, a2: Vector): IntVector;
          lanewise(a0: VectorOperators$Binary, a1: Vector, a2: VectorMask): IntVector;
          lanewise(a0: VectorOperators$Binary, a1: Vector): IntVector;
          lanewise(a0: VectorOperators$Unary, a1: VectorMask): IntVector;
          lanewise(a0: VectorOperators$Unary): IntVector;
          lanewise(a0: VectorOperators$Ternary, a1: Vector, a2: Vector, a3: VectorMask): Vector;
          lanewise(a0: VectorOperators$Ternary, a1: Vector, a2: Vector): Vector;
          lanewise(a0: VectorOperators$Binary, a1: Vector, a2: VectorMask): Vector;
          lanewise(a0: VectorOperators$Binary, a1: Vector): Vector;
          lanewise(a0: VectorOperators$Unary, a1: VectorMask): Vector;
          lanewise(a0: VectorOperators$Unary): Vector;
          _lanewiseShift(op: VectorOperators$Binary, e: int): Int64Vector;
          _lanewiseShift(op: VectorOperators$Binary, e: int, m: VectorMask<int>): Int64Vector;
          _lanewiseShift(a0: VectorOperators$Binary, a1: int, a2: VectorMask): IntVector;
          _lanewiseShift(a0: VectorOperators$Binary, a1: int): IntVector;
          length(): int;
          _maskFromArray(bits: boolean[]): Int64Vector$Int64Mask;
          _maskFromArray(a0: boolean[]): AbstractMask;
          _rOp(v: int, m: VectorMask<int>, f: IntVector$FBinOp): int;
          rearrange(s: VectorShuffle<int>): Int64Vector;
          rearrange(shuffle: VectorShuffle<int>, m: VectorMask<int>): Int64Vector;
          rearrange(s: VectorShuffle<int>, v: Vector<int>): Int64Vector;
          rearrange(a0: VectorShuffle, a1: Vector): IntVector;
          rearrange(a0: VectorShuffle, a1: VectorMask): IntVector;
          rearrange(a0: VectorShuffle): IntVector;
          rearrange(a0: VectorShuffle, a1: Vector): Vector;
          rearrange(a0: VectorShuffle, a1: VectorMask): Vector;
          rearrange(a0: VectorShuffle): Vector;
          reduceLanes(op: VectorOperators$Associative): int;
          reduceLanes(op: VectorOperators$Associative, m: VectorMask<int>): int;
          reduceLanesToLong(op: VectorOperators$Associative): long;
          reduceLanesToLong(op: VectorOperators$Associative, m: VectorMask<int>): long;
          reinterpretShape<F>(toSpecies: VectorSpecies<F>, part: int): Vector<F>;
          selectFrom(v: Vector<int>): Int64Vector;
          selectFrom(v: Vector<int>, m: VectorMask<int>): Int64Vector;
          selectFrom(a0: Vector, a1: VectorMask): IntVector;
          selectFrom(a0: Vector): IntVector;
          selectFrom(a0: Vector, a1: VectorMask): Vector;
          selectFrom(a0: Vector): Vector;
          shape(): VectorShape;
          _shuffleFromArray(indexes: int[], i: int): Int64Vector$Int64Shuffle;
          _shuffleFromArray(a0: int[], a1: int): AbstractShuffle;
          _shuffleFromBytes(reorder: byte[]): Int64Vector$Int64Shuffle;
          _shuffleFromBytes(a0: byte[]): AbstractShuffle;
          _shuffleFromOp(fn: java.util.function.IntUnaryOperator): Int64Vector$Int64Shuffle;
          _shuffleFromOp(a0: java.util.function.IntUnaryOperator): AbstractShuffle;
          slice(origin: int, v: Vector<int>): Int64Vector;
          slice(origin: int): Int64Vector;
          slice(a0: int): IntVector;
          slice(a0: int, a1: Vector): IntVector;
          slice(a0: int): AbstractVector;
          slice(a0: int, a1: Vector): AbstractVector;
          slice(a0: int): Vector;
          slice(a0: int, a1: Vector): Vector;
          _tOp(v1: Vector<int>, v2: Vector<int>, f: IntVector$FTriOp): Int64Vector;
          _tOp(v1: Vector<int>, v2: Vector<int>, m: VectorMask<int>, f: IntVector$FTriOp): Int64Vector;
          _tOp(a0: Vector, a1: Vector, a2: VectorMask, a3: IntVector$FTriOp): IntVector;
          _tOp(a0: Vector, a1: Vector, a2: IntVector$FTriOp): IntVector;
          test(op: VectorOperators$Test): Int64Vector$Int64Mask;
          test(op: VectorOperators$Test, m: VectorMask<int>): Int64Vector$Int64Mask;
          test(a0: VectorOperators$Test, a1: VectorMask): VectorMask;
          test(a0: VectorOperators$Test): VectorMask;
          toShuffle(): VectorShuffle<int>;
          _uOp(f: IntVector$FUnOp): Int64Vector;
          _uOp(m: VectorMask<int>, f: IntVector$FUnOp): Int64Vector;
          _uOp(a0: VectorMask, a1: IntVector$FUnOp): IntVector;
          _uOp(a0: IntVector$FUnOp): IntVector;
          unslice(origin: int, w: Vector<int>, part: int): Int64Vector;
          unslice(origin: int, w: Vector<int>, part: int, m: VectorMask<int>): Int64Vector;
          unslice(origin: int): Int64Vector;
          unslice(a0: int): IntVector;
          unslice(a0: int, a1: Vector, a2: int, a3: VectorMask): IntVector;
          unslice(a0: int, a1: Vector, a2: int): IntVector;
          unslice(a0: int): Vector;
          unslice(a0: int, a1: Vector, a2: int, a3: VectorMask): Vector;
          unslice(a0: int, a1: Vector, a2: int): Vector;
          _vec(): int[];
          _vectorFactory(vec: int[]): Int64Vector;
          _vectorFactory(a0: int[]): IntVector;
          vspecies(): IntVector$IntSpecies;
          vspecies(): AbstractSpecies;
          withLane(i: int, e: int): Int64Vector;
          withLane(a0: int, a1: int): IntVector;
          withLaneHelper(i: int, e: int): Int64Vector;
        }
        interface Int64Vector extends CombineTypes<[_Int64Vector, jdk.incubator.vector.IntVector]> {}
        interface _Int64Vector$Int64Mask$$static extends ClassLike {
          _maskAll(bit: boolean): Int64Vector$Int64Mask;
          _prepare(bits: boolean[], offset: int): boolean[];
          _prepare(val: boolean): boolean[];
          _ETYPE: java.lang.Class<int>;
          _FALSE_MASK: Int64Vector$Int64Mask;
          _TRUE_MASK: Int64Vector$Int64Mask;
          _VLENGTH: int;
          _new(bits: boolean[]): Int64Vector$Int64Mask;
          _new(bits: boolean[], offset: int): Int64Vector$Int64Mask;
          _new(val: boolean): Int64Vector$Int64Mask;
        }
        let Int64Vector$Int64Mask: _Int64Vector$Int64Mask$$static;
        interface _Int64Vector$Int64Mask {
          allTrue(): boolean;
          and(mask: VectorMask<int>): Int64Vector$Int64Mask;
          and(a0: VectorMask): VectorMask;
          anyTrue(): boolean;
          _bOp(m: VectorMask<int>, f: AbstractMask$MBinOp): Int64Vector$Int64Mask;
          _bOp(a0: VectorMask, a1: AbstractMask$MBinOp): AbstractMask;
          cast<E>(dsp: VectorSpecies<E>): VectorMask<E>;
          compress(): Int64Vector$Int64Mask;
          compress(): VectorMask;
          _defaultMaskCast<E>(dsp: AbstractSpecies<E>): VectorMask<E>;
          firstTrue(): int;
          _getBits(): boolean[];
          _indexPartiallyInUpperRange(offset: long, a1: long): Int64Vector$Int64Mask;
          _indexPartiallyInUpperRange(a0: long, a1: long): VectorMask;
          lastTrue(): int;
          not(): Int64Vector$Int64Mask;
          not(): VectorMask;
          or(mask: VectorMask<int>): Int64Vector$Int64Mask;
          or(a0: VectorMask): VectorMask;
          toLong(): long;
          toVector(): Int64Vector;
          toVector(): Vector;
          trueCount(): int;
          _uOp(f: AbstractMask$MUnOp): Int64Vector$Int64Mask;
          _uOp(a0: AbstractMask$MUnOp): AbstractMask;
          vspecies(): IntVector$IntSpecies;
          vspecies(): AbstractSpecies;
          xor(mask: VectorMask<int>): Int64Vector$Int64Mask;
          xor(a0: VectorMask): VectorMask;
        }
        interface Int64Vector$Int64Mask extends CombineTypes<[_Int64Vector$Int64Mask, AbstractMask<int>]> {}
        interface _Int64Vector$Int64Shuffle$$static extends ClassLike {
          _ETYPE: java.lang.Class<int>;
          _IOTA: Int64Vector$Int64Shuffle;
          _VLENGTH: int;
          _new(reorder: byte[]): Int64Vector$Int64Shuffle;
          new(reorder: int[]): Int64Vector$Int64Shuffle;
          new(reorder: int[], i: int): Int64Vector$Int64Shuffle;
          new(fn: java.util.function.IntUnaryOperator): Int64Vector$Int64Shuffle;
        }
        let Int64Vector$Int64Shuffle: _Int64Vector$Int64Shuffle$$static;
        interface _Int64Vector$Int64Shuffle {
          cast<F>(s: VectorSpecies<F>): VectorShuffle<F>;
          rearrange(shuffle: VectorShuffle<int>): Int64Vector$Int64Shuffle;
          rearrange(a0: VectorShuffle): VectorShuffle;
          toVector(): Int64Vector;
          toVector(): Vector;
          vspecies(): IntVector$IntSpecies;
          vspecies(): AbstractSpecies;
        }
        interface Int64Vector$Int64Shuffle extends CombineTypes<[_Int64Vector$Int64Shuffle, AbstractShuffle<int>]> {}
        interface _IntMaxVector$$static extends ClassLike {
          _ETYPE: java.lang.Class<int>;
          _IOTA: IntMaxVector;
          _VCLASS: java.lang.Class<IntMaxVector>;
          _VLENGTH: int;
          _VSHAPE: VectorShape;
          _VSIZE: int;
          _VSPECIES: IntVector$IntSpecies;
          _ZERO: IntMaxVector;
          _new(v: int[]): IntMaxVector;
          _new(v: any): IntMaxVector;
        }
        let IntMaxVector: _IntMaxVector$$static;
        interface _IntMaxVector {
          addIndex(scale: int): IntMaxVector;
          addIndex(a0: int): IntVector;
          addIndex(a0: int): Vector;
          _asByteVectorRaw(): ByteMaxVector;
          _asByteVectorRaw(): ByteVector;
          _asVectorRaw(laneType: LaneType): AbstractVector<any>;
          _bOp(v: Vector<int>, f: IntVector$FBinOp): IntMaxVector;
          _bOp(v: Vector<int>, m: VectorMask<int>, f: IntVector$FBinOp): IntMaxVector;
          _bOp(a0: Vector, a1: VectorMask, a2: IntVector$FBinOp): IntVector;
          _bOp(a0: Vector, a1: IntVector$FBinOp): IntVector;
          bitSize(): int;
          blend(v: Vector<int>, m: VectorMask<int>): IntMaxVector;
          blend(a0: Vector, a1: VectorMask): IntVector;
          blend(a0: Vector, a1: VectorMask): Vector;
          broadcast(e: int): IntMaxVector;
          broadcast(e: long): IntMaxVector;
          broadcast(a0: long): IntVector;
          broadcast(a0: int): IntVector;
          broadcast(a0: long): Vector;
          byteSize(): int;
          compare(op: VectorOperators$Comparison, v: Vector<int>): IntMaxVector$IntMaxMask;
          compare(op: VectorOperators$Comparison, s: int): IntMaxVector$IntMaxMask;
          compare(op: VectorOperators$Comparison, s: long): IntMaxVector$IntMaxMask;
          compare(op: VectorOperators$Comparison, v: Vector<int>, m: VectorMask<int>): IntMaxVector$IntMaxMask;
          compare(a0: VectorOperators$Comparison, a1: long): VectorMask;
          compare(a0: VectorOperators$Comparison, a1: int): VectorMask;
          compare(a0: VectorOperators$Comparison, a1: Vector): VectorMask;
          compare(a0: VectorOperators$Comparison, a1: Vector, a2: VectorMask): VectorMask;
          compress(m: VectorMask<int>): IntMaxVector;
          compress(a0: VectorMask): IntVector;
          compress(a0: VectorMask): Vector;
          convertShape<F>(conv: VectorOperators$Conversion<int,F>, rsp: VectorSpecies<F>, part: int): Vector<F>;
          elementSize(): int;
          elementType(): java.lang.Class<int>;
          expand(m: VectorMask<int>): IntMaxVector;
          expand(a0: VectorMask): IntVector;
          expand(a0: VectorMask): Vector;
          _fromArray0(a: int[], offset: int): IntVector;
          _fromArray0(a: int[], offset: int, m: VectorMask<int>, offsetInRange: int): IntVector;
          _fromArray0(a: int[], offset: int, indexMap: int[], mapOffset: int, m: VectorMask<int>): IntVector;
          _fromMemorySegment0(ms: java.lang.foreign.MemorySegment, offset: long): IntVector;
          _fromMemorySegment0(ms: java.lang.foreign.MemorySegment, offset: long, a2: VectorMask<int>, m: int): IntVector;
          _fromMemorySegment0(a0: java.lang.foreign.MemorySegment, a1: long): AbstractVector;
          _intoArray0(a: int[], offset: int): void;
          _intoArray0(a: int[], offset: int, m: VectorMask<int>): void;
          _intoArray0(a: int[], offset: int, indexMap: int[], mapOffset: int, m: VectorMask<int>): void;
          _intoMemorySegment0(ms: java.lang.foreign.MemorySegment, offset: long, a2: VectorMask<int>): void;
          _iotaShuffle(): IntMaxVector$IntMaxShuffle;
          _iotaShuffle(start: int, step: int, wrap: boolean): IntMaxVector$IntMaxShuffle;
          _iotaShuffle(a0: int, a1: int, a2: boolean): AbstractShuffle;
          _iotaShuffle(): AbstractShuffle;
          lane(i: int): int;
          laneHelper(i: int): int;
          lanewise(op: VectorOperators$Unary): IntMaxVector;
          lanewise(op: VectorOperators$Unary, m: VectorMask<int>): IntMaxVector;
          lanewise(op: VectorOperators$Binary, v: Vector<int>): IntMaxVector;
          lanewise(op: VectorOperators$Binary, v: Vector<int>, m: VectorMask<int>): IntMaxVector;
          lanewise(op: VectorOperators$Ternary, v1: Vector<int>, v2: Vector<int>): IntMaxVector;
          lanewise(op: VectorOperators$Ternary, v1: Vector<int>, v2: Vector<int>, m: VectorMask<int>): IntMaxVector;
          lanewise(a0: VectorOperators$Ternary, a1: Vector, a2: Vector, a3: VectorMask): IntVector;
          lanewise(a0: VectorOperators$Ternary, a1: Vector, a2: Vector): IntVector;
          lanewise(a0: VectorOperators$Binary, a1: Vector, a2: VectorMask): IntVector;
          lanewise(a0: VectorOperators$Binary, a1: Vector): IntVector;
          lanewise(a0: VectorOperators$Unary, a1: VectorMask): IntVector;
          lanewise(a0: VectorOperators$Unary): IntVector;
          lanewise(a0: VectorOperators$Ternary, a1: Vector, a2: Vector, a3: VectorMask): Vector;
          lanewise(a0: VectorOperators$Ternary, a1: Vector, a2: Vector): Vector;
          lanewise(a0: VectorOperators$Binary, a1: Vector, a2: VectorMask): Vector;
          lanewise(a0: VectorOperators$Binary, a1: Vector): Vector;
          lanewise(a0: VectorOperators$Unary, a1: VectorMask): Vector;
          lanewise(a0: VectorOperators$Unary): Vector;
          _lanewiseShift(op: VectorOperators$Binary, e: int): IntMaxVector;
          _lanewiseShift(op: VectorOperators$Binary, e: int, m: VectorMask<int>): IntMaxVector;
          _lanewiseShift(a0: VectorOperators$Binary, a1: int, a2: VectorMask): IntVector;
          _lanewiseShift(a0: VectorOperators$Binary, a1: int): IntVector;
          length(): int;
          _maskFromArray(bits: boolean[]): IntMaxVector$IntMaxMask;
          _maskFromArray(a0: boolean[]): AbstractMask;
          _rOp(v: int, m: VectorMask<int>, f: IntVector$FBinOp): int;
          rearrange(s: VectorShuffle<int>): IntMaxVector;
          rearrange(shuffle: VectorShuffle<int>, m: VectorMask<int>): IntMaxVector;
          rearrange(s: VectorShuffle<int>, v: Vector<int>): IntMaxVector;
          rearrange(a0: VectorShuffle, a1: Vector): IntVector;
          rearrange(a0: VectorShuffle, a1: VectorMask): IntVector;
          rearrange(a0: VectorShuffle): IntVector;
          rearrange(a0: VectorShuffle, a1: Vector): Vector;
          rearrange(a0: VectorShuffle, a1: VectorMask): Vector;
          rearrange(a0: VectorShuffle): Vector;
          reduceLanes(op: VectorOperators$Associative): int;
          reduceLanes(op: VectorOperators$Associative, m: VectorMask<int>): int;
          reduceLanesToLong(op: VectorOperators$Associative): long;
          reduceLanesToLong(op: VectorOperators$Associative, m: VectorMask<int>): long;
          reinterpretShape<F>(toSpecies: VectorSpecies<F>, part: int): Vector<F>;
          selectFrom(v: Vector<int>): IntMaxVector;
          selectFrom(v: Vector<int>, m: VectorMask<int>): IntMaxVector;
          selectFrom(a0: Vector, a1: VectorMask): IntVector;
          selectFrom(a0: Vector): IntVector;
          selectFrom(a0: Vector, a1: VectorMask): Vector;
          selectFrom(a0: Vector): Vector;
          shape(): VectorShape;
          _shuffleFromArray(indexes: int[], i: int): IntMaxVector$IntMaxShuffle;
          _shuffleFromArray(a0: int[], a1: int): AbstractShuffle;
          _shuffleFromBytes(reorder: byte[]): IntMaxVector$IntMaxShuffle;
          _shuffleFromBytes(a0: byte[]): AbstractShuffle;
          _shuffleFromOp(fn: java.util.function.IntUnaryOperator): IntMaxVector$IntMaxShuffle;
          _shuffleFromOp(a0: java.util.function.IntUnaryOperator): AbstractShuffle;
          slice(origin: int, v: Vector<int>): IntMaxVector;
          slice(origin: int): IntMaxVector;
          slice(a0: int): IntVector;
          slice(a0: int, a1: Vector): IntVector;
          slice(a0: int): AbstractVector;
          slice(a0: int, a1: Vector): AbstractVector;
          slice(a0: int): Vector;
          slice(a0: int, a1: Vector): Vector;
          _tOp(v1: Vector<int>, v2: Vector<int>, f: IntVector$FTriOp): IntMaxVector;
          _tOp(v1: Vector<int>, v2: Vector<int>, m: VectorMask<int>, f: IntVector$FTriOp): IntMaxVector;
          _tOp(a0: Vector, a1: Vector, a2: VectorMask, a3: IntVector$FTriOp): IntVector;
          _tOp(a0: Vector, a1: Vector, a2: IntVector$FTriOp): IntVector;
          test(op: VectorOperators$Test): IntMaxVector$IntMaxMask;
          test(op: VectorOperators$Test, m: VectorMask<int>): IntMaxVector$IntMaxMask;
          test(a0: VectorOperators$Test, a1: VectorMask): VectorMask;
          test(a0: VectorOperators$Test): VectorMask;
          toShuffle(): VectorShuffle<int>;
          _uOp(f: IntVector$FUnOp): IntMaxVector;
          _uOp(m: VectorMask<int>, f: IntVector$FUnOp): IntMaxVector;
          _uOp(a0: VectorMask, a1: IntVector$FUnOp): IntVector;
          _uOp(a0: IntVector$FUnOp): IntVector;
          unslice(origin: int, w: Vector<int>, part: int): IntMaxVector;
          unslice(origin: int, w: Vector<int>, part: int, m: VectorMask<int>): IntMaxVector;
          unslice(origin: int): IntMaxVector;
          unslice(a0: int): IntVector;
          unslice(a0: int, a1: Vector, a2: int, a3: VectorMask): IntVector;
          unslice(a0: int, a1: Vector, a2: int): IntVector;
          unslice(a0: int): Vector;
          unslice(a0: int, a1: Vector, a2: int, a3: VectorMask): Vector;
          unslice(a0: int, a1: Vector, a2: int): Vector;
          _vec(): int[];
          _vectorFactory(vec: int[]): IntMaxVector;
          _vectorFactory(a0: int[]): IntVector;
          vspecies(): IntVector$IntSpecies;
          vspecies(): AbstractSpecies;
          withLane(i: int, e: int): IntMaxVector;
          withLane(a0: int, a1: int): IntVector;
          withLaneHelper(i: int, e: int): IntMaxVector;
        }
        interface IntMaxVector extends CombineTypes<[_IntMaxVector, jdk.incubator.vector.IntVector]> {}
        interface _IntMaxVector$IntMaxMask$$static extends ClassLike {
          _maskAll(bit: boolean): IntMaxVector$IntMaxMask;
          _maskLowerHalf(): boolean[];
          _prepare(bits: boolean[], offset: int): boolean[];
          _prepare(val: boolean): boolean[];
          _ETYPE: java.lang.Class<int>;
          _FALSE_MASK: IntMaxVector$IntMaxMask;
          _LOWER_HALF_TRUE_MASK: IntMaxVector$IntMaxMask;
          _TRUE_MASK: IntMaxVector$IntMaxMask;
          _VLENGTH: int;
          _new(bits: boolean[]): IntMaxVector$IntMaxMask;
          _new(bits: boolean[], offset: int): IntMaxVector$IntMaxMask;
          _new(val: boolean): IntMaxVector$IntMaxMask;
        }
        let IntMaxVector$IntMaxMask: _IntMaxVector$IntMaxMask$$static;
        interface _IntMaxVector$IntMaxMask {
          allTrue(): boolean;
          and(mask: VectorMask<int>): IntMaxVector$IntMaxMask;
          and(a0: VectorMask): VectorMask;
          anyTrue(): boolean;
          _bOp(m: VectorMask<int>, f: AbstractMask$MBinOp): IntMaxVector$IntMaxMask;
          _bOp(a0: VectorMask, a1: AbstractMask$MBinOp): AbstractMask;
          cast<E>(dsp: VectorSpecies<E>): VectorMask<E>;
          compress(): IntMaxVector$IntMaxMask;
          compress(): VectorMask;
          _defaultMaskCast<E>(dsp: AbstractSpecies<E>): VectorMask<E>;
          firstTrue(): int;
          _getBits(): boolean[];
          _indexPartiallyInUpperRange(offset: long, a1: long): IntMaxVector$IntMaxMask;
          _indexPartiallyInUpperRange(a0: long, a1: long): VectorMask;
          lastTrue(): int;
          not(): IntMaxVector$IntMaxMask;
          not(): VectorMask;
          or(mask: VectorMask<int>): IntMaxVector$IntMaxMask;
          or(a0: VectorMask): VectorMask;
          toLong(): long;
          toVector(): IntMaxVector;
          toVector(): Vector;
          trueCount(): int;
          _uOp(f: AbstractMask$MUnOp): IntMaxVector$IntMaxMask;
          _uOp(a0: AbstractMask$MUnOp): AbstractMask;
          vspecies(): IntVector$IntSpecies;
          vspecies(): AbstractSpecies;
          xor(mask: VectorMask<int>): IntMaxVector$IntMaxMask;
          xor(a0: VectorMask): VectorMask;
        }
        interface IntMaxVector$IntMaxMask extends CombineTypes<[_IntMaxVector$IntMaxMask, AbstractMask<int>]> {}
        interface _IntMaxVector$IntMaxShuffle$$static extends ClassLike {
          _ETYPE: java.lang.Class<int>;
          _IOTA: IntMaxVector$IntMaxShuffle;
          _VLENGTH: int;
          _new(reorder: byte[]): IntMaxVector$IntMaxShuffle;
          new(reorder: int[]): IntMaxVector$IntMaxShuffle;
          new(reorder: int[], i: int): IntMaxVector$IntMaxShuffle;
          new(fn: java.util.function.IntUnaryOperator): IntMaxVector$IntMaxShuffle;
        }
        let IntMaxVector$IntMaxShuffle: _IntMaxVector$IntMaxShuffle$$static;
        interface _IntMaxVector$IntMaxShuffle {
          cast<F>(s: VectorSpecies<F>): VectorShuffle<F>;
          rearrange(shuffle: VectorShuffle<int>): IntMaxVector$IntMaxShuffle;
          rearrange(a0: VectorShuffle): VectorShuffle;
          toVector(): IntMaxVector;
          toVector(): Vector;
          vspecies(): IntVector$IntSpecies;
          vspecies(): AbstractSpecies;
        }
        interface IntMaxVector$IntMaxShuffle extends CombineTypes<[_IntMaxVector$IntMaxShuffle, AbstractShuffle<int>]> {}
        interface _IntVector$$static extends ClassLike {
          _arrayAddress(a: int[], index: int): long;
          _binaryOperations(opc_: int): jdk.internal.vm.vector.VectorSupport$BinaryOperation<IntVector,VectorMask<int>>;
          broadcast(species: VectorSpecies<int>, e: int): IntVector;
          broadcast(species: VectorSpecies<int>, e: long): IntVector;
          _broadcastIntOperations(opc_: int): jdk.internal.vm.vector.VectorSupport$VectorBroadcastIntOp<IntVector,VectorMask<int>>;
          _byteArrayAddress(a: byte[], index: int): long;
          _checkMaskFromIndexSize(offset: int, vsp: IntVector$IntSpecies, m: VectorMask<int>, scale: int, limit: int): void;
          _checkMaskFromIndexSize(offset: long, a1: IntVector$IntSpecies, vsp: VectorMask<int>, m: int, scale: long): void;
          _compareWithOp(cond: int, a: int, b: int): boolean;
          _compressHelper(v: Vector<int>, m: VectorMask<int>): IntVector;
          _expandHelper(v: Vector<int>, m: VectorMask<int>): IntVector;
          fromArray(species: VectorSpecies<int>, a: int[], offset: int): IntVector;
          fromArray(species: VectorSpecies<int>, a: int[], offset: int, m: VectorMask<int>): IntVector;
          fromArray(species: VectorSpecies<int>, a: int[], offset: int, indexMap: int[], mapOffset: int): IntVector;
          fromArray(species: VectorSpecies<int>, a: int[], offset: int, indexMap: int[], mapOffset: int, m: VectorMask<int>): IntVector;
          _fromBits(bits: long): int;
          fromMemorySegment(species: VectorSpecies<int>, ms: java.lang.foreign.MemorySegment, offset: long, a3: java.nio.ByteOrder): IntVector;
          fromMemorySegment(species: VectorSpecies<int>, ms: java.lang.foreign.MemorySegment, offset: long, a3: java.nio.ByteOrder, bo: VectorMask<int>): IntVector;
          _memorySegmentGet(ms: java.lang.foreign.MemorySegment, o: long, a2: int): int;
          _memorySegmentSet(ms: java.lang.foreign.MemorySegment, o: long, a2: int, i: int): void;
          _opCode(op: VectorOperators$Operator): int;
          _opCode(op: VectorOperators$Operator, requireKind: int): int;
          _opKind(op: VectorOperators$Operator, bit: int): boolean;
          _reductionOperations(opc_: int): jdk.internal.vm.vector.VectorSupport$ReductionOperation<IntVector,VectorMask<int>>;
          _rotateLeft(a: int, n: int): int;
          _rotateRight(a: int, n: int): int;
          _species(s: VectorShape): IntVector$IntSpecies;
          _ternaryOperations(opc_: int): jdk.internal.vm.vector.VectorSupport$TernaryOperation<IntVector,VectorMask<int>>;
          _toBits(e: int): long;
          _unaryOperations(opc_: int): jdk.internal.vm.vector.VectorSupport$UnaryOperation<IntVector,VectorMask<int>>;
          zero(species: VectorSpecies<int>): IntVector;
          _ARRAY_BASE: long;
          _ARRAY_SHIFT: int;
          _BIN_IMPL: VectorOperators$ImplCache<VectorOperators$Binary,jdk.internal.vm.vector.VectorSupport$BinaryOperation<IntVector,VectorMask<int>>>;
          _BIN_INT_IMPL: VectorOperators$ImplCache<VectorOperators$Binary,jdk.internal.vm.vector.VectorSupport$VectorBroadcastIntOp<IntVector,VectorMask<int>>>;
          _ELEMENT_LAYOUT: java.lang.foreign.ValueLayout$OfInt;
          _FORBID_OPCODE_KIND: int;
          _LSHR_SETUP_MASK: int;
          _MAX_OR_INF: int;
          _MIN_OR_INF: int;
          _REDUCE_IMPL: VectorOperators$ImplCache<VectorOperators$Associative,jdk.internal.vm.vector.VectorSupport$ReductionOperation<IntVector,VectorMask<int>>>;
          _SHIFT_MASK: int;
          readonly SPECIES_128: VectorSpecies<int>;
          readonly SPECIES_256: VectorSpecies<int>;
          readonly SPECIES_512: VectorSpecies<int>;
          readonly SPECIES_64: VectorSpecies<int>;
          readonly SPECIES_MAX: VectorSpecies<int>;
          readonly SPECIES_PREFERRED: VectorSpecies<int>;
          _TERN_IMPL: VectorOperators$ImplCache<VectorOperators$Ternary,jdk.internal.vm.vector.VectorSupport$TernaryOperation<IntVector,VectorMask<int>>>;
          _UN_IMPL: VectorOperators$ImplCache<VectorOperators$Unary,jdk.internal.vm.vector.VectorSupport$UnaryOperation<IntVector,VectorMask<int>>>;
          _new(vec: int[]): IntVector;
        }
        let IntVector: _IntVector$$static;
        interface _IntVector {
          abs(): IntVector;
          abs(): Vector;
          add(v: Vector<int>): IntVector;
          add(e: int): IntVector;
          add(v: Vector<int>, m: VectorMask<int>): IntVector;
          add(e: int, m: VectorMask<int>): IntVector;
          add(a0: Vector, a1: VectorMask): Vector;
          add(a0: Vector): Vector;
          addIndex(a0: int): IntVector;
          addIndex(a0: int): Vector;
          _addIndexTemplate(scale: int): IntVector;
          and(v: Vector<int>): IntVector;
          and(e: int): IntVector;
          _bOp(a0: Vector<int>, a1: IntVector$FBinOp): IntVector;
          _bOp(a0: Vector<int>, a1: VectorMask<int>, a2: IntVector$FBinOp): IntVector;
          _bOpTemplate(o: Vector<int>, f: IntVector$FBinOp): IntVector;
          _bOpTemplate(o: Vector<int>, m: VectorMask<int>, f: IntVector$FBinOp): IntVector;
          _bTest(cond: int, o: Vector<int>, f: IntVector$FBinTest): AbstractMask<int>;
          bitwiseBlend(bits: Vector<int>, mask: Vector<int>): IntVector;
          bitwiseBlend(bits: int, mask: int): IntVector;
          bitwiseBlend(bits: int, mask: Vector<int>): IntVector;
          bitwiseBlend(bits: Vector<int>, mask: int): IntVector;
          blend(a0: Vector<int>, a1: VectorMask<int>): IntVector;
          blend(e: int, m: VectorMask<int>): IntVector;
          blend(e: long, a1: VectorMask<int>): IntVector;
          blend(a0: long, a1: VectorMask): Vector;
          blend(a0: Vector, a1: VectorMask): Vector;
          _blendTemplate<M>(maskType: java.lang.Class<M>, v: IntVector, m: M): IntVector;
          broadcast(a0: int): IntVector;
          broadcast(a0: long): IntVector;
          broadcast(a0: long): Vector;
          _broadcastTemplate(e: int): IntVector;
          _broadcastTemplate(e: long): IntVector;
          compare(a0: VectorOperators$Comparison, a1: Vector<int>): VectorMask<int>;
          compare(a0: VectorOperators$Comparison, a1: int): VectorMask<int>;
          compare(op: VectorOperators$Comparison, e: int, m: VectorMask<int>): VectorMask<int>;
          compare(a0: VectorOperators$Comparison, a1: long): VectorMask<int>;
          compare(op: VectorOperators$Comparison, e: long, a2: VectorMask<int>): VectorMask<int>;
          _compareTemplate<M>(maskType: java.lang.Class<M>, op: VectorOperators$Comparison, v: Vector<int>): M;
          _compareTemplate<M>(maskType: java.lang.Class<M>, op: VectorOperators$Comparison, v: Vector<int>, m: M): M;
          _compareTemplate<M>(maskType: java.lang.Class<M>, op: VectorOperators$Comparison, e: int): M;
          _compareTemplate<M>(maskType: java.lang.Class<M>, op: VectorOperators$Comparison, e: long): M;
          compress(a0: VectorMask<int>): IntVector;
          compress(a0: VectorMask): Vector;
          _compressTemplate<M>(masktype: java.lang.Class<M>, m: M): IntVector;
          _conditionalStoreNYI(offset: int, vsp: IntVector$IntSpecies, m: VectorMask<int>, scale: int, limit: int): void;
          div(v: Vector<int>): IntVector;
          div(e: int): IntVector;
          div(v: Vector<int>, m: VectorMask<int>): IntVector;
          div(e: int, m: VectorMask<int>): IntVector;
          div(a0: Vector, a1: VectorMask): Vector;
          div(a0: Vector): Vector;
          eq(v: Vector<int>): VectorMask<int>;
          eq(e: int): VectorMask<int>;
          equals(obj: any): boolean;
          expand(a0: VectorMask<int>): IntVector;
          expand(a0: VectorMask): Vector;
          _expandTemplate<M>(masktype: java.lang.Class<M>, m: M): IntVector;
          _fromArray0(a0: int[], a1: int): IntVector;
          _fromArray0(a0: int[], a1: int, a2: VectorMask<int>, a3: int): IntVector;
          _fromArray0(a0: int[], a1: int, a2: int[], a3: int, a4: VectorMask<int>): IntVector;
          _fromArray0Template(a: int[], offset: int): IntVector;
          _fromArray0Template<M>(maskClass: java.lang.Class<M>, a: int[], offset: int, m: M, offsetInRange: int): IntVector;
          _fromArray0Template<M>(maskClass: java.lang.Class<M>, a: int[], offset: int, indexMap: int[], mapOffset: int, m: M): IntVector;
          _fromMemorySegment0(a0: java.lang.foreign.MemorySegment, a1: long): IntVector;
          _fromMemorySegment0(a0: java.lang.foreign.MemorySegment, a1: long, a2: VectorMask<int>, a3: int): IntVector;
          _fromMemorySegment0(a0: java.lang.foreign.MemorySegment, a1: long): AbstractVector;
          _fromMemorySegment0Template(ms: java.lang.foreign.MemorySegment, offset: long): IntVector;
          _fromMemorySegment0Template<M>(maskClass: java.lang.Class<M>, ms: java.lang.foreign.MemorySegment, offset: long, a3: M, m: int): IntVector;
          hashCode(): int;
          intoArray(a: int[], offset: int): void;
          intoArray(a: int[], offset: int, m: VectorMask<int>): void;
          intoArray(a: int[], offset: int, indexMap: int[], mapOffset: int): void;
          intoArray(a: int[], offset: int, indexMap: int[], mapOffset: int, m: VectorMask<int>): void;
          _intoArray0(a0: int[], a1: int): void;
          _intoArray0(a0: int[], a1: int, a2: VectorMask<int>): void;
          _intoArray0(a0: int[], a1: int, a2: int[], a3: int, a4: VectorMask<int>): void;
          _intoArray0Template(a: int[], offset: int): void;
          _intoArray0Template<M>(maskClass: java.lang.Class<M>, a: int[], offset: int, m: M): void;
          _intoArray0Template<M>(maskClass: java.lang.Class<M>, a: int[], offset: int, indexMap: int[], mapOffset: int, m: M): void;
          intoMemorySegment(ms: java.lang.foreign.MemorySegment, offset: long, a2: java.nio.ByteOrder): void;
          intoMemorySegment(ms: java.lang.foreign.MemorySegment, offset: long, a2: java.nio.ByteOrder, bo: VectorMask<int>): void;
          _intoMemorySegment0(ms: java.lang.foreign.MemorySegment, offset: long): void;
          _intoMemorySegment0(a0: java.lang.foreign.MemorySegment, a1: long, a2: VectorMask<int>): void;
          _intoMemorySegment0Template<M>(maskClass: java.lang.Class<M>, ms: java.lang.foreign.MemorySegment, offset: long, a3: M): void;
          lane(a0: int): int;
          lanewise(a0: VectorOperators$Unary): IntVector;
          lanewise(a0: VectorOperators$Unary, a1: VectorMask<int>): IntVector;
          lanewise(a0: VectorOperators$Binary, a1: Vector<int>): IntVector;
          lanewise(a0: VectorOperators$Binary, a1: Vector<int>, a2: VectorMask<int>): IntVector;
          lanewise(op: VectorOperators$Binary, e: int): IntVector;
          lanewise(op: VectorOperators$Binary, e: int, m: VectorMask<int>): IntVector;
          lanewise(op: VectorOperators$Binary, e: long): IntVector;
          lanewise(op: VectorOperators$Binary, e: long, a2: VectorMask<int>): IntVector;
          lanewise(a0: VectorOperators$Ternary, a1: Vector<int>, a2: Vector<int>): IntVector;
          lanewise(a0: VectorOperators$Ternary, a1: Vector<int>, a2: Vector<int>, a3: VectorMask<int>): IntVector;
          lanewise(op: VectorOperators$Ternary, e1: int, e2: int): IntVector;
          lanewise(op: VectorOperators$Ternary, e1: int, e2: int, m: VectorMask<int>): IntVector;
          lanewise(op: VectorOperators$Ternary, v1: Vector<int>, e2: int): IntVector;
          lanewise(op: VectorOperators$Ternary, v1: Vector<int>, e2: int, m: VectorMask<int>): IntVector;
          lanewise(op: VectorOperators$Ternary, e1: int, v2: Vector<int>): IntVector;
          lanewise(op: VectorOperators$Ternary, e1: int, v2: Vector<int>, m: VectorMask<int>): IntVector;
          lanewise(a0: VectorOperators$Ternary, a1: Vector, a2: Vector, a3: VectorMask): Vector;
          lanewise(a0: VectorOperators$Ternary, a1: Vector, a2: Vector): Vector;
          lanewise(a0: VectorOperators$Binary, a1: long, a2: VectorMask): Vector;
          lanewise(a0: VectorOperators$Binary, a1: long): Vector;
          lanewise(a0: VectorOperators$Binary, a1: Vector, a2: VectorMask): Vector;
          lanewise(a0: VectorOperators$Binary, a1: Vector): Vector;
          lanewise(a0: VectorOperators$Unary, a1: VectorMask): Vector;
          lanewise(a0: VectorOperators$Unary): Vector;
          _lanewiseShift(a0: VectorOperators$Binary, a1: int): IntVector;
          _lanewiseShift(a0: VectorOperators$Binary, a1: int, a2: VectorMask<int>): IntVector;
          _lanewiseShiftTemplate(op: VectorOperators$Binary, e: int): IntVector;
          _lanewiseShiftTemplate(op: VectorOperators$Binary, maskClass: java.lang.Class<VectorMask<int>>, e: int, m: VectorMask<int>): IntVector;
          _lanewiseTemplate(op: VectorOperators$Unary): IntVector;
          _lanewiseTemplate(op: VectorOperators$Unary, maskClass: java.lang.Class<VectorMask<int>>, m: VectorMask<int>): IntVector;
          _lanewiseTemplate(op: VectorOperators$Binary, v: Vector<int>): IntVector;
          _lanewiseTemplate(op: VectorOperators$Binary, maskClass: java.lang.Class<VectorMask<int>>, v: Vector<int>, m: VectorMask<int>): IntVector;
          _lanewiseTemplate(op: VectorOperators$Ternary, v1: Vector<int>, v2: Vector<int>): IntVector;
          _lanewiseTemplate(op: VectorOperators$Ternary, maskClass: java.lang.Class<VectorMask<int>>, v1: Vector<int>, v2: Vector<int>, m: VectorMask<int>): IntVector;
          _ldLongOp(memory: java.lang.foreign.MemorySegment, offset: long, a2: IntVector$FLdLongOp): IntVector;
          _ldLongOp(memory: java.lang.foreign.MemorySegment, offset: long, a2: VectorMask<int>, m: IntVector$FLdLongOp): IntVector;
          _ldOp<M>(memory: M, offset: int, f: IntVector$FLdOp<M>): IntVector;
          _ldOp<M>(memory: M, offset: int, m: VectorMask<int>, f: IntVector$FLdOp<M>): IntVector;
          lt(v: Vector<int>): VectorMask<int>;
          lt(e: int): VectorMask<int>;
          _maskFactory(bits: boolean[]): AbstractMask<int>;
          max(v: Vector<int>): IntVector;
          max(e: int): IntVector;
          max(a0: Vector): Vector;
          _maybeSwap(bo: java.nio.ByteOrder): IntVector;
          _maybeSwap(a0: java.nio.ByteOrder): AbstractVector;
          min(v: Vector<int>): IntVector;
          min(e: int): IntVector;
          min(a0: Vector): Vector;
          mul(v: Vector<int>): IntVector;
          mul(e: int): IntVector;
          mul(v: Vector<int>, m: VectorMask<int>): IntVector;
          mul(e: int, m: VectorMask<int>): IntVector;
          mul(a0: Vector, a1: VectorMask): Vector;
          mul(a0: Vector): Vector;
          neg(): IntVector;
          neg(): Vector;
          not(): IntVector;
          or(v: Vector<int>): IntVector;
          or(e: int): IntVector;
          _rOp(a0: int, a1: VectorMask<int>, a2: IntVector$FBinOp): int;
          _rOpTemplate(v: int, m: VectorMask<int>, f: IntVector$FBinOp): int;
          _rOpTemplate(v: int, f: IntVector$FBinOp): int;
          rearrange(a0: VectorShuffle<int>): IntVector;
          rearrange(a0: VectorShuffle<int>, a1: VectorMask<int>): IntVector;
          rearrange(a0: VectorShuffle<int>, a1: Vector<int>): IntVector;
          rearrange(a0: VectorShuffle, a1: Vector): Vector;
          rearrange(a0: VectorShuffle, a1: VectorMask): Vector;
          rearrange(a0: VectorShuffle): Vector;
          _rearrangeTemplate<S>(shuffletype: java.lang.Class<S>, shuffle: S): IntVector;
          _rearrangeTemplate<S, M>(shuffletype: java.lang.Class<S>, masktype: java.lang.Class<M>, shuffle: S, m: M): IntVector;
          _rearrangeTemplate<S>(shuffletype: java.lang.Class<S>, shuffle: S, v: IntVector): IntVector;
          reduceLanes(a0: VectorOperators$Associative): int;
          reduceLanes(a0: VectorOperators$Associative, a1: VectorMask<int>): int;
          _reduceLanesTemplate(op: VectorOperators$Associative, maskClass: java.lang.Class<VectorMask<int>>, m: VectorMask<int>): int;
          _reduceLanesTemplate(op: VectorOperators$Associative): int;
          reduceLanesToLong(a0: VectorOperators$Associative): long;
          reduceLanesToLong(a0: VectorOperators$Associative, a1: VectorMask<int>): long;
          reinterpretAsBytes(): ByteVector;
          reinterpretAsDoubles(): DoubleVector;
          reinterpretAsFloats(): FloatVector;
          reinterpretAsInts(): IntVector;
          reinterpretAsLongs(): LongVector;
          reinterpretAsShorts(): ShortVector;
          selectFrom(a0: Vector<int>): IntVector;
          selectFrom(a0: Vector<int>, a1: VectorMask<int>): IntVector;
          selectFrom(a0: Vector, a1: VectorMask): Vector;
          selectFrom(a0: Vector): Vector;
          _selectFromTemplate(v: IntVector): IntVector;
          _selectFromTemplate(v: IntVector, m: AbstractMask<int>): IntVector;
          slice(a0: int, a1: Vector<int>): IntVector;
          slice(origin: int, w: Vector<int>, m: VectorMask<int>): IntVector;
          slice(a0: int): IntVector;
          slice(a0: int): AbstractVector;
          slice(a0: int, a1: Vector): AbstractVector;
          slice(a0: int): Vector;
          slice(a0: int, a1: Vector, a2: VectorMask): Vector;
          slice(a0: int, a1: Vector): Vector;
          _sliceTemplate(origin: int, v1: Vector<int>): IntVector;
          _sliceTemplate(origin: int): IntVector;
          _stLongOp(memory: java.lang.foreign.MemorySegment, offset: long, a2: IntVector$FStLongOp): void;
          _stLongOp(memory: java.lang.foreign.MemorySegment, offset: long, a2: VectorMask<int>, m: IntVector$FStLongOp): void;
          _stOp<M>(memory: M, offset: int, f: IntVector$FStOp<M>): void;
          _stOp<M>(memory: M, offset: int, m: VectorMask<int>, f: IntVector$FStOp<M>): void;
          sub(v: Vector<int>): IntVector;
          sub(e: int): IntVector;
          sub(v: Vector<int>, m: VectorMask<int>): IntVector;
          sub(e: int, m: VectorMask<int>): IntVector;
          sub(a0: Vector, a1: VectorMask): Vector;
          sub(a0: Vector): Vector;
          _tOp(a0: Vector<int>, a1: Vector<int>, a2: IntVector$FTriOp): IntVector;
          _tOp(a0: Vector<int>, a1: Vector<int>, a2: VectorMask<int>, a3: IntVector$FTriOp): IntVector;
          _tOpTemplate(o1: Vector<int>, o2: Vector<int>, f: IntVector$FTriOp): IntVector;
          _tOpTemplate(o1: Vector<int>, o2: Vector<int>, m: VectorMask<int>, f: IntVector$FTriOp): IntVector;
          test(a0: VectorOperators$Test): VectorMask<int>;
          test(a0: VectorOperators$Test, a1: VectorMask<int>): VectorMask<int>;
          _testTemplate<M>(maskType: java.lang.Class<M>, op: VectorOperators$Test): M;
          _testTemplate<M>(maskType: java.lang.Class<M>, op: VectorOperators$Test, mask: M): M;
          toArray(): int[];
          toArray(): any;
          toDoubleArray(): double[];
          toIntArray(): int[];
          toLongArray(): long[];
          _toShuffle0(dsp: IntVector$IntSpecies): VectorShuffle<int>;
          _toShuffleTemplate(shuffleType: java.lang.Class<any>): VectorShuffle<int>;
          toString(): string;
          _uOp(a0: IntVector$FUnOp): IntVector;
          _uOp(a0: VectorMask<int>, a1: IntVector$FUnOp): IntVector;
          _uOpTemplate(f: IntVector$FUnOp): IntVector;
          _uOpTemplate(m: VectorMask<int>, f: IntVector$FUnOp): IntVector;
          unslice(a0: int, a1: Vector<int>, a2: int): IntVector;
          unslice(a0: int, a1: Vector<int>, a2: int, a3: VectorMask<int>): IntVector;
          unslice(a0: int): IntVector;
          unslice(a0: int): Vector;
          unslice(a0: int, a1: Vector, a2: int, a3: VectorMask): Vector;
          unslice(a0: int, a1: Vector, a2: int): Vector;
          _unsliceTemplate(origin: int, w: Vector<int>, part: int): IntVector;
          _unsliceTemplate<M>(maskType: java.lang.Class<M>, origin: int, w: Vector<int>, part: int, m: M): IntVector;
          _unsliceTemplate(origin: int): IntVector;
          _vOp(f: IntVector$FVOp): IntVector;
          _vOp(m: VectorMask<int>, f: IntVector$FVOp): IntVector;
          _vec(): int[];
          _vectorFactory(a0: int[]): IntVector;
          viewAsFloatingLanes(): FloatVector;
          viewAsFloatingLanes(): Vector;
          viewAsIntegralLanes(): IntVector;
          viewAsIntegralLanes(): Vector;
          _vspecies(): IntVector$IntSpecies;
          _vspecies(): AbstractSpecies;
          withLane(a0: int, a1: int): IntVector;
          _wrongPartForSlice(part: int): java.lang.ArrayIndexOutOfBoundsException;
        }
        interface IntVector extends CombineTypes<[_IntVector, AbstractVector<int>]> {}
        interface _IntVector$FBinOp$$static extends ClassLike {
        }
        let IntVector$FBinOp: _IntVector$FBinOp$$static;
        interface _IntVector$FBinOp {
          apply(a0: int, a1: int, a2: int): int;
(a0: int, a1: int, a2: int): int;
        }
        interface IntVector$FBinOp extends CombineTypes<[_IntVector$FBinOp, java.lang.Object]> {}
        interface _IntVector$FBinTest$$static extends ClassLike {
        }
        let IntVector$FBinTest: _IntVector$FBinTest$$static;
        interface _IntVector$FBinTest {
          apply(a0: int, a1: int, a2: int, a3: int): boolean;
(a0: int, a1: int, a2: int, a3: int): boolean;
        }
        interface IntVector$FBinTest extends CombineTypes<[_IntVector$FBinTest, java.lang.Object]> {}
        interface _IntVector$FLdLongOp$$static extends ClassLike {
        }
        let IntVector$FLdLongOp: _IntVector$FLdLongOp$$static;
        interface _IntVector$FLdLongOp {
          apply(a0: java.lang.foreign.MemorySegment, a1: long, a2: int): int;
(a0: java.lang.foreign.MemorySegment, a1: long, a2: int): int;
        }
        interface IntVector$FLdLongOp extends CombineTypes<[_IntVector$FLdLongOp, java.lang.Object]> {}
        interface _IntVector$FLdOp$$static<M> extends ClassLike {
        }
        let IntVector$FLdOp: _IntVector$FLdOp$$static<M>;
        interface _IntVector$FLdOp<M> {
          apply(a0: M, a1: int, a2: int): int;
(a0: M, a1: int, a2: int): int;
        }
        interface IntVector$FLdOp<M> extends CombineTypes<[_IntVector$FLdOp<M>, java.lang.Object]> {}
        interface _IntVector$FStLongOp$$static extends ClassLike {
        }
        let IntVector$FStLongOp: _IntVector$FStLongOp$$static;
        interface _IntVector$FStLongOp {
          apply(a0: java.lang.foreign.MemorySegment, a1: long, a2: int, a3: int): void;
(a0: java.lang.foreign.MemorySegment, a1: long, a2: int, a3: int): void;
        }
        interface IntVector$FStLongOp extends CombineTypes<[_IntVector$FStLongOp, java.lang.Object]> {}
        interface _IntVector$FStOp$$static<M> extends ClassLike {
        }
        let IntVector$FStOp: _IntVector$FStOp$$static<M>;
        interface _IntVector$FStOp<M> {
          apply(a0: M, a1: int, a2: int, a3: int): void;
(a0: M, a1: int, a2: int, a3: int): void;
        }
        interface IntVector$FStOp<M> extends CombineTypes<[_IntVector$FStOp<M>, java.lang.Object]> {}
        interface _IntVector$FTriOp$$static extends ClassLike {
        }
        let IntVector$FTriOp: _IntVector$FTriOp$$static;
        interface _IntVector$FTriOp {
          apply(a0: int, a1: int, a2: int, a3: int): int;
(a0: int, a1: int, a2: int, a3: int): int;
        }
        interface IntVector$FTriOp extends CombineTypes<[_IntVector$FTriOp, java.lang.Object]> {}
        interface _IntVector$FUnOp$$static extends ClassLike {
        }
        let IntVector$FUnOp: _IntVector$FUnOp$$static;
        interface _IntVector$FUnOp {
          apply(a0: int, a1: int): int;
(a0: int, a1: int): int;
        }
        interface IntVector$FUnOp extends CombineTypes<[_IntVector$FUnOp, java.lang.Object]> {}
        interface _IntVector$FVOp$$static extends ClassLike {
        }
        let IntVector$FVOp: _IntVector$FVOp$$static;
        interface _IntVector$FVOp {
          apply(a0: int): int;
(a0: int): int;
        }
        interface IntVector$FVOp extends CombineTypes<[_IntVector$FVOp, java.lang.Object]> {}
        interface _IntVector$IntSpecies$$static extends ClassLike {
          _toIntegralChecked(e: int, convertToInt: boolean): long;
        }
        let IntVector$IntSpecies: _IntVector$IntSpecies$$static;
        interface _IntVector$IntSpecies {
          _broadcast(e: int): IntVector;
          broadcast(e: long): IntVector;
          broadcast(a0: long): Vector;
          _broadcastBits(bits: long): IntVector;
          _broadcastBits(a0: long): AbstractVector;
          checkValue(e: long): long;
          _dummyVector(): IntVector;
          _dummyVector(): AbstractVector;
          elementType(): java.lang.Class<int>;
          fromArray(a: any, offset: int): IntVector;
          fromArray(a0: any, a1: int): Vector;
          _fromIntValues(values: int[]): IntVector;
          _fromIntValues(a0: int[]): Vector;
          fromMemorySegment(ms: java.lang.foreign.MemorySegment, offset: long, a2: java.nio.ByteOrder): IntVector;
          fromMemorySegment(a0: java.lang.foreign.MemorySegment, a1: long, a2: java.nio.ByteOrder): Vector;
          _genericElementType(): java.lang.Class<int>;
          iota(): IntVector;
          iota(): AbstractVector;
          _ldLongOp(memory: java.lang.foreign.MemorySegment, offset: long, a2: IntVector$FLdLongOp): IntVector;
          _ldLongOp(memory: java.lang.foreign.MemorySegment, offset: long, a2: VectorMask<int>, m: IntVector$FLdLongOp): IntVector;
          _ldOp<M>(memory: M, offset: int, f: IntVector$FLdOp<M>): IntVector;
          _ldOp<M>(memory: M, offset: int, m: VectorMask<int>, f: IntVector$FLdOp<M>): IntVector;
          _longToElementBits(value: long): long;
          maskAll(bit: boolean): VectorMask<int>;
          _rvOp(f: AbstractSpecies$RVOp): IntVector;
          _rvOp(a0: AbstractSpecies$RVOp): AbstractVector;
          _stLongOp(memory: java.lang.foreign.MemorySegment, offset: long, a2: IntVector$FStLongOp): void;
          _stLongOp(memory: java.lang.foreign.MemorySegment, offset: long, a2: AbstractMask<int>, m: IntVector$FStLongOp): void;
          _stOp<M>(memory: M, offset: int, f: IntVector$FStOp<M>): void;
          _stOp<M>(memory: M, offset: int, m: AbstractMask<int>, f: IntVector$FStOp<M>): void;
          _vOp(f: IntVector$FVOp): IntVector;
          _vOp(m: VectorMask<int>, f: IntVector$FVOp): IntVector;
          vectorType(): java.lang.Class<IntVector>;
          zero(): IntVector;
          zero(): AbstractVector;
          zero(): Vector;
        }
        interface IntVector$IntSpecies extends CombineTypes<[_IntVector$IntSpecies, AbstractSpecies<int>]> {}
        interface _LaneType$$static extends ClassLike {
          _badElementType(elementType: java.lang.Class<any>, expected: any): java.lang.RuntimeException;
          _forClassOrNull(queryType: java.lang.Class<any>): LaneType;
          _of(elementType: java.lang.Class<any>): LaneType;
          _ofBasicType(bt: int): LaneType;
          _ofSlow(elementType: java.lang.Class<any>): LaneType;
          _ofSwitchKey(sk: int): LaneType;
          valueOf(name: string): LaneType;
          values(): LaneType[];
          _BT_MASK: int;
          readonly BYTE: LaneType;
          _C0_MASK: int;
          readonly DOUBLE: LaneType;
          _ENUM_FROM_BT: LaneType[];
          _ENUM_FROM_C0: LaneType[];
          _ENUM_FROM_SK: LaneType[];
          _ENUM_VALUES: LaneType[];
          readonly FLOAT: LaneType;
          readonly INT: LaneType;
          readonly LONG: LaneType;
          readonly SHORT: LaneType;
          _SK_BYTE: int;
          _SK_DOUBLE: int;
          _SK_FLOAT: int;
          _SK_INT: int;
          _SK_LIMIT: int;
          _SK_LONG: int;
          _SK_SHORT: int;
        }
        let LaneType: _LaneType$$static;
        interface _LaneType {
          _asFloating(): LaneType;
          _asIntegral(): LaneType;
          _check(expectedType: java.lang.Class<any>): LaneType;
          _check(): LaneType;
          toString(): string;
          _arrayType: java.lang.Class<any>;
          _asFloating: LaneType;
          _asIntegral: LaneType;
          _basicType: int;
          _elementKind: char;
          _elementPrecision: int;
          _elementSize: int;
          _elementSizeLog2: int;
          _elementType: java.lang.Class<any>;
          _genericElementType: java.lang.Class<any>;
          _printName: string;
          _switchKey: int;
          _typeChar: char;
        }
        interface LaneType extends CombineTypes<[_LaneType]> {}
        interface _Long128Vector$$static extends ClassLike {
          _ETYPE: java.lang.Class<long>;
          _IOTA: Long128Vector;
          _VCLASS: java.lang.Class<Long128Vector>;
          _VLENGTH: int;
          _VSHAPE: VectorShape;
          _VSIZE: int;
          _VSPECIES: LongVector$LongSpecies;
          _ZERO: Long128Vector;
          _new(v: long[]): Long128Vector;
          _new(v: any): Long128Vector;
        }
        let Long128Vector: _Long128Vector$$static;
        interface _Long128Vector {
          addIndex(scale: int): Long128Vector;
          addIndex(a0: int): LongVector;
          addIndex(a0: int): Vector;
          _asByteVectorRaw(): Byte128Vector;
          _asByteVectorRaw(): ByteVector;
          _asVectorRaw(laneType: LaneType): AbstractVector<any>;
          _bOp(v: Vector<long>, f: LongVector$FBinOp): Long128Vector;
          _bOp(v: Vector<long>, m: VectorMask<long>, f: LongVector$FBinOp): Long128Vector;
          _bOp(a0: Vector, a1: VectorMask, a2: LongVector$FBinOp): LongVector;
          _bOp(a0: Vector, a1: LongVector$FBinOp): LongVector;
          bitSize(): int;
          blend(v: Vector<long>, m: VectorMask<long>): Long128Vector;
          blend(a0: Vector, a1: VectorMask): LongVector;
          blend(a0: Vector, a1: VectorMask): Vector;
          broadcast(e: long): Long128Vector;
          broadcast(a0: long): LongVector;
          broadcast(a0: long): Vector;
          byteSize(): int;
          compare(op: VectorOperators$Comparison, v: Vector<long>): Long128Vector$Long128Mask;
          compare(op: VectorOperators$Comparison, s: long): Long128Vector$Long128Mask;
          compare(op: VectorOperators$Comparison, v: Vector<long>, m: VectorMask<long>): Long128Vector$Long128Mask;
          compare(a0: VectorOperators$Comparison, a1: long): VectorMask;
          compare(a0: VectorOperators$Comparison, a1: Vector): VectorMask;
          compare(a0: VectorOperators$Comparison, a1: Vector, a2: VectorMask): VectorMask;
          compress(m: VectorMask<long>): Long128Vector;
          compress(a0: VectorMask): LongVector;
          compress(a0: VectorMask): Vector;
          convertShape<F>(conv: VectorOperators$Conversion<long,F>, rsp: VectorSpecies<F>, part: int): Vector<F>;
          elementSize(): int;
          elementType(): java.lang.Class<long>;
          expand(m: VectorMask<long>): Long128Vector;
          expand(a0: VectorMask): LongVector;
          expand(a0: VectorMask): Vector;
          _fromArray0(a: long[], offset: int): LongVector;
          _fromArray0(a: long[], offset: int, m: VectorMask<long>, offsetInRange: int): LongVector;
          _fromArray0(a: long[], offset: int, indexMap: int[], mapOffset: int, m: VectorMask<long>): LongVector;
          _fromMemorySegment0(ms: java.lang.foreign.MemorySegment, offset: long): LongVector;
          _fromMemorySegment0(ms: java.lang.foreign.MemorySegment, offset: long, a2: VectorMask<long>, m: int): LongVector;
          _fromMemorySegment0(a0: java.lang.foreign.MemorySegment, a1: long): AbstractVector;
          _intoArray0(a: long[], offset: int): void;
          _intoArray0(a: long[], offset: int, m: VectorMask<long>): void;
          _intoArray0(a: long[], offset: int, indexMap: int[], mapOffset: int, m: VectorMask<long>): void;
          _intoMemorySegment0(ms: java.lang.foreign.MemorySegment, offset: long, a2: VectorMask<long>): void;
          _iotaShuffle(): Long128Vector$Long128Shuffle;
          _iotaShuffle(start: int, step: int, wrap: boolean): Long128Vector$Long128Shuffle;
          _iotaShuffle(a0: int, a1: int, a2: boolean): AbstractShuffle;
          _iotaShuffle(): AbstractShuffle;
          lane(i: int): long;
          laneHelper(i: int): long;
          lanewise(op: VectorOperators$Unary): Long128Vector;
          lanewise(op: VectorOperators$Unary, m: VectorMask<long>): Long128Vector;
          lanewise(op: VectorOperators$Binary, v: Vector<long>): Long128Vector;
          lanewise(op: VectorOperators$Binary, v: Vector<long>, m: VectorMask<long>): Long128Vector;
          lanewise(op: VectorOperators$Ternary, v1: Vector<long>, v2: Vector<long>): Long128Vector;
          lanewise(op: VectorOperators$Ternary, v1: Vector<long>, v2: Vector<long>, m: VectorMask<long>): Long128Vector;
          lanewise(a0: VectorOperators$Ternary, a1: Vector, a2: Vector, a3: VectorMask): LongVector;
          lanewise(a0: VectorOperators$Ternary, a1: Vector, a2: Vector): LongVector;
          lanewise(a0: VectorOperators$Binary, a1: Vector, a2: VectorMask): LongVector;
          lanewise(a0: VectorOperators$Binary, a1: Vector): LongVector;
          lanewise(a0: VectorOperators$Unary, a1: VectorMask): LongVector;
          lanewise(a0: VectorOperators$Unary): LongVector;
          lanewise(a0: VectorOperators$Ternary, a1: Vector, a2: Vector, a3: VectorMask): Vector;
          lanewise(a0: VectorOperators$Ternary, a1: Vector, a2: Vector): Vector;
          lanewise(a0: VectorOperators$Binary, a1: Vector, a2: VectorMask): Vector;
          lanewise(a0: VectorOperators$Binary, a1: Vector): Vector;
          lanewise(a0: VectorOperators$Unary, a1: VectorMask): Vector;
          lanewise(a0: VectorOperators$Unary): Vector;
          _lanewiseShift(op: VectorOperators$Binary, e: int): Long128Vector;
          _lanewiseShift(op: VectorOperators$Binary, e: int, m: VectorMask<long>): Long128Vector;
          _lanewiseShift(a0: VectorOperators$Binary, a1: int, a2: VectorMask): LongVector;
          _lanewiseShift(a0: VectorOperators$Binary, a1: int): LongVector;
          length(): int;
          _maskFromArray(bits: boolean[]): Long128Vector$Long128Mask;
          _maskFromArray(a0: boolean[]): AbstractMask;
          _rOp(v: long, a1: VectorMask<long>, m: LongVector$FBinOp): long;
          rearrange(s: VectorShuffle<long>): Long128Vector;
          rearrange(shuffle: VectorShuffle<long>, m: VectorMask<long>): Long128Vector;
          rearrange(s: VectorShuffle<long>, v: Vector<long>): Long128Vector;
          rearrange(a0: VectorShuffle, a1: Vector): LongVector;
          rearrange(a0: VectorShuffle, a1: VectorMask): LongVector;
          rearrange(a0: VectorShuffle): LongVector;
          rearrange(a0: VectorShuffle, a1: Vector): Vector;
          rearrange(a0: VectorShuffle, a1: VectorMask): Vector;
          rearrange(a0: VectorShuffle): Vector;
          reduceLanes(op: VectorOperators$Associative): long;
          reduceLanes(op: VectorOperators$Associative, m: VectorMask<long>): long;
          reduceLanesToLong(op: VectorOperators$Associative): long;
          reduceLanesToLong(op: VectorOperators$Associative, m: VectorMask<long>): long;
          reinterpretShape<F>(toSpecies: VectorSpecies<F>, part: int): Vector<F>;
          selectFrom(v: Vector<long>): Long128Vector;
          selectFrom(v: Vector<long>, m: VectorMask<long>): Long128Vector;
          selectFrom(a0: Vector, a1: VectorMask): LongVector;
          selectFrom(a0: Vector): LongVector;
          selectFrom(a0: Vector, a1: VectorMask): Vector;
          selectFrom(a0: Vector): Vector;
          shape(): VectorShape;
          _shuffleFromArray(indexes: int[], i: int): Long128Vector$Long128Shuffle;
          _shuffleFromArray(a0: int[], a1: int): AbstractShuffle;
          _shuffleFromBytes(reorder: byte[]): Long128Vector$Long128Shuffle;
          _shuffleFromBytes(a0: byte[]): AbstractShuffle;
          _shuffleFromOp(fn: java.util.function.IntUnaryOperator): Long128Vector$Long128Shuffle;
          _shuffleFromOp(a0: java.util.function.IntUnaryOperator): AbstractShuffle;
          slice(origin: int, v: Vector<long>): Long128Vector;
          slice(origin: int): Long128Vector;
          slice(a0: int): LongVector;
          slice(a0: int, a1: Vector): LongVector;
          slice(a0: int): AbstractVector;
          slice(a0: int, a1: Vector): AbstractVector;
          slice(a0: int): Vector;
          slice(a0: int, a1: Vector): Vector;
          _tOp(v1: Vector<long>, v2: Vector<long>, f: LongVector$FTriOp): Long128Vector;
          _tOp(v1: Vector<long>, v2: Vector<long>, m: VectorMask<long>, f: LongVector$FTriOp): Long128Vector;
          _tOp(a0: Vector, a1: Vector, a2: VectorMask, a3: LongVector$FTriOp): LongVector;
          _tOp(a0: Vector, a1: Vector, a2: LongVector$FTriOp): LongVector;
          test(op: VectorOperators$Test): Long128Vector$Long128Mask;
          test(op: VectorOperators$Test, m: VectorMask<long>): Long128Vector$Long128Mask;
          test(a0: VectorOperators$Test, a1: VectorMask): VectorMask;
          test(a0: VectorOperators$Test): VectorMask;
          toShuffle(): VectorShuffle<long>;
          _uOp(f: LongVector$FUnOp): Long128Vector;
          _uOp(m: VectorMask<long>, f: LongVector$FUnOp): Long128Vector;
          _uOp(a0: VectorMask, a1: LongVector$FUnOp): LongVector;
          _uOp(a0: LongVector$FUnOp): LongVector;
          unslice(origin: int, w: Vector<long>, part: int): Long128Vector;
          unslice(origin: int, w: Vector<long>, part: int, m: VectorMask<long>): Long128Vector;
          unslice(origin: int): Long128Vector;
          unslice(a0: int): LongVector;
          unslice(a0: int, a1: Vector, a2: int, a3: VectorMask): LongVector;
          unslice(a0: int, a1: Vector, a2: int): LongVector;
          unslice(a0: int): Vector;
          unslice(a0: int, a1: Vector, a2: int, a3: VectorMask): Vector;
          unslice(a0: int, a1: Vector, a2: int): Vector;
          _vec(): long[];
          _vectorFactory(vec: long[]): Long128Vector;
          _vectorFactory(a0: long[]): LongVector;
          vspecies(): LongVector$LongSpecies;
          vspecies(): AbstractSpecies;
          withLane(i: int, e: long): Long128Vector;
          withLane(a0: int, a1: long): LongVector;
          withLaneHelper(i: int, e: long): Long128Vector;
        }
        interface Long128Vector extends CombineTypes<[_Long128Vector, jdk.incubator.vector.LongVector]> {}
        interface _Long128Vector$Long128Mask$$static extends ClassLike {
          _maskAll(bit: boolean): Long128Vector$Long128Mask;
          _prepare(bits: boolean[], offset: int): boolean[];
          _prepare(val: boolean): boolean[];
          _ETYPE: java.lang.Class<long>;
          _FALSE_MASK: Long128Vector$Long128Mask;
          _TRUE_MASK: Long128Vector$Long128Mask;
          _VLENGTH: int;
          _new(bits: boolean[]): Long128Vector$Long128Mask;
          _new(bits: boolean[], offset: int): Long128Vector$Long128Mask;
          _new(val: boolean): Long128Vector$Long128Mask;
        }
        let Long128Vector$Long128Mask: _Long128Vector$Long128Mask$$static;
        interface _Long128Vector$Long128Mask {
          allTrue(): boolean;
          and(mask: VectorMask<long>): Long128Vector$Long128Mask;
          and(a0: VectorMask): VectorMask;
          anyTrue(): boolean;
          _bOp(m: VectorMask<long>, f: AbstractMask$MBinOp): Long128Vector$Long128Mask;
          _bOp(a0: VectorMask, a1: AbstractMask$MBinOp): AbstractMask;
          cast<E>(dsp: VectorSpecies<E>): VectorMask<E>;
          compress(): Long128Vector$Long128Mask;
          compress(): VectorMask;
          _defaultMaskCast<E>(dsp: AbstractSpecies<E>): VectorMask<E>;
          firstTrue(): int;
          _getBits(): boolean[];
          _indexPartiallyInUpperRange(offset: long, a1: long): Long128Vector$Long128Mask;
          _indexPartiallyInUpperRange(a0: long, a1: long): VectorMask;
          lastTrue(): int;
          not(): Long128Vector$Long128Mask;
          not(): VectorMask;
          or(mask: VectorMask<long>): Long128Vector$Long128Mask;
          or(a0: VectorMask): VectorMask;
          toLong(): long;
          toVector(): Long128Vector;
          toVector(): Vector;
          trueCount(): int;
          _uOp(f: AbstractMask$MUnOp): Long128Vector$Long128Mask;
          _uOp(a0: AbstractMask$MUnOp): AbstractMask;
          vspecies(): LongVector$LongSpecies;
          vspecies(): AbstractSpecies;
          xor(mask: VectorMask<long>): Long128Vector$Long128Mask;
          xor(a0: VectorMask): VectorMask;
        }
        interface Long128Vector$Long128Mask extends CombineTypes<[_Long128Vector$Long128Mask, AbstractMask<long>]> {}
        interface _Long128Vector$Long128Shuffle$$static extends ClassLike {
          _ETYPE: java.lang.Class<long>;
          _IOTA: Long128Vector$Long128Shuffle;
          _VLENGTH: int;
          _new(reorder: byte[]): Long128Vector$Long128Shuffle;
          new(reorder: int[]): Long128Vector$Long128Shuffle;
          new(reorder: int[], i: int): Long128Vector$Long128Shuffle;
          new(fn: java.util.function.IntUnaryOperator): Long128Vector$Long128Shuffle;
        }
        let Long128Vector$Long128Shuffle: _Long128Vector$Long128Shuffle$$static;
        interface _Long128Vector$Long128Shuffle {
          cast<F>(s: VectorSpecies<F>): VectorShuffle<F>;
          rearrange(shuffle: VectorShuffle<long>): Long128Vector$Long128Shuffle;
          rearrange(a0: VectorShuffle): VectorShuffle;
          toVector(): Long128Vector;
          toVector(): Vector;
          vspecies(): LongVector$LongSpecies;
          vspecies(): AbstractSpecies;
        }
        interface Long128Vector$Long128Shuffle extends CombineTypes<[_Long128Vector$Long128Shuffle, AbstractShuffle<long>]> {}
        interface _Long256Vector$$static extends ClassLike {
          _ETYPE: java.lang.Class<long>;
          _IOTA: Long256Vector;
          _VCLASS: java.lang.Class<Long256Vector>;
          _VLENGTH: int;
          _VSHAPE: VectorShape;
          _VSIZE: int;
          _VSPECIES: LongVector$LongSpecies;
          _ZERO: Long256Vector;
          _new(v: long[]): Long256Vector;
          _new(v: any): Long256Vector;
        }
        let Long256Vector: _Long256Vector$$static;
        interface _Long256Vector {
          addIndex(scale: int): Long256Vector;
          addIndex(a0: int): LongVector;
          addIndex(a0: int): Vector;
          _asByteVectorRaw(): Byte256Vector;
          _asByteVectorRaw(): ByteVector;
          _asVectorRaw(laneType: LaneType): AbstractVector<any>;
          _bOp(v: Vector<long>, f: LongVector$FBinOp): Long256Vector;
          _bOp(v: Vector<long>, m: VectorMask<long>, f: LongVector$FBinOp): Long256Vector;
          _bOp(a0: Vector, a1: VectorMask, a2: LongVector$FBinOp): LongVector;
          _bOp(a0: Vector, a1: LongVector$FBinOp): LongVector;
          bitSize(): int;
          blend(v: Vector<long>, m: VectorMask<long>): Long256Vector;
          blend(a0: Vector, a1: VectorMask): LongVector;
          blend(a0: Vector, a1: VectorMask): Vector;
          broadcast(e: long): Long256Vector;
          broadcast(a0: long): LongVector;
          broadcast(a0: long): Vector;
          byteSize(): int;
          compare(op: VectorOperators$Comparison, v: Vector<long>): Long256Vector$Long256Mask;
          compare(op: VectorOperators$Comparison, s: long): Long256Vector$Long256Mask;
          compare(op: VectorOperators$Comparison, v: Vector<long>, m: VectorMask<long>): Long256Vector$Long256Mask;
          compare(a0: VectorOperators$Comparison, a1: long): VectorMask;
          compare(a0: VectorOperators$Comparison, a1: Vector): VectorMask;
          compare(a0: VectorOperators$Comparison, a1: Vector, a2: VectorMask): VectorMask;
          compress(m: VectorMask<long>): Long256Vector;
          compress(a0: VectorMask): LongVector;
          compress(a0: VectorMask): Vector;
          convertShape<F>(conv: VectorOperators$Conversion<long,F>, rsp: VectorSpecies<F>, part: int): Vector<F>;
          elementSize(): int;
          elementType(): java.lang.Class<long>;
          expand(m: VectorMask<long>): Long256Vector;
          expand(a0: VectorMask): LongVector;
          expand(a0: VectorMask): Vector;
          _fromArray0(a: long[], offset: int): LongVector;
          _fromArray0(a: long[], offset: int, m: VectorMask<long>, offsetInRange: int): LongVector;
          _fromArray0(a: long[], offset: int, indexMap: int[], mapOffset: int, m: VectorMask<long>): LongVector;
          _fromMemorySegment0(ms: java.lang.foreign.MemorySegment, offset: long): LongVector;
          _fromMemorySegment0(ms: java.lang.foreign.MemorySegment, offset: long, a2: VectorMask<long>, m: int): LongVector;
          _fromMemorySegment0(a0: java.lang.foreign.MemorySegment, a1: long): AbstractVector;
          _intoArray0(a: long[], offset: int): void;
          _intoArray0(a: long[], offset: int, m: VectorMask<long>): void;
          _intoArray0(a: long[], offset: int, indexMap: int[], mapOffset: int, m: VectorMask<long>): void;
          _intoMemorySegment0(ms: java.lang.foreign.MemorySegment, offset: long, a2: VectorMask<long>): void;
          _iotaShuffle(): Long256Vector$Long256Shuffle;
          _iotaShuffle(start: int, step: int, wrap: boolean): Long256Vector$Long256Shuffle;
          _iotaShuffle(a0: int, a1: int, a2: boolean): AbstractShuffle;
          _iotaShuffle(): AbstractShuffle;
          lane(i: int): long;
          laneHelper(i: int): long;
          lanewise(op: VectorOperators$Unary): Long256Vector;
          lanewise(op: VectorOperators$Unary, m: VectorMask<long>): Long256Vector;
          lanewise(op: VectorOperators$Binary, v: Vector<long>): Long256Vector;
          lanewise(op: VectorOperators$Binary, v: Vector<long>, m: VectorMask<long>): Long256Vector;
          lanewise(op: VectorOperators$Ternary, v1: Vector<long>, v2: Vector<long>): Long256Vector;
          lanewise(op: VectorOperators$Ternary, v1: Vector<long>, v2: Vector<long>, m: VectorMask<long>): Long256Vector;
          lanewise(a0: VectorOperators$Ternary, a1: Vector, a2: Vector, a3: VectorMask): LongVector;
          lanewise(a0: VectorOperators$Ternary, a1: Vector, a2: Vector): LongVector;
          lanewise(a0: VectorOperators$Binary, a1: Vector, a2: VectorMask): LongVector;
          lanewise(a0: VectorOperators$Binary, a1: Vector): LongVector;
          lanewise(a0: VectorOperators$Unary, a1: VectorMask): LongVector;
          lanewise(a0: VectorOperators$Unary): LongVector;
          lanewise(a0: VectorOperators$Ternary, a1: Vector, a2: Vector, a3: VectorMask): Vector;
          lanewise(a0: VectorOperators$Ternary, a1: Vector, a2: Vector): Vector;
          lanewise(a0: VectorOperators$Binary, a1: Vector, a2: VectorMask): Vector;
          lanewise(a0: VectorOperators$Binary, a1: Vector): Vector;
          lanewise(a0: VectorOperators$Unary, a1: VectorMask): Vector;
          lanewise(a0: VectorOperators$Unary): Vector;
          _lanewiseShift(op: VectorOperators$Binary, e: int): Long256Vector;
          _lanewiseShift(op: VectorOperators$Binary, e: int, m: VectorMask<long>): Long256Vector;
          _lanewiseShift(a0: VectorOperators$Binary, a1: int, a2: VectorMask): LongVector;
          _lanewiseShift(a0: VectorOperators$Binary, a1: int): LongVector;
          length(): int;
          _maskFromArray(bits: boolean[]): Long256Vector$Long256Mask;
          _maskFromArray(a0: boolean[]): AbstractMask;
          _rOp(v: long, a1: VectorMask<long>, m: LongVector$FBinOp): long;
          rearrange(s: VectorShuffle<long>): Long256Vector;
          rearrange(shuffle: VectorShuffle<long>, m: VectorMask<long>): Long256Vector;
          rearrange(s: VectorShuffle<long>, v: Vector<long>): Long256Vector;
          rearrange(a0: VectorShuffle, a1: Vector): LongVector;
          rearrange(a0: VectorShuffle, a1: VectorMask): LongVector;
          rearrange(a0: VectorShuffle): LongVector;
          rearrange(a0: VectorShuffle, a1: Vector): Vector;
          rearrange(a0: VectorShuffle, a1: VectorMask): Vector;
          rearrange(a0: VectorShuffle): Vector;
          reduceLanes(op: VectorOperators$Associative): long;
          reduceLanes(op: VectorOperators$Associative, m: VectorMask<long>): long;
          reduceLanesToLong(op: VectorOperators$Associative): long;
          reduceLanesToLong(op: VectorOperators$Associative, m: VectorMask<long>): long;
          reinterpretShape<F>(toSpecies: VectorSpecies<F>, part: int): Vector<F>;
          selectFrom(v: Vector<long>): Long256Vector;
          selectFrom(v: Vector<long>, m: VectorMask<long>): Long256Vector;
          selectFrom(a0: Vector, a1: VectorMask): LongVector;
          selectFrom(a0: Vector): LongVector;
          selectFrom(a0: Vector, a1: VectorMask): Vector;
          selectFrom(a0: Vector): Vector;
          shape(): VectorShape;
          _shuffleFromArray(indexes: int[], i: int): Long256Vector$Long256Shuffle;
          _shuffleFromArray(a0: int[], a1: int): AbstractShuffle;
          _shuffleFromBytes(reorder: byte[]): Long256Vector$Long256Shuffle;
          _shuffleFromBytes(a0: byte[]): AbstractShuffle;
          _shuffleFromOp(fn: java.util.function.IntUnaryOperator): Long256Vector$Long256Shuffle;
          _shuffleFromOp(a0: java.util.function.IntUnaryOperator): AbstractShuffle;
          slice(origin: int, v: Vector<long>): Long256Vector;
          slice(origin: int): Long256Vector;
          slice(a0: int): LongVector;
          slice(a0: int, a1: Vector): LongVector;
          slice(a0: int): AbstractVector;
          slice(a0: int, a1: Vector): AbstractVector;
          slice(a0: int): Vector;
          slice(a0: int, a1: Vector): Vector;
          _tOp(v1: Vector<long>, v2: Vector<long>, f: LongVector$FTriOp): Long256Vector;
          _tOp(v1: Vector<long>, v2: Vector<long>, m: VectorMask<long>, f: LongVector$FTriOp): Long256Vector;
          _tOp(a0: Vector, a1: Vector, a2: VectorMask, a3: LongVector$FTriOp): LongVector;
          _tOp(a0: Vector, a1: Vector, a2: LongVector$FTriOp): LongVector;
          test(op: VectorOperators$Test): Long256Vector$Long256Mask;
          test(op: VectorOperators$Test, m: VectorMask<long>): Long256Vector$Long256Mask;
          test(a0: VectorOperators$Test, a1: VectorMask): VectorMask;
          test(a0: VectorOperators$Test): VectorMask;
          toShuffle(): VectorShuffle<long>;
          _uOp(f: LongVector$FUnOp): Long256Vector;
          _uOp(m: VectorMask<long>, f: LongVector$FUnOp): Long256Vector;
          _uOp(a0: VectorMask, a1: LongVector$FUnOp): LongVector;
          _uOp(a0: LongVector$FUnOp): LongVector;
          unslice(origin: int, w: Vector<long>, part: int): Long256Vector;
          unslice(origin: int, w: Vector<long>, part: int, m: VectorMask<long>): Long256Vector;
          unslice(origin: int): Long256Vector;
          unslice(a0: int): LongVector;
          unslice(a0: int, a1: Vector, a2: int, a3: VectorMask): LongVector;
          unslice(a0: int, a1: Vector, a2: int): LongVector;
          unslice(a0: int): Vector;
          unslice(a0: int, a1: Vector, a2: int, a3: VectorMask): Vector;
          unslice(a0: int, a1: Vector, a2: int): Vector;
          _vec(): long[];
          _vectorFactory(vec: long[]): Long256Vector;
          _vectorFactory(a0: long[]): LongVector;
          vspecies(): LongVector$LongSpecies;
          vspecies(): AbstractSpecies;
          withLane(i: int, e: long): Long256Vector;
          withLane(a0: int, a1: long): LongVector;
          withLaneHelper(i: int, e: long): Long256Vector;
        }
        interface Long256Vector extends CombineTypes<[_Long256Vector, jdk.incubator.vector.LongVector]> {}
        interface _Long256Vector$Long256Mask$$static extends ClassLike {
          _maskAll(bit: boolean): Long256Vector$Long256Mask;
          _prepare(bits: boolean[], offset: int): boolean[];
          _prepare(val: boolean): boolean[];
          _ETYPE: java.lang.Class<long>;
          _FALSE_MASK: Long256Vector$Long256Mask;
          _TRUE_MASK: Long256Vector$Long256Mask;
          _VLENGTH: int;
          _new(bits: boolean[]): Long256Vector$Long256Mask;
          _new(bits: boolean[], offset: int): Long256Vector$Long256Mask;
          _new(val: boolean): Long256Vector$Long256Mask;
        }
        let Long256Vector$Long256Mask: _Long256Vector$Long256Mask$$static;
        interface _Long256Vector$Long256Mask {
          allTrue(): boolean;
          and(mask: VectorMask<long>): Long256Vector$Long256Mask;
          and(a0: VectorMask): VectorMask;
          anyTrue(): boolean;
          _bOp(m: VectorMask<long>, f: AbstractMask$MBinOp): Long256Vector$Long256Mask;
          _bOp(a0: VectorMask, a1: AbstractMask$MBinOp): AbstractMask;
          cast<E>(dsp: VectorSpecies<E>): VectorMask<E>;
          compress(): Long256Vector$Long256Mask;
          compress(): VectorMask;
          _defaultMaskCast<E>(dsp: AbstractSpecies<E>): VectorMask<E>;
          firstTrue(): int;
          _getBits(): boolean[];
          _indexPartiallyInUpperRange(offset: long, a1: long): Long256Vector$Long256Mask;
          _indexPartiallyInUpperRange(a0: long, a1: long): VectorMask;
          lastTrue(): int;
          not(): Long256Vector$Long256Mask;
          not(): VectorMask;
          or(mask: VectorMask<long>): Long256Vector$Long256Mask;
          or(a0: VectorMask): VectorMask;
          toLong(): long;
          toVector(): Long256Vector;
          toVector(): Vector;
          trueCount(): int;
          _uOp(f: AbstractMask$MUnOp): Long256Vector$Long256Mask;
          _uOp(a0: AbstractMask$MUnOp): AbstractMask;
          vspecies(): LongVector$LongSpecies;
          vspecies(): AbstractSpecies;
          xor(mask: VectorMask<long>): Long256Vector$Long256Mask;
          xor(a0: VectorMask): VectorMask;
        }
        interface Long256Vector$Long256Mask extends CombineTypes<[_Long256Vector$Long256Mask, AbstractMask<long>]> {}
        interface _Long256Vector$Long256Shuffle$$static extends ClassLike {
          _ETYPE: java.lang.Class<long>;
          _IOTA: Long256Vector$Long256Shuffle;
          _VLENGTH: int;
          _new(reorder: byte[]): Long256Vector$Long256Shuffle;
          new(reorder: int[]): Long256Vector$Long256Shuffle;
          new(reorder: int[], i: int): Long256Vector$Long256Shuffle;
          new(fn: java.util.function.IntUnaryOperator): Long256Vector$Long256Shuffle;
        }
        let Long256Vector$Long256Shuffle: _Long256Vector$Long256Shuffle$$static;
        interface _Long256Vector$Long256Shuffle {
          cast<F>(s: VectorSpecies<F>): VectorShuffle<F>;
          rearrange(shuffle: VectorShuffle<long>): Long256Vector$Long256Shuffle;
          rearrange(a0: VectorShuffle): VectorShuffle;
          toVector(): Long256Vector;
          toVector(): Vector;
          vspecies(): LongVector$LongSpecies;
          vspecies(): AbstractSpecies;
        }
        interface Long256Vector$Long256Shuffle extends CombineTypes<[_Long256Vector$Long256Shuffle, AbstractShuffle<long>]> {}
        interface _Long512Vector$$static extends ClassLike {
          _ETYPE: java.lang.Class<long>;
          _IOTA: Long512Vector;
          _VCLASS: java.lang.Class<Long512Vector>;
          _VLENGTH: int;
          _VSHAPE: VectorShape;
          _VSIZE: int;
          _VSPECIES: LongVector$LongSpecies;
          _ZERO: Long512Vector;
          _new(v: long[]): Long512Vector;
          _new(v: any): Long512Vector;
        }
        let Long512Vector: _Long512Vector$$static;
        interface _Long512Vector {
          addIndex(scale: int): Long512Vector;
          addIndex(a0: int): LongVector;
          addIndex(a0: int): Vector;
          _asByteVectorRaw(): Byte512Vector;
          _asByteVectorRaw(): ByteVector;
          _asVectorRaw(laneType: LaneType): AbstractVector<any>;
          _bOp(v: Vector<long>, f: LongVector$FBinOp): Long512Vector;
          _bOp(v: Vector<long>, m: VectorMask<long>, f: LongVector$FBinOp): Long512Vector;
          _bOp(a0: Vector, a1: VectorMask, a2: LongVector$FBinOp): LongVector;
          _bOp(a0: Vector, a1: LongVector$FBinOp): LongVector;
          bitSize(): int;
          blend(v: Vector<long>, m: VectorMask<long>): Long512Vector;
          blend(a0: Vector, a1: VectorMask): LongVector;
          blend(a0: Vector, a1: VectorMask): Vector;
          broadcast(e: long): Long512Vector;
          broadcast(a0: long): LongVector;
          broadcast(a0: long): Vector;
          byteSize(): int;
          compare(op: VectorOperators$Comparison, v: Vector<long>): Long512Vector$Long512Mask;
          compare(op: VectorOperators$Comparison, s: long): Long512Vector$Long512Mask;
          compare(op: VectorOperators$Comparison, v: Vector<long>, m: VectorMask<long>): Long512Vector$Long512Mask;
          compare(a0: VectorOperators$Comparison, a1: long): VectorMask;
          compare(a0: VectorOperators$Comparison, a1: Vector): VectorMask;
          compare(a0: VectorOperators$Comparison, a1: Vector, a2: VectorMask): VectorMask;
          compress(m: VectorMask<long>): Long512Vector;
          compress(a0: VectorMask): LongVector;
          compress(a0: VectorMask): Vector;
          convertShape<F>(conv: VectorOperators$Conversion<long,F>, rsp: VectorSpecies<F>, part: int): Vector<F>;
          elementSize(): int;
          elementType(): java.lang.Class<long>;
          expand(m: VectorMask<long>): Long512Vector;
          expand(a0: VectorMask): LongVector;
          expand(a0: VectorMask): Vector;
          _fromArray0(a: long[], offset: int): LongVector;
          _fromArray0(a: long[], offset: int, m: VectorMask<long>, offsetInRange: int): LongVector;
          _fromArray0(a: long[], offset: int, indexMap: int[], mapOffset: int, m: VectorMask<long>): LongVector;
          _fromMemorySegment0(ms: java.lang.foreign.MemorySegment, offset: long): LongVector;
          _fromMemorySegment0(ms: java.lang.foreign.MemorySegment, offset: long, a2: VectorMask<long>, m: int): LongVector;
          _fromMemorySegment0(a0: java.lang.foreign.MemorySegment, a1: long): AbstractVector;
          _intoArray0(a: long[], offset: int): void;
          _intoArray0(a: long[], offset: int, m: VectorMask<long>): void;
          _intoArray0(a: long[], offset: int, indexMap: int[], mapOffset: int, m: VectorMask<long>): void;
          _intoMemorySegment0(ms: java.lang.foreign.MemorySegment, offset: long, a2: VectorMask<long>): void;
          _iotaShuffle(): Long512Vector$Long512Shuffle;
          _iotaShuffle(start: int, step: int, wrap: boolean): Long512Vector$Long512Shuffle;
          _iotaShuffle(a0: int, a1: int, a2: boolean): AbstractShuffle;
          _iotaShuffle(): AbstractShuffle;
          lane(i: int): long;
          laneHelper(i: int): long;
          lanewise(op: VectorOperators$Unary): Long512Vector;
          lanewise(op: VectorOperators$Unary, m: VectorMask<long>): Long512Vector;
          lanewise(op: VectorOperators$Binary, v: Vector<long>): Long512Vector;
          lanewise(op: VectorOperators$Binary, v: Vector<long>, m: VectorMask<long>): Long512Vector;
          lanewise(op: VectorOperators$Ternary, v1: Vector<long>, v2: Vector<long>): Long512Vector;
          lanewise(op: VectorOperators$Ternary, v1: Vector<long>, v2: Vector<long>, m: VectorMask<long>): Long512Vector;
          lanewise(a0: VectorOperators$Ternary, a1: Vector, a2: Vector, a3: VectorMask): LongVector;
          lanewise(a0: VectorOperators$Ternary, a1: Vector, a2: Vector): LongVector;
          lanewise(a0: VectorOperators$Binary, a1: Vector, a2: VectorMask): LongVector;
          lanewise(a0: VectorOperators$Binary, a1: Vector): LongVector;
          lanewise(a0: VectorOperators$Unary, a1: VectorMask): LongVector;
          lanewise(a0: VectorOperators$Unary): LongVector;
          lanewise(a0: VectorOperators$Ternary, a1: Vector, a2: Vector, a3: VectorMask): Vector;
          lanewise(a0: VectorOperators$Ternary, a1: Vector, a2: Vector): Vector;
          lanewise(a0: VectorOperators$Binary, a1: Vector, a2: VectorMask): Vector;
          lanewise(a0: VectorOperators$Binary, a1: Vector): Vector;
          lanewise(a0: VectorOperators$Unary, a1: VectorMask): Vector;
          lanewise(a0: VectorOperators$Unary): Vector;
          _lanewiseShift(op: VectorOperators$Binary, e: int): Long512Vector;
          _lanewiseShift(op: VectorOperators$Binary, e: int, m: VectorMask<long>): Long512Vector;
          _lanewiseShift(a0: VectorOperators$Binary, a1: int, a2: VectorMask): LongVector;
          _lanewiseShift(a0: VectorOperators$Binary, a1: int): LongVector;
          length(): int;
          _maskFromArray(bits: boolean[]): Long512Vector$Long512Mask;
          _maskFromArray(a0: boolean[]): AbstractMask;
          _rOp(v: long, a1: VectorMask<long>, m: LongVector$FBinOp): long;
          rearrange(s: VectorShuffle<long>): Long512Vector;
          rearrange(shuffle: VectorShuffle<long>, m: VectorMask<long>): Long512Vector;
          rearrange(s: VectorShuffle<long>, v: Vector<long>): Long512Vector;
          rearrange(a0: VectorShuffle, a1: Vector): LongVector;
          rearrange(a0: VectorShuffle, a1: VectorMask): LongVector;
          rearrange(a0: VectorShuffle): LongVector;
          rearrange(a0: VectorShuffle, a1: Vector): Vector;
          rearrange(a0: VectorShuffle, a1: VectorMask): Vector;
          rearrange(a0: VectorShuffle): Vector;
          reduceLanes(op: VectorOperators$Associative): long;
          reduceLanes(op: VectorOperators$Associative, m: VectorMask<long>): long;
          reduceLanesToLong(op: VectorOperators$Associative): long;
          reduceLanesToLong(op: VectorOperators$Associative, m: VectorMask<long>): long;
          reinterpretShape<F>(toSpecies: VectorSpecies<F>, part: int): Vector<F>;
          selectFrom(v: Vector<long>): Long512Vector;
          selectFrom(v: Vector<long>, m: VectorMask<long>): Long512Vector;
          selectFrom(a0: Vector, a1: VectorMask): LongVector;
          selectFrom(a0: Vector): LongVector;
          selectFrom(a0: Vector, a1: VectorMask): Vector;
          selectFrom(a0: Vector): Vector;
          shape(): VectorShape;
          _shuffleFromArray(indexes: int[], i: int): Long512Vector$Long512Shuffle;
          _shuffleFromArray(a0: int[], a1: int): AbstractShuffle;
          _shuffleFromBytes(reorder: byte[]): Long512Vector$Long512Shuffle;
          _shuffleFromBytes(a0: byte[]): AbstractShuffle;
          _shuffleFromOp(fn: java.util.function.IntUnaryOperator): Long512Vector$Long512Shuffle;
          _shuffleFromOp(a0: java.util.function.IntUnaryOperator): AbstractShuffle;
          slice(origin: int, v: Vector<long>): Long512Vector;
          slice(origin: int): Long512Vector;
          slice(a0: int): LongVector;
          slice(a0: int, a1: Vector): LongVector;
          slice(a0: int): AbstractVector;
          slice(a0: int, a1: Vector): AbstractVector;
          slice(a0: int): Vector;
          slice(a0: int, a1: Vector): Vector;
          _tOp(v1: Vector<long>, v2: Vector<long>, f: LongVector$FTriOp): Long512Vector;
          _tOp(v1: Vector<long>, v2: Vector<long>, m: VectorMask<long>, f: LongVector$FTriOp): Long512Vector;
          _tOp(a0: Vector, a1: Vector, a2: VectorMask, a3: LongVector$FTriOp): LongVector;
          _tOp(a0: Vector, a1: Vector, a2: LongVector$FTriOp): LongVector;
          test(op: VectorOperators$Test): Long512Vector$Long512Mask;
          test(op: VectorOperators$Test, m: VectorMask<long>): Long512Vector$Long512Mask;
          test(a0: VectorOperators$Test, a1: VectorMask): VectorMask;
          test(a0: VectorOperators$Test): VectorMask;
          toShuffle(): VectorShuffle<long>;
          _uOp(f: LongVector$FUnOp): Long512Vector;
          _uOp(m: VectorMask<long>, f: LongVector$FUnOp): Long512Vector;
          _uOp(a0: VectorMask, a1: LongVector$FUnOp): LongVector;
          _uOp(a0: LongVector$FUnOp): LongVector;
          unslice(origin: int, w: Vector<long>, part: int): Long512Vector;
          unslice(origin: int, w: Vector<long>, part: int, m: VectorMask<long>): Long512Vector;
          unslice(origin: int): Long512Vector;
          unslice(a0: int): LongVector;
          unslice(a0: int, a1: Vector, a2: int, a3: VectorMask): LongVector;
          unslice(a0: int, a1: Vector, a2: int): LongVector;
          unslice(a0: int): Vector;
          unslice(a0: int, a1: Vector, a2: int, a3: VectorMask): Vector;
          unslice(a0: int, a1: Vector, a2: int): Vector;
          _vec(): long[];
          _vectorFactory(vec: long[]): Long512Vector;
          _vectorFactory(a0: long[]): LongVector;
          vspecies(): LongVector$LongSpecies;
          vspecies(): AbstractSpecies;
          withLane(i: int, e: long): Long512Vector;
          withLane(a0: int, a1: long): LongVector;
          withLaneHelper(i: int, e: long): Long512Vector;
        }
        interface Long512Vector extends CombineTypes<[_Long512Vector, jdk.incubator.vector.LongVector]> {}
        interface _Long512Vector$Long512Mask$$static extends ClassLike {
          _maskAll(bit: boolean): Long512Vector$Long512Mask;
          _prepare(bits: boolean[], offset: int): boolean[];
          _prepare(val: boolean): boolean[];
          _ETYPE: java.lang.Class<long>;
          _FALSE_MASK: Long512Vector$Long512Mask;
          _TRUE_MASK: Long512Vector$Long512Mask;
          _VLENGTH: int;
          _new(bits: boolean[]): Long512Vector$Long512Mask;
          _new(bits: boolean[], offset: int): Long512Vector$Long512Mask;
          _new(val: boolean): Long512Vector$Long512Mask;
        }
        let Long512Vector$Long512Mask: _Long512Vector$Long512Mask$$static;
        interface _Long512Vector$Long512Mask {
          allTrue(): boolean;
          and(mask: VectorMask<long>): Long512Vector$Long512Mask;
          and(a0: VectorMask): VectorMask;
          anyTrue(): boolean;
          _bOp(m: VectorMask<long>, f: AbstractMask$MBinOp): Long512Vector$Long512Mask;
          _bOp(a0: VectorMask, a1: AbstractMask$MBinOp): AbstractMask;
          cast<E>(dsp: VectorSpecies<E>): VectorMask<E>;
          compress(): Long512Vector$Long512Mask;
          compress(): VectorMask;
          _defaultMaskCast<E>(dsp: AbstractSpecies<E>): VectorMask<E>;
          firstTrue(): int;
          _getBits(): boolean[];
          _indexPartiallyInUpperRange(offset: long, a1: long): Long512Vector$Long512Mask;
          _indexPartiallyInUpperRange(a0: long, a1: long): VectorMask;
          lastTrue(): int;
          not(): Long512Vector$Long512Mask;
          not(): VectorMask;
          or(mask: VectorMask<long>): Long512Vector$Long512Mask;
          or(a0: VectorMask): VectorMask;
          toLong(): long;
          toVector(): Long512Vector;
          toVector(): Vector;
          trueCount(): int;
          _uOp(f: AbstractMask$MUnOp): Long512Vector$Long512Mask;
          _uOp(a0: AbstractMask$MUnOp): AbstractMask;
          vspecies(): LongVector$LongSpecies;
          vspecies(): AbstractSpecies;
          xor(mask: VectorMask<long>): Long512Vector$Long512Mask;
          xor(a0: VectorMask): VectorMask;
        }
        interface Long512Vector$Long512Mask extends CombineTypes<[_Long512Vector$Long512Mask, AbstractMask<long>]> {}
        interface _Long512Vector$Long512Shuffle$$static extends ClassLike {
          _ETYPE: java.lang.Class<long>;
          _IOTA: Long512Vector$Long512Shuffle;
          _VLENGTH: int;
          _new(reorder: byte[]): Long512Vector$Long512Shuffle;
          new(reorder: int[]): Long512Vector$Long512Shuffle;
          new(reorder: int[], i: int): Long512Vector$Long512Shuffle;
          new(fn: java.util.function.IntUnaryOperator): Long512Vector$Long512Shuffle;
        }
        let Long512Vector$Long512Shuffle: _Long512Vector$Long512Shuffle$$static;
        interface _Long512Vector$Long512Shuffle {
          cast<F>(s: VectorSpecies<F>): VectorShuffle<F>;
          rearrange(shuffle: VectorShuffle<long>): Long512Vector$Long512Shuffle;
          rearrange(a0: VectorShuffle): VectorShuffle;
          toVector(): Long512Vector;
          toVector(): Vector;
          vspecies(): LongVector$LongSpecies;
          vspecies(): AbstractSpecies;
        }
        interface Long512Vector$Long512Shuffle extends CombineTypes<[_Long512Vector$Long512Shuffle, AbstractShuffle<long>]> {}
        interface _Long64Vector$$static extends ClassLike {
          _ETYPE: java.lang.Class<long>;
          _IOTA: Long64Vector;
          _VCLASS: java.lang.Class<Long64Vector>;
          _VLENGTH: int;
          _VSHAPE: VectorShape;
          _VSIZE: int;
          _VSPECIES: LongVector$LongSpecies;
          _ZERO: Long64Vector;
          _new(v: long[]): Long64Vector;
          _new(v: any): Long64Vector;
        }
        let Long64Vector: _Long64Vector$$static;
        interface _Long64Vector {
          addIndex(scale: int): Long64Vector;
          addIndex(a0: int): LongVector;
          addIndex(a0: int): Vector;
          _asByteVectorRaw(): Byte64Vector;
          _asByteVectorRaw(): ByteVector;
          _asVectorRaw(laneType: LaneType): AbstractVector<any>;
          _bOp(v: Vector<long>, f: LongVector$FBinOp): Long64Vector;
          _bOp(v: Vector<long>, m: VectorMask<long>, f: LongVector$FBinOp): Long64Vector;
          _bOp(a0: Vector, a1: VectorMask, a2: LongVector$FBinOp): LongVector;
          _bOp(a0: Vector, a1: LongVector$FBinOp): LongVector;
          bitSize(): int;
          blend(v: Vector<long>, m: VectorMask<long>): Long64Vector;
          blend(a0: Vector, a1: VectorMask): LongVector;
          blend(a0: Vector, a1: VectorMask): Vector;
          broadcast(e: long): Long64Vector;
          broadcast(a0: long): LongVector;
          broadcast(a0: long): Vector;
          byteSize(): int;
          compare(op: VectorOperators$Comparison, v: Vector<long>): Long64Vector$Long64Mask;
          compare(op: VectorOperators$Comparison, s: long): Long64Vector$Long64Mask;
          compare(op: VectorOperators$Comparison, v: Vector<long>, m: VectorMask<long>): Long64Vector$Long64Mask;
          compare(a0: VectorOperators$Comparison, a1: long): VectorMask;
          compare(a0: VectorOperators$Comparison, a1: Vector): VectorMask;
          compare(a0: VectorOperators$Comparison, a1: Vector, a2: VectorMask): VectorMask;
          compress(m: VectorMask<long>): Long64Vector;
          compress(a0: VectorMask): LongVector;
          compress(a0: VectorMask): Vector;
          convertShape<F>(conv: VectorOperators$Conversion<long,F>, rsp: VectorSpecies<F>, part: int): Vector<F>;
          elementSize(): int;
          elementType(): java.lang.Class<long>;
          expand(m: VectorMask<long>): Long64Vector;
          expand(a0: VectorMask): LongVector;
          expand(a0: VectorMask): Vector;
          _fromArray0(a: long[], offset: int): LongVector;
          _fromArray0(a: long[], offset: int, m: VectorMask<long>, offsetInRange: int): LongVector;
          _fromArray0(a: long[], offset: int, indexMap: int[], mapOffset: int, m: VectorMask<long>): LongVector;
          _fromMemorySegment0(ms: java.lang.foreign.MemorySegment, offset: long): LongVector;
          _fromMemorySegment0(ms: java.lang.foreign.MemorySegment, offset: long, a2: VectorMask<long>, m: int): LongVector;
          _fromMemorySegment0(a0: java.lang.foreign.MemorySegment, a1: long): AbstractVector;
          _intoArray0(a: long[], offset: int): void;
          _intoArray0(a: long[], offset: int, m: VectorMask<long>): void;
          _intoArray0(a: long[], offset: int, indexMap: int[], mapOffset: int, m: VectorMask<long>): void;
          _intoMemorySegment0(ms: java.lang.foreign.MemorySegment, offset: long, a2: VectorMask<long>): void;
          _iotaShuffle(): Long64Vector$Long64Shuffle;
          _iotaShuffle(start: int, step: int, wrap: boolean): Long64Vector$Long64Shuffle;
          _iotaShuffle(a0: int, a1: int, a2: boolean): AbstractShuffle;
          _iotaShuffle(): AbstractShuffle;
          lane(i: int): long;
          laneHelper(i: int): long;
          lanewise(op: VectorOperators$Unary): Long64Vector;
          lanewise(op: VectorOperators$Unary, m: VectorMask<long>): Long64Vector;
          lanewise(op: VectorOperators$Binary, v: Vector<long>): Long64Vector;
          lanewise(op: VectorOperators$Binary, v: Vector<long>, m: VectorMask<long>): Long64Vector;
          lanewise(op: VectorOperators$Ternary, v1: Vector<long>, v2: Vector<long>): Long64Vector;
          lanewise(op: VectorOperators$Ternary, v1: Vector<long>, v2: Vector<long>, m: VectorMask<long>): Long64Vector;
          lanewise(a0: VectorOperators$Ternary, a1: Vector, a2: Vector, a3: VectorMask): LongVector;
          lanewise(a0: VectorOperators$Ternary, a1: Vector, a2: Vector): LongVector;
          lanewise(a0: VectorOperators$Binary, a1: Vector, a2: VectorMask): LongVector;
          lanewise(a0: VectorOperators$Binary, a1: Vector): LongVector;
          lanewise(a0: VectorOperators$Unary, a1: VectorMask): LongVector;
          lanewise(a0: VectorOperators$Unary): LongVector;
          lanewise(a0: VectorOperators$Ternary, a1: Vector, a2: Vector, a3: VectorMask): Vector;
          lanewise(a0: VectorOperators$Ternary, a1: Vector, a2: Vector): Vector;
          lanewise(a0: VectorOperators$Binary, a1: Vector, a2: VectorMask): Vector;
          lanewise(a0: VectorOperators$Binary, a1: Vector): Vector;
          lanewise(a0: VectorOperators$Unary, a1: VectorMask): Vector;
          lanewise(a0: VectorOperators$Unary): Vector;
          _lanewiseShift(op: VectorOperators$Binary, e: int): Long64Vector;
          _lanewiseShift(op: VectorOperators$Binary, e: int, m: VectorMask<long>): Long64Vector;
          _lanewiseShift(a0: VectorOperators$Binary, a1: int, a2: VectorMask): LongVector;
          _lanewiseShift(a0: VectorOperators$Binary, a1: int): LongVector;
          length(): int;
          _maskFromArray(bits: boolean[]): Long64Vector$Long64Mask;
          _maskFromArray(a0: boolean[]): AbstractMask;
          _rOp(v: long, a1: VectorMask<long>, m: LongVector$FBinOp): long;
          rearrange(s: VectorShuffle<long>): Long64Vector;
          rearrange(shuffle: VectorShuffle<long>, m: VectorMask<long>): Long64Vector;
          rearrange(s: VectorShuffle<long>, v: Vector<long>): Long64Vector;
          rearrange(a0: VectorShuffle, a1: Vector): LongVector;
          rearrange(a0: VectorShuffle, a1: VectorMask): LongVector;
          rearrange(a0: VectorShuffle): LongVector;
          rearrange(a0: VectorShuffle, a1: Vector): Vector;
          rearrange(a0: VectorShuffle, a1: VectorMask): Vector;
          rearrange(a0: VectorShuffle): Vector;
          reduceLanes(op: VectorOperators$Associative): long;
          reduceLanes(op: VectorOperators$Associative, m: VectorMask<long>): long;
          reduceLanesToLong(op: VectorOperators$Associative): long;
          reduceLanesToLong(op: VectorOperators$Associative, m: VectorMask<long>): long;
          reinterpretShape<F>(toSpecies: VectorSpecies<F>, part: int): Vector<F>;
          selectFrom(v: Vector<long>): Long64Vector;
          selectFrom(v: Vector<long>, m: VectorMask<long>): Long64Vector;
          selectFrom(a0: Vector, a1: VectorMask): LongVector;
          selectFrom(a0: Vector): LongVector;
          selectFrom(a0: Vector, a1: VectorMask): Vector;
          selectFrom(a0: Vector): Vector;
          shape(): VectorShape;
          _shuffleFromArray(indexes: int[], i: int): Long64Vector$Long64Shuffle;
          _shuffleFromArray(a0: int[], a1: int): AbstractShuffle;
          _shuffleFromBytes(reorder: byte[]): Long64Vector$Long64Shuffle;
          _shuffleFromBytes(a0: byte[]): AbstractShuffle;
          _shuffleFromOp(fn: java.util.function.IntUnaryOperator): Long64Vector$Long64Shuffle;
          _shuffleFromOp(a0: java.util.function.IntUnaryOperator): AbstractShuffle;
          slice(origin: int, v: Vector<long>): Long64Vector;
          slice(origin: int): Long64Vector;
          slice(a0: int): LongVector;
          slice(a0: int, a1: Vector): LongVector;
          slice(a0: int): AbstractVector;
          slice(a0: int, a1: Vector): AbstractVector;
          slice(a0: int): Vector;
          slice(a0: int, a1: Vector): Vector;
          _tOp(v1: Vector<long>, v2: Vector<long>, f: LongVector$FTriOp): Long64Vector;
          _tOp(v1: Vector<long>, v2: Vector<long>, m: VectorMask<long>, f: LongVector$FTriOp): Long64Vector;
          _tOp(a0: Vector, a1: Vector, a2: VectorMask, a3: LongVector$FTriOp): LongVector;
          _tOp(a0: Vector, a1: Vector, a2: LongVector$FTriOp): LongVector;
          test(op: VectorOperators$Test): Long64Vector$Long64Mask;
          test(op: VectorOperators$Test, m: VectorMask<long>): Long64Vector$Long64Mask;
          test(a0: VectorOperators$Test, a1: VectorMask): VectorMask;
          test(a0: VectorOperators$Test): VectorMask;
          toShuffle(): VectorShuffle<long>;
          _uOp(f: LongVector$FUnOp): Long64Vector;
          _uOp(m: VectorMask<long>, f: LongVector$FUnOp): Long64Vector;
          _uOp(a0: VectorMask, a1: LongVector$FUnOp): LongVector;
          _uOp(a0: LongVector$FUnOp): LongVector;
          unslice(origin: int, w: Vector<long>, part: int): Long64Vector;
          unslice(origin: int, w: Vector<long>, part: int, m: VectorMask<long>): Long64Vector;
          unslice(origin: int): Long64Vector;
          unslice(a0: int): LongVector;
          unslice(a0: int, a1: Vector, a2: int, a3: VectorMask): LongVector;
          unslice(a0: int, a1: Vector, a2: int): LongVector;
          unslice(a0: int): Vector;
          unslice(a0: int, a1: Vector, a2: int, a3: VectorMask): Vector;
          unslice(a0: int, a1: Vector, a2: int): Vector;
          _vec(): long[];
          _vectorFactory(vec: long[]): Long64Vector;
          _vectorFactory(a0: long[]): LongVector;
          vspecies(): LongVector$LongSpecies;
          vspecies(): AbstractSpecies;
          withLane(i: int, e: long): Long64Vector;
          withLane(a0: int, a1: long): LongVector;
          withLaneHelper(i: int, e: long): Long64Vector;
        }
        interface Long64Vector extends CombineTypes<[_Long64Vector, jdk.incubator.vector.LongVector]> {}
        interface _Long64Vector$Long64Mask$$static extends ClassLike {
          _maskAll(bit: boolean): Long64Vector$Long64Mask;
          _prepare(bits: boolean[], offset: int): boolean[];
          _prepare(val: boolean): boolean[];
          _ETYPE: java.lang.Class<long>;
          _FALSE_MASK: Long64Vector$Long64Mask;
          _TRUE_MASK: Long64Vector$Long64Mask;
          _VLENGTH: int;
          _new(bits: boolean[]): Long64Vector$Long64Mask;
          _new(bits: boolean[], offset: int): Long64Vector$Long64Mask;
          _new(val: boolean): Long64Vector$Long64Mask;
        }
        let Long64Vector$Long64Mask: _Long64Vector$Long64Mask$$static;
        interface _Long64Vector$Long64Mask {
          allTrue(): boolean;
          and(mask: VectorMask<long>): Long64Vector$Long64Mask;
          and(a0: VectorMask): VectorMask;
          anyTrue(): boolean;
          _bOp(m: VectorMask<long>, f: AbstractMask$MBinOp): Long64Vector$Long64Mask;
          _bOp(a0: VectorMask, a1: AbstractMask$MBinOp): AbstractMask;
          cast<E>(dsp: VectorSpecies<E>): VectorMask<E>;
          compress(): Long64Vector$Long64Mask;
          compress(): VectorMask;
          _defaultMaskCast<E>(dsp: AbstractSpecies<E>): VectorMask<E>;
          firstTrue(): int;
          _getBits(): boolean[];
          _indexPartiallyInUpperRange(offset: long, a1: long): Long64Vector$Long64Mask;
          _indexPartiallyInUpperRange(a0: long, a1: long): VectorMask;
          lastTrue(): int;
          not(): Long64Vector$Long64Mask;
          not(): VectorMask;
          or(mask: VectorMask<long>): Long64Vector$Long64Mask;
          or(a0: VectorMask): VectorMask;
          toLong(): long;
          toVector(): Long64Vector;
          toVector(): Vector;
          trueCount(): int;
          _uOp(f: AbstractMask$MUnOp): Long64Vector$Long64Mask;
          _uOp(a0: AbstractMask$MUnOp): AbstractMask;
          vspecies(): LongVector$LongSpecies;
          vspecies(): AbstractSpecies;
          xor(mask: VectorMask<long>): Long64Vector$Long64Mask;
          xor(a0: VectorMask): VectorMask;
        }
        interface Long64Vector$Long64Mask extends CombineTypes<[_Long64Vector$Long64Mask, AbstractMask<long>]> {}
        interface _Long64Vector$Long64Shuffle$$static extends ClassLike {
          _ETYPE: java.lang.Class<long>;
          _IOTA: Long64Vector$Long64Shuffle;
          _VLENGTH: int;
          _new(reorder: byte[]): Long64Vector$Long64Shuffle;
          new(reorder: int[]): Long64Vector$Long64Shuffle;
          new(reorder: int[], i: int): Long64Vector$Long64Shuffle;
          new(fn: java.util.function.IntUnaryOperator): Long64Vector$Long64Shuffle;
        }
        let Long64Vector$Long64Shuffle: _Long64Vector$Long64Shuffle$$static;
        interface _Long64Vector$Long64Shuffle {
          cast<F>(s: VectorSpecies<F>): VectorShuffle<F>;
          rearrange(shuffle: VectorShuffle<long>): Long64Vector$Long64Shuffle;
          rearrange(a0: VectorShuffle): VectorShuffle;
          toVector(): Long64Vector;
          toVector(): Vector;
          vspecies(): LongVector$LongSpecies;
          vspecies(): AbstractSpecies;
        }
        interface Long64Vector$Long64Shuffle extends CombineTypes<[_Long64Vector$Long64Shuffle, AbstractShuffle<long>]> {}
        interface _LongMaxVector$$static extends ClassLike {
          _ETYPE: java.lang.Class<long>;
          _IOTA: LongMaxVector;
          _VCLASS: java.lang.Class<LongMaxVector>;
          _VLENGTH: int;
          _VSHAPE: VectorShape;
          _VSIZE: int;
          _VSPECIES: LongVector$LongSpecies;
          _ZERO: LongMaxVector;
          _new(v: long[]): LongMaxVector;
          _new(v: any): LongMaxVector;
        }
        let LongMaxVector: _LongMaxVector$$static;
        interface _LongMaxVector {
          addIndex(scale: int): LongMaxVector;
          addIndex(a0: int): LongVector;
          addIndex(a0: int): Vector;
          _asByteVectorRaw(): ByteMaxVector;
          _asByteVectorRaw(): ByteVector;
          _asVectorRaw(laneType: LaneType): AbstractVector<any>;
          _bOp(v: Vector<long>, f: LongVector$FBinOp): LongMaxVector;
          _bOp(v: Vector<long>, m: VectorMask<long>, f: LongVector$FBinOp): LongMaxVector;
          _bOp(a0: Vector, a1: VectorMask, a2: LongVector$FBinOp): LongVector;
          _bOp(a0: Vector, a1: LongVector$FBinOp): LongVector;
          bitSize(): int;
          blend(v: Vector<long>, m: VectorMask<long>): LongMaxVector;
          blend(a0: Vector, a1: VectorMask): LongVector;
          blend(a0: Vector, a1: VectorMask): Vector;
          broadcast(e: long): LongMaxVector;
          broadcast(a0: long): LongVector;
          broadcast(a0: long): Vector;
          byteSize(): int;
          compare(op: VectorOperators$Comparison, v: Vector<long>): LongMaxVector$LongMaxMask;
          compare(op: VectorOperators$Comparison, s: long): LongMaxVector$LongMaxMask;
          compare(op: VectorOperators$Comparison, v: Vector<long>, m: VectorMask<long>): LongMaxVector$LongMaxMask;
          compare(a0: VectorOperators$Comparison, a1: long): VectorMask;
          compare(a0: VectorOperators$Comparison, a1: Vector): VectorMask;
          compare(a0: VectorOperators$Comparison, a1: Vector, a2: VectorMask): VectorMask;
          compress(m: VectorMask<long>): LongMaxVector;
          compress(a0: VectorMask): LongVector;
          compress(a0: VectorMask): Vector;
          convertShape<F>(conv: VectorOperators$Conversion<long,F>, rsp: VectorSpecies<F>, part: int): Vector<F>;
          elementSize(): int;
          elementType(): java.lang.Class<long>;
          expand(m: VectorMask<long>): LongMaxVector;
          expand(a0: VectorMask): LongVector;
          expand(a0: VectorMask): Vector;
          _fromArray0(a: long[], offset: int): LongVector;
          _fromArray0(a: long[], offset: int, m: VectorMask<long>, offsetInRange: int): LongVector;
          _fromArray0(a: long[], offset: int, indexMap: int[], mapOffset: int, m: VectorMask<long>): LongVector;
          _fromMemorySegment0(ms: java.lang.foreign.MemorySegment, offset: long): LongVector;
          _fromMemorySegment0(ms: java.lang.foreign.MemorySegment, offset: long, a2: VectorMask<long>, m: int): LongVector;
          _fromMemorySegment0(a0: java.lang.foreign.MemorySegment, a1: long): AbstractVector;
          _intoArray0(a: long[], offset: int): void;
          _intoArray0(a: long[], offset: int, m: VectorMask<long>): void;
          _intoArray0(a: long[], offset: int, indexMap: int[], mapOffset: int, m: VectorMask<long>): void;
          _intoMemorySegment0(ms: java.lang.foreign.MemorySegment, offset: long, a2: VectorMask<long>): void;
          _iotaShuffle(): LongMaxVector$LongMaxShuffle;
          _iotaShuffle(start: int, step: int, wrap: boolean): LongMaxVector$LongMaxShuffle;
          _iotaShuffle(a0: int, a1: int, a2: boolean): AbstractShuffle;
          _iotaShuffle(): AbstractShuffle;
          lane(i: int): long;
          laneHelper(i: int): long;
          lanewise(op: VectorOperators$Unary): LongMaxVector;
          lanewise(op: VectorOperators$Unary, m: VectorMask<long>): LongMaxVector;
          lanewise(op: VectorOperators$Binary, v: Vector<long>): LongMaxVector;
          lanewise(op: VectorOperators$Binary, v: Vector<long>, m: VectorMask<long>): LongMaxVector;
          lanewise(op: VectorOperators$Ternary, v1: Vector<long>, v2: Vector<long>): LongMaxVector;
          lanewise(op: VectorOperators$Ternary, v1: Vector<long>, v2: Vector<long>, m: VectorMask<long>): LongMaxVector;
          lanewise(a0: VectorOperators$Ternary, a1: Vector, a2: Vector, a3: VectorMask): LongVector;
          lanewise(a0: VectorOperators$Ternary, a1: Vector, a2: Vector): LongVector;
          lanewise(a0: VectorOperators$Binary, a1: Vector, a2: VectorMask): LongVector;
          lanewise(a0: VectorOperators$Binary, a1: Vector): LongVector;
          lanewise(a0: VectorOperators$Unary, a1: VectorMask): LongVector;
          lanewise(a0: VectorOperators$Unary): LongVector;
          lanewise(a0: VectorOperators$Ternary, a1: Vector, a2: Vector, a3: VectorMask): Vector;
          lanewise(a0: VectorOperators$Ternary, a1: Vector, a2: Vector): Vector;
          lanewise(a0: VectorOperators$Binary, a1: Vector, a2: VectorMask): Vector;
          lanewise(a0: VectorOperators$Binary, a1: Vector): Vector;
          lanewise(a0: VectorOperators$Unary, a1: VectorMask): Vector;
          lanewise(a0: VectorOperators$Unary): Vector;
          _lanewiseShift(op: VectorOperators$Binary, e: int): LongMaxVector;
          _lanewiseShift(op: VectorOperators$Binary, e: int, m: VectorMask<long>): LongMaxVector;
          _lanewiseShift(a0: VectorOperators$Binary, a1: int, a2: VectorMask): LongVector;
          _lanewiseShift(a0: VectorOperators$Binary, a1: int): LongVector;
          length(): int;
          _maskFromArray(bits: boolean[]): LongMaxVector$LongMaxMask;
          _maskFromArray(a0: boolean[]): AbstractMask;
          _rOp(v: long, a1: VectorMask<long>, m: LongVector$FBinOp): long;
          rearrange(s: VectorShuffle<long>): LongMaxVector;
          rearrange(shuffle: VectorShuffle<long>, m: VectorMask<long>): LongMaxVector;
          rearrange(s: VectorShuffle<long>, v: Vector<long>): LongMaxVector;
          rearrange(a0: VectorShuffle, a1: Vector): LongVector;
          rearrange(a0: VectorShuffle, a1: VectorMask): LongVector;
          rearrange(a0: VectorShuffle): LongVector;
          rearrange(a0: VectorShuffle, a1: Vector): Vector;
          rearrange(a0: VectorShuffle, a1: VectorMask): Vector;
          rearrange(a0: VectorShuffle): Vector;
          reduceLanes(op: VectorOperators$Associative): long;
          reduceLanes(op: VectorOperators$Associative, m: VectorMask<long>): long;
          reduceLanesToLong(op: VectorOperators$Associative): long;
          reduceLanesToLong(op: VectorOperators$Associative, m: VectorMask<long>): long;
          reinterpretShape<F>(toSpecies: VectorSpecies<F>, part: int): Vector<F>;
          selectFrom(v: Vector<long>): LongMaxVector;
          selectFrom(v: Vector<long>, m: VectorMask<long>): LongMaxVector;
          selectFrom(a0: Vector, a1: VectorMask): LongVector;
          selectFrom(a0: Vector): LongVector;
          selectFrom(a0: Vector, a1: VectorMask): Vector;
          selectFrom(a0: Vector): Vector;
          shape(): VectorShape;
          _shuffleFromArray(indexes: int[], i: int): LongMaxVector$LongMaxShuffle;
          _shuffleFromArray(a0: int[], a1: int): AbstractShuffle;
          _shuffleFromBytes(reorder: byte[]): LongMaxVector$LongMaxShuffle;
          _shuffleFromBytes(a0: byte[]): AbstractShuffle;
          _shuffleFromOp(fn: java.util.function.IntUnaryOperator): LongMaxVector$LongMaxShuffle;
          _shuffleFromOp(a0: java.util.function.IntUnaryOperator): AbstractShuffle;
          slice(origin: int, v: Vector<long>): LongMaxVector;
          slice(origin: int): LongMaxVector;
          slice(a0: int): LongVector;
          slice(a0: int, a1: Vector): LongVector;
          slice(a0: int): AbstractVector;
          slice(a0: int, a1: Vector): AbstractVector;
          slice(a0: int): Vector;
          slice(a0: int, a1: Vector): Vector;
          _tOp(v1: Vector<long>, v2: Vector<long>, f: LongVector$FTriOp): LongMaxVector;
          _tOp(v1: Vector<long>, v2: Vector<long>, m: VectorMask<long>, f: LongVector$FTriOp): LongMaxVector;
          _tOp(a0: Vector, a1: Vector, a2: VectorMask, a3: LongVector$FTriOp): LongVector;
          _tOp(a0: Vector, a1: Vector, a2: LongVector$FTriOp): LongVector;
          test(op: VectorOperators$Test): LongMaxVector$LongMaxMask;
          test(op: VectorOperators$Test, m: VectorMask<long>): LongMaxVector$LongMaxMask;
          test(a0: VectorOperators$Test, a1: VectorMask): VectorMask;
          test(a0: VectorOperators$Test): VectorMask;
          toShuffle(): VectorShuffle<long>;
          _uOp(f: LongVector$FUnOp): LongMaxVector;
          _uOp(m: VectorMask<long>, f: LongVector$FUnOp): LongMaxVector;
          _uOp(a0: VectorMask, a1: LongVector$FUnOp): LongVector;
          _uOp(a0: LongVector$FUnOp): LongVector;
          unslice(origin: int, w: Vector<long>, part: int): LongMaxVector;
          unslice(origin: int, w: Vector<long>, part: int, m: VectorMask<long>): LongMaxVector;
          unslice(origin: int): LongMaxVector;
          unslice(a0: int): LongVector;
          unslice(a0: int, a1: Vector, a2: int, a3: VectorMask): LongVector;
          unslice(a0: int, a1: Vector, a2: int): LongVector;
          unslice(a0: int): Vector;
          unslice(a0: int, a1: Vector, a2: int, a3: VectorMask): Vector;
          unslice(a0: int, a1: Vector, a2: int): Vector;
          _vec(): long[];
          _vectorFactory(vec: long[]): LongMaxVector;
          _vectorFactory(a0: long[]): LongVector;
          vspecies(): LongVector$LongSpecies;
          vspecies(): AbstractSpecies;
          withLane(i: int, e: long): LongMaxVector;
          withLane(a0: int, a1: long): LongVector;
          withLaneHelper(i: int, e: long): LongMaxVector;
        }
        interface LongMaxVector extends CombineTypes<[_LongMaxVector, jdk.incubator.vector.LongVector]> {}
        interface _LongMaxVector$LongMaxMask$$static extends ClassLike {
          _maskAll(bit: boolean): LongMaxVector$LongMaxMask;
          _prepare(bits: boolean[], offset: int): boolean[];
          _prepare(val: boolean): boolean[];
          _ETYPE: java.lang.Class<long>;
          _FALSE_MASK: LongMaxVector$LongMaxMask;
          _TRUE_MASK: LongMaxVector$LongMaxMask;
          _VLENGTH: int;
          _new(bits: boolean[]): LongMaxVector$LongMaxMask;
          _new(bits: boolean[], offset: int): LongMaxVector$LongMaxMask;
          _new(val: boolean): LongMaxVector$LongMaxMask;
        }
        let LongMaxVector$LongMaxMask: _LongMaxVector$LongMaxMask$$static;
        interface _LongMaxVector$LongMaxMask {
          allTrue(): boolean;
          and(mask: VectorMask<long>): LongMaxVector$LongMaxMask;
          and(a0: VectorMask): VectorMask;
          anyTrue(): boolean;
          _bOp(m: VectorMask<long>, f: AbstractMask$MBinOp): LongMaxVector$LongMaxMask;
          _bOp(a0: VectorMask, a1: AbstractMask$MBinOp): AbstractMask;
          cast<E>(dsp: VectorSpecies<E>): VectorMask<E>;
          compress(): LongMaxVector$LongMaxMask;
          compress(): VectorMask;
          _defaultMaskCast<E>(dsp: AbstractSpecies<E>): VectorMask<E>;
          firstTrue(): int;
          _getBits(): boolean[];
          _indexPartiallyInUpperRange(offset: long, a1: long): LongMaxVector$LongMaxMask;
          _indexPartiallyInUpperRange(a0: long, a1: long): VectorMask;
          lastTrue(): int;
          not(): LongMaxVector$LongMaxMask;
          not(): VectorMask;
          or(mask: VectorMask<long>): LongMaxVector$LongMaxMask;
          or(a0: VectorMask): VectorMask;
          toLong(): long;
          toVector(): LongMaxVector;
          toVector(): Vector;
          trueCount(): int;
          _uOp(f: AbstractMask$MUnOp): LongMaxVector$LongMaxMask;
          _uOp(a0: AbstractMask$MUnOp): AbstractMask;
          vspecies(): LongVector$LongSpecies;
          vspecies(): AbstractSpecies;
          xor(mask: VectorMask<long>): LongMaxVector$LongMaxMask;
          xor(a0: VectorMask): VectorMask;
        }
        interface LongMaxVector$LongMaxMask extends CombineTypes<[_LongMaxVector$LongMaxMask, AbstractMask<long>]> {}
        interface _LongMaxVector$LongMaxShuffle$$static extends ClassLike {
          _ETYPE: java.lang.Class<long>;
          _IOTA: LongMaxVector$LongMaxShuffle;
          _VLENGTH: int;
          _new(reorder: byte[]): LongMaxVector$LongMaxShuffle;
          new(reorder: int[]): LongMaxVector$LongMaxShuffle;
          new(reorder: int[], i: int): LongMaxVector$LongMaxShuffle;
          new(fn: java.util.function.IntUnaryOperator): LongMaxVector$LongMaxShuffle;
        }
        let LongMaxVector$LongMaxShuffle: _LongMaxVector$LongMaxShuffle$$static;
        interface _LongMaxVector$LongMaxShuffle {
          cast<F>(s: VectorSpecies<F>): VectorShuffle<F>;
          rearrange(shuffle: VectorShuffle<long>): LongMaxVector$LongMaxShuffle;
          rearrange(a0: VectorShuffle): VectorShuffle;
          toVector(): LongMaxVector;
          toVector(): Vector;
          vspecies(): LongVector$LongSpecies;
          vspecies(): AbstractSpecies;
        }
        interface LongMaxVector$LongMaxShuffle extends CombineTypes<[_LongMaxVector$LongMaxShuffle, AbstractShuffle<long>]> {}
        interface _LongVector$$static extends ClassLike {
          _arrayAddress(a: long[], index: int): long;
          _binaryOperations(opc_: int): jdk.internal.vm.vector.VectorSupport$BinaryOperation<LongVector,VectorMask<long>>;
          broadcast(species: VectorSpecies<long>, e: long): LongVector;
          _broadcastIntOperations(opc_: int): jdk.internal.vm.vector.VectorSupport$VectorBroadcastIntOp<LongVector,VectorMask<long>>;
          _byteArrayAddress(a: byte[], index: int): long;
          _checkMaskFromIndexSize(offset: int, vsp: LongVector$LongSpecies, m: VectorMask<long>, scale: int, limit: int): void;
          _checkMaskFromIndexSize(offset: long, a1: LongVector$LongSpecies, vsp: VectorMask<long>, m: int, scale: long): void;
          _compareWithOp(cond: int, a: long, a2: long): boolean;
          _compressHelper(v: Vector<long>, m: VectorMask<long>): LongVector;
          _expandHelper(v: Vector<long>, m: VectorMask<long>): LongVector;
          fromArray(species: VectorSpecies<long>, a: long[], offset: int): LongVector;
          fromArray(species: VectorSpecies<long>, a: long[], offset: int, m: VectorMask<long>): LongVector;
          fromArray(species: VectorSpecies<long>, a: long[], offset: int, indexMap: int[], mapOffset: int): LongVector;
          fromArray(species: VectorSpecies<long>, a: long[], offset: int, indexMap: int[], mapOffset: int, m: VectorMask<long>): LongVector;
          _fromBits(bits: long): long;
          fromMemorySegment(species: VectorSpecies<long>, ms: java.lang.foreign.MemorySegment, offset: long, a3: java.nio.ByteOrder): LongVector;
          fromMemorySegment(species: VectorSpecies<long>, ms: java.lang.foreign.MemorySegment, offset: long, a3: java.nio.ByteOrder, bo: VectorMask<long>): LongVector;
          _memorySegmentGet(ms: java.lang.foreign.MemorySegment, o: long, a2: int): long;
          _memorySegmentSet(ms: java.lang.foreign.MemorySegment, o: long, a2: int, i: long): void;
          _opCode(op: VectorOperators$Operator): int;
          _opCode(op: VectorOperators$Operator, requireKind: int): int;
          _opKind(op: VectorOperators$Operator, bit: int): boolean;
          _reductionOperations(opc_: int): jdk.internal.vm.vector.VectorSupport$ReductionOperation<LongVector,VectorMask<long>>;
          _rotateLeft(a: long, a1: int): long;
          _rotateRight(a: long, a1: int): long;
          _species(s: VectorShape): LongVector$LongSpecies;
          _ternaryOperations(opc_: int): jdk.internal.vm.vector.VectorSupport$TernaryOperation<LongVector,VectorMask<long>>;
          _toBits(e: long): long;
          _unaryOperations(opc_: int): jdk.internal.vm.vector.VectorSupport$UnaryOperation<LongVector,VectorMask<long>>;
          zero(species: VectorSpecies<long>): LongVector;
          _ARRAY_BASE: long;
          _ARRAY_SHIFT: int;
          _BIN_IMPL: VectorOperators$ImplCache<VectorOperators$Binary,jdk.internal.vm.vector.VectorSupport$BinaryOperation<LongVector,VectorMask<long>>>;
          _BIN_INT_IMPL: VectorOperators$ImplCache<VectorOperators$Binary,jdk.internal.vm.vector.VectorSupport$VectorBroadcastIntOp<LongVector,VectorMask<long>>>;
          _ELEMENT_LAYOUT: java.lang.foreign.ValueLayout$OfLong;
          _FORBID_OPCODE_KIND: int;
          _LSHR_SETUP_MASK: long;
          _MAX_OR_INF: long;
          _MIN_OR_INF: long;
          _REDUCE_IMPL: VectorOperators$ImplCache<VectorOperators$Associative,jdk.internal.vm.vector.VectorSupport$ReductionOperation<LongVector,VectorMask<long>>>;
          _SHIFT_MASK: int;
          readonly SPECIES_128: VectorSpecies<long>;
          readonly SPECIES_256: VectorSpecies<long>;
          readonly SPECIES_512: VectorSpecies<long>;
          readonly SPECIES_64: VectorSpecies<long>;
          readonly SPECIES_MAX: VectorSpecies<long>;
          readonly SPECIES_PREFERRED: VectorSpecies<long>;
          _TERN_IMPL: VectorOperators$ImplCache<VectorOperators$Ternary,jdk.internal.vm.vector.VectorSupport$TernaryOperation<LongVector,VectorMask<long>>>;
          _UN_IMPL: VectorOperators$ImplCache<VectorOperators$Unary,jdk.internal.vm.vector.VectorSupport$UnaryOperation<LongVector,VectorMask<long>>>;
          _new(vec: long[]): LongVector;
        }
        let LongVector: _LongVector$$static;
        interface _LongVector {
          abs(): LongVector;
          abs(): Vector;
          add(v: Vector<long>): LongVector;
          add(e: long): LongVector;
          add(v: Vector<long>, m: VectorMask<long>): LongVector;
          add(e: long, a1: VectorMask<long>): LongVector;
          add(a0: Vector, a1: VectorMask): Vector;
          add(a0: Vector): Vector;
          addIndex(a0: int): LongVector;
          addIndex(a0: int): Vector;
          _addIndexTemplate(scale: int): LongVector;
          and(v: Vector<long>): LongVector;
          and(e: long): LongVector;
          _bOp(a0: Vector<long>, a1: LongVector$FBinOp): LongVector;
          _bOp(a0: Vector<long>, a1: VectorMask<long>, a2: LongVector$FBinOp): LongVector;
          _bOpTemplate(o: Vector<long>, f: LongVector$FBinOp): LongVector;
          _bOpTemplate(o: Vector<long>, m: VectorMask<long>, f: LongVector$FBinOp): LongVector;
          _bTest(cond: int, o: Vector<long>, f: LongVector$FBinTest): AbstractMask<long>;
          bitwiseBlend(bits: Vector<long>, mask: Vector<long>): LongVector;
          bitwiseBlend(bits: long, a1: long): LongVector;
          bitwiseBlend(bits: long, a1: Vector<long>): LongVector;
          bitwiseBlend(bits: Vector<long>, mask: long): LongVector;
          blend(a0: Vector<long>, a1: VectorMask<long>): LongVector;
          blend(e: long, a1: VectorMask<long>): LongVector;
          blend(a0: long, a1: VectorMask): Vector;
          blend(a0: Vector, a1: VectorMask): Vector;
          _blendTemplate<M>(maskType: java.lang.Class<M>, v: LongVector, m: M): LongVector;
          broadcast(a0: long): LongVector;
          broadcast(a0: long): Vector;
          _broadcastTemplate(e: long): LongVector;
          compare(a0: VectorOperators$Comparison, a1: Vector<long>): VectorMask<long>;
          compare(a0: VectorOperators$Comparison, a1: long): VectorMask<long>;
          compare(op: VectorOperators$Comparison, e: long, a2: VectorMask<long>): VectorMask<long>;
          _compareTemplate<M>(maskType: java.lang.Class<M>, op: VectorOperators$Comparison, v: Vector<long>): M;
          _compareTemplate<M>(maskType: java.lang.Class<M>, op: VectorOperators$Comparison, v: Vector<long>, m: M): M;
          _compareTemplate<M>(maskType: java.lang.Class<M>, op: VectorOperators$Comparison, e: long): M;
          compress(a0: VectorMask<long>): LongVector;
          compress(a0: VectorMask): Vector;
          _compressTemplate<M>(masktype: java.lang.Class<M>, m: M): LongVector;
          _conditionalStoreNYI(offset: int, vsp: LongVector$LongSpecies, m: VectorMask<long>, scale: int, limit: int): void;
          div(v: Vector<long>): LongVector;
          div(e: long): LongVector;
          div(v: Vector<long>, m: VectorMask<long>): LongVector;
          div(e: long, a1: VectorMask<long>): LongVector;
          div(a0: Vector, a1: VectorMask): Vector;
          div(a0: Vector): Vector;
          eq(v: Vector<long>): VectorMask<long>;
          eq(e: long): VectorMask<long>;
          equals(obj: any): boolean;
          expand(a0: VectorMask<long>): LongVector;
          expand(a0: VectorMask): Vector;
          _expandTemplate<M>(masktype: java.lang.Class<M>, m: M): LongVector;
          _fromArray0(a0: long[], a1: int): LongVector;
          _fromArray0(a0: long[], a1: int, a2: VectorMask<long>, a3: int): LongVector;
          _fromArray0(a0: long[], a1: int, a2: int[], a3: int, a4: VectorMask<long>): LongVector;
          _fromArray0Template(a: long[], offset: int): LongVector;
          _fromArray0Template<M>(maskClass: java.lang.Class<M>, a: long[], offset: int, m: M, offsetInRange: int): LongVector;
          _fromArray0Template<M>(maskClass: java.lang.Class<M>, a: long[], offset: int, indexMap: int[], mapOffset: int, m: M): LongVector;
          _fromMemorySegment0(a0: java.lang.foreign.MemorySegment, a1: long): LongVector;
          _fromMemorySegment0(a0: java.lang.foreign.MemorySegment, a1: long, a2: VectorMask<long>, a3: int): LongVector;
          _fromMemorySegment0(a0: java.lang.foreign.MemorySegment, a1: long): AbstractVector;
          _fromMemorySegment0Template(ms: java.lang.foreign.MemorySegment, offset: long): LongVector;
          _fromMemorySegment0Template<M>(maskClass: java.lang.Class<M>, ms: java.lang.foreign.MemorySegment, offset: long, a3: M, m: int): LongVector;
          hashCode(): int;
          intoArray(a: long[], offset: int): void;
          intoArray(a: long[], offset: int, m: VectorMask<long>): void;
          intoArray(a: long[], offset: int, indexMap: int[], mapOffset: int): void;
          intoArray(a: long[], offset: int, indexMap: int[], mapOffset: int, m: VectorMask<long>): void;
          _intoArray0(a0: long[], a1: int): void;
          _intoArray0(a0: long[], a1: int, a2: VectorMask<long>): void;
          _intoArray0(a0: long[], a1: int, a2: int[], a3: int, a4: VectorMask<long>): void;
          _intoArray0Template(a: long[], offset: int): void;
          _intoArray0Template<M>(maskClass: java.lang.Class<M>, a: long[], offset: int, m: M): void;
          _intoArray0Template<M>(maskClass: java.lang.Class<M>, a: long[], offset: int, indexMap: int[], mapOffset: int, m: M): void;
          intoMemorySegment(ms: java.lang.foreign.MemorySegment, offset: long, a2: java.nio.ByteOrder): void;
          intoMemorySegment(ms: java.lang.foreign.MemorySegment, offset: long, a2: java.nio.ByteOrder, bo: VectorMask<long>): void;
          _intoMemorySegment0(ms: java.lang.foreign.MemorySegment, offset: long): void;
          _intoMemorySegment0(a0: java.lang.foreign.MemorySegment, a1: long, a2: VectorMask<long>): void;
          _intoMemorySegment0Template<M>(maskClass: java.lang.Class<M>, ms: java.lang.foreign.MemorySegment, offset: long, a3: M): void;
          lane(a0: int): long;
          lanewise(a0: VectorOperators$Unary): LongVector;
          lanewise(a0: VectorOperators$Unary, a1: VectorMask<long>): LongVector;
          lanewise(a0: VectorOperators$Binary, a1: Vector<long>): LongVector;
          lanewise(a0: VectorOperators$Binary, a1: Vector<long>, a2: VectorMask<long>): LongVector;
          lanewise(op: VectorOperators$Binary, e: long): LongVector;
          lanewise(op: VectorOperators$Binary, e: long, a2: VectorMask<long>): LongVector;
          lanewise(a0: VectorOperators$Ternary, a1: Vector<long>, a2: Vector<long>): LongVector;
          lanewise(a0: VectorOperators$Ternary, a1: Vector<long>, a2: Vector<long>, a3: VectorMask<long>): LongVector;
          lanewise(op: VectorOperators$Ternary, e1: long, a2: long): LongVector;
          lanewise(op: VectorOperators$Ternary, e1: long, a2: long, e2: VectorMask<long>): LongVector;
          lanewise(op: VectorOperators$Ternary, v1: Vector<long>, e2: long): LongVector;
          lanewise(op: VectorOperators$Ternary, v1: Vector<long>, e2: long, a3: VectorMask<long>): LongVector;
          lanewise(op: VectorOperators$Ternary, e1: long, a2: Vector<long>): LongVector;
          lanewise(op: VectorOperators$Ternary, e1: long, a2: Vector<long>, v2: VectorMask<long>): LongVector;
          lanewise(a0: VectorOperators$Ternary, a1: Vector, a2: Vector, a3: VectorMask): Vector;
          lanewise(a0: VectorOperators$Ternary, a1: Vector, a2: Vector): Vector;
          lanewise(a0: VectorOperators$Binary, a1: long, a2: VectorMask): Vector;
          lanewise(a0: VectorOperators$Binary, a1: long): Vector;
          lanewise(a0: VectorOperators$Binary, a1: Vector, a2: VectorMask): Vector;
          lanewise(a0: VectorOperators$Binary, a1: Vector): Vector;
          lanewise(a0: VectorOperators$Unary, a1: VectorMask): Vector;
          lanewise(a0: VectorOperators$Unary): Vector;
          _lanewiseShift(a0: VectorOperators$Binary, a1: int): LongVector;
          _lanewiseShift(a0: VectorOperators$Binary, a1: int, a2: VectorMask<long>): LongVector;
          _lanewiseShiftTemplate(op: VectorOperators$Binary, e: int): LongVector;
          _lanewiseShiftTemplate(op: VectorOperators$Binary, maskClass: java.lang.Class<VectorMask<long>>, e: int, m: VectorMask<long>): LongVector;
          _lanewiseTemplate(op: VectorOperators$Unary): LongVector;
          _lanewiseTemplate(op: VectorOperators$Unary, maskClass: java.lang.Class<VectorMask<long>>, m: VectorMask<long>): LongVector;
          _lanewiseTemplate(op: VectorOperators$Binary, v: Vector<long>): LongVector;
          _lanewiseTemplate(op: VectorOperators$Binary, maskClass: java.lang.Class<VectorMask<long>>, v: Vector<long>, m: VectorMask<long>): LongVector;
          _lanewiseTemplate(op: VectorOperators$Ternary, v1: Vector<long>, v2: Vector<long>): LongVector;
          _lanewiseTemplate(op: VectorOperators$Ternary, maskClass: java.lang.Class<VectorMask<long>>, v1: Vector<long>, v2: Vector<long>, m: VectorMask<long>): LongVector;
          _ldLongOp(memory: java.lang.foreign.MemorySegment, offset: long, a2: LongVector$FLdLongOp): LongVector;
          _ldLongOp(memory: java.lang.foreign.MemorySegment, offset: long, a2: VectorMask<long>, m: LongVector$FLdLongOp): LongVector;
          _ldOp<M>(memory: M, offset: int, f: LongVector$FLdOp<M>): LongVector;
          _ldOp<M>(memory: M, offset: int, m: VectorMask<long>, f: LongVector$FLdOp<M>): LongVector;
          lt(v: Vector<long>): VectorMask<long>;
          lt(e: long): VectorMask<long>;
          _maskFactory(bits: boolean[]): AbstractMask<long>;
          max(v: Vector<long>): LongVector;
          max(e: long): LongVector;
          max(a0: Vector): Vector;
          _maybeSwap(bo: java.nio.ByteOrder): LongVector;
          _maybeSwap(a0: java.nio.ByteOrder): AbstractVector;
          min(v: Vector<long>): LongVector;
          min(e: long): LongVector;
          min(a0: Vector): Vector;
          mul(v: Vector<long>): LongVector;
          mul(e: long): LongVector;
          mul(v: Vector<long>, m: VectorMask<long>): LongVector;
          mul(e: long, a1: VectorMask<long>): LongVector;
          mul(a0: Vector, a1: VectorMask): Vector;
          mul(a0: Vector): Vector;
          neg(): LongVector;
          neg(): Vector;
          not(): LongVector;
          or(v: Vector<long>): LongVector;
          or(e: long): LongVector;
          _rOp(a0: long, a1: VectorMask<long>, a2: LongVector$FBinOp): long;
          _rOpTemplate(v: long, a1: VectorMask<long>, m: LongVector$FBinOp): long;
          _rOpTemplate(v: long, a1: LongVector$FBinOp): long;
          rearrange(a0: VectorShuffle<long>): LongVector;
          rearrange(a0: VectorShuffle<long>, a1: VectorMask<long>): LongVector;
          rearrange(a0: VectorShuffle<long>, a1: Vector<long>): LongVector;
          rearrange(a0: VectorShuffle, a1: Vector): Vector;
          rearrange(a0: VectorShuffle, a1: VectorMask): Vector;
          rearrange(a0: VectorShuffle): Vector;
          _rearrangeTemplate<S>(shuffletype: java.lang.Class<S>, shuffle: S): LongVector;
          _rearrangeTemplate<S, M>(shuffletype: java.lang.Class<S>, masktype: java.lang.Class<M>, shuffle: S, m: M): LongVector;
          _rearrangeTemplate<S>(shuffletype: java.lang.Class<S>, shuffle: S, v: LongVector): LongVector;
          reduceLanes(a0: VectorOperators$Associative): long;
          reduceLanes(a0: VectorOperators$Associative, a1: VectorMask<long>): long;
          _reduceLanesTemplate(op: VectorOperators$Associative, maskClass: java.lang.Class<VectorMask<long>>, m: VectorMask<long>): long;
          _reduceLanesTemplate(op: VectorOperators$Associative): long;
          reduceLanesToLong(a0: VectorOperators$Associative): long;
          reduceLanesToLong(a0: VectorOperators$Associative, a1: VectorMask<long>): long;
          reinterpretAsBytes(): ByteVector;
          reinterpretAsDoubles(): DoubleVector;
          reinterpretAsFloats(): FloatVector;
          reinterpretAsInts(): IntVector;
          reinterpretAsLongs(): LongVector;
          reinterpretAsShorts(): ShortVector;
          selectFrom(a0: Vector<long>): LongVector;
          selectFrom(a0: Vector<long>, a1: VectorMask<long>): LongVector;
          selectFrom(a0: Vector, a1: VectorMask): Vector;
          selectFrom(a0: Vector): Vector;
          _selectFromTemplate(v: LongVector): LongVector;
          _selectFromTemplate(v: LongVector, m: AbstractMask<long>): LongVector;
          slice(a0: int, a1: Vector<long>): LongVector;
          slice(origin: int, w: Vector<long>, m: VectorMask<long>): LongVector;
          slice(a0: int): LongVector;
          slice(a0: int): AbstractVector;
          slice(a0: int, a1: Vector): AbstractVector;
          slice(a0: int): Vector;
          slice(a0: int, a1: Vector, a2: VectorMask): Vector;
          slice(a0: int, a1: Vector): Vector;
          _sliceTemplate(origin: int, v1: Vector<long>): LongVector;
          _sliceTemplate(origin: int): LongVector;
          _stLongOp(memory: java.lang.foreign.MemorySegment, offset: long, a2: LongVector$FStLongOp): void;
          _stLongOp(memory: java.lang.foreign.MemorySegment, offset: long, a2: VectorMask<long>, m: LongVector$FStLongOp): void;
          _stOp<M>(memory: M, offset: int, f: LongVector$FStOp<M>): void;
          _stOp<M>(memory: M, offset: int, m: VectorMask<long>, f: LongVector$FStOp<M>): void;
          sub(v: Vector<long>): LongVector;
          sub(e: long): LongVector;
          sub(v: Vector<long>, m: VectorMask<long>): LongVector;
          sub(e: long, a1: VectorMask<long>): LongVector;
          sub(a0: Vector, a1: VectorMask): Vector;
          sub(a0: Vector): Vector;
          _tOp(a0: Vector<long>, a1: Vector<long>, a2: LongVector$FTriOp): LongVector;
          _tOp(a0: Vector<long>, a1: Vector<long>, a2: VectorMask<long>, a3: LongVector$FTriOp): LongVector;
          _tOpTemplate(o1: Vector<long>, o2: Vector<long>, f: LongVector$FTriOp): LongVector;
          _tOpTemplate(o1: Vector<long>, o2: Vector<long>, m: VectorMask<long>, f: LongVector$FTriOp): LongVector;
          test(a0: VectorOperators$Test): VectorMask<long>;
          test(a0: VectorOperators$Test, a1: VectorMask<long>): VectorMask<long>;
          _testTemplate<M>(maskType: java.lang.Class<M>, op: VectorOperators$Test): M;
          _testTemplate<M>(maskType: java.lang.Class<M>, op: VectorOperators$Test, mask: M): M;
          toArray(): long[];
          toArray(): any;
          toDoubleArray(): double[];
          toIntArray(): int[];
          toLongArray(): long[];
          _toShuffle0(dsp: LongVector$LongSpecies): VectorShuffle<long>;
          _toShuffleTemplate(shuffleType: java.lang.Class<any>): VectorShuffle<long>;
          toString(): string;
          _uOp(a0: LongVector$FUnOp): LongVector;
          _uOp(a0: VectorMask<long>, a1: LongVector$FUnOp): LongVector;
          _uOpTemplate(f: LongVector$FUnOp): LongVector;
          _uOpTemplate(m: VectorMask<long>, f: LongVector$FUnOp): LongVector;
          unslice(a0: int, a1: Vector<long>, a2: int): LongVector;
          unslice(a0: int, a1: Vector<long>, a2: int, a3: VectorMask<long>): LongVector;
          unslice(a0: int): LongVector;
          unslice(a0: int): Vector;
          unslice(a0: int, a1: Vector, a2: int, a3: VectorMask): Vector;
          unslice(a0: int, a1: Vector, a2: int): Vector;
          _unsliceTemplate(origin: int, w: Vector<long>, part: int): LongVector;
          _unsliceTemplate<M>(maskType: java.lang.Class<M>, origin: int, w: Vector<long>, part: int, m: M): LongVector;
          _unsliceTemplate(origin: int): LongVector;
          _vOp(f: LongVector$FVOp): LongVector;
          _vOp(m: VectorMask<long>, f: LongVector$FVOp): LongVector;
          _vec(): long[];
          _vectorFactory(a0: long[]): LongVector;
          viewAsFloatingLanes(): DoubleVector;
          viewAsFloatingLanes(): Vector;
          viewAsIntegralLanes(): LongVector;
          viewAsIntegralLanes(): Vector;
          _vspecies(): LongVector$LongSpecies;
          _vspecies(): AbstractSpecies;
          withLane(a0: int, a1: long): LongVector;
          _wrongPartForSlice(part: int): java.lang.ArrayIndexOutOfBoundsException;
        }
        interface LongVector extends CombineTypes<[_LongVector, AbstractVector<long>]> {}
        interface _LongVector$FBinOp$$static extends ClassLike {
        }
        let LongVector$FBinOp: _LongVector$FBinOp$$static;
        interface _LongVector$FBinOp {
          apply(a0: int, a1: long, a2: long): long;
(a0: int, a1: long, a2: long): long;
        }
        interface LongVector$FBinOp extends CombineTypes<[_LongVector$FBinOp, java.lang.Object]> {}
        interface _LongVector$FBinTest$$static extends ClassLike {
        }
        let LongVector$FBinTest: _LongVector$FBinTest$$static;
        interface _LongVector$FBinTest {
          apply(a0: int, a1: int, a2: long, a3: long): boolean;
(a0: int, a1: int, a2: long, a3: long): boolean;
        }
        interface LongVector$FBinTest extends CombineTypes<[_LongVector$FBinTest, java.lang.Object]> {}
        interface _LongVector$FLdLongOp$$static extends ClassLike {
        }
        let LongVector$FLdLongOp: _LongVector$FLdLongOp$$static;
        interface _LongVector$FLdLongOp {
          apply(a0: java.lang.foreign.MemorySegment, a1: long, a2: int): long;
(a0: java.lang.foreign.MemorySegment, a1: long, a2: int): long;
        }
        interface LongVector$FLdLongOp extends CombineTypes<[_LongVector$FLdLongOp, java.lang.Object]> {}
        interface _LongVector$FLdOp$$static<M> extends ClassLike {
        }
        let LongVector$FLdOp: _LongVector$FLdOp$$static<M>;
        interface _LongVector$FLdOp<M> {
          apply(a0: M, a1: int, a2: int): long;
(a0: M, a1: int, a2: int): long;
        }
        interface LongVector$FLdOp<M> extends CombineTypes<[_LongVector$FLdOp<M>, java.lang.Object]> {}
        interface _LongVector$FStLongOp$$static extends ClassLike {
        }
        let LongVector$FStLongOp: _LongVector$FStLongOp$$static;
        interface _LongVector$FStLongOp {
          apply(a0: java.lang.foreign.MemorySegment, a1: long, a2: int, a3: long): void;
(a0: java.lang.foreign.MemorySegment, a1: long, a2: int, a3: long): void;
        }
        interface LongVector$FStLongOp extends CombineTypes<[_LongVector$FStLongOp, java.lang.Object]> {}
        interface _LongVector$FStOp$$static<M> extends ClassLike {
        }
        let LongVector$FStOp: _LongVector$FStOp$$static<M>;
        interface _LongVector$FStOp<M> {
          apply(a0: M, a1: int, a2: int, a3: long): void;
(a0: M, a1: int, a2: int, a3: long): void;
        }
        interface LongVector$FStOp<M> extends CombineTypes<[_LongVector$FStOp<M>, java.lang.Object]> {}
        interface _LongVector$FTriOp$$static extends ClassLike {
        }
        let LongVector$FTriOp: _LongVector$FTriOp$$static;
        interface _LongVector$FTriOp {
          apply(a0: int, a1: long, a2: long, a3: long): long;
(a0: int, a1: long, a2: long, a3: long): long;
        }
        interface LongVector$FTriOp extends CombineTypes<[_LongVector$FTriOp, java.lang.Object]> {}
        interface _LongVector$FUnOp$$static extends ClassLike {
        }
        let LongVector$FUnOp: _LongVector$FUnOp$$static;
        interface _LongVector$FUnOp {
          apply(a0: int, a1: long): long;
(a0: int, a1: long): long;
        }
        interface LongVector$FUnOp extends CombineTypes<[_LongVector$FUnOp, java.lang.Object]> {}
        interface _LongVector$FVOp$$static extends ClassLike {
        }
        let LongVector$FVOp: _LongVector$FVOp$$static;
        interface _LongVector$FVOp {
          apply(a0: int): long;
(a0: int): long;
        }
        interface LongVector$FVOp extends CombineTypes<[_LongVector$FVOp, java.lang.Object]> {}
        interface _LongVector$LongSpecies$$static extends ClassLike {
          _toIntegralChecked(e: long, a1: boolean): long;
        }
        let LongVector$LongSpecies: _LongVector$LongSpecies$$static;
        interface _LongVector$LongSpecies {
          broadcast(e: long): LongVector;
          broadcast(a0: long): Vector;
          _broadcastBits(bits: long): LongVector;
          _broadcastBits(a0: long): AbstractVector;
          checkValue(e: long): long;
          _dummyVector(): LongVector;
          _dummyVector(): AbstractVector;
          elementType(): java.lang.Class<long>;
          fromArray(a: any, offset: int): LongVector;
          fromArray(a0: any, a1: int): Vector;
          _fromIntValues(values: int[]): LongVector;
          _fromIntValues(a0: int[]): Vector;
          fromMemorySegment(ms: java.lang.foreign.MemorySegment, offset: long, a2: java.nio.ByteOrder): LongVector;
          fromMemorySegment(a0: java.lang.foreign.MemorySegment, a1: long, a2: java.nio.ByteOrder): Vector;
          _genericElementType(): java.lang.Class<long>;
          iota(): LongVector;
          iota(): AbstractVector;
          _ldLongOp(memory: java.lang.foreign.MemorySegment, offset: long, a2: LongVector$FLdLongOp): LongVector;
          _ldLongOp(memory: java.lang.foreign.MemorySegment, offset: long, a2: VectorMask<long>, m: LongVector$FLdLongOp): LongVector;
          _ldOp<M>(memory: M, offset: int, f: LongVector$FLdOp<M>): LongVector;
          _ldOp<M>(memory: M, offset: int, m: VectorMask<long>, f: LongVector$FLdOp<M>): LongVector;
          _longToElementBits(value: long): long;
          maskAll(bit: boolean): VectorMask<long>;
          _rvOp(f: AbstractSpecies$RVOp): LongVector;
          _rvOp(a0: AbstractSpecies$RVOp): AbstractVector;
          _stLongOp(memory: java.lang.foreign.MemorySegment, offset: long, a2: LongVector$FStLongOp): void;
          _stLongOp(memory: java.lang.foreign.MemorySegment, offset: long, a2: AbstractMask<long>, m: LongVector$FStLongOp): void;
          _stOp<M>(memory: M, offset: int, f: LongVector$FStOp<M>): void;
          _stOp<M>(memory: M, offset: int, m: AbstractMask<long>, f: LongVector$FStOp<M>): void;
          _vOp(f: LongVector$FVOp): LongVector;
          _vOp(m: VectorMask<long>, f: LongVector$FVOp): LongVector;
          vectorType(): java.lang.Class<LongVector>;
          zero(): LongVector;
          zero(): AbstractVector;
          zero(): Vector;
        }
        interface LongVector$LongSpecies extends CombineTypes<[_LongVector$LongSpecies, AbstractSpecies<long>]> {}
        interface _Short128Vector$$static extends ClassLike {
          _ETYPE: java.lang.Class<short>;
          _IOTA: Short128Vector;
          _VCLASS: java.lang.Class<Short128Vector>;
          _VLENGTH: int;
          _VSHAPE: VectorShape;
          _VSIZE: int;
          _VSPECIES: ShortVector$ShortSpecies;
          _ZERO: Short128Vector;
          _new(v: short[]): Short128Vector;
          _new(v: any): Short128Vector;
        }
        let Short128Vector: _Short128Vector$$static;
        interface _Short128Vector {
          addIndex(scale: int): Short128Vector;
          addIndex(a0: int): ShortVector;
          addIndex(a0: int): Vector;
          _asByteVectorRaw(): Byte128Vector;
          _asByteVectorRaw(): ByteVector;
          _asVectorRaw(laneType: LaneType): AbstractVector<any>;
          _bOp(v: Vector<short>, f: ShortVector$FBinOp): Short128Vector;
          _bOp(v: Vector<short>, m: VectorMask<short>, f: ShortVector$FBinOp): Short128Vector;
          _bOp(a0: Vector, a1: VectorMask, a2: ShortVector$FBinOp): ShortVector;
          _bOp(a0: Vector, a1: ShortVector$FBinOp): ShortVector;
          bitSize(): int;
          blend(v: Vector<short>, m: VectorMask<short>): Short128Vector;
          blend(a0: Vector, a1: VectorMask): ShortVector;
          blend(a0: Vector, a1: VectorMask): Vector;
          broadcast(e: short): Short128Vector;
          broadcast(e: long): Short128Vector;
          broadcast(a0: long): ShortVector;
          broadcast(a0: short): ShortVector;
          broadcast(a0: long): Vector;
          byteSize(): int;
          compare(op: VectorOperators$Comparison, v: Vector<short>): Short128Vector$Short128Mask;
          compare(op: VectorOperators$Comparison, s: short): Short128Vector$Short128Mask;
          compare(op: VectorOperators$Comparison, s: long): Short128Vector$Short128Mask;
          compare(op: VectorOperators$Comparison, v: Vector<short>, m: VectorMask<short>): Short128Vector$Short128Mask;
          compare(a0: VectorOperators$Comparison, a1: long): VectorMask;
          compare(a0: VectorOperators$Comparison, a1: short): VectorMask;
          compare(a0: VectorOperators$Comparison, a1: Vector): VectorMask;
          compare(a0: VectorOperators$Comparison, a1: Vector, a2: VectorMask): VectorMask;
          compress(m: VectorMask<short>): Short128Vector;
          compress(a0: VectorMask): ShortVector;
          compress(a0: VectorMask): Vector;
          convertShape<F>(conv: VectorOperators$Conversion<short,F>, rsp: VectorSpecies<F>, part: int): Vector<F>;
          elementSize(): int;
          elementType(): java.lang.Class<short>;
          expand(m: VectorMask<short>): Short128Vector;
          expand(a0: VectorMask): ShortVector;
          expand(a0: VectorMask): Vector;
          _fromArray0(a: short[], offset: int): ShortVector;
          _fromArray0(a: short[], offset: int, m: VectorMask<short>, offsetInRange: int): ShortVector;
          _fromCharArray0(a: char[], offset: int): ShortVector;
          _fromCharArray0(a: char[], offset: int, m: VectorMask<short>, offsetInRange: int): ShortVector;
          _fromMemorySegment0(ms: java.lang.foreign.MemorySegment, offset: long): ShortVector;
          _fromMemorySegment0(ms: java.lang.foreign.MemorySegment, offset: long, a2: VectorMask<short>, m: int): ShortVector;
          _fromMemorySegment0(a0: java.lang.foreign.MemorySegment, a1: long): AbstractVector;
          _intoArray0(a: short[], offset: int): void;
          _intoArray0(a: short[], offset: int, m: VectorMask<short>): void;
          _intoCharArray0(a: char[], offset: int, m: VectorMask<short>): void;
          _intoMemorySegment0(ms: java.lang.foreign.MemorySegment, offset: long, a2: VectorMask<short>): void;
          _iotaShuffle(): Short128Vector$Short128Shuffle;
          _iotaShuffle(start: int, step: int, wrap: boolean): Short128Vector$Short128Shuffle;
          _iotaShuffle(a0: int, a1: int, a2: boolean): AbstractShuffle;
          _iotaShuffle(): AbstractShuffle;
          lane(i: int): short;
          laneHelper(i: int): short;
          lanewise(op: VectorOperators$Unary): Short128Vector;
          lanewise(op: VectorOperators$Unary, m: VectorMask<short>): Short128Vector;
          lanewise(op: VectorOperators$Binary, v: Vector<short>): Short128Vector;
          lanewise(op: VectorOperators$Binary, v: Vector<short>, m: VectorMask<short>): Short128Vector;
          lanewise(op: VectorOperators$Ternary, v1: Vector<short>, v2: Vector<short>): Short128Vector;
          lanewise(op: VectorOperators$Ternary, v1: Vector<short>, v2: Vector<short>, m: VectorMask<short>): Short128Vector;
          lanewise(a0: VectorOperators$Ternary, a1: Vector, a2: Vector, a3: VectorMask): ShortVector;
          lanewise(a0: VectorOperators$Ternary, a1: Vector, a2: Vector): ShortVector;
          lanewise(a0: VectorOperators$Binary, a1: Vector, a2: VectorMask): ShortVector;
          lanewise(a0: VectorOperators$Binary, a1: Vector): ShortVector;
          lanewise(a0: VectorOperators$Unary, a1: VectorMask): ShortVector;
          lanewise(a0: VectorOperators$Unary): ShortVector;
          lanewise(a0: VectorOperators$Ternary, a1: Vector, a2: Vector, a3: VectorMask): Vector;
          lanewise(a0: VectorOperators$Ternary, a1: Vector, a2: Vector): Vector;
          lanewise(a0: VectorOperators$Binary, a1: Vector, a2: VectorMask): Vector;
          lanewise(a0: VectorOperators$Binary, a1: Vector): Vector;
          lanewise(a0: VectorOperators$Unary, a1: VectorMask): Vector;
          lanewise(a0: VectorOperators$Unary): Vector;
          _lanewiseShift(op: VectorOperators$Binary, e: int): Short128Vector;
          _lanewiseShift(op: VectorOperators$Binary, e: int, m: VectorMask<short>): Short128Vector;
          _lanewiseShift(a0: VectorOperators$Binary, a1: int, a2: VectorMask): ShortVector;
          _lanewiseShift(a0: VectorOperators$Binary, a1: int): ShortVector;
          length(): int;
          _maskFromArray(bits: boolean[]): Short128Vector$Short128Mask;
          _maskFromArray(a0: boolean[]): AbstractMask;
          _rOp(v: short, m: VectorMask<short>, f: ShortVector$FBinOp): short;
          rearrange(s: VectorShuffle<short>): Short128Vector;
          rearrange(shuffle: VectorShuffle<short>, m: VectorMask<short>): Short128Vector;
          rearrange(s: VectorShuffle<short>, v: Vector<short>): Short128Vector;
          rearrange(a0: VectorShuffle, a1: Vector): ShortVector;
          rearrange(a0: VectorShuffle, a1: VectorMask): ShortVector;
          rearrange(a0: VectorShuffle): ShortVector;
          rearrange(a0: VectorShuffle, a1: Vector): Vector;
          rearrange(a0: VectorShuffle, a1: VectorMask): Vector;
          rearrange(a0: VectorShuffle): Vector;
          reduceLanes(op: VectorOperators$Associative): short;
          reduceLanes(op: VectorOperators$Associative, m: VectorMask<short>): short;
          reduceLanesToLong(op: VectorOperators$Associative): long;
          reduceLanesToLong(op: VectorOperators$Associative, m: VectorMask<short>): long;
          reinterpretShape<F>(toSpecies: VectorSpecies<F>, part: int): Vector<F>;
          selectFrom(v: Vector<short>): Short128Vector;
          selectFrom(v: Vector<short>, m: VectorMask<short>): Short128Vector;
          selectFrom(a0: Vector, a1: VectorMask): ShortVector;
          selectFrom(a0: Vector): ShortVector;
          selectFrom(a0: Vector, a1: VectorMask): Vector;
          selectFrom(a0: Vector): Vector;
          shape(): VectorShape;
          _shuffleFromArray(indexes: int[], i: int): Short128Vector$Short128Shuffle;
          _shuffleFromArray(a0: int[], a1: int): AbstractShuffle;
          _shuffleFromBytes(reorder: byte[]): Short128Vector$Short128Shuffle;
          _shuffleFromBytes(a0: byte[]): AbstractShuffle;
          _shuffleFromOp(fn: java.util.function.IntUnaryOperator): Short128Vector$Short128Shuffle;
          _shuffleFromOp(a0: java.util.function.IntUnaryOperator): AbstractShuffle;
          slice(origin: int, v: Vector<short>): Short128Vector;
          slice(origin: int): Short128Vector;
          slice(a0: int): ShortVector;
          slice(a0: int, a1: Vector): ShortVector;
          slice(a0: int): AbstractVector;
          slice(a0: int, a1: Vector): AbstractVector;
          slice(a0: int): Vector;
          slice(a0: int, a1: Vector): Vector;
          _tOp(v1: Vector<short>, v2: Vector<short>, f: ShortVector$FTriOp): Short128Vector;
          _tOp(v1: Vector<short>, v2: Vector<short>, m: VectorMask<short>, f: ShortVector$FTriOp): Short128Vector;
          _tOp(a0: Vector, a1: Vector, a2: VectorMask, a3: ShortVector$FTriOp): ShortVector;
          _tOp(a0: Vector, a1: Vector, a2: ShortVector$FTriOp): ShortVector;
          test(op: VectorOperators$Test): Short128Vector$Short128Mask;
          test(op: VectorOperators$Test, m: VectorMask<short>): Short128Vector$Short128Mask;
          test(a0: VectorOperators$Test, a1: VectorMask): VectorMask;
          test(a0: VectorOperators$Test): VectorMask;
          toShuffle(): VectorShuffle<short>;
          _uOp(f: ShortVector$FUnOp): Short128Vector;
          _uOp(m: VectorMask<short>, f: ShortVector$FUnOp): Short128Vector;
          _uOp(a0: VectorMask, a1: ShortVector$FUnOp): ShortVector;
          _uOp(a0: ShortVector$FUnOp): ShortVector;
          unslice(origin: int, w: Vector<short>, part: int): Short128Vector;
          unslice(origin: int, w: Vector<short>, part: int, m: VectorMask<short>): Short128Vector;
          unslice(origin: int): Short128Vector;
          unslice(a0: int): ShortVector;
          unslice(a0: int, a1: Vector, a2: int, a3: VectorMask): ShortVector;
          unslice(a0: int, a1: Vector, a2: int): ShortVector;
          unslice(a0: int): Vector;
          unslice(a0: int, a1: Vector, a2: int, a3: VectorMask): Vector;
          unslice(a0: int, a1: Vector, a2: int): Vector;
          _vec(): short[];
          _vectorFactory(vec: short[]): Short128Vector;
          _vectorFactory(a0: short[]): ShortVector;
          vspecies(): ShortVector$ShortSpecies;
          vspecies(): AbstractSpecies;
          withLane(i: int, e: short): Short128Vector;
          withLane(a0: int, a1: short): ShortVector;
          withLaneHelper(i: int, e: short): Short128Vector;
        }
        interface Short128Vector extends CombineTypes<[_Short128Vector, jdk.incubator.vector.ShortVector]> {}
        interface _Short128Vector$Short128Mask$$static extends ClassLike {
          _maskAll(bit: boolean): Short128Vector$Short128Mask;
          _prepare(bits: boolean[], offset: int): boolean[];
          _prepare(val: boolean): boolean[];
          _ETYPE: java.lang.Class<short>;
          _FALSE_MASK: Short128Vector$Short128Mask;
          _TRUE_MASK: Short128Vector$Short128Mask;
          _VLENGTH: int;
          _new(bits: boolean[]): Short128Vector$Short128Mask;
          _new(bits: boolean[], offset: int): Short128Vector$Short128Mask;
          _new(val: boolean): Short128Vector$Short128Mask;
        }
        let Short128Vector$Short128Mask: _Short128Vector$Short128Mask$$static;
        interface _Short128Vector$Short128Mask {
          allTrue(): boolean;
          and(mask: VectorMask<short>): Short128Vector$Short128Mask;
          and(a0: VectorMask): VectorMask;
          anyTrue(): boolean;
          _bOp(m: VectorMask<short>, f: AbstractMask$MBinOp): Short128Vector$Short128Mask;
          _bOp(a0: VectorMask, a1: AbstractMask$MBinOp): AbstractMask;
          cast<E>(dsp: VectorSpecies<E>): VectorMask<E>;
          compress(): Short128Vector$Short128Mask;
          compress(): VectorMask;
          _defaultMaskCast<E>(dsp: AbstractSpecies<E>): VectorMask<E>;
          firstTrue(): int;
          _getBits(): boolean[];
          _indexPartiallyInUpperRange(offset: long, a1: long): Short128Vector$Short128Mask;
          _indexPartiallyInUpperRange(a0: long, a1: long): VectorMask;
          lastTrue(): int;
          not(): Short128Vector$Short128Mask;
          not(): VectorMask;
          or(mask: VectorMask<short>): Short128Vector$Short128Mask;
          or(a0: VectorMask): VectorMask;
          toLong(): long;
          toVector(): Short128Vector;
          toVector(): Vector;
          trueCount(): int;
          _uOp(f: AbstractMask$MUnOp): Short128Vector$Short128Mask;
          _uOp(a0: AbstractMask$MUnOp): AbstractMask;
          vspecies(): ShortVector$ShortSpecies;
          vspecies(): AbstractSpecies;
          xor(mask: VectorMask<short>): Short128Vector$Short128Mask;
          xor(a0: VectorMask): VectorMask;
        }
        interface Short128Vector$Short128Mask extends CombineTypes<[_Short128Vector$Short128Mask, AbstractMask<short>]> {}
        interface _Short128Vector$Short128Shuffle$$static extends ClassLike {
          _ETYPE: java.lang.Class<short>;
          _IOTA: Short128Vector$Short128Shuffle;
          _VLENGTH: int;
          _new(reorder: byte[]): Short128Vector$Short128Shuffle;
          new(reorder: int[]): Short128Vector$Short128Shuffle;
          new(reorder: int[], i: int): Short128Vector$Short128Shuffle;
          new(fn: java.util.function.IntUnaryOperator): Short128Vector$Short128Shuffle;
        }
        let Short128Vector$Short128Shuffle: _Short128Vector$Short128Shuffle$$static;
        interface _Short128Vector$Short128Shuffle {
          cast<F>(s: VectorSpecies<F>): VectorShuffle<F>;
          rearrange(shuffle: VectorShuffle<short>): Short128Vector$Short128Shuffle;
          rearrange(a0: VectorShuffle): VectorShuffle;
          toVector(): Short128Vector;
          toVector(): Vector;
          vspecies(): ShortVector$ShortSpecies;
          vspecies(): AbstractSpecies;
        }
        interface Short128Vector$Short128Shuffle extends CombineTypes<[_Short128Vector$Short128Shuffle, AbstractShuffle<short>]> {}
        interface _Short256Vector$$static extends ClassLike {
          _ETYPE: java.lang.Class<short>;
          _IOTA: Short256Vector;
          _VCLASS: java.lang.Class<Short256Vector>;
          _VLENGTH: int;
          _VSHAPE: VectorShape;
          _VSIZE: int;
          _VSPECIES: ShortVector$ShortSpecies;
          _ZERO: Short256Vector;
          _new(v: short[]): Short256Vector;
          _new(v: any): Short256Vector;
        }
        let Short256Vector: _Short256Vector$$static;
        interface _Short256Vector {
          addIndex(scale: int): Short256Vector;
          addIndex(a0: int): ShortVector;
          addIndex(a0: int): Vector;
          _asByteVectorRaw(): Byte256Vector;
          _asByteVectorRaw(): ByteVector;
          _asVectorRaw(laneType: LaneType): AbstractVector<any>;
          _bOp(v: Vector<short>, f: ShortVector$FBinOp): Short256Vector;
          _bOp(v: Vector<short>, m: VectorMask<short>, f: ShortVector$FBinOp): Short256Vector;
          _bOp(a0: Vector, a1: VectorMask, a2: ShortVector$FBinOp): ShortVector;
          _bOp(a0: Vector, a1: ShortVector$FBinOp): ShortVector;
          bitSize(): int;
          blend(v: Vector<short>, m: VectorMask<short>): Short256Vector;
          blend(a0: Vector, a1: VectorMask): ShortVector;
          blend(a0: Vector, a1: VectorMask): Vector;
          broadcast(e: short): Short256Vector;
          broadcast(e: long): Short256Vector;
          broadcast(a0: long): ShortVector;
          broadcast(a0: short): ShortVector;
          broadcast(a0: long): Vector;
          byteSize(): int;
          compare(op: VectorOperators$Comparison, v: Vector<short>): Short256Vector$Short256Mask;
          compare(op: VectorOperators$Comparison, s: short): Short256Vector$Short256Mask;
          compare(op: VectorOperators$Comparison, s: long): Short256Vector$Short256Mask;
          compare(op: VectorOperators$Comparison, v: Vector<short>, m: VectorMask<short>): Short256Vector$Short256Mask;
          compare(a0: VectorOperators$Comparison, a1: long): VectorMask;
          compare(a0: VectorOperators$Comparison, a1: short): VectorMask;
          compare(a0: VectorOperators$Comparison, a1: Vector): VectorMask;
          compare(a0: VectorOperators$Comparison, a1: Vector, a2: VectorMask): VectorMask;
          compress(m: VectorMask<short>): Short256Vector;
          compress(a0: VectorMask): ShortVector;
          compress(a0: VectorMask): Vector;
          convertShape<F>(conv: VectorOperators$Conversion<short,F>, rsp: VectorSpecies<F>, part: int): Vector<F>;
          elementSize(): int;
          elementType(): java.lang.Class<short>;
          expand(m: VectorMask<short>): Short256Vector;
          expand(a0: VectorMask): ShortVector;
          expand(a0: VectorMask): Vector;
          _fromArray0(a: short[], offset: int): ShortVector;
          _fromArray0(a: short[], offset: int, m: VectorMask<short>, offsetInRange: int): ShortVector;
          _fromCharArray0(a: char[], offset: int): ShortVector;
          _fromCharArray0(a: char[], offset: int, m: VectorMask<short>, offsetInRange: int): ShortVector;
          _fromMemorySegment0(ms: java.lang.foreign.MemorySegment, offset: long): ShortVector;
          _fromMemorySegment0(ms: java.lang.foreign.MemorySegment, offset: long, a2: VectorMask<short>, m: int): ShortVector;
          _fromMemorySegment0(a0: java.lang.foreign.MemorySegment, a1: long): AbstractVector;
          _intoArray0(a: short[], offset: int): void;
          _intoArray0(a: short[], offset: int, m: VectorMask<short>): void;
          _intoCharArray0(a: char[], offset: int, m: VectorMask<short>): void;
          _intoMemorySegment0(ms: java.lang.foreign.MemorySegment, offset: long, a2: VectorMask<short>): void;
          _iotaShuffle(): Short256Vector$Short256Shuffle;
          _iotaShuffle(start: int, step: int, wrap: boolean): Short256Vector$Short256Shuffle;
          _iotaShuffle(a0: int, a1: int, a2: boolean): AbstractShuffle;
          _iotaShuffle(): AbstractShuffle;
          lane(i: int): short;
          laneHelper(i: int): short;
          lanewise(op: VectorOperators$Unary): Short256Vector;
          lanewise(op: VectorOperators$Unary, m: VectorMask<short>): Short256Vector;
          lanewise(op: VectorOperators$Binary, v: Vector<short>): Short256Vector;
          lanewise(op: VectorOperators$Binary, v: Vector<short>, m: VectorMask<short>): Short256Vector;
          lanewise(op: VectorOperators$Ternary, v1: Vector<short>, v2: Vector<short>): Short256Vector;
          lanewise(op: VectorOperators$Ternary, v1: Vector<short>, v2: Vector<short>, m: VectorMask<short>): Short256Vector;
          lanewise(a0: VectorOperators$Ternary, a1: Vector, a2: Vector, a3: VectorMask): ShortVector;
          lanewise(a0: VectorOperators$Ternary, a1: Vector, a2: Vector): ShortVector;
          lanewise(a0: VectorOperators$Binary, a1: Vector, a2: VectorMask): ShortVector;
          lanewise(a0: VectorOperators$Binary, a1: Vector): ShortVector;
          lanewise(a0: VectorOperators$Unary, a1: VectorMask): ShortVector;
          lanewise(a0: VectorOperators$Unary): ShortVector;
          lanewise(a0: VectorOperators$Ternary, a1: Vector, a2: Vector, a3: VectorMask): Vector;
          lanewise(a0: VectorOperators$Ternary, a1: Vector, a2: Vector): Vector;
          lanewise(a0: VectorOperators$Binary, a1: Vector, a2: VectorMask): Vector;
          lanewise(a0: VectorOperators$Binary, a1: Vector): Vector;
          lanewise(a0: VectorOperators$Unary, a1: VectorMask): Vector;
          lanewise(a0: VectorOperators$Unary): Vector;
          _lanewiseShift(op: VectorOperators$Binary, e: int): Short256Vector;
          _lanewiseShift(op: VectorOperators$Binary, e: int, m: VectorMask<short>): Short256Vector;
          _lanewiseShift(a0: VectorOperators$Binary, a1: int, a2: VectorMask): ShortVector;
          _lanewiseShift(a0: VectorOperators$Binary, a1: int): ShortVector;
          length(): int;
          _maskFromArray(bits: boolean[]): Short256Vector$Short256Mask;
          _maskFromArray(a0: boolean[]): AbstractMask;
          _rOp(v: short, m: VectorMask<short>, f: ShortVector$FBinOp): short;
          rearrange(s: VectorShuffle<short>): Short256Vector;
          rearrange(shuffle: VectorShuffle<short>, m: VectorMask<short>): Short256Vector;
          rearrange(s: VectorShuffle<short>, v: Vector<short>): Short256Vector;
          rearrange(a0: VectorShuffle, a1: Vector): ShortVector;
          rearrange(a0: VectorShuffle, a1: VectorMask): ShortVector;
          rearrange(a0: VectorShuffle): ShortVector;
          rearrange(a0: VectorShuffle, a1: Vector): Vector;
          rearrange(a0: VectorShuffle, a1: VectorMask): Vector;
          rearrange(a0: VectorShuffle): Vector;
          reduceLanes(op: VectorOperators$Associative): short;
          reduceLanes(op: VectorOperators$Associative, m: VectorMask<short>): short;
          reduceLanesToLong(op: VectorOperators$Associative): long;
          reduceLanesToLong(op: VectorOperators$Associative, m: VectorMask<short>): long;
          reinterpretShape<F>(toSpecies: VectorSpecies<F>, part: int): Vector<F>;
          selectFrom(v: Vector<short>): Short256Vector;
          selectFrom(v: Vector<short>, m: VectorMask<short>): Short256Vector;
          selectFrom(a0: Vector, a1: VectorMask): ShortVector;
          selectFrom(a0: Vector): ShortVector;
          selectFrom(a0: Vector, a1: VectorMask): Vector;
          selectFrom(a0: Vector): Vector;
          shape(): VectorShape;
          _shuffleFromArray(indexes: int[], i: int): Short256Vector$Short256Shuffle;
          _shuffleFromArray(a0: int[], a1: int): AbstractShuffle;
          _shuffleFromBytes(reorder: byte[]): Short256Vector$Short256Shuffle;
          _shuffleFromBytes(a0: byte[]): AbstractShuffle;
          _shuffleFromOp(fn: java.util.function.IntUnaryOperator): Short256Vector$Short256Shuffle;
          _shuffleFromOp(a0: java.util.function.IntUnaryOperator): AbstractShuffle;
          slice(origin: int, v: Vector<short>): Short256Vector;
          slice(origin: int): Short256Vector;
          slice(a0: int): ShortVector;
          slice(a0: int, a1: Vector): ShortVector;
          slice(a0: int): AbstractVector;
          slice(a0: int, a1: Vector): AbstractVector;
          slice(a0: int): Vector;
          slice(a0: int, a1: Vector): Vector;
          _tOp(v1: Vector<short>, v2: Vector<short>, f: ShortVector$FTriOp): Short256Vector;
          _tOp(v1: Vector<short>, v2: Vector<short>, m: VectorMask<short>, f: ShortVector$FTriOp): Short256Vector;
          _tOp(a0: Vector, a1: Vector, a2: VectorMask, a3: ShortVector$FTriOp): ShortVector;
          _tOp(a0: Vector, a1: Vector, a2: ShortVector$FTriOp): ShortVector;
          test(op: VectorOperators$Test): Short256Vector$Short256Mask;
          test(op: VectorOperators$Test, m: VectorMask<short>): Short256Vector$Short256Mask;
          test(a0: VectorOperators$Test, a1: VectorMask): VectorMask;
          test(a0: VectorOperators$Test): VectorMask;
          toShuffle(): VectorShuffle<short>;
          _uOp(f: ShortVector$FUnOp): Short256Vector;
          _uOp(m: VectorMask<short>, f: ShortVector$FUnOp): Short256Vector;
          _uOp(a0: VectorMask, a1: ShortVector$FUnOp): ShortVector;
          _uOp(a0: ShortVector$FUnOp): ShortVector;
          unslice(origin: int, w: Vector<short>, part: int): Short256Vector;
          unslice(origin: int, w: Vector<short>, part: int, m: VectorMask<short>): Short256Vector;
          unslice(origin: int): Short256Vector;
          unslice(a0: int): ShortVector;
          unslice(a0: int, a1: Vector, a2: int, a3: VectorMask): ShortVector;
          unslice(a0: int, a1: Vector, a2: int): ShortVector;
          unslice(a0: int): Vector;
          unslice(a0: int, a1: Vector, a2: int, a3: VectorMask): Vector;
          unslice(a0: int, a1: Vector, a2: int): Vector;
          _vec(): short[];
          _vectorFactory(vec: short[]): Short256Vector;
          _vectorFactory(a0: short[]): ShortVector;
          vspecies(): ShortVector$ShortSpecies;
          vspecies(): AbstractSpecies;
          withLane(i: int, e: short): Short256Vector;
          withLane(a0: int, a1: short): ShortVector;
          withLaneHelper(i: int, e: short): Short256Vector;
        }
        interface Short256Vector extends CombineTypes<[_Short256Vector, jdk.incubator.vector.ShortVector]> {}
        interface _Short256Vector$Short256Mask$$static extends ClassLike {
          _maskAll(bit: boolean): Short256Vector$Short256Mask;
          _prepare(bits: boolean[], offset: int): boolean[];
          _prepare(val: boolean): boolean[];
          _ETYPE: java.lang.Class<short>;
          _FALSE_MASK: Short256Vector$Short256Mask;
          _TRUE_MASK: Short256Vector$Short256Mask;
          _VLENGTH: int;
          _new(bits: boolean[]): Short256Vector$Short256Mask;
          _new(bits: boolean[], offset: int): Short256Vector$Short256Mask;
          _new(val: boolean): Short256Vector$Short256Mask;
        }
        let Short256Vector$Short256Mask: _Short256Vector$Short256Mask$$static;
        interface _Short256Vector$Short256Mask {
          allTrue(): boolean;
          and(mask: VectorMask<short>): Short256Vector$Short256Mask;
          and(a0: VectorMask): VectorMask;
          anyTrue(): boolean;
          _bOp(m: VectorMask<short>, f: AbstractMask$MBinOp): Short256Vector$Short256Mask;
          _bOp(a0: VectorMask, a1: AbstractMask$MBinOp): AbstractMask;
          cast<E>(dsp: VectorSpecies<E>): VectorMask<E>;
          compress(): Short256Vector$Short256Mask;
          compress(): VectorMask;
          _defaultMaskCast<E>(dsp: AbstractSpecies<E>): VectorMask<E>;
          firstTrue(): int;
          _getBits(): boolean[];
          _indexPartiallyInUpperRange(offset: long, a1: long): Short256Vector$Short256Mask;
          _indexPartiallyInUpperRange(a0: long, a1: long): VectorMask;
          lastTrue(): int;
          not(): Short256Vector$Short256Mask;
          not(): VectorMask;
          or(mask: VectorMask<short>): Short256Vector$Short256Mask;
          or(a0: VectorMask): VectorMask;
          toLong(): long;
          toVector(): Short256Vector;
          toVector(): Vector;
          trueCount(): int;
          _uOp(f: AbstractMask$MUnOp): Short256Vector$Short256Mask;
          _uOp(a0: AbstractMask$MUnOp): AbstractMask;
          vspecies(): ShortVector$ShortSpecies;
          vspecies(): AbstractSpecies;
          xor(mask: VectorMask<short>): Short256Vector$Short256Mask;
          xor(a0: VectorMask): VectorMask;
        }
        interface Short256Vector$Short256Mask extends CombineTypes<[_Short256Vector$Short256Mask, AbstractMask<short>]> {}
        interface _Short256Vector$Short256Shuffle$$static extends ClassLike {
          _ETYPE: java.lang.Class<short>;
          _IOTA: Short256Vector$Short256Shuffle;
          _VLENGTH: int;
          _new(reorder: byte[]): Short256Vector$Short256Shuffle;
          new(reorder: int[]): Short256Vector$Short256Shuffle;
          new(reorder: int[], i: int): Short256Vector$Short256Shuffle;
          new(fn: java.util.function.IntUnaryOperator): Short256Vector$Short256Shuffle;
        }
        let Short256Vector$Short256Shuffle: _Short256Vector$Short256Shuffle$$static;
        interface _Short256Vector$Short256Shuffle {
          cast<F>(s: VectorSpecies<F>): VectorShuffle<F>;
          rearrange(shuffle: VectorShuffle<short>): Short256Vector$Short256Shuffle;
          rearrange(a0: VectorShuffle): VectorShuffle;
          toVector(): Short256Vector;
          toVector(): Vector;
          vspecies(): ShortVector$ShortSpecies;
          vspecies(): AbstractSpecies;
        }
        interface Short256Vector$Short256Shuffle extends CombineTypes<[_Short256Vector$Short256Shuffle, AbstractShuffle<short>]> {}
        interface _Short512Vector$$static extends ClassLike {
          _ETYPE: java.lang.Class<short>;
          _IOTA: Short512Vector;
          _VCLASS: java.lang.Class<Short512Vector>;
          _VLENGTH: int;
          _VSHAPE: VectorShape;
          _VSIZE: int;
          _VSPECIES: ShortVector$ShortSpecies;
          _ZERO: Short512Vector;
          _new(v: short[]): Short512Vector;
          _new(v: any): Short512Vector;
        }
        let Short512Vector: _Short512Vector$$static;
        interface _Short512Vector {
          addIndex(scale: int): Short512Vector;
          addIndex(a0: int): ShortVector;
          addIndex(a0: int): Vector;
          _asByteVectorRaw(): Byte512Vector;
          _asByteVectorRaw(): ByteVector;
          _asVectorRaw(laneType: LaneType): AbstractVector<any>;
          _bOp(v: Vector<short>, f: ShortVector$FBinOp): Short512Vector;
          _bOp(v: Vector<short>, m: VectorMask<short>, f: ShortVector$FBinOp): Short512Vector;
          _bOp(a0: Vector, a1: VectorMask, a2: ShortVector$FBinOp): ShortVector;
          _bOp(a0: Vector, a1: ShortVector$FBinOp): ShortVector;
          bitSize(): int;
          blend(v: Vector<short>, m: VectorMask<short>): Short512Vector;
          blend(a0: Vector, a1: VectorMask): ShortVector;
          blend(a0: Vector, a1: VectorMask): Vector;
          broadcast(e: short): Short512Vector;
          broadcast(e: long): Short512Vector;
          broadcast(a0: long): ShortVector;
          broadcast(a0: short): ShortVector;
          broadcast(a0: long): Vector;
          byteSize(): int;
          compare(op: VectorOperators$Comparison, v: Vector<short>): Short512Vector$Short512Mask;
          compare(op: VectorOperators$Comparison, s: short): Short512Vector$Short512Mask;
          compare(op: VectorOperators$Comparison, s: long): Short512Vector$Short512Mask;
          compare(op: VectorOperators$Comparison, v: Vector<short>, m: VectorMask<short>): Short512Vector$Short512Mask;
          compare(a0: VectorOperators$Comparison, a1: long): VectorMask;
          compare(a0: VectorOperators$Comparison, a1: short): VectorMask;
          compare(a0: VectorOperators$Comparison, a1: Vector): VectorMask;
          compare(a0: VectorOperators$Comparison, a1: Vector, a2: VectorMask): VectorMask;
          compress(m: VectorMask<short>): Short512Vector;
          compress(a0: VectorMask): ShortVector;
          compress(a0: VectorMask): Vector;
          convertShape<F>(conv: VectorOperators$Conversion<short,F>, rsp: VectorSpecies<F>, part: int): Vector<F>;
          elementSize(): int;
          elementType(): java.lang.Class<short>;
          expand(m: VectorMask<short>): Short512Vector;
          expand(a0: VectorMask): ShortVector;
          expand(a0: VectorMask): Vector;
          _fromArray0(a: short[], offset: int): ShortVector;
          _fromArray0(a: short[], offset: int, m: VectorMask<short>, offsetInRange: int): ShortVector;
          _fromCharArray0(a: char[], offset: int): ShortVector;
          _fromCharArray0(a: char[], offset: int, m: VectorMask<short>, offsetInRange: int): ShortVector;
          _fromMemorySegment0(ms: java.lang.foreign.MemorySegment, offset: long): ShortVector;
          _fromMemorySegment0(ms: java.lang.foreign.MemorySegment, offset: long, a2: VectorMask<short>, m: int): ShortVector;
          _fromMemorySegment0(a0: java.lang.foreign.MemorySegment, a1: long): AbstractVector;
          _intoArray0(a: short[], offset: int): void;
          _intoArray0(a: short[], offset: int, m: VectorMask<short>): void;
          _intoCharArray0(a: char[], offset: int, m: VectorMask<short>): void;
          _intoMemorySegment0(ms: java.lang.foreign.MemorySegment, offset: long, a2: VectorMask<short>): void;
          _iotaShuffle(): Short512Vector$Short512Shuffle;
          _iotaShuffle(start: int, step: int, wrap: boolean): Short512Vector$Short512Shuffle;
          _iotaShuffle(a0: int, a1: int, a2: boolean): AbstractShuffle;
          _iotaShuffle(): AbstractShuffle;
          lane(i: int): short;
          laneHelper(i: int): short;
          lanewise(op: VectorOperators$Unary): Short512Vector;
          lanewise(op: VectorOperators$Unary, m: VectorMask<short>): Short512Vector;
          lanewise(op: VectorOperators$Binary, v: Vector<short>): Short512Vector;
          lanewise(op: VectorOperators$Binary, v: Vector<short>, m: VectorMask<short>): Short512Vector;
          lanewise(op: VectorOperators$Ternary, v1: Vector<short>, v2: Vector<short>): Short512Vector;
          lanewise(op: VectorOperators$Ternary, v1: Vector<short>, v2: Vector<short>, m: VectorMask<short>): Short512Vector;
          lanewise(a0: VectorOperators$Ternary, a1: Vector, a2: Vector, a3: VectorMask): ShortVector;
          lanewise(a0: VectorOperators$Ternary, a1: Vector, a2: Vector): ShortVector;
          lanewise(a0: VectorOperators$Binary, a1: Vector, a2: VectorMask): ShortVector;
          lanewise(a0: VectorOperators$Binary, a1: Vector): ShortVector;
          lanewise(a0: VectorOperators$Unary, a1: VectorMask): ShortVector;
          lanewise(a0: VectorOperators$Unary): ShortVector;
          lanewise(a0: VectorOperators$Ternary, a1: Vector, a2: Vector, a3: VectorMask): Vector;
          lanewise(a0: VectorOperators$Ternary, a1: Vector, a2: Vector): Vector;
          lanewise(a0: VectorOperators$Binary, a1: Vector, a2: VectorMask): Vector;
          lanewise(a0: VectorOperators$Binary, a1: Vector): Vector;
          lanewise(a0: VectorOperators$Unary, a1: VectorMask): Vector;
          lanewise(a0: VectorOperators$Unary): Vector;
          _lanewiseShift(op: VectorOperators$Binary, e: int): Short512Vector;
          _lanewiseShift(op: VectorOperators$Binary, e: int, m: VectorMask<short>): Short512Vector;
          _lanewiseShift(a0: VectorOperators$Binary, a1: int, a2: VectorMask): ShortVector;
          _lanewiseShift(a0: VectorOperators$Binary, a1: int): ShortVector;
          length(): int;
          _maskFromArray(bits: boolean[]): Short512Vector$Short512Mask;
          _maskFromArray(a0: boolean[]): AbstractMask;
          _rOp(v: short, m: VectorMask<short>, f: ShortVector$FBinOp): short;
          rearrange(s: VectorShuffle<short>): Short512Vector;
          rearrange(shuffle: VectorShuffle<short>, m: VectorMask<short>): Short512Vector;
          rearrange(s: VectorShuffle<short>, v: Vector<short>): Short512Vector;
          rearrange(a0: VectorShuffle, a1: Vector): ShortVector;
          rearrange(a0: VectorShuffle, a1: VectorMask): ShortVector;
          rearrange(a0: VectorShuffle): ShortVector;
          rearrange(a0: VectorShuffle, a1: Vector): Vector;
          rearrange(a0: VectorShuffle, a1: VectorMask): Vector;
          rearrange(a0: VectorShuffle): Vector;
          reduceLanes(op: VectorOperators$Associative): short;
          reduceLanes(op: VectorOperators$Associative, m: VectorMask<short>): short;
          reduceLanesToLong(op: VectorOperators$Associative): long;
          reduceLanesToLong(op: VectorOperators$Associative, m: VectorMask<short>): long;
          reinterpretShape<F>(toSpecies: VectorSpecies<F>, part: int): Vector<F>;
          selectFrom(v: Vector<short>): Short512Vector;
          selectFrom(v: Vector<short>, m: VectorMask<short>): Short512Vector;
          selectFrom(a0: Vector, a1: VectorMask): ShortVector;
          selectFrom(a0: Vector): ShortVector;
          selectFrom(a0: Vector, a1: VectorMask): Vector;
          selectFrom(a0: Vector): Vector;
          shape(): VectorShape;
          _shuffleFromArray(indexes: int[], i: int): Short512Vector$Short512Shuffle;
          _shuffleFromArray(a0: int[], a1: int): AbstractShuffle;
          _shuffleFromBytes(reorder: byte[]): Short512Vector$Short512Shuffle;
          _shuffleFromBytes(a0: byte[]): AbstractShuffle;
          _shuffleFromOp(fn: java.util.function.IntUnaryOperator): Short512Vector$Short512Shuffle;
          _shuffleFromOp(a0: java.util.function.IntUnaryOperator): AbstractShuffle;
          slice(origin: int, v: Vector<short>): Short512Vector;
          slice(origin: int): Short512Vector;
          slice(a0: int): ShortVector;
          slice(a0: int, a1: Vector): ShortVector;
          slice(a0: int): AbstractVector;
          slice(a0: int, a1: Vector): AbstractVector;
          slice(a0: int): Vector;
          slice(a0: int, a1: Vector): Vector;
          _tOp(v1: Vector<short>, v2: Vector<short>, f: ShortVector$FTriOp): Short512Vector;
          _tOp(v1: Vector<short>, v2: Vector<short>, m: VectorMask<short>, f: ShortVector$FTriOp): Short512Vector;
          _tOp(a0: Vector, a1: Vector, a2: VectorMask, a3: ShortVector$FTriOp): ShortVector;
          _tOp(a0: Vector, a1: Vector, a2: ShortVector$FTriOp): ShortVector;
          test(op: VectorOperators$Test): Short512Vector$Short512Mask;
          test(op: VectorOperators$Test, m: VectorMask<short>): Short512Vector$Short512Mask;
          test(a0: VectorOperators$Test, a1: VectorMask): VectorMask;
          test(a0: VectorOperators$Test): VectorMask;
          toShuffle(): VectorShuffle<short>;
          _uOp(f: ShortVector$FUnOp): Short512Vector;
          _uOp(m: VectorMask<short>, f: ShortVector$FUnOp): Short512Vector;
          _uOp(a0: VectorMask, a1: ShortVector$FUnOp): ShortVector;
          _uOp(a0: ShortVector$FUnOp): ShortVector;
          unslice(origin: int, w: Vector<short>, part: int): Short512Vector;
          unslice(origin: int, w: Vector<short>, part: int, m: VectorMask<short>): Short512Vector;
          unslice(origin: int): Short512Vector;
          unslice(a0: int): ShortVector;
          unslice(a0: int, a1: Vector, a2: int, a3: VectorMask): ShortVector;
          unslice(a0: int, a1: Vector, a2: int): ShortVector;
          unslice(a0: int): Vector;
          unslice(a0: int, a1: Vector, a2: int, a3: VectorMask): Vector;
          unslice(a0: int, a1: Vector, a2: int): Vector;
          _vec(): short[];
          _vectorFactory(vec: short[]): Short512Vector;
          _vectorFactory(a0: short[]): ShortVector;
          vspecies(): ShortVector$ShortSpecies;
          vspecies(): AbstractSpecies;
          withLane(i: int, e: short): Short512Vector;
          withLane(a0: int, a1: short): ShortVector;
          withLaneHelper(i: int, e: short): Short512Vector;
        }
        interface Short512Vector extends CombineTypes<[_Short512Vector, jdk.incubator.vector.ShortVector]> {}
        interface _Short512Vector$Short512Mask$$static extends ClassLike {
          _maskAll(bit: boolean): Short512Vector$Short512Mask;
          _prepare(bits: boolean[], offset: int): boolean[];
          _prepare(val: boolean): boolean[];
          _ETYPE: java.lang.Class<short>;
          _FALSE_MASK: Short512Vector$Short512Mask;
          _TRUE_MASK: Short512Vector$Short512Mask;
          _VLENGTH: int;
          _new(bits: boolean[]): Short512Vector$Short512Mask;
          _new(bits: boolean[], offset: int): Short512Vector$Short512Mask;
          _new(val: boolean): Short512Vector$Short512Mask;
        }
        let Short512Vector$Short512Mask: _Short512Vector$Short512Mask$$static;
        interface _Short512Vector$Short512Mask {
          allTrue(): boolean;
          and(mask: VectorMask<short>): Short512Vector$Short512Mask;
          and(a0: VectorMask): VectorMask;
          anyTrue(): boolean;
          _bOp(m: VectorMask<short>, f: AbstractMask$MBinOp): Short512Vector$Short512Mask;
          _bOp(a0: VectorMask, a1: AbstractMask$MBinOp): AbstractMask;
          cast<E>(dsp: VectorSpecies<E>): VectorMask<E>;
          compress(): Short512Vector$Short512Mask;
          compress(): VectorMask;
          _defaultMaskCast<E>(dsp: AbstractSpecies<E>): VectorMask<E>;
          firstTrue(): int;
          _getBits(): boolean[];
          _indexPartiallyInUpperRange(offset: long, a1: long): Short512Vector$Short512Mask;
          _indexPartiallyInUpperRange(a0: long, a1: long): VectorMask;
          lastTrue(): int;
          not(): Short512Vector$Short512Mask;
          not(): VectorMask;
          or(mask: VectorMask<short>): Short512Vector$Short512Mask;
          or(a0: VectorMask): VectorMask;
          toLong(): long;
          toVector(): Short512Vector;
          toVector(): Vector;
          trueCount(): int;
          _uOp(f: AbstractMask$MUnOp): Short512Vector$Short512Mask;
          _uOp(a0: AbstractMask$MUnOp): AbstractMask;
          vspecies(): ShortVector$ShortSpecies;
          vspecies(): AbstractSpecies;
          xor(mask: VectorMask<short>): Short512Vector$Short512Mask;
          xor(a0: VectorMask): VectorMask;
        }
        interface Short512Vector$Short512Mask extends CombineTypes<[_Short512Vector$Short512Mask, AbstractMask<short>]> {}
        interface _Short512Vector$Short512Shuffle$$static extends ClassLike {
          _ETYPE: java.lang.Class<short>;
          _IOTA: Short512Vector$Short512Shuffle;
          _VLENGTH: int;
          _new(reorder: byte[]): Short512Vector$Short512Shuffle;
          new(reorder: int[]): Short512Vector$Short512Shuffle;
          new(reorder: int[], i: int): Short512Vector$Short512Shuffle;
          new(fn: java.util.function.IntUnaryOperator): Short512Vector$Short512Shuffle;
        }
        let Short512Vector$Short512Shuffle: _Short512Vector$Short512Shuffle$$static;
        interface _Short512Vector$Short512Shuffle {
          cast<F>(s: VectorSpecies<F>): VectorShuffle<F>;
          rearrange(shuffle: VectorShuffle<short>): Short512Vector$Short512Shuffle;
          rearrange(a0: VectorShuffle): VectorShuffle;
          toVector(): Short512Vector;
          toVector(): Vector;
          vspecies(): ShortVector$ShortSpecies;
          vspecies(): AbstractSpecies;
        }
        interface Short512Vector$Short512Shuffle extends CombineTypes<[_Short512Vector$Short512Shuffle, AbstractShuffle<short>]> {}
        interface _Short64Vector$$static extends ClassLike {
          _ETYPE: java.lang.Class<short>;
          _IOTA: Short64Vector;
          _VCLASS: java.lang.Class<Short64Vector>;
          _VLENGTH: int;
          _VSHAPE: VectorShape;
          _VSIZE: int;
          _VSPECIES: ShortVector$ShortSpecies;
          _ZERO: Short64Vector;
          _new(v: short[]): Short64Vector;
          _new(v: any): Short64Vector;
        }
        let Short64Vector: _Short64Vector$$static;
        interface _Short64Vector {
          addIndex(scale: int): Short64Vector;
          addIndex(a0: int): ShortVector;
          addIndex(a0: int): Vector;
          _asByteVectorRaw(): Byte64Vector;
          _asByteVectorRaw(): ByteVector;
          _asVectorRaw(laneType: LaneType): AbstractVector<any>;
          _bOp(v: Vector<short>, f: ShortVector$FBinOp): Short64Vector;
          _bOp(v: Vector<short>, m: VectorMask<short>, f: ShortVector$FBinOp): Short64Vector;
          _bOp(a0: Vector, a1: VectorMask, a2: ShortVector$FBinOp): ShortVector;
          _bOp(a0: Vector, a1: ShortVector$FBinOp): ShortVector;
          bitSize(): int;
          blend(v: Vector<short>, m: VectorMask<short>): Short64Vector;
          blend(a0: Vector, a1: VectorMask): ShortVector;
          blend(a0: Vector, a1: VectorMask): Vector;
          broadcast(e: short): Short64Vector;
          broadcast(e: long): Short64Vector;
          broadcast(a0: long): ShortVector;
          broadcast(a0: short): ShortVector;
          broadcast(a0: long): Vector;
          byteSize(): int;
          compare(op: VectorOperators$Comparison, v: Vector<short>): Short64Vector$Short64Mask;
          compare(op: VectorOperators$Comparison, s: short): Short64Vector$Short64Mask;
          compare(op: VectorOperators$Comparison, s: long): Short64Vector$Short64Mask;
          compare(op: VectorOperators$Comparison, v: Vector<short>, m: VectorMask<short>): Short64Vector$Short64Mask;
          compare(a0: VectorOperators$Comparison, a1: long): VectorMask;
          compare(a0: VectorOperators$Comparison, a1: short): VectorMask;
          compare(a0: VectorOperators$Comparison, a1: Vector): VectorMask;
          compare(a0: VectorOperators$Comparison, a1: Vector, a2: VectorMask): VectorMask;
          compress(m: VectorMask<short>): Short64Vector;
          compress(a0: VectorMask): ShortVector;
          compress(a0: VectorMask): Vector;
          convertShape<F>(conv: VectorOperators$Conversion<short,F>, rsp: VectorSpecies<F>, part: int): Vector<F>;
          elementSize(): int;
          elementType(): java.lang.Class<short>;
          expand(m: VectorMask<short>): Short64Vector;
          expand(a0: VectorMask): ShortVector;
          expand(a0: VectorMask): Vector;
          _fromArray0(a: short[], offset: int): ShortVector;
          _fromArray0(a: short[], offset: int, m: VectorMask<short>, offsetInRange: int): ShortVector;
          _fromCharArray0(a: char[], offset: int): ShortVector;
          _fromCharArray0(a: char[], offset: int, m: VectorMask<short>, offsetInRange: int): ShortVector;
          _fromMemorySegment0(ms: java.lang.foreign.MemorySegment, offset: long): ShortVector;
          _fromMemorySegment0(ms: java.lang.foreign.MemorySegment, offset: long, a2: VectorMask<short>, m: int): ShortVector;
          _fromMemorySegment0(a0: java.lang.foreign.MemorySegment, a1: long): AbstractVector;
          _intoArray0(a: short[], offset: int): void;
          _intoArray0(a: short[], offset: int, m: VectorMask<short>): void;
          _intoCharArray0(a: char[], offset: int, m: VectorMask<short>): void;
          _intoMemorySegment0(ms: java.lang.foreign.MemorySegment, offset: long, a2: VectorMask<short>): void;
          _iotaShuffle(): Short64Vector$Short64Shuffle;
          _iotaShuffle(start: int, step: int, wrap: boolean): Short64Vector$Short64Shuffle;
          _iotaShuffle(a0: int, a1: int, a2: boolean): AbstractShuffle;
          _iotaShuffle(): AbstractShuffle;
          lane(i: int): short;
          laneHelper(i: int): short;
          lanewise(op: VectorOperators$Unary): Short64Vector;
          lanewise(op: VectorOperators$Unary, m: VectorMask<short>): Short64Vector;
          lanewise(op: VectorOperators$Binary, v: Vector<short>): Short64Vector;
          lanewise(op: VectorOperators$Binary, v: Vector<short>, m: VectorMask<short>): Short64Vector;
          lanewise(op: VectorOperators$Ternary, v1: Vector<short>, v2: Vector<short>): Short64Vector;
          lanewise(op: VectorOperators$Ternary, v1: Vector<short>, v2: Vector<short>, m: VectorMask<short>): Short64Vector;
          lanewise(a0: VectorOperators$Ternary, a1: Vector, a2: Vector, a3: VectorMask): ShortVector;
          lanewise(a0: VectorOperators$Ternary, a1: Vector, a2: Vector): ShortVector;
          lanewise(a0: VectorOperators$Binary, a1: Vector, a2: VectorMask): ShortVector;
          lanewise(a0: VectorOperators$Binary, a1: Vector): ShortVector;
          lanewise(a0: VectorOperators$Unary, a1: VectorMask): ShortVector;
          lanewise(a0: VectorOperators$Unary): ShortVector;
          lanewise(a0: VectorOperators$Ternary, a1: Vector, a2: Vector, a3: VectorMask): Vector;
          lanewise(a0: VectorOperators$Ternary, a1: Vector, a2: Vector): Vector;
          lanewise(a0: VectorOperators$Binary, a1: Vector, a2: VectorMask): Vector;
          lanewise(a0: VectorOperators$Binary, a1: Vector): Vector;
          lanewise(a0: VectorOperators$Unary, a1: VectorMask): Vector;
          lanewise(a0: VectorOperators$Unary): Vector;
          _lanewiseShift(op: VectorOperators$Binary, e: int): Short64Vector;
          _lanewiseShift(op: VectorOperators$Binary, e: int, m: VectorMask<short>): Short64Vector;
          _lanewiseShift(a0: VectorOperators$Binary, a1: int, a2: VectorMask): ShortVector;
          _lanewiseShift(a0: VectorOperators$Binary, a1: int): ShortVector;
          length(): int;
          _maskFromArray(bits: boolean[]): Short64Vector$Short64Mask;
          _maskFromArray(a0: boolean[]): AbstractMask;
          _rOp(v: short, m: VectorMask<short>, f: ShortVector$FBinOp): short;
          rearrange(s: VectorShuffle<short>): Short64Vector;
          rearrange(shuffle: VectorShuffle<short>, m: VectorMask<short>): Short64Vector;
          rearrange(s: VectorShuffle<short>, v: Vector<short>): Short64Vector;
          rearrange(a0: VectorShuffle, a1: Vector): ShortVector;
          rearrange(a0: VectorShuffle, a1: VectorMask): ShortVector;
          rearrange(a0: VectorShuffle): ShortVector;
          rearrange(a0: VectorShuffle, a1: Vector): Vector;
          rearrange(a0: VectorShuffle, a1: VectorMask): Vector;
          rearrange(a0: VectorShuffle): Vector;
          reduceLanes(op: VectorOperators$Associative): short;
          reduceLanes(op: VectorOperators$Associative, m: VectorMask<short>): short;
          reduceLanesToLong(op: VectorOperators$Associative): long;
          reduceLanesToLong(op: VectorOperators$Associative, m: VectorMask<short>): long;
          reinterpretShape<F>(toSpecies: VectorSpecies<F>, part: int): Vector<F>;
          selectFrom(v: Vector<short>): Short64Vector;
          selectFrom(v: Vector<short>, m: VectorMask<short>): Short64Vector;
          selectFrom(a0: Vector, a1: VectorMask): ShortVector;
          selectFrom(a0: Vector): ShortVector;
          selectFrom(a0: Vector, a1: VectorMask): Vector;
          selectFrom(a0: Vector): Vector;
          shape(): VectorShape;
          _shuffleFromArray(indexes: int[], i: int): Short64Vector$Short64Shuffle;
          _shuffleFromArray(a0: int[], a1: int): AbstractShuffle;
          _shuffleFromBytes(reorder: byte[]): Short64Vector$Short64Shuffle;
          _shuffleFromBytes(a0: byte[]): AbstractShuffle;
          _shuffleFromOp(fn: java.util.function.IntUnaryOperator): Short64Vector$Short64Shuffle;
          _shuffleFromOp(a0: java.util.function.IntUnaryOperator): AbstractShuffle;
          slice(origin: int, v: Vector<short>): Short64Vector;
          slice(origin: int): Short64Vector;
          slice(a0: int): ShortVector;
          slice(a0: int, a1: Vector): ShortVector;
          slice(a0: int): AbstractVector;
          slice(a0: int, a1: Vector): AbstractVector;
          slice(a0: int): Vector;
          slice(a0: int, a1: Vector): Vector;
          _tOp(v1: Vector<short>, v2: Vector<short>, f: ShortVector$FTriOp): Short64Vector;
          _tOp(v1: Vector<short>, v2: Vector<short>, m: VectorMask<short>, f: ShortVector$FTriOp): Short64Vector;
          _tOp(a0: Vector, a1: Vector, a2: VectorMask, a3: ShortVector$FTriOp): ShortVector;
          _tOp(a0: Vector, a1: Vector, a2: ShortVector$FTriOp): ShortVector;
          test(op: VectorOperators$Test): Short64Vector$Short64Mask;
          test(op: VectorOperators$Test, m: VectorMask<short>): Short64Vector$Short64Mask;
          test(a0: VectorOperators$Test, a1: VectorMask): VectorMask;
          test(a0: VectorOperators$Test): VectorMask;
          toShuffle(): VectorShuffle<short>;
          _uOp(f: ShortVector$FUnOp): Short64Vector;
          _uOp(m: VectorMask<short>, f: ShortVector$FUnOp): Short64Vector;
          _uOp(a0: VectorMask, a1: ShortVector$FUnOp): ShortVector;
          _uOp(a0: ShortVector$FUnOp): ShortVector;
          unslice(origin: int, w: Vector<short>, part: int): Short64Vector;
          unslice(origin: int, w: Vector<short>, part: int, m: VectorMask<short>): Short64Vector;
          unslice(origin: int): Short64Vector;
          unslice(a0: int): ShortVector;
          unslice(a0: int, a1: Vector, a2: int, a3: VectorMask): ShortVector;
          unslice(a0: int, a1: Vector, a2: int): ShortVector;
          unslice(a0: int): Vector;
          unslice(a0: int, a1: Vector, a2: int, a3: VectorMask): Vector;
          unslice(a0: int, a1: Vector, a2: int): Vector;
          _vec(): short[];
          _vectorFactory(vec: short[]): Short64Vector;
          _vectorFactory(a0: short[]): ShortVector;
          vspecies(): ShortVector$ShortSpecies;
          vspecies(): AbstractSpecies;
          withLane(i: int, e: short): Short64Vector;
          withLane(a0: int, a1: short): ShortVector;
          withLaneHelper(i: int, e: short): Short64Vector;
        }
        interface Short64Vector extends CombineTypes<[_Short64Vector, jdk.incubator.vector.ShortVector]> {}
        interface _Short64Vector$Short64Mask$$static extends ClassLike {
          _maskAll(bit: boolean): Short64Vector$Short64Mask;
          _prepare(bits: boolean[], offset: int): boolean[];
          _prepare(val: boolean): boolean[];
          _ETYPE: java.lang.Class<short>;
          _FALSE_MASK: Short64Vector$Short64Mask;
          _TRUE_MASK: Short64Vector$Short64Mask;
          _VLENGTH: int;
          _new(bits: boolean[]): Short64Vector$Short64Mask;
          _new(bits: boolean[], offset: int): Short64Vector$Short64Mask;
          _new(val: boolean): Short64Vector$Short64Mask;
        }
        let Short64Vector$Short64Mask: _Short64Vector$Short64Mask$$static;
        interface _Short64Vector$Short64Mask {
          allTrue(): boolean;
          and(mask: VectorMask<short>): Short64Vector$Short64Mask;
          and(a0: VectorMask): VectorMask;
          anyTrue(): boolean;
          _bOp(m: VectorMask<short>, f: AbstractMask$MBinOp): Short64Vector$Short64Mask;
          _bOp(a0: VectorMask, a1: AbstractMask$MBinOp): AbstractMask;
          cast<E>(dsp: VectorSpecies<E>): VectorMask<E>;
          compress(): Short64Vector$Short64Mask;
          compress(): VectorMask;
          _defaultMaskCast<E>(dsp: AbstractSpecies<E>): VectorMask<E>;
          firstTrue(): int;
          _getBits(): boolean[];
          _indexPartiallyInUpperRange(offset: long, a1: long): Short64Vector$Short64Mask;
          _indexPartiallyInUpperRange(a0: long, a1: long): VectorMask;
          lastTrue(): int;
          not(): Short64Vector$Short64Mask;
          not(): VectorMask;
          or(mask: VectorMask<short>): Short64Vector$Short64Mask;
          or(a0: VectorMask): VectorMask;
          toLong(): long;
          toVector(): Short64Vector;
          toVector(): Vector;
          trueCount(): int;
          _uOp(f: AbstractMask$MUnOp): Short64Vector$Short64Mask;
          _uOp(a0: AbstractMask$MUnOp): AbstractMask;
          vspecies(): ShortVector$ShortSpecies;
          vspecies(): AbstractSpecies;
          xor(mask: VectorMask<short>): Short64Vector$Short64Mask;
          xor(a0: VectorMask): VectorMask;
        }
        interface Short64Vector$Short64Mask extends CombineTypes<[_Short64Vector$Short64Mask, AbstractMask<short>]> {}
        interface _Short64Vector$Short64Shuffle$$static extends ClassLike {
          _ETYPE: java.lang.Class<short>;
          _IOTA: Short64Vector$Short64Shuffle;
          _VLENGTH: int;
          _new(reorder: byte[]): Short64Vector$Short64Shuffle;
          new(reorder: int[]): Short64Vector$Short64Shuffle;
          new(reorder: int[], i: int): Short64Vector$Short64Shuffle;
          new(fn: java.util.function.IntUnaryOperator): Short64Vector$Short64Shuffle;
        }
        let Short64Vector$Short64Shuffle: _Short64Vector$Short64Shuffle$$static;
        interface _Short64Vector$Short64Shuffle {
          cast<F>(s: VectorSpecies<F>): VectorShuffle<F>;
          rearrange(shuffle: VectorShuffle<short>): Short64Vector$Short64Shuffle;
          rearrange(a0: VectorShuffle): VectorShuffle;
          toVector(): Short64Vector;
          toVector(): Vector;
          vspecies(): ShortVector$ShortSpecies;
          vspecies(): AbstractSpecies;
        }
        interface Short64Vector$Short64Shuffle extends CombineTypes<[_Short64Vector$Short64Shuffle, AbstractShuffle<short>]> {}
        interface _ShortMaxVector$$static extends ClassLike {
          _ETYPE: java.lang.Class<short>;
          _IOTA: ShortMaxVector;
          _VCLASS: java.lang.Class<ShortMaxVector>;
          _VLENGTH: int;
          _VSHAPE: VectorShape;
          _VSIZE: int;
          _VSPECIES: ShortVector$ShortSpecies;
          _ZERO: ShortMaxVector;
          _new(v: short[]): ShortMaxVector;
          _new(v: any): ShortMaxVector;
        }
        let ShortMaxVector: _ShortMaxVector$$static;
        interface _ShortMaxVector {
          addIndex(scale: int): ShortMaxVector;
          addIndex(a0: int): ShortVector;
          addIndex(a0: int): Vector;
          _asByteVectorRaw(): ByteMaxVector;
          _asByteVectorRaw(): ByteVector;
          _asVectorRaw(laneType: LaneType): AbstractVector<any>;
          _bOp(v: Vector<short>, f: ShortVector$FBinOp): ShortMaxVector;
          _bOp(v: Vector<short>, m: VectorMask<short>, f: ShortVector$FBinOp): ShortMaxVector;
          _bOp(a0: Vector, a1: VectorMask, a2: ShortVector$FBinOp): ShortVector;
          _bOp(a0: Vector, a1: ShortVector$FBinOp): ShortVector;
          bitSize(): int;
          blend(v: Vector<short>, m: VectorMask<short>): ShortMaxVector;
          blend(a0: Vector, a1: VectorMask): ShortVector;
          blend(a0: Vector, a1: VectorMask): Vector;
          broadcast(e: short): ShortMaxVector;
          broadcast(e: long): ShortMaxVector;
          broadcast(a0: long): ShortVector;
          broadcast(a0: short): ShortVector;
          broadcast(a0: long): Vector;
          byteSize(): int;
          compare(op: VectorOperators$Comparison, v: Vector<short>): ShortMaxVector$ShortMaxMask;
          compare(op: VectorOperators$Comparison, s: short): ShortMaxVector$ShortMaxMask;
          compare(op: VectorOperators$Comparison, s: long): ShortMaxVector$ShortMaxMask;
          compare(op: VectorOperators$Comparison, v: Vector<short>, m: VectorMask<short>): ShortMaxVector$ShortMaxMask;
          compare(a0: VectorOperators$Comparison, a1: long): VectorMask;
          compare(a0: VectorOperators$Comparison, a1: short): VectorMask;
          compare(a0: VectorOperators$Comparison, a1: Vector): VectorMask;
          compare(a0: VectorOperators$Comparison, a1: Vector, a2: VectorMask): VectorMask;
          compress(m: VectorMask<short>): ShortMaxVector;
          compress(a0: VectorMask): ShortVector;
          compress(a0: VectorMask): Vector;
          convertShape<F>(conv: VectorOperators$Conversion<short,F>, rsp: VectorSpecies<F>, part: int): Vector<F>;
          elementSize(): int;
          elementType(): java.lang.Class<short>;
          expand(m: VectorMask<short>): ShortMaxVector;
          expand(a0: VectorMask): ShortVector;
          expand(a0: VectorMask): Vector;
          _fromArray0(a: short[], offset: int): ShortVector;
          _fromArray0(a: short[], offset: int, m: VectorMask<short>, offsetInRange: int): ShortVector;
          _fromCharArray0(a: char[], offset: int): ShortVector;
          _fromCharArray0(a: char[], offset: int, m: VectorMask<short>, offsetInRange: int): ShortVector;
          _fromMemorySegment0(ms: java.lang.foreign.MemorySegment, offset: long): ShortVector;
          _fromMemorySegment0(ms: java.lang.foreign.MemorySegment, offset: long, a2: VectorMask<short>, m: int): ShortVector;
          _fromMemorySegment0(a0: java.lang.foreign.MemorySegment, a1: long): AbstractVector;
          _intoArray0(a: short[], offset: int): void;
          _intoArray0(a: short[], offset: int, m: VectorMask<short>): void;
          _intoCharArray0(a: char[], offset: int, m: VectorMask<short>): void;
          _intoMemorySegment0(ms: java.lang.foreign.MemorySegment, offset: long, a2: VectorMask<short>): void;
          _iotaShuffle(): ShortMaxVector$ShortMaxShuffle;
          _iotaShuffle(start: int, step: int, wrap: boolean): ShortMaxVector$ShortMaxShuffle;
          _iotaShuffle(a0: int, a1: int, a2: boolean): AbstractShuffle;
          _iotaShuffle(): AbstractShuffle;
          lane(i: int): short;
          laneHelper(i: int): short;
          lanewise(op: VectorOperators$Unary): ShortMaxVector;
          lanewise(op: VectorOperators$Unary, m: VectorMask<short>): ShortMaxVector;
          lanewise(op: VectorOperators$Binary, v: Vector<short>): ShortMaxVector;
          lanewise(op: VectorOperators$Binary, v: Vector<short>, m: VectorMask<short>): ShortMaxVector;
          lanewise(op: VectorOperators$Ternary, v1: Vector<short>, v2: Vector<short>): ShortMaxVector;
          lanewise(op: VectorOperators$Ternary, v1: Vector<short>, v2: Vector<short>, m: VectorMask<short>): ShortMaxVector;
          lanewise(a0: VectorOperators$Ternary, a1: Vector, a2: Vector, a3: VectorMask): ShortVector;
          lanewise(a0: VectorOperators$Ternary, a1: Vector, a2: Vector): ShortVector;
          lanewise(a0: VectorOperators$Binary, a1: Vector, a2: VectorMask): ShortVector;
          lanewise(a0: VectorOperators$Binary, a1: Vector): ShortVector;
          lanewise(a0: VectorOperators$Unary, a1: VectorMask): ShortVector;
          lanewise(a0: VectorOperators$Unary): ShortVector;
          lanewise(a0: VectorOperators$Ternary, a1: Vector, a2: Vector, a3: VectorMask): Vector;
          lanewise(a0: VectorOperators$Ternary, a1: Vector, a2: Vector): Vector;
          lanewise(a0: VectorOperators$Binary, a1: Vector, a2: VectorMask): Vector;
          lanewise(a0: VectorOperators$Binary, a1: Vector): Vector;
          lanewise(a0: VectorOperators$Unary, a1: VectorMask): Vector;
          lanewise(a0: VectorOperators$Unary): Vector;
          _lanewiseShift(op: VectorOperators$Binary, e: int): ShortMaxVector;
          _lanewiseShift(op: VectorOperators$Binary, e: int, m: VectorMask<short>): ShortMaxVector;
          _lanewiseShift(a0: VectorOperators$Binary, a1: int, a2: VectorMask): ShortVector;
          _lanewiseShift(a0: VectorOperators$Binary, a1: int): ShortVector;
          length(): int;
          _maskFromArray(bits: boolean[]): ShortMaxVector$ShortMaxMask;
          _maskFromArray(a0: boolean[]): AbstractMask;
          _rOp(v: short, m: VectorMask<short>, f: ShortVector$FBinOp): short;
          rearrange(s: VectorShuffle<short>): ShortMaxVector;
          rearrange(shuffle: VectorShuffle<short>, m: VectorMask<short>): ShortMaxVector;
          rearrange(s: VectorShuffle<short>, v: Vector<short>): ShortMaxVector;
          rearrange(a0: VectorShuffle, a1: Vector): ShortVector;
          rearrange(a0: VectorShuffle, a1: VectorMask): ShortVector;
          rearrange(a0: VectorShuffle): ShortVector;
          rearrange(a0: VectorShuffle, a1: Vector): Vector;
          rearrange(a0: VectorShuffle, a1: VectorMask): Vector;
          rearrange(a0: VectorShuffle): Vector;
          reduceLanes(op: VectorOperators$Associative): short;
          reduceLanes(op: VectorOperators$Associative, m: VectorMask<short>): short;
          reduceLanesToLong(op: VectorOperators$Associative): long;
          reduceLanesToLong(op: VectorOperators$Associative, m: VectorMask<short>): long;
          reinterpretShape<F>(toSpecies: VectorSpecies<F>, part: int): Vector<F>;
          selectFrom(v: Vector<short>): ShortMaxVector;
          selectFrom(v: Vector<short>, m: VectorMask<short>): ShortMaxVector;
          selectFrom(a0: Vector, a1: VectorMask): ShortVector;
          selectFrom(a0: Vector): ShortVector;
          selectFrom(a0: Vector, a1: VectorMask): Vector;
          selectFrom(a0: Vector): Vector;
          shape(): VectorShape;
          _shuffleFromArray(indexes: int[], i: int): ShortMaxVector$ShortMaxShuffle;
          _shuffleFromArray(a0: int[], a1: int): AbstractShuffle;
          _shuffleFromBytes(reorder: byte[]): ShortMaxVector$ShortMaxShuffle;
          _shuffleFromBytes(a0: byte[]): AbstractShuffle;
          _shuffleFromOp(fn: java.util.function.IntUnaryOperator): ShortMaxVector$ShortMaxShuffle;
          _shuffleFromOp(a0: java.util.function.IntUnaryOperator): AbstractShuffle;
          slice(origin: int, v: Vector<short>): ShortMaxVector;
          slice(origin: int): ShortMaxVector;
          slice(a0: int): ShortVector;
          slice(a0: int, a1: Vector): ShortVector;
          slice(a0: int): AbstractVector;
          slice(a0: int, a1: Vector): AbstractVector;
          slice(a0: int): Vector;
          slice(a0: int, a1: Vector): Vector;
          _tOp(v1: Vector<short>, v2: Vector<short>, f: ShortVector$FTriOp): ShortMaxVector;
          _tOp(v1: Vector<short>, v2: Vector<short>, m: VectorMask<short>, f: ShortVector$FTriOp): ShortMaxVector;
          _tOp(a0: Vector, a1: Vector, a2: VectorMask, a3: ShortVector$FTriOp): ShortVector;
          _tOp(a0: Vector, a1: Vector, a2: ShortVector$FTriOp): ShortVector;
          test(op: VectorOperators$Test): ShortMaxVector$ShortMaxMask;
          test(op: VectorOperators$Test, m: VectorMask<short>): ShortMaxVector$ShortMaxMask;
          test(a0: VectorOperators$Test, a1: VectorMask): VectorMask;
          test(a0: VectorOperators$Test): VectorMask;
          toShuffle(): VectorShuffle<short>;
          _uOp(f: ShortVector$FUnOp): ShortMaxVector;
          _uOp(m: VectorMask<short>, f: ShortVector$FUnOp): ShortMaxVector;
          _uOp(a0: VectorMask, a1: ShortVector$FUnOp): ShortVector;
          _uOp(a0: ShortVector$FUnOp): ShortVector;
          unslice(origin: int, w: Vector<short>, part: int): ShortMaxVector;
          unslice(origin: int, w: Vector<short>, part: int, m: VectorMask<short>): ShortMaxVector;
          unslice(origin: int): ShortMaxVector;
          unslice(a0: int): ShortVector;
          unslice(a0: int, a1: Vector, a2: int, a3: VectorMask): ShortVector;
          unslice(a0: int, a1: Vector, a2: int): ShortVector;
          unslice(a0: int): Vector;
          unslice(a0: int, a1: Vector, a2: int, a3: VectorMask): Vector;
          unslice(a0: int, a1: Vector, a2: int): Vector;
          _vec(): short[];
          _vectorFactory(vec: short[]): ShortMaxVector;
          _vectorFactory(a0: short[]): ShortVector;
          vspecies(): ShortVector$ShortSpecies;
          vspecies(): AbstractSpecies;
          withLane(i: int, e: short): ShortMaxVector;
          withLane(a0: int, a1: short): ShortVector;
          withLaneHelper(i: int, e: short): ShortMaxVector;
        }
        interface ShortMaxVector extends CombineTypes<[_ShortMaxVector, jdk.incubator.vector.ShortVector]> {}
        interface _ShortMaxVector$ShortMaxMask$$static extends ClassLike {
          _maskAll(bit: boolean): ShortMaxVector$ShortMaxMask;
          _prepare(bits: boolean[], offset: int): boolean[];
          _prepare(val: boolean): boolean[];
          _ETYPE: java.lang.Class<short>;
          _FALSE_MASK: ShortMaxVector$ShortMaxMask;
          _TRUE_MASK: ShortMaxVector$ShortMaxMask;
          _VLENGTH: int;
          _new(bits: boolean[]): ShortMaxVector$ShortMaxMask;
          _new(bits: boolean[], offset: int): ShortMaxVector$ShortMaxMask;
          _new(val: boolean): ShortMaxVector$ShortMaxMask;
        }
        let ShortMaxVector$ShortMaxMask: _ShortMaxVector$ShortMaxMask$$static;
        interface _ShortMaxVector$ShortMaxMask {
          allTrue(): boolean;
          and(mask: VectorMask<short>): ShortMaxVector$ShortMaxMask;
          and(a0: VectorMask): VectorMask;
          anyTrue(): boolean;
          _bOp(m: VectorMask<short>, f: AbstractMask$MBinOp): ShortMaxVector$ShortMaxMask;
          _bOp(a0: VectorMask, a1: AbstractMask$MBinOp): AbstractMask;
          cast<E>(dsp: VectorSpecies<E>): VectorMask<E>;
          compress(): ShortMaxVector$ShortMaxMask;
          compress(): VectorMask;
          _defaultMaskCast<E>(dsp: AbstractSpecies<E>): VectorMask<E>;
          firstTrue(): int;
          _getBits(): boolean[];
          _indexPartiallyInUpperRange(offset: long, a1: long): ShortMaxVector$ShortMaxMask;
          _indexPartiallyInUpperRange(a0: long, a1: long): VectorMask;
          lastTrue(): int;
          not(): ShortMaxVector$ShortMaxMask;
          not(): VectorMask;
          or(mask: VectorMask<short>): ShortMaxVector$ShortMaxMask;
          or(a0: VectorMask): VectorMask;
          toLong(): long;
          toVector(): ShortMaxVector;
          toVector(): Vector;
          trueCount(): int;
          _uOp(f: AbstractMask$MUnOp): ShortMaxVector$ShortMaxMask;
          _uOp(a0: AbstractMask$MUnOp): AbstractMask;
          vspecies(): ShortVector$ShortSpecies;
          vspecies(): AbstractSpecies;
          xor(mask: VectorMask<short>): ShortMaxVector$ShortMaxMask;
          xor(a0: VectorMask): VectorMask;
        }
        interface ShortMaxVector$ShortMaxMask extends CombineTypes<[_ShortMaxVector$ShortMaxMask, AbstractMask<short>]> {}
        interface _ShortMaxVector$ShortMaxShuffle$$static extends ClassLike {
          _ETYPE: java.lang.Class<short>;
          _IOTA: ShortMaxVector$ShortMaxShuffle;
          _VLENGTH: int;
          _new(reorder: byte[]): ShortMaxVector$ShortMaxShuffle;
          new(reorder: int[]): ShortMaxVector$ShortMaxShuffle;
          new(reorder: int[], i: int): ShortMaxVector$ShortMaxShuffle;
          new(fn: java.util.function.IntUnaryOperator): ShortMaxVector$ShortMaxShuffle;
        }
        let ShortMaxVector$ShortMaxShuffle: _ShortMaxVector$ShortMaxShuffle$$static;
        interface _ShortMaxVector$ShortMaxShuffle {
          cast<F>(s: VectorSpecies<F>): VectorShuffle<F>;
          rearrange(shuffle: VectorShuffle<short>): ShortMaxVector$ShortMaxShuffle;
          rearrange(a0: VectorShuffle): VectorShuffle;
          toVector(): ShortMaxVector;
          toVector(): Vector;
          vspecies(): ShortVector$ShortSpecies;
          vspecies(): AbstractSpecies;
        }
        interface ShortMaxVector$ShortMaxShuffle extends CombineTypes<[_ShortMaxVector$ShortMaxShuffle, AbstractShuffle<short>]> {}
        interface _ShortVector$$static extends ClassLike {
          _arrayAddress(a: short[], index: int): long;
          _binaryOperations(opc_: int): jdk.internal.vm.vector.VectorSupport$BinaryOperation<ShortVector,VectorMask<short>>;
          _bitCount(a: short): int;
          broadcast(species: VectorSpecies<short>, e: short): ShortVector;
          broadcast(species: VectorSpecies<short>, e: long): ShortVector;
          _broadcastIntOperations(opc_: int): jdk.internal.vm.vector.VectorSupport$VectorBroadcastIntOp<ShortVector,VectorMask<short>>;
          _byteArrayAddress(a: byte[], index: int): long;
          _charArrayAddress(a: char[], index: int): long;
          _checkMaskFromIndexSize(offset: int, vsp: ShortVector$ShortSpecies, m: VectorMask<short>, scale: int, limit: int): void;
          _checkMaskFromIndexSize(offset: long, a1: ShortVector$ShortSpecies, vsp: VectorMask<short>, m: int, scale: long): void;
          _compareWithOp(cond: int, a: short, b: short): boolean;
          _compressHelper(v: Vector<short>, m: VectorMask<short>): ShortVector;
          _expandHelper(v: Vector<short>, m: VectorMask<short>): ShortVector;
          fromArray(species: VectorSpecies<short>, a: short[], offset: int): ShortVector;
          fromArray(species: VectorSpecies<short>, a: short[], offset: int, m: VectorMask<short>): ShortVector;
          fromArray(species: VectorSpecies<short>, a: short[], offset: int, indexMap: int[], mapOffset: int): ShortVector;
          fromArray(species: VectorSpecies<short>, a: short[], offset: int, indexMap: int[], mapOffset: int, m: VectorMask<short>): ShortVector;
          _fromBits(bits: long): short;
          fromCharArray(species: VectorSpecies<short>, a: char[], offset: int): ShortVector;
          fromCharArray(species: VectorSpecies<short>, a: char[], offset: int, m: VectorMask<short>): ShortVector;
          fromCharArray(species: VectorSpecies<short>, a: char[], offset: int, indexMap: int[], mapOffset: int): ShortVector;
          fromCharArray(species: VectorSpecies<short>, a: char[], offset: int, indexMap: int[], mapOffset: int, m: VectorMask<short>): ShortVector;
          fromMemorySegment(species: VectorSpecies<short>, ms: java.lang.foreign.MemorySegment, offset: long, a3: java.nio.ByteOrder): ShortVector;
          fromMemorySegment(species: VectorSpecies<short>, ms: java.lang.foreign.MemorySegment, offset: long, a3: java.nio.ByteOrder, bo: VectorMask<short>): ShortVector;
          _memorySegmentGet(ms: java.lang.foreign.MemorySegment, o: long, a2: int): short;
          _memorySegmentSet(ms: java.lang.foreign.MemorySegment, o: long, a2: int, i: short): void;
          _numberOfLeadingZeros(a: short): int;
          _numberOfTrailingZeros(a: short): int;
          _opCode(op: VectorOperators$Operator): int;
          _opCode(op: VectorOperators$Operator, requireKind: int): int;
          _opKind(op: VectorOperators$Operator, bit: int): boolean;
          _reductionOperations(opc_: int): jdk.internal.vm.vector.VectorSupport$ReductionOperation<ShortVector,VectorMask<short>>;
          _reverse(a: short): short;
          _rotateLeft(a: short, n: int): short;
          _rotateRight(a: short, n: int): short;
          _species(s: VectorShape): ShortVector$ShortSpecies;
          _ternaryOperations(opc_: int): jdk.internal.vm.vector.VectorSupport$TernaryOperation<ShortVector,VectorMask<short>>;
          _toBits(e: short): long;
          _unaryOperations(opc_: int): jdk.internal.vm.vector.VectorSupport$UnaryOperation<ShortVector,VectorMask<short>>;
          zero(species: VectorSpecies<short>): ShortVector;
          _ARRAY_BASE: long;
          _ARRAY_CHAR_BASE: long;
          _ARRAY_CHAR_SHIFT: int;
          _ARRAY_SHIFT: int;
          _BIN_IMPL: VectorOperators$ImplCache<VectorOperators$Binary,jdk.internal.vm.vector.VectorSupport$BinaryOperation<ShortVector,VectorMask<short>>>;
          _BIN_INT_IMPL: VectorOperators$ImplCache<VectorOperators$Binary,jdk.internal.vm.vector.VectorSupport$VectorBroadcastIntOp<ShortVector,VectorMask<short>>>;
          _ELEMENT_LAYOUT: java.lang.foreign.ValueLayout$OfShort;
          _FORBID_OPCODE_KIND: int;
          _LSHR_SETUP_MASK: int;
          _MAX_OR_INF: short;
          _MIN_OR_INF: short;
          _REDUCE_IMPL: VectorOperators$ImplCache<VectorOperators$Associative,jdk.internal.vm.vector.VectorSupport$ReductionOperation<ShortVector,VectorMask<short>>>;
          _SHIFT_MASK: int;
          readonly SPECIES_128: VectorSpecies<short>;
          readonly SPECIES_256: VectorSpecies<short>;
          readonly SPECIES_512: VectorSpecies<short>;
          readonly SPECIES_64: VectorSpecies<short>;
          readonly SPECIES_MAX: VectorSpecies<short>;
          readonly SPECIES_PREFERRED: VectorSpecies<short>;
          _TERN_IMPL: VectorOperators$ImplCache<VectorOperators$Ternary,jdk.internal.vm.vector.VectorSupport$TernaryOperation<ShortVector,VectorMask<short>>>;
          _UN_IMPL: VectorOperators$ImplCache<VectorOperators$Unary,jdk.internal.vm.vector.VectorSupport$UnaryOperation<ShortVector,VectorMask<short>>>;
          _new(vec: short[]): ShortVector;
        }
        let ShortVector: _ShortVector$$static;
        interface _ShortVector {
          abs(): ShortVector;
          abs(): Vector;
          add(v: Vector<short>): ShortVector;
          add(e: short): ShortVector;
          add(v: Vector<short>, m: VectorMask<short>): ShortVector;
          add(e: short, m: VectorMask<short>): ShortVector;
          add(a0: Vector, a1: VectorMask): Vector;
          add(a0: Vector): Vector;
          addIndex(a0: int): ShortVector;
          addIndex(a0: int): Vector;
          _addIndexTemplate(scale: int): ShortVector;
          and(v: Vector<short>): ShortVector;
          and(e: short): ShortVector;
          _bOp(a0: Vector<short>, a1: ShortVector$FBinOp): ShortVector;
          _bOp(a0: Vector<short>, a1: VectorMask<short>, a2: ShortVector$FBinOp): ShortVector;
          _bOpTemplate(o: Vector<short>, f: ShortVector$FBinOp): ShortVector;
          _bOpTemplate(o: Vector<short>, m: VectorMask<short>, f: ShortVector$FBinOp): ShortVector;
          _bTest(cond: int, o: Vector<short>, f: ShortVector$FBinTest): AbstractMask<short>;
          bitwiseBlend(bits: Vector<short>, mask: Vector<short>): ShortVector;
          bitwiseBlend(bits: short, mask: short): ShortVector;
          bitwiseBlend(bits: short, mask: Vector<short>): ShortVector;
          bitwiseBlend(bits: Vector<short>, mask: short): ShortVector;
          blend(a0: Vector<short>, a1: VectorMask<short>): ShortVector;
          blend(e: short, m: VectorMask<short>): ShortVector;
          blend(e: long, a1: VectorMask<short>): ShortVector;
          blend(a0: long, a1: VectorMask): Vector;
          blend(a0: Vector, a1: VectorMask): Vector;
          _blendTemplate<M>(maskType: java.lang.Class<M>, v: ShortVector, m: M): ShortVector;
          broadcast(a0: short): ShortVector;
          broadcast(a0: long): ShortVector;
          broadcast(a0: long): Vector;
          _broadcastTemplate(e: short): ShortVector;
          _broadcastTemplate(e: long): ShortVector;
          compare(a0: VectorOperators$Comparison, a1: Vector<short>): VectorMask<short>;
          compare(a0: VectorOperators$Comparison, a1: short): VectorMask<short>;
          compare(op: VectorOperators$Comparison, e: short, m: VectorMask<short>): VectorMask<short>;
          compare(a0: VectorOperators$Comparison, a1: long): VectorMask<short>;
          compare(op: VectorOperators$Comparison, e: long, a2: VectorMask<short>): VectorMask<short>;
          _compareTemplate<M>(maskType: java.lang.Class<M>, op: VectorOperators$Comparison, v: Vector<short>): M;
          _compareTemplate<M>(maskType: java.lang.Class<M>, op: VectorOperators$Comparison, v: Vector<short>, m: M): M;
          _compareTemplate<M>(maskType: java.lang.Class<M>, op: VectorOperators$Comparison, e: short): M;
          _compareTemplate<M>(maskType: java.lang.Class<M>, op: VectorOperators$Comparison, e: long): M;
          compress(a0: VectorMask<short>): ShortVector;
          compress(a0: VectorMask): Vector;
          _compressTemplate<M>(masktype: java.lang.Class<M>, m: M): ShortVector;
          _conditionalStoreNYI(offset: int, vsp: ShortVector$ShortSpecies, m: VectorMask<short>, scale: int, limit: int): void;
          div(v: Vector<short>): ShortVector;
          div(e: short): ShortVector;
          div(v: Vector<short>, m: VectorMask<short>): ShortVector;
          div(e: short, m: VectorMask<short>): ShortVector;
          div(a0: Vector, a1: VectorMask): Vector;
          div(a0: Vector): Vector;
          eq(v: Vector<short>): VectorMask<short>;
          eq(e: short): VectorMask<short>;
          equals(obj: any): boolean;
          expand(a0: VectorMask<short>): ShortVector;
          expand(a0: VectorMask): Vector;
          _expandTemplate<M>(masktype: java.lang.Class<M>, m: M): ShortVector;
          _fromArray0(a0: short[], a1: int): ShortVector;
          _fromArray0(a0: short[], a1: int, a2: VectorMask<short>, a3: int): ShortVector;
          _fromArray0Template(a: short[], offset: int): ShortVector;
          _fromArray0Template<M>(maskClass: java.lang.Class<M>, a: short[], offset: int, m: M, offsetInRange: int): ShortVector;
          _fromCharArray0(a0: char[], a1: int): ShortVector;
          _fromCharArray0(a0: char[], a1: int, a2: VectorMask<short>, a3: int): ShortVector;
          _fromCharArray0Template(a: char[], offset: int): ShortVector;
          _fromCharArray0Template<M>(maskClass: java.lang.Class<M>, a: char[], offset: int, m: M, offsetInRange: int): ShortVector;
          _fromMemorySegment0(a0: java.lang.foreign.MemorySegment, a1: long): ShortVector;
          _fromMemorySegment0(a0: java.lang.foreign.MemorySegment, a1: long, a2: VectorMask<short>, a3: int): ShortVector;
          _fromMemorySegment0(a0: java.lang.foreign.MemorySegment, a1: long): AbstractVector;
          _fromMemorySegment0Template(ms: java.lang.foreign.MemorySegment, offset: long): ShortVector;
          _fromMemorySegment0Template<M>(maskClass: java.lang.Class<M>, ms: java.lang.foreign.MemorySegment, offset: long, a3: M, m: int): ShortVector;
          hashCode(): int;
          intoArray(a: short[], offset: int): void;
          intoArray(a: short[], offset: int, m: VectorMask<short>): void;
          intoArray(a: short[], offset: int, indexMap: int[], mapOffset: int): void;
          intoArray(a: short[], offset: int, indexMap: int[], mapOffset: int, m: VectorMask<short>): void;
          _intoArray0(a0: short[], a1: int): void;
          _intoArray0(a0: short[], a1: int, a2: VectorMask<short>): void;
          _intoArray0Template(a: short[], offset: int): void;
          _intoArray0Template<M>(maskClass: java.lang.Class<M>, a: short[], offset: int, m: M): void;
          intoCharArray(a: char[], offset: int): void;
          intoCharArray(a: char[], offset: int, m: VectorMask<short>): void;
          intoCharArray(a: char[], offset: int, indexMap: int[], mapOffset: int): void;
          intoCharArray(a: char[], offset: int, indexMap: int[], mapOffset: int, m: VectorMask<short>): void;
          _intoCharArray0(a0: char[], a1: int, a2: VectorMask<short>): void;
          _intoCharArray0Template<M>(maskClass: java.lang.Class<M>, a: char[], offset: int, m: M): void;
          intoMemorySegment(ms: java.lang.foreign.MemorySegment, offset: long, a2: java.nio.ByteOrder): void;
          intoMemorySegment(ms: java.lang.foreign.MemorySegment, offset: long, a2: java.nio.ByteOrder, bo: VectorMask<short>): void;
          _intoMemorySegment0(ms: java.lang.foreign.MemorySegment, offset: long): void;
          _intoMemorySegment0(a0: java.lang.foreign.MemorySegment, a1: long, a2: VectorMask<short>): void;
          _intoMemorySegment0Template<M>(maskClass: java.lang.Class<M>, ms: java.lang.foreign.MemorySegment, offset: long, a3: M): void;
          lane(a0: int): short;
          lanewise(a0: VectorOperators$Unary): ShortVector;
          lanewise(a0: VectorOperators$Unary, a1: VectorMask<short>): ShortVector;
          lanewise(a0: VectorOperators$Binary, a1: Vector<short>): ShortVector;
          lanewise(a0: VectorOperators$Binary, a1: Vector<short>, a2: VectorMask<short>): ShortVector;
          lanewise(op: VectorOperators$Binary, e: short): ShortVector;
          lanewise(op: VectorOperators$Binary, e: short, m: VectorMask<short>): ShortVector;
          lanewise(op: VectorOperators$Binary, e: long): ShortVector;
          lanewise(op: VectorOperators$Binary, e: long, a2: VectorMask<short>): ShortVector;
          lanewise(a0: VectorOperators$Ternary, a1: Vector<short>, a2: Vector<short>): ShortVector;
          lanewise(a0: VectorOperators$Ternary, a1: Vector<short>, a2: Vector<short>, a3: VectorMask<short>): ShortVector;
          lanewise(op: VectorOperators$Ternary, e1: short, e2: short): ShortVector;
          lanewise(op: VectorOperators$Ternary, e1: short, e2: short, m: VectorMask<short>): ShortVector;
          lanewise(op: VectorOperators$Ternary, v1: Vector<short>, e2: short): ShortVector;
          lanewise(op: VectorOperators$Ternary, v1: Vector<short>, e2: short, m: VectorMask<short>): ShortVector;
          lanewise(op: VectorOperators$Ternary, e1: short, v2: Vector<short>): ShortVector;
          lanewise(op: VectorOperators$Ternary, e1: short, v2: Vector<short>, m: VectorMask<short>): ShortVector;
          lanewise(a0: VectorOperators$Ternary, a1: Vector, a2: Vector, a3: VectorMask): Vector;
          lanewise(a0: VectorOperators$Ternary, a1: Vector, a2: Vector): Vector;
          lanewise(a0: VectorOperators$Binary, a1: long, a2: VectorMask): Vector;
          lanewise(a0: VectorOperators$Binary, a1: long): Vector;
          lanewise(a0: VectorOperators$Binary, a1: Vector, a2: VectorMask): Vector;
          lanewise(a0: VectorOperators$Binary, a1: Vector): Vector;
          lanewise(a0: VectorOperators$Unary, a1: VectorMask): Vector;
          lanewise(a0: VectorOperators$Unary): Vector;
          _lanewiseShift(a0: VectorOperators$Binary, a1: int): ShortVector;
          _lanewiseShift(a0: VectorOperators$Binary, a1: int, a2: VectorMask<short>): ShortVector;
          _lanewiseShiftTemplate(op: VectorOperators$Binary, e: int): ShortVector;
          _lanewiseShiftTemplate(op: VectorOperators$Binary, maskClass: java.lang.Class<VectorMask<short>>, e: int, m: VectorMask<short>): ShortVector;
          _lanewiseTemplate(op: VectorOperators$Unary): ShortVector;
          _lanewiseTemplate(op: VectorOperators$Unary, maskClass: java.lang.Class<VectorMask<short>>, m: VectorMask<short>): ShortVector;
          _lanewiseTemplate(op: VectorOperators$Binary, v: Vector<short>): ShortVector;
          _lanewiseTemplate(op: VectorOperators$Binary, maskClass: java.lang.Class<VectorMask<short>>, v: Vector<short>, m: VectorMask<short>): ShortVector;
          _lanewiseTemplate(op: VectorOperators$Ternary, v1: Vector<short>, v2: Vector<short>): ShortVector;
          _lanewiseTemplate(op: VectorOperators$Ternary, maskClass: java.lang.Class<VectorMask<short>>, v1: Vector<short>, v2: Vector<short>, m: VectorMask<short>): ShortVector;
          _ldLongOp(memory: java.lang.foreign.MemorySegment, offset: long, a2: ShortVector$FLdLongOp): ShortVector;
          _ldLongOp(memory: java.lang.foreign.MemorySegment, offset: long, a2: VectorMask<short>, m: ShortVector$FLdLongOp): ShortVector;
          _ldOp<M>(memory: M, offset: int, f: ShortVector$FLdOp<M>): ShortVector;
          _ldOp<M>(memory: M, offset: int, m: VectorMask<short>, f: ShortVector$FLdOp<M>): ShortVector;
          lt(v: Vector<short>): VectorMask<short>;
          lt(e: short): VectorMask<short>;
          _maskFactory(bits: boolean[]): AbstractMask<short>;
          max(v: Vector<short>): ShortVector;
          max(e: short): ShortVector;
          max(a0: Vector): Vector;
          _maybeSwap(bo: java.nio.ByteOrder): ShortVector;
          _maybeSwap(a0: java.nio.ByteOrder): AbstractVector;
          min(v: Vector<short>): ShortVector;
          min(e: short): ShortVector;
          min(a0: Vector): Vector;
          mul(v: Vector<short>): ShortVector;
          mul(e: short): ShortVector;
          mul(v: Vector<short>, m: VectorMask<short>): ShortVector;
          mul(e: short, m: VectorMask<short>): ShortVector;
          mul(a0: Vector, a1: VectorMask): Vector;
          mul(a0: Vector): Vector;
          neg(): ShortVector;
          neg(): Vector;
          not(): ShortVector;
          or(v: Vector<short>): ShortVector;
          or(e: short): ShortVector;
          _rOp(a0: short, a1: VectorMask<short>, a2: ShortVector$FBinOp): short;
          _rOpTemplate(v: short, m: VectorMask<short>, f: ShortVector$FBinOp): short;
          _rOpTemplate(v: short, f: ShortVector$FBinOp): short;
          rearrange(a0: VectorShuffle<short>): ShortVector;
          rearrange(a0: VectorShuffle<short>, a1: VectorMask<short>): ShortVector;
          rearrange(a0: VectorShuffle<short>, a1: Vector<short>): ShortVector;
          rearrange(a0: VectorShuffle, a1: Vector): Vector;
          rearrange(a0: VectorShuffle, a1: VectorMask): Vector;
          rearrange(a0: VectorShuffle): Vector;
          _rearrangeTemplate<S>(shuffletype: java.lang.Class<S>, shuffle: S): ShortVector;
          _rearrangeTemplate<S, M>(shuffletype: java.lang.Class<S>, masktype: java.lang.Class<M>, shuffle: S, m: M): ShortVector;
          _rearrangeTemplate<S>(shuffletype: java.lang.Class<S>, shuffle: S, v: ShortVector): ShortVector;
          reduceLanes(a0: VectorOperators$Associative): short;
          reduceLanes(a0: VectorOperators$Associative, a1: VectorMask<short>): short;
          _reduceLanesTemplate(op: VectorOperators$Associative, maskClass: java.lang.Class<VectorMask<short>>, m: VectorMask<short>): short;
          _reduceLanesTemplate(op: VectorOperators$Associative): short;
          reduceLanesToLong(a0: VectorOperators$Associative): long;
          reduceLanesToLong(a0: VectorOperators$Associative, a1: VectorMask<short>): long;
          reinterpretAsBytes(): ByteVector;
          reinterpretAsDoubles(): DoubleVector;
          reinterpretAsFloats(): FloatVector;
          reinterpretAsInts(): IntVector;
          reinterpretAsLongs(): LongVector;
          reinterpretAsShorts(): ShortVector;
          selectFrom(a0: Vector<short>): ShortVector;
          selectFrom(a0: Vector<short>, a1: VectorMask<short>): ShortVector;
          selectFrom(a0: Vector, a1: VectorMask): Vector;
          selectFrom(a0: Vector): Vector;
          _selectFromTemplate(v: ShortVector): ShortVector;
          _selectFromTemplate(v: ShortVector, m: AbstractMask<short>): ShortVector;
          slice(a0: int, a1: Vector<short>): ShortVector;
          slice(origin: int, w: Vector<short>, m: VectorMask<short>): ShortVector;
          slice(a0: int): ShortVector;
          slice(a0: int): AbstractVector;
          slice(a0: int, a1: Vector): AbstractVector;
          slice(a0: int): Vector;
          slice(a0: int, a1: Vector, a2: VectorMask): Vector;
          slice(a0: int, a1: Vector): Vector;
          _sliceTemplate(origin: int, v1: Vector<short>): ShortVector;
          _sliceTemplate(origin: int): ShortVector;
          _stLongOp(memory: java.lang.foreign.MemorySegment, offset: long, a2: ShortVector$FStLongOp): void;
          _stLongOp(memory: java.lang.foreign.MemorySegment, offset: long, a2: VectorMask<short>, m: ShortVector$FStLongOp): void;
          _stOp<M>(memory: M, offset: int, f: ShortVector$FStOp<M>): void;
          _stOp<M>(memory: M, offset: int, m: VectorMask<short>, f: ShortVector$FStOp<M>): void;
          sub(v: Vector<short>): ShortVector;
          sub(e: short): ShortVector;
          sub(v: Vector<short>, m: VectorMask<short>): ShortVector;
          sub(e: short, m: VectorMask<short>): ShortVector;
          sub(a0: Vector, a1: VectorMask): Vector;
          sub(a0: Vector): Vector;
          _tOp(a0: Vector<short>, a1: Vector<short>, a2: ShortVector$FTriOp): ShortVector;
          _tOp(a0: Vector<short>, a1: Vector<short>, a2: VectorMask<short>, a3: ShortVector$FTriOp): ShortVector;
          _tOpTemplate(o1: Vector<short>, o2: Vector<short>, f: ShortVector$FTriOp): ShortVector;
          _tOpTemplate(o1: Vector<short>, o2: Vector<short>, m: VectorMask<short>, f: ShortVector$FTriOp): ShortVector;
          test(a0: VectorOperators$Test): VectorMask<short>;
          test(a0: VectorOperators$Test, a1: VectorMask<short>): VectorMask<short>;
          _testTemplate<M>(maskType: java.lang.Class<M>, op: VectorOperators$Test): M;
          _testTemplate<M>(maskType: java.lang.Class<M>, op: VectorOperators$Test, mask: M): M;
          toArray(): short[];
          toArray(): any;
          toDoubleArray(): double[];
          toIntArray(): int[];
          toLongArray(): long[];
          _toShuffle0(dsp: ShortVector$ShortSpecies): VectorShuffle<short>;
          _toShuffleTemplate(shuffleType: java.lang.Class<any>): VectorShuffle<short>;
          toString(): string;
          _uOp(a0: ShortVector$FUnOp): ShortVector;
          _uOp(a0: VectorMask<short>, a1: ShortVector$FUnOp): ShortVector;
          _uOpTemplate(f: ShortVector$FUnOp): ShortVector;
          _uOpTemplate(m: VectorMask<short>, f: ShortVector$FUnOp): ShortVector;
          unslice(a0: int, a1: Vector<short>, a2: int): ShortVector;
          unslice(a0: int, a1: Vector<short>, a2: int, a3: VectorMask<short>): ShortVector;
          unslice(a0: int): ShortVector;
          unslice(a0: int): Vector;
          unslice(a0: int, a1: Vector, a2: int, a3: VectorMask): Vector;
          unslice(a0: int, a1: Vector, a2: int): Vector;
          _unsliceTemplate(origin: int, w: Vector<short>, part: int): ShortVector;
          _unsliceTemplate<M>(maskType: java.lang.Class<M>, origin: int, w: Vector<short>, part: int, m: M): ShortVector;
          _unsliceTemplate(origin: int): ShortVector;
          _vOp(f: ShortVector$FVOp): ShortVector;
          _vOp(m: VectorMask<short>, f: ShortVector$FVOp): ShortVector;
          _vec(): short[];
          _vectorFactory(a0: short[]): ShortVector;
          viewAsFloatingLanes(): Vector<any>;
          viewAsIntegralLanes(): ShortVector;
          viewAsIntegralLanes(): Vector;
          _vspecies(): ShortVector$ShortSpecies;
          _vspecies(): AbstractSpecies;
          withLane(a0: int, a1: short): ShortVector;
          _wrongPartForSlice(part: int): java.lang.ArrayIndexOutOfBoundsException;
        }
        interface ShortVector extends CombineTypes<[_ShortVector, AbstractVector<short>]> {}
        interface _ShortVector$FBinOp$$static extends ClassLike {
        }
        let ShortVector$FBinOp: _ShortVector$FBinOp$$static;
        interface _ShortVector$FBinOp {
          apply(a0: int, a1: short, a2: short): short;
(a0: int, a1: short, a2: short): short;
        }
        interface ShortVector$FBinOp extends CombineTypes<[_ShortVector$FBinOp, java.lang.Object]> {}
        interface _ShortVector$FBinTest$$static extends ClassLike {
        }
        let ShortVector$FBinTest: _ShortVector$FBinTest$$static;
        interface _ShortVector$FBinTest {
          apply(a0: int, a1: int, a2: short, a3: short): boolean;
(a0: int, a1: int, a2: short, a3: short): boolean;
        }
        interface ShortVector$FBinTest extends CombineTypes<[_ShortVector$FBinTest, java.lang.Object]> {}
        interface _ShortVector$FLdLongOp$$static extends ClassLike {
        }
        let ShortVector$FLdLongOp: _ShortVector$FLdLongOp$$static;
        interface _ShortVector$FLdLongOp {
          apply(a0: java.lang.foreign.MemorySegment, a1: long, a2: int): short;
(a0: java.lang.foreign.MemorySegment, a1: long, a2: int): short;
        }
        interface ShortVector$FLdLongOp extends CombineTypes<[_ShortVector$FLdLongOp, java.lang.Object]> {}
        interface _ShortVector$FLdOp$$static<M> extends ClassLike {
        }
        let ShortVector$FLdOp: _ShortVector$FLdOp$$static<M>;
        interface _ShortVector$FLdOp<M> {
          apply(a0: M, a1: int, a2: int): short;
(a0: M, a1: int, a2: int): short;
        }
        interface ShortVector$FLdOp<M> extends CombineTypes<[_ShortVector$FLdOp<M>, java.lang.Object]> {}
        interface _ShortVector$FStLongOp$$static extends ClassLike {
        }
        let ShortVector$FStLongOp: _ShortVector$FStLongOp$$static;
        interface _ShortVector$FStLongOp {
          apply(a0: java.lang.foreign.MemorySegment, a1: long, a2: int, a3: short): void;
(a0: java.lang.foreign.MemorySegment, a1: long, a2: int, a3: short): void;
        }
        interface ShortVector$FStLongOp extends CombineTypes<[_ShortVector$FStLongOp, java.lang.Object]> {}
        interface _ShortVector$FStOp$$static<M> extends ClassLike {
        }
        let ShortVector$FStOp: _ShortVector$FStOp$$static<M>;
        interface _ShortVector$FStOp<M> {
          apply(a0: M, a1: int, a2: int, a3: short): void;
(a0: M, a1: int, a2: int, a3: short): void;
        }
        interface ShortVector$FStOp<M> extends CombineTypes<[_ShortVector$FStOp<M>, java.lang.Object]> {}
        interface _ShortVector$FTriOp$$static extends ClassLike {
        }
        let ShortVector$FTriOp: _ShortVector$FTriOp$$static;
        interface _ShortVector$FTriOp {
          apply(a0: int, a1: short, a2: short, a3: short): short;
(a0: int, a1: short, a2: short, a3: short): short;
        }
        interface ShortVector$FTriOp extends CombineTypes<[_ShortVector$FTriOp, java.lang.Object]> {}
        interface _ShortVector$FUnOp$$static extends ClassLike {
        }
        let ShortVector$FUnOp: _ShortVector$FUnOp$$static;
        interface _ShortVector$FUnOp {
          apply(a0: int, a1: short): short;
(a0: int, a1: short): short;
        }
        interface ShortVector$FUnOp extends CombineTypes<[_ShortVector$FUnOp, java.lang.Object]> {}
        interface _ShortVector$FVOp$$static extends ClassLike {
        }
        let ShortVector$FVOp: _ShortVector$FVOp$$static;
        interface _ShortVector$FVOp {
          apply(a0: int): short;
(a0: int): short;
        }
        interface ShortVector$FVOp extends CombineTypes<[_ShortVector$FVOp, java.lang.Object]> {}
        interface _ShortVector$ShortSpecies$$static extends ClassLike {
          _toIntegralChecked(e: short, convertToInt: boolean): long;
        }
        let ShortVector$ShortSpecies: _ShortVector$ShortSpecies$$static;
        interface _ShortVector$ShortSpecies {
          _broadcast(e: short): ShortVector;
          broadcast(e: long): ShortVector;
          broadcast(a0: long): Vector;
          _broadcastBits(bits: long): ShortVector;
          _broadcastBits(a0: long): AbstractVector;
          checkValue(e: long): long;
          _dummyVector(): ShortVector;
          _dummyVector(): AbstractVector;
          elementType(): java.lang.Class<short>;
          fromArray(a: any, offset: int): ShortVector;
          fromArray(a0: any, a1: int): Vector;
          _fromIntValues(values: int[]): ShortVector;
          _fromIntValues(a0: int[]): Vector;
          fromMemorySegment(ms: java.lang.foreign.MemorySegment, offset: long, a2: java.nio.ByteOrder): ShortVector;
          fromMemorySegment(a0: java.lang.foreign.MemorySegment, a1: long, a2: java.nio.ByteOrder): Vector;
          _genericElementType(): java.lang.Class<short>;
          iota(): ShortVector;
          iota(): AbstractVector;
          _ldLongOp(memory: java.lang.foreign.MemorySegment, offset: long, a2: ShortVector$FLdLongOp): ShortVector;
          _ldLongOp(memory: java.lang.foreign.MemorySegment, offset: long, a2: VectorMask<short>, m: ShortVector$FLdLongOp): ShortVector;
          _ldOp<M>(memory: M, offset: int, f: ShortVector$FLdOp<M>): ShortVector;
          _ldOp<M>(memory: M, offset: int, m: VectorMask<short>, f: ShortVector$FLdOp<M>): ShortVector;
          _longToElementBits(value: long): long;
          maskAll(bit: boolean): VectorMask<short>;
          _rvOp(f: AbstractSpecies$RVOp): ShortVector;
          _rvOp(a0: AbstractSpecies$RVOp): AbstractVector;
          _stLongOp(memory: java.lang.foreign.MemorySegment, offset: long, a2: ShortVector$FStLongOp): void;
          _stLongOp(memory: java.lang.foreign.MemorySegment, offset: long, a2: AbstractMask<short>, m: ShortVector$FStLongOp): void;
          _stOp<M>(memory: M, offset: int, f: ShortVector$FStOp<M>): void;
          _stOp<M>(memory: M, offset: int, m: AbstractMask<short>, f: ShortVector$FStOp<M>): void;
          _vOp(f: ShortVector$FVOp): ShortVector;
          _vOp(m: VectorMask<short>, f: ShortVector$FVOp): ShortVector;
          vectorType(): java.lang.Class<ShortVector>;
          zero(): ShortVector;
          zero(): AbstractVector;
          zero(): Vector;
        }
        interface ShortVector$ShortSpecies extends CombineTypes<[_ShortVector$ShortSpecies, AbstractSpecies<short>]> {}
        interface _Vector$$static<E> extends ClassLike {
          _new(bits: any): Vector<E>;
        }
        let Vector: _Vector$$static<E>;
        interface _Vector<E> {
          abs(): Vector<E>;
          add(a0: Vector<E>): Vector<E>;
          add(a0: Vector<E>, a1: VectorMask<E>): Vector<E>;
          addIndex(a0: int): Vector<E>;
          bitSize(): int;
          blend(a0: Vector<E>, a1: VectorMask<E>): Vector<E>;
          blend(a0: long, a1: VectorMask<E>): Vector<E>;
          broadcast(a0: long): Vector<E>;
          byteSize(): int;
          castShape<F>(a0: VectorSpecies<F>, a1: int): Vector<F>;
          check<F>(a0: java.lang.Class<F>): Vector<F>;
          check<F>(a0: VectorSpecies<F>): Vector<F>;
          compare(a0: VectorOperators$Comparison, a1: Vector<E>): VectorMask<E>;
          compare(a0: VectorOperators$Comparison, a1: Vector<E>, a2: VectorMask<E>): VectorMask<E>;
          compare(a0: VectorOperators$Comparison, a1: long): VectorMask<E>;
          compare(a0: VectorOperators$Comparison, a1: long, a2: VectorMask<E>): VectorMask<E>;
          compress(a0: VectorMask<E>): Vector<E>;
          convert<F>(a0: VectorOperators$Conversion<E,F>, a1: int): Vector<F>;
          convertShape<F>(a0: VectorOperators$Conversion<E,F>, a1: VectorSpecies<F>, a2: int): Vector<F>;
          div(a0: Vector<E>): Vector<E>;
          div(a0: Vector<E>, a1: VectorMask<E>): Vector<E>;
          elementSize(): int;
          elementType(): java.lang.Class<E>;
          eq(a0: Vector<E>): VectorMask<E>;
          equals(a0: any): boolean;
          expand(a0: VectorMask<E>): Vector<E>;
          hashCode(): int;
          intoMemorySegment(a0: java.lang.foreign.MemorySegment, a1: long, a2: java.nio.ByteOrder): void;
          intoMemorySegment(a0: java.lang.foreign.MemorySegment, a1: long, a2: java.nio.ByteOrder, a3: VectorMask<E>): void;
          lanewise(a0: VectorOperators$Unary): Vector<E>;
          lanewise(a0: VectorOperators$Unary, a1: VectorMask<E>): Vector<E>;
          lanewise(a0: VectorOperators$Binary, a1: Vector<E>): Vector<E>;
          lanewise(a0: VectorOperators$Binary, a1: Vector<E>, a2: VectorMask<E>): Vector<E>;
          lanewise(a0: VectorOperators$Binary, a1: long): Vector<E>;
          lanewise(a0: VectorOperators$Binary, a1: long, a2: VectorMask<E>): Vector<E>;
          lanewise(a0: VectorOperators$Ternary, a1: Vector<E>, a2: Vector<E>): Vector<E>;
          lanewise(a0: VectorOperators$Ternary, a1: Vector<E>, a2: Vector<E>, a3: VectorMask<E>): Vector<E>;
          length(): int;
          lt(a0: Vector<E>): VectorMask<E>;
          maskAll(a0: boolean): VectorMask<E>;
          max(a0: Vector<E>): Vector<E>;
          min(a0: Vector<E>): Vector<E>;
          mul(a0: Vector<E>): Vector<E>;
          mul(a0: Vector<E>, a1: VectorMask<E>): Vector<E>;
          neg(): Vector<E>;
          rearrange(a0: VectorShuffle<E>): Vector<E>;
          rearrange(a0: VectorShuffle<E>, a1: VectorMask<E>): Vector<E>;
          rearrange(a0: VectorShuffle<E>, a1: Vector<E>): Vector<E>;
          reduceLanesToLong(a0: VectorOperators$Associative): long;
          reduceLanesToLong(a0: VectorOperators$Associative, a1: VectorMask<E>): long;
          reinterpretAsBytes(): ByteVector;
          reinterpretAsDoubles(): DoubleVector;
          reinterpretAsFloats(): FloatVector;
          reinterpretAsInts(): IntVector;
          reinterpretAsLongs(): LongVector;
          reinterpretAsShorts(): ShortVector;
          reinterpretShape<F>(a0: VectorSpecies<F>, a1: int): Vector<F>;
          selectFrom(a0: Vector<E>): Vector<E>;
          selectFrom(a0: Vector<E>, a1: VectorMask<E>): Vector<E>;
          shape(): VectorShape;
          slice(a0: int, a1: Vector<E>): Vector<E>;
          slice(a0: int, a1: Vector<E>, a2: VectorMask<E>): Vector<E>;
          slice(a0: int): Vector<E>;
          species(): VectorSpecies<E>;
          sub(a0: Vector<E>): Vector<E>;
          sub(a0: Vector<E>, a1: VectorMask<E>): Vector<E>;
          test(a0: VectorOperators$Test): VectorMask<E>;
          test(a0: VectorOperators$Test, a1: VectorMask<E>): VectorMask<E>;
          toArray(): any;
          toDoubleArray(): double[];
          toIntArray(): int[];
          toLongArray(): long[];
          toShuffle(): VectorShuffle<E>;
          toString(): string;
          unslice(a0: int, a1: Vector<E>, a2: int): Vector<E>;
          unslice(a0: int, a1: Vector<E>, a2: int, a3: VectorMask<E>): Vector<E>;
          unslice(a0: int): Vector<E>;
          viewAsFloatingLanes(): Vector<any>;
          viewAsIntegralLanes(): Vector<any>;
        }
        interface Vector<E> extends CombineTypes<[_Vector<E>, jdk.internal.vm.vector.VectorSupport$Vector<E>]> {}
        interface _VectorIntrinsics$$static extends ClassLike {
          _checkFromIndexSize(ix: int, vlen: int, length: int): int;
          _checkFromIndexSize(ix: long, a1: long, vlen: long): long;
          _checkIndex(vix: IntVector, length: int): IntVector;
          _checkIndexFailed(vix: IntVector, length: int): java.lang.IndexOutOfBoundsException;
          _indexInRange(ix: long, a1: long, vlen: long): boolean;
          _requireLength(haveLength: int, length: int): void;
          _requireLengthFailed(haveLength: int, length: int): java.lang.IllegalArgumentException;
          _roundDown(index: int, size: int): int;
          _roundDown(index: long, a1: int): long;
          _roundDownNPOT(index: int, size: int): int;
          _roundDownNPOT(index: long, a1: int): long;
          _wrapToRange(index: int, size: int): int;
          _wrapToRangeNPOT(index: int, size: int): int;
          _VECTOR_ACCESS_OOB_CHECK: int;
          _new(): VectorIntrinsics;
        }
        let VectorIntrinsics: _VectorIntrinsics$$static;
        interface _VectorIntrinsics {
        }
        interface VectorIntrinsics extends CombineTypes<[_VectorIntrinsics, java.lang.Object]> {}
        interface _VectorMask$$static<E> extends ClassLike {
          fromArray<E>(species: VectorSpecies<E>, bits: boolean[], offset: int): VectorMask<E>;
          fromLong<E>(species: VectorSpecies<E>, bits: long): VectorMask<E>;
          fromValues<E>(species: VectorSpecies<E>, bits: boolean[]): VectorMask<E>;
          fromValues<E>(species: VectorSpecies<E>, ...bits: boolean[]): VectorMask<E>;
          _new(bits: boolean[]): VectorMask<E>;
        }
        let VectorMask: _VectorMask$$static<E>;
        interface _VectorMask<E> {
          allTrue(): boolean;
          and(a0: VectorMask<E>): VectorMask<E>;
          andNot(a0: VectorMask<E>): VectorMask<E>;
          anyTrue(): boolean;
          cast<F>(a0: VectorSpecies<F>): VectorMask<F>;
          check<F>(a0: java.lang.Class<F>): VectorMask<F>;
          check<F>(a0: VectorSpecies<F>): VectorMask<F>;
          _check<F>(a0: java.lang.Class<VectorMask<F>>, a1: Vector<F>): VectorMask<F>;
          compress(): VectorMask<E>;
          eq(a0: VectorMask<E>): VectorMask<E>;
          equals(obj: any): boolean;
          firstTrue(): int;
          hashCode(): int;
          indexInRange(a0: int, a1: int): VectorMask<E>;
          indexInRange(a0: long, a1: long): VectorMask<E>;
          intoArray(a0: boolean[], a1: int): void;
          laneIsSet(a0: int): boolean;
          lastTrue(): int;
          length(): int;
          not(): VectorMask<E>;
          or(a0: VectorMask<E>): VectorMask<E>;
          toArray(): boolean[];
          toLong(): long;
          toString(): string;
          toVector(): Vector<E>;
          trueCount(): int;
          vectorSpecies(): VectorSpecies<E>;
          xor(a0: VectorMask<E>): VectorMask<E>;
        }
        interface VectorMask<E> extends CombineTypes<[_VectorMask<E>, jdk.internal.vm.vector.VectorSupport$VectorMask<E>]> {}
        interface _VectorOperators$$static extends ClassLike {
          _assoc(name: string, opName: string, opCode: int, flags: int): VectorOperators$Associative;
          _binary(name: string, opName: string, opCode: int, flags: int): VectorOperators$Binary;
          _checkConstants(): boolean;
          _compare(name: string, opName: string, opCode: int, flags: int): VectorOperators$Comparison;
          _convert<E, F>(name: string, kind: char, dom: java.lang.Class<E>, ran: java.lang.Class<F>, opCode: int, flags: int): VectorOperators$ConversionImpl<E,F>;
          _opCode(op: VectorOperators$Operator, requireKind: int, forbidKind: int): int;
          _opInfo(opCode: int, bits: int): int;
          _opKind(op: VectorOperators$Operator, bit: int): boolean;
          _predicate(name: string, opName: string, opCode: int, flags: int): VectorOperators$Test;
          _ternary(name: string, opName: string, opCode: int, flags: int): VectorOperators$Ternary;
          _unary(name: string, opName: string, opCode: int, flags: int): VectorOperators$Unary;
          readonly ABS: VectorOperators$Unary;
          readonly ACOS: VectorOperators$Unary;
          readonly ADD: VectorOperators$Associative;
          readonly AND: VectorOperators$Associative;
          readonly AND_NOT: VectorOperators$Binary;
          readonly ASHR: VectorOperators$Binary;
          readonly ASIN: VectorOperators$Unary;
          readonly ATAN: VectorOperators$Unary;
          readonly ATAN2: VectorOperators$Binary;
          readonly B2D: VectorOperators$Conversion<byte,double>;
          readonly B2F: VectorOperators$Conversion<byte,float>;
          readonly B2I: VectorOperators$Conversion<byte,int>;
          readonly B2L: VectorOperators$Conversion<byte,long>;
          readonly B2S: VectorOperators$Conversion<byte,short>;
          readonly BITWISE_BLEND: VectorOperators$Ternary;
          readonly BIT_COUNT: VectorOperators$Unary;
          readonly CBRT: VectorOperators$Unary;
          _CMP_OPC_NAME: java.util.HashMap<int,string>;
          readonly COMPRESS_BITS: VectorOperators$Binary;
          _CONV_OPC_NAME: java.util.HashMap<int,string>;
          readonly COS: VectorOperators$Unary;
          readonly COSH: VectorOperators$Unary;
          readonly D2B: VectorOperators$Conversion<double,byte>;
          readonly D2F: VectorOperators$Conversion<double,float>;
          readonly D2I: VectorOperators$Conversion<double,int>;
          readonly D2L: VectorOperators$Conversion<double,long>;
          readonly D2S: VectorOperators$Conversion<double,short>;
          readonly DIV: VectorOperators$Binary;
          readonly EQ: VectorOperators$Comparison;
          readonly EXP: VectorOperators$Unary;
          readonly EXPAND_BITS: VectorOperators$Binary;
          readonly EXPM1: VectorOperators$Unary;
          readonly F2B: VectorOperators$Conversion<float,byte>;
          readonly F2D: VectorOperators$Conversion<float,double>;
          readonly F2I: VectorOperators$Conversion<float,int>;
          readonly F2L: VectorOperators$Conversion<float,long>;
          readonly F2S: VectorOperators$Conversion<float,short>;
          readonly FIRST_NONZERO: VectorOperators$Associative;
          readonly FMA: VectorOperators$Ternary;
          readonly GE: VectorOperators$Comparison;
          readonly GT: VectorOperators$Comparison;
          readonly HYPOT: VectorOperators$Binary;
          readonly I2B: VectorOperators$Conversion<int,byte>;
          readonly I2D: VectorOperators$Conversion<int,double>;
          readonly I2F: VectorOperators$Conversion<int,float>;
          readonly I2L: VectorOperators$Conversion<int,long>;
          readonly I2S: VectorOperators$Conversion<int,short>;
          readonly IS_DEFAULT: VectorOperators$Test;
          readonly IS_FINITE: VectorOperators$Test;
          readonly IS_INFINITE: VectorOperators$Test;
          readonly IS_NAN: VectorOperators$Test;
          readonly IS_NEGATIVE: VectorOperators$Test;
          readonly L2B: VectorOperators$Conversion<long,byte>;
          readonly L2D: VectorOperators$Conversion<long,double>;
          readonly L2F: VectorOperators$Conversion<long,float>;
          readonly L2I: VectorOperators$Conversion<long,int>;
          readonly L2S: VectorOperators$Conversion<long,short>;
          readonly LE: VectorOperators$Comparison;
          readonly LEADING_ZEROS_COUNT: VectorOperators$Unary;
          readonly LOG: VectorOperators$Unary;
          readonly LOG10: VectorOperators$Unary;
          readonly LOG1P: VectorOperators$Unary;
          readonly LSHL: VectorOperators$Binary;
          readonly LSHR: VectorOperators$Binary;
          readonly LT: VectorOperators$Comparison;
          readonly MAX: VectorOperators$Associative;
          readonly MIN: VectorOperators$Associative;
          readonly MUL: VectorOperators$Associative;
          readonly NE: VectorOperators$Comparison;
          readonly NEG: VectorOperators$Unary;
          readonly NOT: VectorOperators$Unary;
          _OPC_NAME: java.util.HashMap<int,string>;
          readonly OR: VectorOperators$Associative;
          _OR_UNCHECKED: VectorOperators$Associative;
          readonly POW: VectorOperators$Binary;
          readonly REINTERPRET_D2L: VectorOperators$Conversion<double,long>;
          readonly REINTERPRET_F2I: VectorOperators$Conversion<float,int>;
          readonly REINTERPRET_I2F: VectorOperators$Conversion<int,float>;
          readonly REINTERPRET_L2D: VectorOperators$Conversion<long,double>;
          readonly REVERSE: VectorOperators$Unary;
          readonly REVERSE_BYTES: VectorOperators$Unary;
          readonly ROL: VectorOperators$Binary;
          readonly ROR: VectorOperators$Binary;
          readonly S2B: VectorOperators$Conversion<short,byte>;
          readonly S2D: VectorOperators$Conversion<short,double>;
          readonly S2F: VectorOperators$Conversion<short,float>;
          readonly S2I: VectorOperators$Conversion<short,int>;
          readonly S2L: VectorOperators$Conversion<short,long>;
          readonly SIN: VectorOperators$Unary;
          readonly SINH: VectorOperators$Unary;
          readonly SQRT: VectorOperators$Unary;
          readonly SUB: VectorOperators$Binary;
          readonly TAN: VectorOperators$Unary;
          readonly TANH: VectorOperators$Unary;
          readonly TRAILING_ZEROS_COUNT: VectorOperators$Unary;
          readonly UNSIGNED_GE: VectorOperators$Comparison;
          readonly UNSIGNED_GT: VectorOperators$Comparison;
          readonly UNSIGNED_LE: VectorOperators$Comparison;
          readonly UNSIGNED_LT: VectorOperators$Comparison;
          _VO_ALL: int;
          _VO_ARITY_MASK: int;
          _VO_ASSOC: int;
          _VO_BINARY: int;
          _VO_BOOL: int;
          _VO_CONV: int;
          _VO_DOM_RAN_MASK: int;
          _VO_DOM_SHIFT: int;
          _VO_KIND_BITWISE: int;
          _VO_KIND_CAST: int;
          _VO_NOFP: int;
          _VO_ONLYFP: int;
          _VO_OPCODE_LIMIT: int;
          _VO_OPCODE_SHIFT: int;
          _VO_OPCODE_VALID: int;
          _VO_PRIVATE: int;
          _VO_RAN_SHIFT: int;
          _VO_SHIFT: int;
          _VO_SPECIAL: int;
          _VO_TERNARY: int;
          _VO_UNARY: int;
          readonly XOR: VectorOperators$Associative;
          readonly ZERO_EXTEND_B2I: VectorOperators$Conversion<byte,int>;
          readonly ZERO_EXTEND_B2L: VectorOperators$Conversion<byte,long>;
          readonly ZERO_EXTEND_B2S: VectorOperators$Conversion<byte,short>;
          readonly ZERO_EXTEND_I2L: VectorOperators$Conversion<int,long>;
          readonly ZERO_EXTEND_S2I: VectorOperators$Conversion<short,int>;
          readonly ZERO_EXTEND_S2L: VectorOperators$Conversion<short,long>;
          readonly ZOMO: VectorOperators$Unary;
        }
        let VectorOperators: _VectorOperators$$static;
        interface _VectorOperators {
        }
        interface VectorOperators extends CombineTypes<[_VectorOperators, java.lang.Object]> {}
        interface _VectorOperators$Associative$$static extends ClassLike {
        }
        let VectorOperators$Associative: _VectorOperators$Associative$$static;
        interface _VectorOperators$Associative {
        }
        interface VectorOperators$Associative extends CombineTypes<[_VectorOperators$Associative, java.lang.Object, jdk.incubator.vector.VectorOperators$Binary]> {}
        interface _VectorOperators$AssociativeImpl$$static extends ClassLike {
        }
        let VectorOperators$AssociativeImpl: _VectorOperators$AssociativeImpl$$static;
        interface _VectorOperators$AssociativeImpl {
        }
        interface VectorOperators$AssociativeImpl extends CombineTypes<[_VectorOperators$AssociativeImpl, jdk.incubator.vector.VectorOperators$Associative, jdk.incubator.vector.VectorOperators$BinaryImpl]> {}
        interface _VectorOperators$Binary$$static extends ClassLike {
        }
        let VectorOperators$Binary: _VectorOperators$Binary$$static;
        interface _VectorOperators$Binary {
        }
        interface VectorOperators$Binary extends CombineTypes<[_VectorOperators$Binary, jdk.incubator.vector.VectorOperators$Operator, java.lang.Object]> {}
        interface _VectorOperators$BinaryImpl$$static extends ClassLike {
        }
        let VectorOperators$BinaryImpl: _VectorOperators$BinaryImpl$$static;
        interface _VectorOperators$BinaryImpl {
        }
        interface VectorOperators$BinaryImpl extends CombineTypes<[_VectorOperators$BinaryImpl, jdk.incubator.vector.VectorOperators$OperatorImpl, jdk.incubator.vector.VectorOperators$Binary]> {}
        interface _VectorOperators$Comparison$$static extends ClassLike {
        }
        let VectorOperators$Comparison: _VectorOperators$Comparison$$static;
        interface _VectorOperators$Comparison {
        }
        interface VectorOperators$Comparison extends CombineTypes<[_VectorOperators$Comparison, jdk.incubator.vector.VectorOperators$Operator, java.lang.Object]> {}
        interface _VectorOperators$ComparisonImpl$$static extends ClassLike {
        }
        let VectorOperators$ComparisonImpl: _VectorOperators$ComparisonImpl$$static;
        interface _VectorOperators$ComparisonImpl {
          rangeType(): java.lang.Class<any>;
        }
        interface VectorOperators$ComparisonImpl extends CombineTypes<[_VectorOperators$ComparisonImpl, jdk.incubator.vector.VectorOperators$OperatorImpl, jdk.incubator.vector.VectorOperators$Comparison]> {}
        interface _VectorOperators$Conversion$$static<E,F> extends ClassLike {
          ofCast<E, F>(from: java.lang.Class<E>, to: java.lang.Class<F>): VectorOperators$Conversion<E,F>;
          ofReinterpret<E, F>(from: java.lang.Class<E>, to: java.lang.Class<F>): VectorOperators$Conversion<E,F>;
        }
        let VectorOperators$Conversion: _VectorOperators$Conversion$$static<E,F>;
        interface _VectorOperators$Conversion<E,F> {
          check<E, F>(a0: java.lang.Class<E>, a1: java.lang.Class<F>): VectorOperators$Conversion<E,F>;
          domainType(): java.lang.Class<E>;
          rangeType(): java.lang.Class<F>;
        }
        interface VectorOperators$Conversion<E,F> extends CombineTypes<[_VectorOperators$Conversion<E,F>, VectorOperators$Operator, java.lang.Object]> {}
        interface _VectorOperators$ConversionImpl$$static<E,F> extends ClassLike {
          _a2b(dom: LaneType, ran: LaneType): string;
          _cacheOf(kind: char, dom: LaneType): VectorOperators$ConversionImpl<any,any>[];
          _findConv(kind: char, dom: LaneType, ran: LaneType): VectorOperators$ConversionImpl<any,any>;
          _genCode(): boolean;
          _initCaches(): void;
          _makeConv(kind: char, dom: LaneType, ran: LaneType): VectorOperators$ConversionImpl<any,any>;
          _ofCast(dom: LaneType, ran: LaneType): VectorOperators$ConversionImpl<any,any>;
          _ofCopy(dom: LaneType): VectorOperators$ConversionImpl<any,any>;
          _ofReinterpret(dom: LaneType, ran: LaneType): VectorOperators$ConversionImpl<any,any>;
          _CACHES: VectorOperators$ConversionImpl<any,any>[][][];
          _KIND_CI: int;
          _KIND_LIMIT: int;
          _KIND_RZ: int;
          _KIND_WN: int;
          _LINE_LIMIT: int;
        }
        let VectorOperators$ConversionImpl: _VectorOperators$ConversionImpl$$static<E,F>;
        interface _VectorOperators$ConversionImpl<E,F> {
          check<E, F>(dom: java.lang.Class<E>, ran: java.lang.Class<F>): VectorOperators$Conversion<E,F>;
          _check(kind: char, dom: LaneType, ran: LaneType): void;
          _checkFailed(dom: java.lang.Class<any>, ran: java.lang.Class<any>): java.lang.RuntimeException;
          _domain(): LaneType;
          domainType(): java.lang.Class<E>;
          _genCode(opcs: string): string;
          _kind(): char;
          _range(): LaneType;
          rangeType(): java.lang.Class<F>;
          _sizeChangeLog2(): int;
          _dom: LaneType;
          _kind: char;
          _ran: LaneType;
        }
        interface VectorOperators$ConversionImpl<E,F> extends CombineTypes<[_VectorOperators$ConversionImpl<E,F>, VectorOperators$OperatorImpl, VectorOperators$Conversion<E,F>]> {}
        interface _VectorOperators$ImplCache$$static<OP,T> extends ClassLike {
          new(whatKind: java.lang.Class<OP>, whatVec: java.lang.Class<Vector<any>>): VectorOperators$ImplCache<OP,T>;
        }
        let VectorOperators$ImplCache: _VectorOperators$ImplCache$$static<OP,T>;
        interface _VectorOperators$ImplCache<OP,T> {
          _badOp(op: VectorOperators$Operator): java.lang.UnsupportedOperationException;
          find(op: OP, opc: int, supplier: java.util.function.IntFunction<T>): T;
          toString(): string;
          _cache: any[];
          _whatKind: java.lang.Class<OP>;
          _whatVec: java.lang.Class<Vector<any>>;
        }
        interface VectorOperators$ImplCache<OP,T> extends CombineTypes<[_VectorOperators$ImplCache<OP,T>, java.lang.Object]> {}
        interface _VectorOperators$Operator$$static extends ClassLike {
        }
        let VectorOperators$Operator: _VectorOperators$Operator$$static;
        interface _VectorOperators$Operator {
          arity(): int;
          compatibleWith(a0: java.lang.Class<any>): boolean;
          isAssociative(): boolean;
          isBoolean(): boolean;
          name(): string;
          operatorName(): string;
          rangeType(): java.lang.Class<any>;
        }
        interface VectorOperators$Operator extends CombineTypes<[_VectorOperators$Operator, java.lang.Object]> {}
        interface _VectorOperators$OperatorImpl$$static extends ClassLike {
          _new(symName: string, opName: string, opInfo: int): VectorOperators$OperatorImpl;
        }
        let VectorOperators$OperatorImpl: _VectorOperators$OperatorImpl$$static;
        interface _VectorOperators$OperatorImpl {
          arity(): int;
          compatibleWith(elementType: java.lang.Class<any>): boolean;
          _compatibleWith(laneType: LaneType): boolean;
          _illegalOperation(requireKind: int, forbidKind: int): java.lang.UnsupportedOperationException;
          _illegalOperation(msg1: string, msg2: string): java.lang.UnsupportedOperationException;
          isAssociative(): boolean;
          isBoolean(): boolean;
          name(): string;
          _opCode(requireKind: int, forbidKind: int): int;
          _opCodeRaw(): int;
          _opInfo(): int;
          _opKind(kindBit: int): boolean;
          operatorName(): string;
          rangeType(): java.lang.Class<any>;
          toString(): string;
          _opInfo: int;
          _opName: string;
          _symName: string;
        }
        interface VectorOperators$OperatorImpl extends CombineTypes<[_VectorOperators$OperatorImpl, jdk.incubator.vector.VectorOperators$Operator, java.lang.Object]> {}
        interface _VectorOperators$Ternary$$static extends ClassLike {
        }
        let VectorOperators$Ternary: _VectorOperators$Ternary$$static;
        interface _VectorOperators$Ternary {
        }
        interface VectorOperators$Ternary extends CombineTypes<[_VectorOperators$Ternary, jdk.incubator.vector.VectorOperators$Operator, java.lang.Object]> {}
        interface _VectorOperators$TernaryImpl$$static extends ClassLike {
        }
        let VectorOperators$TernaryImpl: _VectorOperators$TernaryImpl$$static;
        interface _VectorOperators$TernaryImpl {
        }
        interface VectorOperators$TernaryImpl extends CombineTypes<[_VectorOperators$TernaryImpl, jdk.incubator.vector.VectorOperators$Ternary, jdk.incubator.vector.VectorOperators$OperatorImpl]> {}
        interface _VectorOperators$Test$$static extends ClassLike {
        }
        let VectorOperators$Test: _VectorOperators$Test$$static;
        interface _VectorOperators$Test {
        }
        interface VectorOperators$Test extends CombineTypes<[_VectorOperators$Test, jdk.incubator.vector.VectorOperators$Operator, java.lang.Object]> {}
        interface _VectorOperators$TestImpl$$static extends ClassLike {
        }
        let VectorOperators$TestImpl: _VectorOperators$TestImpl$$static;
        interface _VectorOperators$TestImpl {
          rangeType(): java.lang.Class<any>;
        }
        interface VectorOperators$TestImpl extends CombineTypes<[_VectorOperators$TestImpl, jdk.incubator.vector.VectorOperators$Test, jdk.incubator.vector.VectorOperators$OperatorImpl]> {}
        interface _VectorOperators$Unary$$static extends ClassLike {
        }
        let VectorOperators$Unary: _VectorOperators$Unary$$static;
        interface _VectorOperators$Unary {
        }
        interface VectorOperators$Unary extends CombineTypes<[_VectorOperators$Unary, jdk.incubator.vector.VectorOperators$Operator, java.lang.Object]> {}
        interface _VectorOperators$UnaryImpl$$static extends ClassLike {
        }
        let VectorOperators$UnaryImpl: _VectorOperators$UnaryImpl$$static;
        interface _VectorOperators$UnaryImpl {
        }
        interface VectorOperators$UnaryImpl extends CombineTypes<[_VectorOperators$UnaryImpl, jdk.incubator.vector.VectorOperators$OperatorImpl, jdk.incubator.vector.VectorOperators$Unary]> {}
        interface _VectorShape$$static extends ClassLike {
          _computePreferredShape(): VectorShape;
          forBitSize(bitSize: int): VectorShape;
          forIndexBitSize(indexBitSize: int, elementSize: int): VectorShape;
          _getMaxVectorBitSize(etype: java.lang.Class<any>): int;
          _largestShapeFor(etype: java.lang.Class<any>): VectorShape;
          _ofSwitchKey(sk: int): VectorShape;
          preferredShape(): VectorShape;
          valueOf(name: string): VectorShape;
          values(): VectorShape[];
          _INC_VECTOR_SIZE: int;
          _MAX_VECTOR_SIZE: int;
          _PREFERRED_SHAPE: VectorShape;
          _SK_128_BIT: int;
          _SK_256_BIT: int;
          _SK_512_BIT: int;
          _SK_64_BIT: int;
          _SK_LIMIT: int;
          _SK_Max_BIT: int;
          readonly S_128_BIT: VectorShape;
          readonly S_256_BIT: VectorShape;
          readonly S_512_BIT: VectorShape;
          readonly S_64_BIT: VectorShape;
          readonly S_Max_BIT: VectorShape;
        }
        let VectorShape: _VectorShape$$static;
        interface _VectorShape {
          _laneCount(species: VectorSpecies<any>): int;
          vectorBitSize(): int;
          withLanes<E>(elementType: java.lang.Class<E>): VectorSpecies<E>;
          _switchKey: int;
          _vectorBitSize: int;
          _vectorBitSizeLog2: int;
        }
        interface VectorShape extends CombineTypes<[_VectorShape]> {}
        interface _VectorShuffle$$static<E> extends ClassLike {
          fromArray<E>(species: VectorSpecies<E>, sourceIndexes: int[], offset: int): VectorShuffle<E>;
          fromOp<E>(species: VectorSpecies<E>, fn: java.util.function.IntUnaryOperator): VectorShuffle<E>;
          fromValues<E>(species: VectorSpecies<E>, sourceIndexes: int[]): VectorShuffle<E>;
          fromValues<E>(species: VectorSpecies<E>, ...sourceIndexes: int[]): VectorShuffle<E>;
          iota<E>(species: VectorSpecies<E>, start: int, step: int, wrap: boolean): VectorShuffle<E>;
          makeUnzip<E>(species: VectorSpecies<E>, part: int): VectorShuffle<E>;
          makeZip<E>(species: VectorSpecies<E>, part: int): VectorShuffle<E>;
          _unzipIndex(i: int, vlen: int, part: int): int;
          _wrongPartForZip(part: int, unzip: boolean): java.lang.ArrayIndexOutOfBoundsException;
          _zipIndex(i: int, vlen: int, part: int): int;
          _new(reorder: byte[]): VectorShuffle<E>;
        }
        let VectorShuffle: _VectorShuffle$$static<E>;
        interface _VectorShuffle<E> {
          cast<F>(a0: VectorSpecies<F>): VectorShuffle<F>;
          check<F>(a0: VectorSpecies<F>): VectorShuffle<F>;
          checkIndex(a0: int): int;
          checkIndexes(): VectorShuffle<E>;
          equals(obj: any): boolean;
          hashCode(): int;
          intoArray(a0: int[], a1: int): void;
          laneIsValid(): VectorMask<E>;
          laneSource(i: int): int;
          length(): int;
          rearrange(a0: VectorShuffle<E>): VectorShuffle<E>;
          toArray(): int[];
          toString(): string;
          toVector(): Vector<E>;
          vectorSpecies(): VectorSpecies<E>;
          wrapIndex(a0: int): int;
          wrapIndexes(): VectorShuffle<E>;
        }
        interface VectorShuffle<E> extends CombineTypes<[_VectorShuffle<E>, jdk.internal.vm.vector.VectorSupport$VectorShuffle<E>]> {}
        interface _VectorSpecies$$static<E> extends ClassLike {
          elementSize(elementType: java.lang.Class<any>): int;
          of<E>(elementType: java.lang.Class<E>, shape: VectorShape): VectorSpecies<E>;
          ofLargestShape<E>(etype: java.lang.Class<E>): VectorSpecies<E>;
          ofPreferred<E>(etype: java.lang.Class<E>): VectorSpecies<E>;
        }
        let VectorSpecies: _VectorSpecies$$static<E>;
        interface _VectorSpecies<E> {
          broadcast(a0: long): Vector<E>;
          check<F>(a0: java.lang.Class<F>): VectorSpecies<F>;
          checkValue(a0: long): long;
          elementSize(): int;
          elementType(): java.lang.Class<E>;
          equals(a0: any): boolean;
          fromArray(a0: any, a1: int): Vector<E>;
          fromMemorySegment(a0: java.lang.foreign.MemorySegment, a1: long, a2: java.nio.ByteOrder): Vector<E>;
          hashCode(): int;
          indexInRange(a0: int, a1: int): VectorMask<E>;
          indexInRange(a0: long, a1: long): VectorMask<E>;
          iotaShuffle(a0: int, a1: int, a2: boolean): VectorShuffle<E>;
          length(): int;
          loadMask(a0: boolean[], a1: int): VectorMask<E>;
          loopBound(a0: int): int;
          loopBound(a0: long): long;
          maskAll(a0: boolean): VectorMask<E>;
          maskType(): java.lang.Class<VectorMask<E>>;
          partLimit(a0: VectorSpecies<any>, a1: boolean): int;
          shuffleFromArray(a0: int[], a1: int): VectorShuffle<E>;
          shuffleFromOp(a0: java.util.function.IntUnaryOperator): VectorShuffle<E>;
          shuffleFromValues(a0: int[]): VectorShuffle<E>;
          shuffleFromValues(...a0: int[]): VectorShuffle<E>;
          toString(): string;
          vectorBitSize(): int;
          vectorByteSize(): int;
          vectorShape(): VectorShape;
          vectorType(): java.lang.Class<Vector<E>>;
          withLanes<F>(a0: java.lang.Class<F>): VectorSpecies<F>;
          withShape(a0: VectorShape): VectorSpecies<E>;
          zero(): Vector<E>;
        }
        interface VectorSpecies<E> extends CombineTypes<[_VectorSpecies<E>, java.lang.Object]> {}
      }
    }
  }
}

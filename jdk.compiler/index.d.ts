type ClassLike = {
  class: Packages.java.lang.Class<any>;
  [Symbol.hasInstance](v): boolean
 }
type isAny<T> = (T extends never ? true : false) extends false ? false : true;
type CombineTypes<A> = (
  A extends [infer B, ...infer Rest] ?
    isAny<B> extends true ?
      CombineTypes<Rest>
      : CombineTypes<Rest> extends never ? B : B & CombineTypes<Rest>
    : A extends [infer B] ?
      isAny<B> extends true ? never : B
  : never
)
type char   = number & {};
type byte   = number & {};
type short  = number & {};
type int    = number & {};
type long   = number | BigInt;
type float  = number & {};
type double = number & {};
type Function$$JS = Function;
declare module Packages {
  module com {
    module sun {
      module source {
        module doctree {
          interface _AttributeTree$$static extends ClassLike {
          }
          let AttributeTree: _AttributeTree$$static;
          interface _AttributeTree {
            getName(): javax.lang.model.element.Name;
            getValue(): java.util.List<DocTree>;
            getValueKind(): AttributeTree$ValueKind;
          }
          interface AttributeTree extends CombineTypes<[_AttributeTree, com.sun.source.doctree.DocTree, java.lang.Object]> {}
          interface _AttributeTree$ValueKind$$static extends ClassLike {
            valueOf(name: string): AttributeTree$ValueKind;
            values(): AttributeTree$ValueKind[];
            readonly DOUBLE: AttributeTree$ValueKind;
            readonly EMPTY: AttributeTree$ValueKind;
            readonly SINGLE: AttributeTree$ValueKind;
            readonly UNQUOTED: AttributeTree$ValueKind;
          }
          let AttributeTree$ValueKind: _AttributeTree$ValueKind$$static;
          interface _AttributeTree$ValueKind {
          }
          interface AttributeTree$ValueKind extends CombineTypes<[_AttributeTree$ValueKind]> {}
          interface _AuthorTree$$static extends ClassLike {
          }
          let AuthorTree: _AuthorTree$$static;
          interface _AuthorTree {
            getName(): java.util.List<DocTree>;
(): java.util.List<DocTree>;
          }
          interface AuthorTree extends CombineTypes<[_AuthorTree, java.lang.Object, com.sun.source.doctree.BlockTagTree]> {}
          interface _BlockTagTree$$static extends ClassLike {
          }
          let BlockTagTree: _BlockTagTree$$static;
          interface _BlockTagTree {
            getTagName(): string;
(): string;
          }
          interface BlockTagTree extends CombineTypes<[_BlockTagTree, com.sun.source.doctree.DocTree, java.lang.Object]> {}
          interface _CommentTree$$static extends ClassLike {
          }
          let CommentTree: _CommentTree$$static;
          interface _CommentTree {
            getBody(): string;
(): string;
          }
          interface CommentTree extends CombineTypes<[_CommentTree, com.sun.source.doctree.DocTree, java.lang.Object]> {}
          interface _DeprecatedTree$$static extends ClassLike {
          }
          let DeprecatedTree: _DeprecatedTree$$static;
          interface _DeprecatedTree {
            getBody(): java.util.List<DocTree>;
(): java.util.List<DocTree>;
          }
          interface DeprecatedTree extends CombineTypes<[_DeprecatedTree, java.lang.Object, com.sun.source.doctree.BlockTagTree]> {}
          interface _DocCommentTree$$static extends ClassLike {
          }
          let DocCommentTree: _DocCommentTree$$static;
          interface _DocCommentTree {
            getBlockTags(): java.util.List<DocTree>;
            getBody(): java.util.List<DocTree>;
            getFirstSentence(): java.util.List<DocTree>;
            getFullBody(): java.util.List<DocTree>;
            getPostamble(): java.util.List<DocTree>;
            getPreamble(): java.util.List<DocTree>;
          }
          interface DocCommentTree extends CombineTypes<[_DocCommentTree, com.sun.source.doctree.DocTree, java.lang.Object]> {}
          interface _DocRootTree$$static extends ClassLike {
          }
          let DocRootTree: _DocRootTree$$static;
          interface _DocRootTree {
          }
          interface DocRootTree extends CombineTypes<[_DocRootTree, com.sun.source.doctree.InlineTagTree, java.lang.Object]> {}
          interface _DocTree$$static extends ClassLike {
          }
          let DocTree: _DocTree$$static;
          interface _DocTree {
            accept<R, D>(a0: DocTreeVisitor<R,D>, a1: D): R;
            getKind(): DocTree$Kind;
          }
          interface DocTree extends CombineTypes<[_DocTree, java.lang.Object]> {}
          interface _DocTree$Kind$$static extends ClassLike {
            valueOf(name: string): DocTree$Kind;
            values(): DocTree$Kind[];
            readonly ATTRIBUTE: DocTree$Kind;
            readonly AUTHOR: DocTree$Kind;
            readonly CODE: DocTree$Kind;
            readonly COMMENT: DocTree$Kind;
            readonly DEPRECATED: DocTree$Kind;
            readonly DOC_COMMENT: DocTree$Kind;
            readonly DOC_ROOT: DocTree$Kind;
            readonly DOC_TYPE: DocTree$Kind;
            readonly END_ELEMENT: DocTree$Kind;
            readonly ENTITY: DocTree$Kind;
            readonly ERRONEOUS: DocTree$Kind;
            readonly ESCAPE: DocTree$Kind;
            readonly EXCEPTION: DocTree$Kind;
            readonly HIDDEN: DocTree$Kind;
            readonly IDENTIFIER: DocTree$Kind;
            readonly INDEX: DocTree$Kind;
            readonly INHERIT_DOC: DocTree$Kind;
            readonly LINK: DocTree$Kind;
            readonly LINK_PLAIN: DocTree$Kind;
            readonly LITERAL: DocTree$Kind;
            readonly OTHER: DocTree$Kind;
            readonly PARAM: DocTree$Kind;
            readonly PROVIDES: DocTree$Kind;
            readonly REFERENCE: DocTree$Kind;
            readonly RETURN: DocTree$Kind;
            readonly SEE: DocTree$Kind;
            readonly SERIAL: DocTree$Kind;
            readonly SERIAL_DATA: DocTree$Kind;
            readonly SERIAL_FIELD: DocTree$Kind;
            readonly SINCE: DocTree$Kind;
            readonly SNIPPET: DocTree$Kind;
            readonly SPEC: DocTree$Kind;
            readonly START_ELEMENT: DocTree$Kind;
            readonly SUMMARY: DocTree$Kind;
            readonly SYSTEM_PROPERTY: DocTree$Kind;
            readonly TEXT: DocTree$Kind;
            readonly THROWS: DocTree$Kind;
            readonly UNKNOWN_BLOCK_TAG: DocTree$Kind;
            readonly UNKNOWN_INLINE_TAG: DocTree$Kind;
            readonly USES: DocTree$Kind;
            readonly VALUE: DocTree$Kind;
            readonly VERSION: DocTree$Kind;
          }
          let DocTree$Kind: _DocTree$Kind$$static;
          interface _DocTree$Kind {
            readonly tagName: string;
          }
          interface DocTree$Kind extends CombineTypes<[_DocTree$Kind]> {}
          interface _DocTreeVisitor$$static<R,P> extends ClassLike {
          }
          let DocTreeVisitor: _DocTreeVisitor$$static<R,P>;
          interface _DocTreeVisitor<R,P> {
            visitAttribute(a0: AttributeTree, a1: P): R;
            visitAuthor(a0: AuthorTree, a1: P): R;
            visitComment(a0: CommentTree, a1: P): R;
            visitDeprecated(a0: DeprecatedTree, a1: P): R;
            visitDocComment(a0: DocCommentTree, a1: P): R;
            visitDocRoot(a0: DocRootTree, a1: P): R;
            visitDocType(node: DocTypeTree, p: P): R;
            visitEndElement(a0: EndElementTree, a1: P): R;
            visitEntity(a0: EntityTree, a1: P): R;
            visitErroneous(a0: ErroneousTree, a1: P): R;
            visitEscape(node: EscapeTree, p: P): R;
            visitHidden(node: HiddenTree, p: P): R;
            visitIdentifier(a0: IdentifierTree, a1: P): R;
            visitIndex(node: IndexTree, p: P): R;
            visitInheritDoc(a0: InheritDocTree, a1: P): R;
            visitLink(a0: LinkTree, a1: P): R;
            visitLiteral(a0: LiteralTree, a1: P): R;
            visitOther(a0: DocTree, a1: P): R;
            visitParam(a0: ParamTree, a1: P): R;
            visitProvides(node: ProvidesTree, p: P): R;
            visitReference(a0: ReferenceTree, a1: P): R;
            visitReturn(a0: ReturnTree, a1: P): R;
            visitSee(a0: SeeTree, a1: P): R;
            visitSerial(a0: SerialTree, a1: P): R;
            visitSerialData(a0: SerialDataTree, a1: P): R;
            visitSerialField(a0: SerialFieldTree, a1: P): R;
            visitSince(a0: SinceTree, a1: P): R;
            visitSnippet(node: SnippetTree, p: P): R;
            visitSpec(node: SpecTree, p: P): R;
            visitStartElement(a0: StartElementTree, a1: P): R;
            visitSummary(node: SummaryTree, p: P): R;
            visitSystemProperty(node: SystemPropertyTree, p: P): R;
            visitText(a0: TextTree, a1: P): R;
            visitThrows(a0: ThrowsTree, a1: P): R;
            visitUnknownBlockTag(a0: UnknownBlockTagTree, a1: P): R;
            visitUnknownInlineTag(a0: UnknownInlineTagTree, a1: P): R;
            visitUses(node: UsesTree, p: P): R;
            visitValue(a0: ValueTree, a1: P): R;
            visitVersion(a0: VersionTree, a1: P): R;
          }
          interface DocTreeVisitor<R,P> extends CombineTypes<[_DocTreeVisitor<R,P>, java.lang.Object]> {}
          interface _DocTypeTree$$static extends ClassLike {
          }
          let DocTypeTree: _DocTypeTree$$static;
          interface _DocTypeTree {
            getText(): string;
(): string;
          }
          interface DocTypeTree extends CombineTypes<[_DocTypeTree, com.sun.source.doctree.DocTree, java.lang.Object]> {}
          interface _EndElementTree$$static extends ClassLike {
          }
          let EndElementTree: _EndElementTree$$static;
          interface _EndElementTree {
            getName(): javax.lang.model.element.Name;
(): javax.lang.model.element.Name;
          }
          interface EndElementTree extends CombineTypes<[_EndElementTree, com.sun.source.doctree.DocTree, java.lang.Object]> {}
          interface _EntityTree$$static extends ClassLike {
          }
          let EntityTree: _EntityTree$$static;
          interface _EntityTree {
            getName(): javax.lang.model.element.Name;
(): javax.lang.model.element.Name;
          }
          interface EntityTree extends CombineTypes<[_EntityTree, com.sun.source.doctree.DocTree, java.lang.Object]> {}
          interface _ErroneousTree$$static extends ClassLike {
          }
          let ErroneousTree: _ErroneousTree$$static;
          interface _ErroneousTree {
            getDiagnostic(): javax.tools.Diagnostic<javax.tools.JavaFileObject>;
(): javax.tools.Diagnostic<javax.tools.JavaFileObject>;
          }
          interface ErroneousTree extends CombineTypes<[_ErroneousTree, java.lang.Object, com.sun.source.doctree.TextTree]> {}
          interface _EscapeTree$$static extends ClassLike {
          }
          let EscapeTree: _EscapeTree$$static;
          interface _EscapeTree {
            getBody(): string;
(): string;
          }
          interface EscapeTree extends CombineTypes<[_EscapeTree, java.lang.Object, com.sun.source.doctree.TextTree]> {}
          interface _HiddenTree$$static extends ClassLike {
          }
          let HiddenTree: _HiddenTree$$static;
          interface _HiddenTree {
            getBody(): java.util.List<DocTree>;
(): java.util.List<DocTree>;
          }
          interface HiddenTree extends CombineTypes<[_HiddenTree, java.lang.Object, com.sun.source.doctree.BlockTagTree]> {}
          interface _IdentifierTree$$static extends ClassLike {
          }
          let IdentifierTree: _IdentifierTree$$static;
          interface _IdentifierTree {
            getName(): javax.lang.model.element.Name;
(): javax.lang.model.element.Name;
          }
          interface IdentifierTree extends CombineTypes<[_IdentifierTree, com.sun.source.doctree.DocTree, java.lang.Object]> {}
          interface _IndexTree$$static extends ClassLike {
          }
          let IndexTree: _IndexTree$$static;
          interface _IndexTree {
            getDescription(): java.util.List<DocTree>;
            getSearchTerm(): DocTree;
          }
          interface IndexTree extends CombineTypes<[_IndexTree, com.sun.source.doctree.InlineTagTree, java.lang.Object]> {}
          interface _InheritDocTree$$static extends ClassLike {
          }
          let InheritDocTree: _InheritDocTree$$static;
          interface _InheritDocTree {
          }
          interface InheritDocTree extends CombineTypes<[_InheritDocTree, com.sun.source.doctree.InlineTagTree, java.lang.Object]> {}
          interface _InlineTagTree$$static extends ClassLike {
          }
          let InlineTagTree: _InlineTagTree$$static;
          interface _InlineTagTree {
            getTagName(): string;
(): string;
          }
          interface InlineTagTree extends CombineTypes<[_InlineTagTree, com.sun.source.doctree.DocTree, java.lang.Object]> {}
          interface _LinkTree$$static extends ClassLike {
          }
          let LinkTree: _LinkTree$$static;
          interface _LinkTree {
            getLabel(): java.util.List<DocTree>;
            getReference(): ReferenceTree;
          }
          interface LinkTree extends CombineTypes<[_LinkTree, com.sun.source.doctree.InlineTagTree, java.lang.Object]> {}
          interface _LiteralTree$$static extends ClassLike {
          }
          let LiteralTree: _LiteralTree$$static;
          interface _LiteralTree {
            getBody(): TextTree;
(): TextTree;
          }
          interface LiteralTree extends CombineTypes<[_LiteralTree, com.sun.source.doctree.InlineTagTree, java.lang.Object]> {}
          interface _ParamTree$$static extends ClassLike {
          }
          let ParamTree: _ParamTree$$static;
          interface _ParamTree {
            getDescription(): java.util.List<DocTree>;
            getName(): IdentifierTree;
            isTypeParameter(): boolean;
          }
          interface ParamTree extends CombineTypes<[_ParamTree, java.lang.Object, com.sun.source.doctree.BlockTagTree]> {}
          interface _ProvidesTree$$static extends ClassLike {
          }
          let ProvidesTree: _ProvidesTree$$static;
          interface _ProvidesTree {
            getDescription(): java.util.List<DocTree>;
            getServiceType(): ReferenceTree;
          }
          interface ProvidesTree extends CombineTypes<[_ProvidesTree, java.lang.Object, com.sun.source.doctree.BlockTagTree]> {}
          interface _ReferenceTree$$static extends ClassLike {
          }
          let ReferenceTree: _ReferenceTree$$static;
          interface _ReferenceTree {
            getSignature(): string;
(): string;
          }
          interface ReferenceTree extends CombineTypes<[_ReferenceTree, com.sun.source.doctree.DocTree, java.lang.Object]> {}
          interface _ReturnTree$$static extends ClassLike {
          }
          let ReturnTree: _ReturnTree$$static;
          interface _ReturnTree {
            getDescription(): java.util.List<DocTree>;
(): java.util.List<DocTree>;
            isInline(): boolean;
          }
          interface ReturnTree extends CombineTypes<[_ReturnTree, com.sun.source.doctree.InlineTagTree, java.lang.Object, com.sun.source.doctree.BlockTagTree]> {}
          interface _SeeTree$$static extends ClassLike {
          }
          let SeeTree: _SeeTree$$static;
          interface _SeeTree {
            getReference(): java.util.List<DocTree>;
(): java.util.List<DocTree>;
          }
          interface SeeTree extends CombineTypes<[_SeeTree, java.lang.Object, com.sun.source.doctree.BlockTagTree]> {}
          interface _SerialDataTree$$static extends ClassLike {
          }
          let SerialDataTree: _SerialDataTree$$static;
          interface _SerialDataTree {
            getDescription(): java.util.List<DocTree>;
(): java.util.List<DocTree>;
          }
          interface SerialDataTree extends CombineTypes<[_SerialDataTree, java.lang.Object, com.sun.source.doctree.BlockTagTree]> {}
          interface _SerialFieldTree$$static extends ClassLike {
          }
          let SerialFieldTree: _SerialFieldTree$$static;
          interface _SerialFieldTree {
            getDescription(): java.util.List<DocTree>;
            getName(): IdentifierTree;
            getType(): ReferenceTree;
          }
          interface SerialFieldTree extends CombineTypes<[_SerialFieldTree, java.lang.Object, com.sun.source.doctree.BlockTagTree]> {}
          interface _SerialTree$$static extends ClassLike {
          }
          let SerialTree: _SerialTree$$static;
          interface _SerialTree {
            getDescription(): java.util.List<DocTree>;
(): java.util.List<DocTree>;
          }
          interface SerialTree extends CombineTypes<[_SerialTree, java.lang.Object, com.sun.source.doctree.BlockTagTree]> {}
          interface _SinceTree$$static extends ClassLike {
          }
          let SinceTree: _SinceTree$$static;
          interface _SinceTree {
            getBody(): java.util.List<DocTree>;
(): java.util.List<DocTree>;
          }
          interface SinceTree extends CombineTypes<[_SinceTree, java.lang.Object, com.sun.source.doctree.BlockTagTree]> {}
          interface _SnippetTree$$static extends ClassLike {
          }
          let SnippetTree: _SnippetTree$$static;
          interface _SnippetTree {
            getAttributes(): java.util.List<DocTree>;
            getBody(): TextTree;
          }
          interface SnippetTree extends CombineTypes<[_SnippetTree, com.sun.source.doctree.InlineTagTree, java.lang.Object]> {}
          interface _SpecTree$$static extends ClassLike {
          }
          let SpecTree: _SpecTree$$static;
          interface _SpecTree {
            getTitle(): java.util.List<DocTree>;
            getURL(): TextTree;
          }
          interface SpecTree extends CombineTypes<[_SpecTree, java.lang.Object, com.sun.source.doctree.BlockTagTree]> {}
          interface _StartElementTree$$static extends ClassLike {
          }
          let StartElementTree: _StartElementTree$$static;
          interface _StartElementTree {
            getAttributes(): java.util.List<DocTree>;
            getName(): javax.lang.model.element.Name;
            isSelfClosing(): boolean;
          }
          interface StartElementTree extends CombineTypes<[_StartElementTree, com.sun.source.doctree.DocTree, java.lang.Object]> {}
          interface _SummaryTree$$static extends ClassLike {
          }
          let SummaryTree: _SummaryTree$$static;
          interface _SummaryTree {
            getSummary(): java.util.List<DocTree>;
(): java.util.List<DocTree>;
          }
          interface SummaryTree extends CombineTypes<[_SummaryTree, com.sun.source.doctree.InlineTagTree, java.lang.Object]> {}
          interface _SystemPropertyTree$$static extends ClassLike {
          }
          let SystemPropertyTree: _SystemPropertyTree$$static;
          interface _SystemPropertyTree {
            getPropertyName(): javax.lang.model.element.Name;
(): javax.lang.model.element.Name;
          }
          interface SystemPropertyTree extends CombineTypes<[_SystemPropertyTree, com.sun.source.doctree.InlineTagTree, java.lang.Object]> {}
          interface _TextTree$$static extends ClassLike {
          }
          let TextTree: _TextTree$$static;
          interface _TextTree {
            getBody(): string;
(): string;
          }
          interface TextTree extends CombineTypes<[_TextTree, com.sun.source.doctree.DocTree, java.lang.Object]> {}
          interface _ThrowsTree$$static extends ClassLike {
          }
          let ThrowsTree: _ThrowsTree$$static;
          interface _ThrowsTree {
            getDescription(): java.util.List<DocTree>;
            getExceptionName(): ReferenceTree;
          }
          interface ThrowsTree extends CombineTypes<[_ThrowsTree, java.lang.Object, com.sun.source.doctree.BlockTagTree]> {}
          interface _UnknownBlockTagTree$$static extends ClassLike {
          }
          let UnknownBlockTagTree: _UnknownBlockTagTree$$static;
          interface _UnknownBlockTagTree {
            getContent(): java.util.List<DocTree>;
(): java.util.List<DocTree>;
          }
          interface UnknownBlockTagTree extends CombineTypes<[_UnknownBlockTagTree, java.lang.Object, com.sun.source.doctree.BlockTagTree]> {}
          interface _UnknownInlineTagTree$$static extends ClassLike {
          }
          let UnknownInlineTagTree: _UnknownInlineTagTree$$static;
          interface _UnknownInlineTagTree {
            getContent(): java.util.List<DocTree>;
(): java.util.List<DocTree>;
          }
          interface UnknownInlineTagTree extends CombineTypes<[_UnknownInlineTagTree, com.sun.source.doctree.InlineTagTree, java.lang.Object]> {}
          interface _UsesTree$$static extends ClassLike {
          }
          let UsesTree: _UsesTree$$static;
          interface _UsesTree {
            getDescription(): java.util.List<DocTree>;
            getServiceType(): ReferenceTree;
          }
          interface UsesTree extends CombineTypes<[_UsesTree, java.lang.Object, com.sun.source.doctree.BlockTagTree]> {}
          interface _ValueTree$$static extends ClassLike {
          }
          let ValueTree: _ValueTree$$static;
          interface _ValueTree {
            getFormat(): TextTree;
            getReference(): ReferenceTree;
(): ReferenceTree;
          }
          interface ValueTree extends CombineTypes<[_ValueTree, com.sun.source.doctree.InlineTagTree, java.lang.Object]> {}
          interface _VersionTree$$static extends ClassLike {
          }
          let VersionTree: _VersionTree$$static;
          interface _VersionTree {
            getBody(): java.util.List<DocTree>;
(): java.util.List<DocTree>;
          }
          interface VersionTree extends CombineTypes<[_VersionTree, java.lang.Object, com.sun.source.doctree.BlockTagTree]> {}
        }
        module tree {
          interface _AnnotatedTypeTree$$static extends ClassLike {
          }
          let AnnotatedTypeTree: _AnnotatedTypeTree$$static;
          interface _AnnotatedTypeTree {
            getAnnotations(): java.util.List<AnnotationTree>;
            getUnderlyingType(): ExpressionTree;
          }
          interface AnnotatedTypeTree extends CombineTypes<[_AnnotatedTypeTree, com.sun.source.tree.ExpressionTree, java.lang.Object]> {}
          interface _AnnotationTree$$static extends ClassLike {
          }
          let AnnotationTree: _AnnotationTree$$static;
          interface _AnnotationTree {
            getAnnotationType(): Tree;
            getArguments(): java.util.List<ExpressionTree>;
          }
          interface AnnotationTree extends CombineTypes<[_AnnotationTree, com.sun.source.tree.ExpressionTree, java.lang.Object]> {}
          interface _AnyPatternTree$$static extends ClassLike {
          }
          let AnyPatternTree: _AnyPatternTree$$static;
          interface _AnyPatternTree {
          }
          interface AnyPatternTree extends CombineTypes<[_AnyPatternTree, java.lang.Object, com.sun.source.tree.PatternTree]> {}
          interface _ArrayAccessTree$$static extends ClassLike {
          }
          let ArrayAccessTree: _ArrayAccessTree$$static;
          interface _ArrayAccessTree {
            getExpression(): ExpressionTree;
            getIndex(): ExpressionTree;
          }
          interface ArrayAccessTree extends CombineTypes<[_ArrayAccessTree, com.sun.source.tree.ExpressionTree, java.lang.Object]> {}
          interface _ArrayTypeTree$$static extends ClassLike {
          }
          let ArrayTypeTree: _ArrayTypeTree$$static;
          interface _ArrayTypeTree {
            getType(): Tree;
(): Tree;
          }
          interface ArrayTypeTree extends CombineTypes<[_ArrayTypeTree, java.lang.Object, com.sun.source.tree.Tree]> {}
          interface _AssertTree$$static extends ClassLike {
          }
          let AssertTree: _AssertTree$$static;
          interface _AssertTree {
            getCondition(): ExpressionTree;
            getDetail(): ExpressionTree;
          }
          interface AssertTree extends CombineTypes<[_AssertTree, com.sun.source.tree.StatementTree, java.lang.Object]> {}
          interface _AssignmentTree$$static extends ClassLike {
          }
          let AssignmentTree: _AssignmentTree$$static;
          interface _AssignmentTree {
            getExpression(): ExpressionTree;
            getVariable(): ExpressionTree;
          }
          interface AssignmentTree extends CombineTypes<[_AssignmentTree, com.sun.source.tree.ExpressionTree, java.lang.Object]> {}
          interface _BinaryTree$$static extends ClassLike {
          }
          let BinaryTree: _BinaryTree$$static;
          interface _BinaryTree {
            getLeftOperand(): ExpressionTree;
            getRightOperand(): ExpressionTree;
          }
          interface BinaryTree extends CombineTypes<[_BinaryTree, com.sun.source.tree.ExpressionTree, java.lang.Object]> {}
          interface _BindingPatternTree$$static extends ClassLike {
          }
          let BindingPatternTree: _BindingPatternTree$$static;
          interface _BindingPatternTree {
            getVariable(): VariableTree;
(): VariableTree;
          }
          interface BindingPatternTree extends CombineTypes<[_BindingPatternTree, java.lang.Object, com.sun.source.tree.PatternTree]> {}
          interface _BlockTree$$static extends ClassLike {
          }
          let BlockTree: _BlockTree$$static;
          interface _BlockTree {
            getStatements(): java.util.List<StatementTree>;
            isStatic(): boolean;
          }
          interface BlockTree extends CombineTypes<[_BlockTree, com.sun.source.tree.StatementTree, java.lang.Object]> {}
          interface _BreakTree$$static extends ClassLike {
          }
          let BreakTree: _BreakTree$$static;
          interface _BreakTree {
            getLabel(): javax.lang.model.element.Name;
(): javax.lang.model.element.Name;
          }
          interface BreakTree extends CombineTypes<[_BreakTree, com.sun.source.tree.StatementTree, java.lang.Object]> {}
          interface _CaseLabelTree$$static extends ClassLike {
          }
          let CaseLabelTree: _CaseLabelTree$$static;
          interface _CaseLabelTree {
          }
          interface CaseLabelTree extends CombineTypes<[_CaseLabelTree, java.lang.Object, com.sun.source.tree.Tree]> {}
          interface _CaseTree$$static extends ClassLike {
          }
          let CaseTree: _CaseTree$$static;
          interface _CaseTree {
            getBody(): Tree;
            getCaseKind(): CaseTree$CaseKind;
            getExpression(): ExpressionTree;
            getExpressions(): java.util.List<ExpressionTree>;
            getGuard(): ExpressionTree;
            getLabels(): java.util.List<CaseLabelTree>;
            getStatements(): java.util.List<StatementTree>;
          }
          interface CaseTree extends CombineTypes<[_CaseTree, java.lang.Object, com.sun.source.tree.Tree]> {}
          interface _CaseTree$CaseKind$$static extends ClassLike {
            valueOf(name: string): CaseTree$CaseKind;
            values(): CaseTree$CaseKind[];
            readonly RULE: CaseTree$CaseKind;
            readonly STATEMENT: CaseTree$CaseKind;
          }
          let CaseTree$CaseKind: _CaseTree$CaseKind$$static;
          interface _CaseTree$CaseKind {
          }
          interface CaseTree$CaseKind extends CombineTypes<[_CaseTree$CaseKind]> {}
          interface _CatchTree$$static extends ClassLike {
          }
          let CatchTree: _CatchTree$$static;
          interface _CatchTree {
            getBlock(): BlockTree;
            getParameter(): VariableTree;
          }
          interface CatchTree extends CombineTypes<[_CatchTree, java.lang.Object, com.sun.source.tree.Tree]> {}
          interface _ClassTree$$static extends ClassLike {
          }
          let ClassTree: _ClassTree$$static;
          interface _ClassTree {
            getExtendsClause(): Tree;
            getImplementsClause(): java.util.List<Tree>;
            getMembers(): java.util.List<Tree>;
            getModifiers(): ModifiersTree;
            getPermitsClause(): java.util.List<Tree>;
            getSimpleName(): javax.lang.model.element.Name;
            getTypeParameters(): java.util.List<TypeParameterTree>;
          }
          interface ClassTree extends CombineTypes<[_ClassTree, com.sun.source.tree.StatementTree, java.lang.Object]> {}
          interface _CompilationUnitTree$$static extends ClassLike {
          }
          let CompilationUnitTree: _CompilationUnitTree$$static;
          interface _CompilationUnitTree {
            getImports(): java.util.List<ImportTree>;
            getLineMap(): LineMap;
            getModule(): ModuleTree;
            getPackage(): PackageTree;
            getPackageAnnotations(): java.util.List<AnnotationTree>;
            getPackageName(): ExpressionTree;
            getSourceFile(): javax.tools.JavaFileObject;
            getTypeDecls(): java.util.List<Tree>;
          }
          interface CompilationUnitTree extends CombineTypes<[_CompilationUnitTree, java.lang.Object, com.sun.source.tree.Tree]> {}
          interface _CompoundAssignmentTree$$static extends ClassLike {
          }
          let CompoundAssignmentTree: _CompoundAssignmentTree$$static;
          interface _CompoundAssignmentTree {
            getExpression(): ExpressionTree;
            getVariable(): ExpressionTree;
          }
          interface CompoundAssignmentTree extends CombineTypes<[_CompoundAssignmentTree, com.sun.source.tree.ExpressionTree, java.lang.Object]> {}
          interface _ConditionalExpressionTree$$static extends ClassLike {
          }
          let ConditionalExpressionTree: _ConditionalExpressionTree$$static;
          interface _ConditionalExpressionTree {
            getCondition(): ExpressionTree;
            getFalseExpression(): ExpressionTree;
            getTrueExpression(): ExpressionTree;
          }
          interface ConditionalExpressionTree extends CombineTypes<[_ConditionalExpressionTree, com.sun.source.tree.ExpressionTree, java.lang.Object]> {}
          interface _ConstantCaseLabelTree$$static extends ClassLike {
          }
          let ConstantCaseLabelTree: _ConstantCaseLabelTree$$static;
          interface _ConstantCaseLabelTree {
            getConstantExpression(): ExpressionTree;
(): ExpressionTree;
          }
          interface ConstantCaseLabelTree extends CombineTypes<[_ConstantCaseLabelTree, com.sun.source.tree.CaseLabelTree, java.lang.Object]> {}
          interface _ContinueTree$$static extends ClassLike {
          }
          let ContinueTree: _ContinueTree$$static;
          interface _ContinueTree {
            getLabel(): javax.lang.model.element.Name;
(): javax.lang.model.element.Name;
          }
          interface ContinueTree extends CombineTypes<[_ContinueTree, com.sun.source.tree.StatementTree, java.lang.Object]> {}
          interface _DeconstructionPatternTree$$static extends ClassLike {
          }
          let DeconstructionPatternTree: _DeconstructionPatternTree$$static;
          interface _DeconstructionPatternTree {
            getDeconstructor(): ExpressionTree;
            getNestedPatterns(): java.util.List<PatternTree>;
          }
          interface DeconstructionPatternTree extends CombineTypes<[_DeconstructionPatternTree, java.lang.Object, com.sun.source.tree.PatternTree]> {}
          interface _DefaultCaseLabelTree$$static extends ClassLike {
          }
          let DefaultCaseLabelTree: _DefaultCaseLabelTree$$static;
          interface _DefaultCaseLabelTree {
          }
          interface DefaultCaseLabelTree extends CombineTypes<[_DefaultCaseLabelTree, com.sun.source.tree.CaseLabelTree, java.lang.Object]> {}
          interface _DirectiveTree$$static extends ClassLike {
          }
          let DirectiveTree: _DirectiveTree$$static;
          interface _DirectiveTree {
          }
          interface DirectiveTree extends CombineTypes<[_DirectiveTree, java.lang.Object, com.sun.source.tree.Tree]> {}
          interface _DoWhileLoopTree$$static extends ClassLike {
          }
          let DoWhileLoopTree: _DoWhileLoopTree$$static;
          interface _DoWhileLoopTree {
            getCondition(): ExpressionTree;
            getStatement(): StatementTree;
          }
          interface DoWhileLoopTree extends CombineTypes<[_DoWhileLoopTree, com.sun.source.tree.StatementTree, java.lang.Object]> {}
          interface _EmptyStatementTree$$static extends ClassLike {
          }
          let EmptyStatementTree: _EmptyStatementTree$$static;
          interface _EmptyStatementTree {
          }
          interface EmptyStatementTree extends CombineTypes<[_EmptyStatementTree, com.sun.source.tree.StatementTree, java.lang.Object]> {}
          interface _EnhancedForLoopTree$$static extends ClassLike {
          }
          let EnhancedForLoopTree: _EnhancedForLoopTree$$static;
          interface _EnhancedForLoopTree {
            getExpression(): ExpressionTree;
            getStatement(): StatementTree;
            getVariable(): VariableTree;
          }
          interface EnhancedForLoopTree extends CombineTypes<[_EnhancedForLoopTree, com.sun.source.tree.StatementTree, java.lang.Object]> {}
          interface _ErroneousTree$$static extends ClassLike {
          }
          let ErroneousTree: _ErroneousTree$$static;
          interface _ErroneousTree {
            getErrorTrees(): java.util.List<Tree>;
(): java.util.List<Tree>;
          }
          interface ErroneousTree extends CombineTypes<[_ErroneousTree, com.sun.source.tree.ExpressionTree, java.lang.Object]> {}
          interface _ExportsTree$$static extends ClassLike {
          }
          let ExportsTree: _ExportsTree$$static;
          interface _ExportsTree {
            getModuleNames(): java.util.List<ExpressionTree>;
            getPackageName(): ExpressionTree;
          }
          interface ExportsTree extends CombineTypes<[_ExportsTree, com.sun.source.tree.DirectiveTree, java.lang.Object]> {}
          interface _ExpressionStatementTree$$static extends ClassLike {
          }
          let ExpressionStatementTree: _ExpressionStatementTree$$static;
          interface _ExpressionStatementTree {
            getExpression(): ExpressionTree;
(): ExpressionTree;
          }
          interface ExpressionStatementTree extends CombineTypes<[_ExpressionStatementTree, com.sun.source.tree.StatementTree, java.lang.Object]> {}
          interface _ExpressionTree$$static extends ClassLike {
          }
          let ExpressionTree: _ExpressionTree$$static;
          interface _ExpressionTree {
          }
          interface ExpressionTree extends CombineTypes<[_ExpressionTree, java.lang.Object, com.sun.source.tree.Tree]> {}
          interface _ForLoopTree$$static extends ClassLike {
          }
          let ForLoopTree: _ForLoopTree$$static;
          interface _ForLoopTree {
            getCondition(): ExpressionTree;
            getInitializer(): java.util.List<StatementTree>;
            getStatement(): StatementTree;
            getUpdate(): java.util.List<ExpressionStatementTree>;
          }
          interface ForLoopTree extends CombineTypes<[_ForLoopTree, com.sun.source.tree.StatementTree, java.lang.Object]> {}
          interface _IdentifierTree$$static extends ClassLike {
          }
          let IdentifierTree: _IdentifierTree$$static;
          interface _IdentifierTree {
            getName(): javax.lang.model.element.Name;
(): javax.lang.model.element.Name;
          }
          interface IdentifierTree extends CombineTypes<[_IdentifierTree, com.sun.source.tree.ExpressionTree, java.lang.Object]> {}
          interface _IfTree$$static extends ClassLike {
          }
          let IfTree: _IfTree$$static;
          interface _IfTree {
            getCondition(): ExpressionTree;
            getElseStatement(): StatementTree;
            getThenStatement(): StatementTree;
          }
          interface IfTree extends CombineTypes<[_IfTree, com.sun.source.tree.StatementTree, java.lang.Object]> {}
          interface _ImportTree$$static extends ClassLike {
          }
          let ImportTree: _ImportTree$$static;
          interface _ImportTree {
            getQualifiedIdentifier(): Tree;
            isStatic(): boolean;
          }
          interface ImportTree extends CombineTypes<[_ImportTree, java.lang.Object, com.sun.source.tree.Tree]> {}
          interface _InstanceOfTree$$static extends ClassLike {
          }
          let InstanceOfTree: _InstanceOfTree$$static;
          interface _InstanceOfTree {
            getExpression(): ExpressionTree;
            getPattern(): PatternTree;
            getType(): Tree;
          }
          interface InstanceOfTree extends CombineTypes<[_InstanceOfTree, com.sun.source.tree.ExpressionTree, java.lang.Object]> {}
          interface _IntersectionTypeTree$$static extends ClassLike {
          }
          let IntersectionTypeTree: _IntersectionTypeTree$$static;
          interface _IntersectionTypeTree {
            getBounds(): java.util.List<Tree>;
(): java.util.List<Tree>;
          }
          interface IntersectionTypeTree extends CombineTypes<[_IntersectionTypeTree, java.lang.Object, com.sun.source.tree.Tree]> {}
          interface _LabeledStatementTree$$static extends ClassLike {
          }
          let LabeledStatementTree: _LabeledStatementTree$$static;
          interface _LabeledStatementTree {
            getLabel(): javax.lang.model.element.Name;
            getStatement(): StatementTree;
          }
          interface LabeledStatementTree extends CombineTypes<[_LabeledStatementTree, com.sun.source.tree.StatementTree, java.lang.Object]> {}
          interface _LambdaExpressionTree$$static extends ClassLike {
          }
          let LambdaExpressionTree: _LambdaExpressionTree$$static;
          interface _LambdaExpressionTree {
            getBody(): Tree;
            getBodyKind(): LambdaExpressionTree$BodyKind;
            getParameters(): java.util.List<VariableTree>;
          }
          interface LambdaExpressionTree extends CombineTypes<[_LambdaExpressionTree, com.sun.source.tree.ExpressionTree, java.lang.Object]> {}
          interface _LambdaExpressionTree$BodyKind$$static extends ClassLike {
            valueOf(name: string): LambdaExpressionTree$BodyKind;
            values(): LambdaExpressionTree$BodyKind[];
            readonly EXPRESSION: LambdaExpressionTree$BodyKind;
            readonly STATEMENT: LambdaExpressionTree$BodyKind;
          }
          let LambdaExpressionTree$BodyKind: _LambdaExpressionTree$BodyKind$$static;
          interface _LambdaExpressionTree$BodyKind {
          }
          interface LambdaExpressionTree$BodyKind extends CombineTypes<[_LambdaExpressionTree$BodyKind]> {}
          interface _LineMap$$static extends ClassLike {
          }
          let LineMap: _LineMap$$static;
          interface _LineMap {
            getColumnNumber(a0: long): long;
            getLineNumber(a0: long): long;
            getPosition(a0: long, a1: long): long;
            getStartPosition(a0: long): long;
          }
          interface LineMap extends CombineTypes<[_LineMap, java.lang.Object]> {}
          interface _LiteralTree$$static extends ClassLike {
          }
          let LiteralTree: _LiteralTree$$static;
          interface _LiteralTree {
            getValue(): any;
(): any;
          }
          interface LiteralTree extends CombineTypes<[_LiteralTree, com.sun.source.tree.ExpressionTree, java.lang.Object]> {}
          interface _MemberReferenceTree$$static extends ClassLike {
          }
          let MemberReferenceTree: _MemberReferenceTree$$static;
          interface _MemberReferenceTree {
            getMode(): MemberReferenceTree$ReferenceMode;
            getName(): javax.lang.model.element.Name;
            getQualifierExpression(): ExpressionTree;
            getTypeArguments(): java.util.List<ExpressionTree>;
          }
          interface MemberReferenceTree extends CombineTypes<[_MemberReferenceTree, com.sun.source.tree.ExpressionTree, java.lang.Object]> {}
          interface _MemberReferenceTree$ReferenceMode$$static extends ClassLike {
            valueOf(name: string): MemberReferenceTree$ReferenceMode;
            values(): MemberReferenceTree$ReferenceMode[];
            readonly INVOKE: MemberReferenceTree$ReferenceMode;
            readonly NEW: MemberReferenceTree$ReferenceMode;
          }
          let MemberReferenceTree$ReferenceMode: _MemberReferenceTree$ReferenceMode$$static;
          interface _MemberReferenceTree$ReferenceMode {
          }
          interface MemberReferenceTree$ReferenceMode extends CombineTypes<[_MemberReferenceTree$ReferenceMode]> {}
          interface _MemberSelectTree$$static extends ClassLike {
          }
          let MemberSelectTree: _MemberSelectTree$$static;
          interface _MemberSelectTree {
            getExpression(): ExpressionTree;
            getIdentifier(): javax.lang.model.element.Name;
          }
          interface MemberSelectTree extends CombineTypes<[_MemberSelectTree, com.sun.source.tree.ExpressionTree, java.lang.Object]> {}
          interface _MethodInvocationTree$$static extends ClassLike {
          }
          let MethodInvocationTree: _MethodInvocationTree$$static;
          interface _MethodInvocationTree {
            getArguments(): java.util.List<ExpressionTree>;
            getMethodSelect(): ExpressionTree;
            getTypeArguments(): java.util.List<Tree>;
          }
          interface MethodInvocationTree extends CombineTypes<[_MethodInvocationTree, com.sun.source.tree.ExpressionTree, java.lang.Object]> {}
          interface _MethodTree$$static extends ClassLike {
          }
          let MethodTree: _MethodTree$$static;
          interface _MethodTree {
            getBody(): BlockTree;
            getDefaultValue(): Tree;
            getModifiers(): ModifiersTree;
            getName(): javax.lang.model.element.Name;
            getParameters(): java.util.List<VariableTree>;
            getReceiverParameter(): VariableTree;
            getReturnType(): Tree;
            getThrows(): java.util.List<ExpressionTree>;
            getTypeParameters(): java.util.List<TypeParameterTree>;
          }
          interface MethodTree extends CombineTypes<[_MethodTree, java.lang.Object, com.sun.source.tree.Tree]> {}
          interface _ModifiersTree$$static extends ClassLike {
          }
          let ModifiersTree: _ModifiersTree$$static;
          interface _ModifiersTree {
            getAnnotations(): java.util.List<AnnotationTree>;
            getFlags(): java.util.Set<javax.lang.model.element.Modifier>;
          }
          interface ModifiersTree extends CombineTypes<[_ModifiersTree, java.lang.Object, com.sun.source.tree.Tree]> {}
          interface _ModuleTree$$static extends ClassLike {
          }
          let ModuleTree: _ModuleTree$$static;
          interface _ModuleTree {
            getAnnotations(): java.util.List<AnnotationTree>;
            getDirectives(): java.util.List<DirectiveTree>;
            getModuleType(): ModuleTree$ModuleKind;
            getName(): ExpressionTree;
          }
          interface ModuleTree extends CombineTypes<[_ModuleTree, java.lang.Object, com.sun.source.tree.Tree]> {}
          interface _ModuleTree$ModuleKind$$static extends ClassLike {
            valueOf(name: string): ModuleTree$ModuleKind;
            values(): ModuleTree$ModuleKind[];
            readonly OPEN: ModuleTree$ModuleKind;
            readonly STRONG: ModuleTree$ModuleKind;
          }
          let ModuleTree$ModuleKind: _ModuleTree$ModuleKind$$static;
          interface _ModuleTree$ModuleKind {
          }
          interface ModuleTree$ModuleKind extends CombineTypes<[_ModuleTree$ModuleKind]> {}
          interface _NewArrayTree$$static extends ClassLike {
          }
          let NewArrayTree: _NewArrayTree$$static;
          interface _NewArrayTree {
            getAnnotations(): java.util.List<AnnotationTree>;
            getDimAnnotations(): java.util.List<java.util.List<AnnotationTree>>;
            getDimensions(): java.util.List<ExpressionTree>;
            getInitializers(): java.util.List<ExpressionTree>;
            getType(): Tree;
          }
          interface NewArrayTree extends CombineTypes<[_NewArrayTree, com.sun.source.tree.ExpressionTree, java.lang.Object]> {}
          interface _NewClassTree$$static extends ClassLike {
          }
          let NewClassTree: _NewClassTree$$static;
          interface _NewClassTree {
            getArguments(): java.util.List<ExpressionTree>;
            getClassBody(): ClassTree;
            getEnclosingExpression(): ExpressionTree;
            getIdentifier(): ExpressionTree;
            getTypeArguments(): java.util.List<Tree>;
          }
          interface NewClassTree extends CombineTypes<[_NewClassTree, com.sun.source.tree.ExpressionTree, java.lang.Object]> {}
          interface _OpensTree$$static extends ClassLike {
          }
          let OpensTree: _OpensTree$$static;
          interface _OpensTree {
            getModuleNames(): java.util.List<ExpressionTree>;
            getPackageName(): ExpressionTree;
          }
          interface OpensTree extends CombineTypes<[_OpensTree, com.sun.source.tree.DirectiveTree, java.lang.Object]> {}
          interface _PackageTree$$static extends ClassLike {
          }
          let PackageTree: _PackageTree$$static;
          interface _PackageTree {
            getAnnotations(): java.util.List<AnnotationTree>;
            getPackageName(): ExpressionTree;
          }
          interface PackageTree extends CombineTypes<[_PackageTree, java.lang.Object, com.sun.source.tree.Tree]> {}
          interface _ParameterizedTypeTree$$static extends ClassLike {
          }
          let ParameterizedTypeTree: _ParameterizedTypeTree$$static;
          interface _ParameterizedTypeTree {
            getType(): Tree;
            getTypeArguments(): java.util.List<Tree>;
          }
          interface ParameterizedTypeTree extends CombineTypes<[_ParameterizedTypeTree, java.lang.Object, com.sun.source.tree.Tree]> {}
          interface _ParenthesizedTree$$static extends ClassLike {
          }
          let ParenthesizedTree: _ParenthesizedTree$$static;
          interface _ParenthesizedTree {
            getExpression(): ExpressionTree;
(): ExpressionTree;
          }
          interface ParenthesizedTree extends CombineTypes<[_ParenthesizedTree, com.sun.source.tree.ExpressionTree, java.lang.Object]> {}
          interface _PatternCaseLabelTree$$static extends ClassLike {
          }
          let PatternCaseLabelTree: _PatternCaseLabelTree$$static;
          interface _PatternCaseLabelTree {
            getPattern(): PatternTree;
(): PatternTree;
          }
          interface PatternCaseLabelTree extends CombineTypes<[_PatternCaseLabelTree, com.sun.source.tree.CaseLabelTree, java.lang.Object]> {}
          interface _PatternTree$$static extends ClassLike {
          }
          let PatternTree: _PatternTree$$static;
          interface _PatternTree {
          }
          interface PatternTree extends CombineTypes<[_PatternTree, java.lang.Object, com.sun.source.tree.Tree]> {}
          interface _PrimitiveTypeTree$$static extends ClassLike {
          }
          let PrimitiveTypeTree: _PrimitiveTypeTree$$static;
          interface _PrimitiveTypeTree {
            getPrimitiveTypeKind(): javax.lang.model.type.TypeKind;
(): javax.lang.model.type.TypeKind;
          }
          interface PrimitiveTypeTree extends CombineTypes<[_PrimitiveTypeTree, java.lang.Object, com.sun.source.tree.Tree]> {}
          interface _ProvidesTree$$static extends ClassLike {
          }
          let ProvidesTree: _ProvidesTree$$static;
          interface _ProvidesTree {
            getImplementationNames(): java.util.List<ExpressionTree>;
            getServiceName(): ExpressionTree;
          }
          interface ProvidesTree extends CombineTypes<[_ProvidesTree, com.sun.source.tree.DirectiveTree, java.lang.Object]> {}
          interface _RequiresTree$$static extends ClassLike {
          }
          let RequiresTree: _RequiresTree$$static;
          interface _RequiresTree {
            getModuleName(): ExpressionTree;
            isStatic(): boolean;
            isTransitive(): boolean;
          }
          interface RequiresTree extends CombineTypes<[_RequiresTree, com.sun.source.tree.DirectiveTree, java.lang.Object]> {}
          interface _ReturnTree$$static extends ClassLike {
          }
          let ReturnTree: _ReturnTree$$static;
          interface _ReturnTree {
            getExpression(): ExpressionTree;
(): ExpressionTree;
          }
          interface ReturnTree extends CombineTypes<[_ReturnTree, com.sun.source.tree.StatementTree, java.lang.Object]> {}
          interface _Scope$$static extends ClassLike {
          }
          let Scope: _Scope$$static;
          interface _Scope {
            getEnclosingClass(): javax.lang.model.element.TypeElement;
            getEnclosingMethod(): javax.lang.model.element.ExecutableElement;
            getEnclosingScope(): Scope;
            getLocalElements(): java.lang.Iterable<javax.lang.model.element.Element>;
          }
          interface Scope extends CombineTypes<[_Scope, java.lang.Object]> {}
          interface _StatementTree$$static extends ClassLike {
          }
          let StatementTree: _StatementTree$$static;
          interface _StatementTree {
          }
          interface StatementTree extends CombineTypes<[_StatementTree, java.lang.Object, com.sun.source.tree.Tree]> {}
          interface _StringTemplateTree$$static extends ClassLike {
          }
          let StringTemplateTree: _StringTemplateTree$$static;
          interface _StringTemplateTree {
            getExpressions(): java.util.List<ExpressionTree>;
            getFragments(): java.util.List<string>;
            getProcessor(): ExpressionTree;
          }
          interface StringTemplateTree extends CombineTypes<[_StringTemplateTree, com.sun.source.tree.ExpressionTree, java.lang.Object]> {}
          interface _SwitchExpressionTree$$static extends ClassLike {
          }
          let SwitchExpressionTree: _SwitchExpressionTree$$static;
          interface _SwitchExpressionTree {
            getCases(): java.util.List<CaseTree>;
            getExpression(): ExpressionTree;
          }
          interface SwitchExpressionTree extends CombineTypes<[_SwitchExpressionTree, com.sun.source.tree.ExpressionTree, java.lang.Object]> {}
          interface _SwitchTree$$static extends ClassLike {
          }
          let SwitchTree: _SwitchTree$$static;
          interface _SwitchTree {
            getCases(): java.util.List<CaseTree>;
            getExpression(): ExpressionTree;
          }
          interface SwitchTree extends CombineTypes<[_SwitchTree, com.sun.source.tree.StatementTree, java.lang.Object]> {}
          interface _SynchronizedTree$$static extends ClassLike {
          }
          let SynchronizedTree: _SynchronizedTree$$static;
          interface _SynchronizedTree {
            getBlock(): BlockTree;
            getExpression(): ExpressionTree;
          }
          interface SynchronizedTree extends CombineTypes<[_SynchronizedTree, com.sun.source.tree.StatementTree, java.lang.Object]> {}
          interface _ThrowTree$$static extends ClassLike {
          }
          let ThrowTree: _ThrowTree$$static;
          interface _ThrowTree {
            getExpression(): ExpressionTree;
(): ExpressionTree;
          }
          interface ThrowTree extends CombineTypes<[_ThrowTree, com.sun.source.tree.StatementTree, java.lang.Object]> {}
          interface _Tree$$static extends ClassLike {
          }
          let Tree: _Tree$$static;
          interface _Tree {
            accept<R, D>(a0: TreeVisitor<R,D>, a1: D): R;
            getKind(): Tree$Kind;
          }
          interface Tree extends CombineTypes<[_Tree, java.lang.Object]> {}
          interface _Tree$Kind$$static extends ClassLike {
            valueOf(name: string): Tree$Kind;
            values(): Tree$Kind[];
            readonly AND: Tree$Kind;
            readonly AND_ASSIGNMENT: Tree$Kind;
            readonly ANNOTATED_TYPE: Tree$Kind;
            readonly ANNOTATION: Tree$Kind;
            readonly ANNOTATION_TYPE: Tree$Kind;
            readonly ANY_PATTERN: Tree$Kind;
            readonly ARRAY_ACCESS: Tree$Kind;
            readonly ARRAY_TYPE: Tree$Kind;
            readonly ASSERT: Tree$Kind;
            readonly ASSIGNMENT: Tree$Kind;
            readonly BINDING_PATTERN: Tree$Kind;
            readonly BITWISE_COMPLEMENT: Tree$Kind;
            readonly BLOCK: Tree$Kind;
            readonly BOOLEAN_LITERAL: Tree$Kind;
            readonly BREAK: Tree$Kind;
            readonly CASE: Tree$Kind;
            readonly CATCH: Tree$Kind;
            readonly CHAR_LITERAL: Tree$Kind;
            readonly CLASS: Tree$Kind;
            readonly COMPILATION_UNIT: Tree$Kind;
            readonly CONDITIONAL_AND: Tree$Kind;
            readonly CONDITIONAL_EXPRESSION: Tree$Kind;
            readonly CONDITIONAL_OR: Tree$Kind;
            readonly CONSTANT_CASE_LABEL: Tree$Kind;
            readonly CONTINUE: Tree$Kind;
            readonly DECONSTRUCTION_PATTERN: Tree$Kind;
            readonly DEFAULT_CASE_LABEL: Tree$Kind;
            readonly DIVIDE: Tree$Kind;
            readonly DIVIDE_ASSIGNMENT: Tree$Kind;
            readonly DOUBLE_LITERAL: Tree$Kind;
            readonly DO_WHILE_LOOP: Tree$Kind;
            readonly EMPTY_STATEMENT: Tree$Kind;
            readonly ENHANCED_FOR_LOOP: Tree$Kind;
            readonly ENUM: Tree$Kind;
            readonly EQUAL_TO: Tree$Kind;
            readonly ERRONEOUS: Tree$Kind;
            readonly EXPORTS: Tree$Kind;
            readonly EXPRESSION_STATEMENT: Tree$Kind;
            readonly EXTENDS_WILDCARD: Tree$Kind;
            readonly FLOAT_LITERAL: Tree$Kind;
            readonly FOR_LOOP: Tree$Kind;
            readonly GREATER_THAN: Tree$Kind;
            readonly GREATER_THAN_EQUAL: Tree$Kind;
            readonly IDENTIFIER: Tree$Kind;
            readonly IF: Tree$Kind;
            readonly IMPORT: Tree$Kind;
            readonly INSTANCE_OF: Tree$Kind;
            readonly INTERFACE: Tree$Kind;
            readonly INTERSECTION_TYPE: Tree$Kind;
            readonly INT_LITERAL: Tree$Kind;
            readonly LABELED_STATEMENT: Tree$Kind;
            readonly LAMBDA_EXPRESSION: Tree$Kind;
            readonly LEFT_SHIFT: Tree$Kind;
            readonly LEFT_SHIFT_ASSIGNMENT: Tree$Kind;
            readonly LESS_THAN: Tree$Kind;
            readonly LESS_THAN_EQUAL: Tree$Kind;
            readonly LOGICAL_COMPLEMENT: Tree$Kind;
            readonly LONG_LITERAL: Tree$Kind;
            readonly MEMBER_REFERENCE: Tree$Kind;
            readonly MEMBER_SELECT: Tree$Kind;
            readonly METHOD: Tree$Kind;
            readonly METHOD_INVOCATION: Tree$Kind;
            readonly MINUS: Tree$Kind;
            readonly MINUS_ASSIGNMENT: Tree$Kind;
            readonly MODIFIERS: Tree$Kind;
            readonly MODULE: Tree$Kind;
            readonly MULTIPLY: Tree$Kind;
            readonly MULTIPLY_ASSIGNMENT: Tree$Kind;
            readonly NEW_ARRAY: Tree$Kind;
            readonly NEW_CLASS: Tree$Kind;
            readonly NOT_EQUAL_TO: Tree$Kind;
            readonly NULL_LITERAL: Tree$Kind;
            readonly OPENS: Tree$Kind;
            readonly OR: Tree$Kind;
            readonly OR_ASSIGNMENT: Tree$Kind;
            readonly OTHER: Tree$Kind;
            readonly PACKAGE: Tree$Kind;
            readonly PARAMETERIZED_TYPE: Tree$Kind;
            readonly PARENTHESIZED: Tree$Kind;
            readonly PATTERN_CASE_LABEL: Tree$Kind;
            readonly PLUS: Tree$Kind;
            readonly PLUS_ASSIGNMENT: Tree$Kind;
            readonly POSTFIX_DECREMENT: Tree$Kind;
            readonly POSTFIX_INCREMENT: Tree$Kind;
            readonly PREFIX_DECREMENT: Tree$Kind;
            readonly PREFIX_INCREMENT: Tree$Kind;
            readonly PRIMITIVE_TYPE: Tree$Kind;
            readonly PROVIDES: Tree$Kind;
            readonly RECORD: Tree$Kind;
            readonly REMAINDER: Tree$Kind;
            readonly REMAINDER_ASSIGNMENT: Tree$Kind;
            readonly REQUIRES: Tree$Kind;
            readonly RETURN: Tree$Kind;
            readonly RIGHT_SHIFT: Tree$Kind;
            readonly RIGHT_SHIFT_ASSIGNMENT: Tree$Kind;
            readonly STRING_LITERAL: Tree$Kind;
            readonly SUPER_WILDCARD: Tree$Kind;
            readonly SWITCH: Tree$Kind;
            readonly SWITCH_EXPRESSION: Tree$Kind;
            readonly SYNCHRONIZED: Tree$Kind;
            readonly TEMPLATE: Tree$Kind;
            readonly THROW: Tree$Kind;
            readonly TRY: Tree$Kind;
            readonly TYPE_ANNOTATION: Tree$Kind;
            readonly TYPE_CAST: Tree$Kind;
            readonly TYPE_PARAMETER: Tree$Kind;
            readonly UNARY_MINUS: Tree$Kind;
            readonly UNARY_PLUS: Tree$Kind;
            readonly UNBOUNDED_WILDCARD: Tree$Kind;
            readonly UNION_TYPE: Tree$Kind;
            readonly UNSIGNED_RIGHT_SHIFT: Tree$Kind;
            readonly UNSIGNED_RIGHT_SHIFT_ASSIGNMENT: Tree$Kind;
            readonly USES: Tree$Kind;
            readonly VARIABLE: Tree$Kind;
            readonly WHILE_LOOP: Tree$Kind;
            readonly XOR: Tree$Kind;
            readonly XOR_ASSIGNMENT: Tree$Kind;
            readonly YIELD: Tree$Kind;
          }
          let Tree$Kind: _Tree$Kind$$static;
          interface _Tree$Kind {
            asInterface(): java.lang.Class<Tree>;
            _associatedInterface: java.lang.Class<Tree>;
          }
          interface Tree$Kind extends CombineTypes<[_Tree$Kind]> {}
          interface _TreeVisitor$$static<R,P> extends ClassLike {
          }
          let TreeVisitor: _TreeVisitor$$static<R,P>;
          interface _TreeVisitor<R,P> {
            visitAnnotatedType(a0: AnnotatedTypeTree, a1: P): R;
            visitAnnotation(a0: AnnotationTree, a1: P): R;
            visitAnyPattern(a0: AnyPatternTree, a1: P): R;
            visitArrayAccess(a0: ArrayAccessTree, a1: P): R;
            visitArrayType(a0: ArrayTypeTree, a1: P): R;
            visitAssert(a0: AssertTree, a1: P): R;
            visitAssignment(a0: AssignmentTree, a1: P): R;
            visitBinary(a0: BinaryTree, a1: P): R;
            visitBindingPattern(a0: BindingPatternTree, a1: P): R;
            visitBlock(a0: BlockTree, a1: P): R;
            visitBreak(a0: BreakTree, a1: P): R;
            visitCase(a0: CaseTree, a1: P): R;
            visitCatch(a0: CatchTree, a1: P): R;
            visitClass(a0: ClassTree, a1: P): R;
            visitCompilationUnit(a0: CompilationUnitTree, a1: P): R;
            visitCompoundAssignment(a0: CompoundAssignmentTree, a1: P): R;
            visitConditionalExpression(a0: ConditionalExpressionTree, a1: P): R;
            visitConstantCaseLabel(a0: ConstantCaseLabelTree, a1: P): R;
            visitContinue(a0: ContinueTree, a1: P): R;
            visitDeconstructionPattern(a0: DeconstructionPatternTree, a1: P): R;
            visitDefaultCaseLabel(a0: DefaultCaseLabelTree, a1: P): R;
            visitDoWhileLoop(a0: DoWhileLoopTree, a1: P): R;
            visitEmptyStatement(a0: EmptyStatementTree, a1: P): R;
            visitEnhancedForLoop(a0: EnhancedForLoopTree, a1: P): R;
            visitErroneous(a0: ErroneousTree, a1: P): R;
            visitExports(a0: ExportsTree, a1: P): R;
            visitExpressionStatement(a0: ExpressionStatementTree, a1: P): R;
            visitForLoop(a0: ForLoopTree, a1: P): R;
            visitIdentifier(a0: IdentifierTree, a1: P): R;
            visitIf(a0: IfTree, a1: P): R;
            visitImport(a0: ImportTree, a1: P): R;
            visitInstanceOf(a0: InstanceOfTree, a1: P): R;
            visitIntersectionType(a0: IntersectionTypeTree, a1: P): R;
            visitLabeledStatement(a0: LabeledStatementTree, a1: P): R;
            visitLambdaExpression(a0: LambdaExpressionTree, a1: P): R;
            visitLiteral(a0: LiteralTree, a1: P): R;
            visitMemberReference(a0: MemberReferenceTree, a1: P): R;
            visitMemberSelect(a0: MemberSelectTree, a1: P): R;
            visitMethod(a0: MethodTree, a1: P): R;
            visitMethodInvocation(a0: MethodInvocationTree, a1: P): R;
            visitModifiers(a0: ModifiersTree, a1: P): R;
            visitModule(a0: ModuleTree, a1: P): R;
            visitNewArray(a0: NewArrayTree, a1: P): R;
            visitNewClass(a0: NewClassTree, a1: P): R;
            visitOpens(a0: OpensTree, a1: P): R;
            visitOther(a0: Tree, a1: P): R;
            visitPackage(a0: PackageTree, a1: P): R;
            visitParameterizedType(a0: ParameterizedTypeTree, a1: P): R;
            visitParenthesized(a0: ParenthesizedTree, a1: P): R;
            visitPatternCaseLabel(a0: PatternCaseLabelTree, a1: P): R;
            visitPrimitiveType(a0: PrimitiveTypeTree, a1: P): R;
            visitProvides(a0: ProvidesTree, a1: P): R;
            visitRequires(a0: RequiresTree, a1: P): R;
            visitReturn(a0: ReturnTree, a1: P): R;
            visitStringTemplate(a0: StringTemplateTree, a1: P): R;
            visitSwitch(a0: SwitchTree, a1: P): R;
            visitSwitchExpression(a0: SwitchExpressionTree, a1: P): R;
            visitSynchronized(a0: SynchronizedTree, a1: P): R;
            visitThrow(a0: ThrowTree, a1: P): R;
            visitTry(a0: TryTree, a1: P): R;
            visitTypeCast(a0: TypeCastTree, a1: P): R;
            visitTypeParameter(a0: TypeParameterTree, a1: P): R;
            visitUnary(a0: UnaryTree, a1: P): R;
            visitUnionType(a0: UnionTypeTree, a1: P): R;
            visitUses(a0: UsesTree, a1: P): R;
            visitVariable(a0: VariableTree, a1: P): R;
            visitWhileLoop(a0: WhileLoopTree, a1: P): R;
            visitWildcard(a0: WildcardTree, a1: P): R;
            visitYield(a0: YieldTree, a1: P): R;
          }
          interface TreeVisitor<R,P> extends CombineTypes<[_TreeVisitor<R,P>, java.lang.Object]> {}
          interface _TryTree$$static extends ClassLike {
          }
          let TryTree: _TryTree$$static;
          interface _TryTree {
            getBlock(): BlockTree;
            getCatches(): java.util.List<CatchTree>;
            getFinallyBlock(): BlockTree;
            getResources(): java.util.List<Tree>;
          }
          interface TryTree extends CombineTypes<[_TryTree, com.sun.source.tree.StatementTree, java.lang.Object]> {}
          interface _TypeCastTree$$static extends ClassLike {
          }
          let TypeCastTree: _TypeCastTree$$static;
          interface _TypeCastTree {
            getExpression(): ExpressionTree;
            getType(): Tree;
          }
          interface TypeCastTree extends CombineTypes<[_TypeCastTree, com.sun.source.tree.ExpressionTree, java.lang.Object]> {}
          interface _TypeParameterTree$$static extends ClassLike {
          }
          let TypeParameterTree: _TypeParameterTree$$static;
          interface _TypeParameterTree {
            getAnnotations(): java.util.List<AnnotationTree>;
            getBounds(): java.util.List<Tree>;
            getName(): javax.lang.model.element.Name;
          }
          interface TypeParameterTree extends CombineTypes<[_TypeParameterTree, java.lang.Object, com.sun.source.tree.Tree]> {}
          interface _UnaryTree$$static extends ClassLike {
          }
          let UnaryTree: _UnaryTree$$static;
          interface _UnaryTree {
            getExpression(): ExpressionTree;
(): ExpressionTree;
          }
          interface UnaryTree extends CombineTypes<[_UnaryTree, com.sun.source.tree.ExpressionTree, java.lang.Object]> {}
          interface _UnionTypeTree$$static extends ClassLike {
          }
          let UnionTypeTree: _UnionTypeTree$$static;
          interface _UnionTypeTree {
            getTypeAlternatives(): java.util.List<Tree>;
(): java.util.List<Tree>;
          }
          interface UnionTypeTree extends CombineTypes<[_UnionTypeTree, java.lang.Object, com.sun.source.tree.Tree]> {}
          interface _UsesTree$$static extends ClassLike {
          }
          let UsesTree: _UsesTree$$static;
          interface _UsesTree {
            getServiceName(): ExpressionTree;
(): ExpressionTree;
          }
          interface UsesTree extends CombineTypes<[_UsesTree, com.sun.source.tree.DirectiveTree, java.lang.Object]> {}
          interface _VariableTree$$static extends ClassLike {
          }
          let VariableTree: _VariableTree$$static;
          interface _VariableTree {
            getInitializer(): ExpressionTree;
            getModifiers(): ModifiersTree;
            getName(): javax.lang.model.element.Name;
            getNameExpression(): ExpressionTree;
            getType(): Tree;
          }
          interface VariableTree extends CombineTypes<[_VariableTree, com.sun.source.tree.StatementTree, java.lang.Object]> {}
          interface _WhileLoopTree$$static extends ClassLike {
          }
          let WhileLoopTree: _WhileLoopTree$$static;
          interface _WhileLoopTree {
            getCondition(): ExpressionTree;
            getStatement(): StatementTree;
          }
          interface WhileLoopTree extends CombineTypes<[_WhileLoopTree, com.sun.source.tree.StatementTree, java.lang.Object]> {}
          interface _WildcardTree$$static extends ClassLike {
          }
          let WildcardTree: _WildcardTree$$static;
          interface _WildcardTree {
            getBound(): Tree;
(): Tree;
          }
          interface WildcardTree extends CombineTypes<[_WildcardTree, java.lang.Object, com.sun.source.tree.Tree]> {}
          interface _YieldTree$$static extends ClassLike {
          }
          let YieldTree: _YieldTree$$static;
          interface _YieldTree {
            getValue(): ExpressionTree;
(): ExpressionTree;
          }
          interface YieldTree extends CombineTypes<[_YieldTree, com.sun.source.tree.StatementTree, java.lang.Object]> {}
        }
        module util {
          interface _DocSourcePositions$$static extends ClassLike {
          }
          let DocSourcePositions: _DocSourcePositions$$static;
          interface _DocSourcePositions {
            getEndPosition(a0: source.tree.CompilationUnitTree, a1: source.doctree.DocCommentTree, a2: source.doctree.DocTree): long;
            getStartPosition(a0: source.tree.CompilationUnitTree, a1: source.doctree.DocCommentTree, a2: source.doctree.DocTree): long;
          }
          interface DocSourcePositions extends CombineTypes<[_DocSourcePositions, com.sun.source.util.SourcePositions, java.lang.Object]> {}
          interface _DocTreeFactory$$static extends ClassLike {
          }
          let DocTreeFactory: _DocTreeFactory$$static;
          interface _DocTreeFactory {
            at(a0: int): DocTreeFactory;
            getFirstSentence(a0: java.util.List<source.doctree.DocTree>): java.util.List<source.doctree.DocTree>;
            newAttributeTree(a0: javax.lang.model.element.Name, a1: source.doctree.AttributeTree$ValueKind, a2: java.util.List<source.doctree.DocTree>): source.doctree.AttributeTree;
            newAuthorTree(a0: java.util.List<source.doctree.DocTree>): source.doctree.AuthorTree;
            newCodeTree(a0: source.doctree.TextTree): source.doctree.LiteralTree;
            newCommentTree(a0: string): source.doctree.CommentTree;
            newDeprecatedTree(a0: java.util.List<source.doctree.DocTree>): source.doctree.DeprecatedTree;
            newDocCommentTree(a0: java.util.List<source.doctree.DocTree>, a1: java.util.List<source.doctree.DocTree>): source.doctree.DocCommentTree;
            newDocCommentTree(a0: java.util.List<source.doctree.DocTree>, a1: java.util.List<source.doctree.DocTree>, a2: java.util.List<source.doctree.DocTree>, a3: java.util.List<source.doctree.DocTree>): source.doctree.DocCommentTree;
            newDocRootTree(): source.doctree.DocRootTree;
            newDocTypeTree(a0: string): source.doctree.DocTypeTree;
            newEndElementTree(a0: javax.lang.model.element.Name): source.doctree.EndElementTree;
            newEntityTree(a0: javax.lang.model.element.Name): source.doctree.EntityTree;
            newErroneousTree(a0: string, a1: javax.tools.Diagnostic<javax.tools.JavaFileObject>): source.doctree.ErroneousTree;
            newEscapeTree(a0: char): source.doctree.EscapeTree;
            newExceptionTree(a0: source.doctree.ReferenceTree, a1: java.util.List<source.doctree.DocTree>): source.doctree.ThrowsTree;
            newHiddenTree(a0: java.util.List<source.doctree.DocTree>): source.doctree.HiddenTree;
            newIdentifierTree(a0: javax.lang.model.element.Name): source.doctree.IdentifierTree;
            newIndexTree(a0: source.doctree.DocTree, a1: java.util.List<source.doctree.DocTree>): source.doctree.IndexTree;
            newInheritDocTree(): source.doctree.InheritDocTree;
            newLinkPlainTree(a0: source.doctree.ReferenceTree, a1: java.util.List<source.doctree.DocTree>): source.doctree.LinkTree;
            newLinkTree(a0: source.doctree.ReferenceTree, a1: java.util.List<source.doctree.DocTree>): source.doctree.LinkTree;
            newLiteralTree(a0: source.doctree.TextTree): source.doctree.LiteralTree;
            newParamTree(a0: boolean, a1: source.doctree.IdentifierTree, a2: java.util.List<source.doctree.DocTree>): source.doctree.ParamTree;
            newProvidesTree(a0: source.doctree.ReferenceTree, a1: java.util.List<source.doctree.DocTree>): source.doctree.ProvidesTree;
            newReferenceTree(a0: string): source.doctree.ReferenceTree;
            newReturnTree(a0: java.util.List<source.doctree.DocTree>): source.doctree.ReturnTree;
            newReturnTree(isInline: boolean, description: java.util.List<source.doctree.DocTree>): source.doctree.ReturnTree;
            newSeeTree(a0: java.util.List<source.doctree.DocTree>): source.doctree.SeeTree;
            newSerialDataTree(a0: java.util.List<source.doctree.DocTree>): source.doctree.SerialDataTree;
            newSerialFieldTree(a0: source.doctree.IdentifierTree, a1: source.doctree.ReferenceTree, a2: java.util.List<source.doctree.DocTree>): source.doctree.SerialFieldTree;
            newSerialTree(a0: java.util.List<source.doctree.DocTree>): source.doctree.SerialTree;
            newSinceTree(a0: java.util.List<source.doctree.DocTree>): source.doctree.SinceTree;
            newSnippetTree(a0: java.util.List<source.doctree.DocTree>, a1: source.doctree.TextTree): source.doctree.SnippetTree;
            newSpecTree(a0: source.doctree.TextTree, a1: java.util.List<source.doctree.DocTree>): source.doctree.SpecTree;
            newStartElementTree(a0: javax.lang.model.element.Name, a1: java.util.List<source.doctree.DocTree>, a2: boolean): source.doctree.StartElementTree;
            newSummaryTree(summary: java.util.List<source.doctree.DocTree>): source.doctree.SummaryTree;
            newSystemPropertyTree(a0: javax.lang.model.element.Name): source.doctree.SystemPropertyTree;
            newTextTree(a0: string): source.doctree.TextTree;
            newThrowsTree(a0: source.doctree.ReferenceTree, a1: java.util.List<source.doctree.DocTree>): source.doctree.ThrowsTree;
            newUnknownBlockTagTree(a0: javax.lang.model.element.Name, a1: java.util.List<source.doctree.DocTree>): source.doctree.UnknownBlockTagTree;
            newUnknownInlineTagTree(a0: javax.lang.model.element.Name, a1: java.util.List<source.doctree.DocTree>): source.doctree.UnknownInlineTagTree;
            newUsesTree(a0: source.doctree.ReferenceTree, a1: java.util.List<source.doctree.DocTree>): source.doctree.UsesTree;
            newValueTree(a0: source.doctree.ReferenceTree): source.doctree.ValueTree;
            newValueTree(format: source.doctree.TextTree, ref: source.doctree.ReferenceTree): source.doctree.ValueTree;
            newVersionTree(a0: java.util.List<source.doctree.DocTree>): source.doctree.VersionTree;
          }
          interface DocTreeFactory extends CombineTypes<[_DocTreeFactory, java.lang.Object]> {}
          interface _DocTreePath$$static extends ClassLike {
            getPath(treePath: TreePath, doc: source.doctree.DocCommentTree, target: source.doctree.DocTree): DocTreePath;
            getPath(path: DocTreePath, target: source.doctree.DocTree): DocTreePath;
            new(treePath: TreePath, t: source.doctree.DocCommentTree): DocTreePath;
            new(p: DocTreePath, t: source.doctree.DocTree): DocTreePath;
          }
          let DocTreePath: _DocTreePath$$static;
          interface _DocTreePath {
            getDocComment(): source.doctree.DocCommentTree;
            getLeaf(): source.doctree.DocTree;
            getParentPath(): DocTreePath;
            getTreePath(): TreePath;
            iterator(): java.util.Iterator<source.doctree.DocTree>;
            _docComment: source.doctree.DocCommentTree;
            _leaf: source.doctree.DocTree;
            _parent: DocTreePath;
            _treePath: TreePath;
          }
          interface DocTreePath extends CombineTypes<[_DocTreePath, java.lang.Iterable<source.doctree.DocTree>, java.lang.Object]> {}
          interface _DocTreePathScanner$$static<R,P> extends ClassLike {
            new(): DocTreePathScanner<R,P>;
          }
          let DocTreePathScanner: _DocTreePathScanner$$static<R,P>;
          interface _DocTreePathScanner<R,P> {
            getCurrentPath(): DocTreePath;
            scan(path: DocTreePath, p: P): R;
            scan(tree: source.doctree.DocTree, p: P): R;
            _path: DocTreePath;
          }
          interface DocTreePathScanner<R,P> extends CombineTypes<[_DocTreePathScanner<R,P>, DocTreeScanner<R,P>]> {}
          interface _DocTreeScanner$$static<R,P> extends ClassLike {
            new(): DocTreeScanner<R,P>;
          }
          let DocTreeScanner: _DocTreeScanner$$static<R,P>;
          interface _DocTreeScanner<R,P> {
            reduce(r1: R, r2: R): R;
            scan(node: source.doctree.DocTree, p: P): R;
            scan(nodes: java.lang.Iterable<source.doctree.DocTree>, p: P): R;
            _scanAndReduce(node: source.doctree.DocTree, p: P, r: R): R;
            _scanAndReduce(nodes: java.lang.Iterable<source.doctree.DocTree>, p: P, r: R): R;
            visitAttribute(node: source.doctree.AttributeTree, p: P): R;
            visitAuthor(node: source.doctree.AuthorTree, p: P): R;
            visitComment(node: source.doctree.CommentTree, p: P): R;
            visitDeprecated(node: source.doctree.DeprecatedTree, p: P): R;
            visitDocComment(node: source.doctree.DocCommentTree, p: P): R;
            visitDocRoot(node: source.doctree.DocRootTree, p: P): R;
            visitDocType(node: source.doctree.DocTypeTree, p: P): R;
            visitEndElement(node: source.doctree.EndElementTree, p: P): R;
            visitEntity(node: source.doctree.EntityTree, p: P): R;
            visitErroneous(node: source.doctree.ErroneousTree, p: P): R;
            visitEscape(node: source.doctree.EscapeTree, p: P): R;
            visitHidden(node: source.doctree.HiddenTree, p: P): R;
            visitIdentifier(node: source.doctree.IdentifierTree, p: P): R;
            visitIndex(node: source.doctree.IndexTree, p: P): R;
            visitInheritDoc(node: source.doctree.InheritDocTree, p: P): R;
            visitLink(node: source.doctree.LinkTree, p: P): R;
            visitLiteral(node: source.doctree.LiteralTree, p: P): R;
            visitOther(node: source.doctree.DocTree, p: P): R;
            visitParam(node: source.doctree.ParamTree, p: P): R;
            visitProvides(node: source.doctree.ProvidesTree, p: P): R;
            visitReference(node: source.doctree.ReferenceTree, p: P): R;
            visitReturn(node: source.doctree.ReturnTree, p: P): R;
            visitSee(node: source.doctree.SeeTree, p: P): R;
            visitSerial(node: source.doctree.SerialTree, p: P): R;
            visitSerialData(node: source.doctree.SerialDataTree, p: P): R;
            visitSerialField(node: source.doctree.SerialFieldTree, p: P): R;
            visitSince(node: source.doctree.SinceTree, p: P): R;
            visitSnippet(node: source.doctree.SnippetTree, p: P): R;
            visitSpec(node: source.doctree.SpecTree, p: P): R;
            visitStartElement(node: source.doctree.StartElementTree, p: P): R;
            visitSummary(node: source.doctree.SummaryTree, p: P): R;
            visitSystemProperty(node: source.doctree.SystemPropertyTree, p: P): R;
            visitText(node: source.doctree.TextTree, p: P): R;
            visitThrows(node: source.doctree.ThrowsTree, p: P): R;
            visitUnknownBlockTag(node: source.doctree.UnknownBlockTagTree, p: P): R;
            visitUnknownInlineTag(node: source.doctree.UnknownInlineTagTree, p: P): R;
            visitUses(node: source.doctree.UsesTree, p: P): R;
            visitValue(node: source.doctree.ValueTree, p: P): R;
            visitVersion(node: source.doctree.VersionTree, p: P): R;
          }
          interface DocTreeScanner<R,P> extends CombineTypes<[_DocTreeScanner<R,P>, source.doctree.DocTreeVisitor<R,P>, java.lang.Object]> {}
          interface _DocTrees$$static extends ClassLike {
            instance(task: javax.tools.JavaCompiler$CompilationTask): DocTrees;
            instance(env: javax.annotation.processing.ProcessingEnvironment): DocTrees;
            new(): DocTrees;
          }
          let DocTrees: _DocTrees$$static;
          interface _DocTrees {
            getBreakIterator(): java.text.BreakIterator;
            getCharacters(a0: source.doctree.EntityTree): string;
            getDocCommentTree(a0: TreePath): source.doctree.DocCommentTree;
            getDocCommentTree(a0: javax.lang.model.element.Element): source.doctree.DocCommentTree;
            getDocCommentTree(a0: javax.tools.FileObject): source.doctree.DocCommentTree;
            getDocCommentTree(a0: javax.lang.model.element.Element, a1: string): source.doctree.DocCommentTree;
            getDocTreeFactory(): DocTreeFactory;
            getDocTreePath(a0: javax.tools.FileObject, a1: javax.lang.model.element.PackageElement): DocTreePath;
            getElement(a0: DocTreePath): javax.lang.model.element.Element;
            getFirstSentence(a0: java.util.List<source.doctree.DocTree>): java.util.List<source.doctree.DocTree>;
            getSourcePositions(): DocSourcePositions;
            getSourcePositions(): SourcePositions;
            getType(a0: DocTreePath): javax.lang.model.type.TypeMirror;
            printMessage(a0: javax.tools.Diagnostic$Kind, a1: DocTrees$charSequence, a2: source.doctree.DocTree, a3: source.doctree.DocCommentTree, a4: source.tree.CompilationUnitTree): void;
            setBreakIterator(a0: java.text.BreakIterator): void;
          }
          interface DocTrees extends CombineTypes<[_DocTrees, com.sun.source.util.Trees]> {}
          interface _JavacTask$$static extends ClassLike {
            instance(processingEnvironment: javax.annotation.processing.ProcessingEnvironment): JavacTask;
            _new(): JavacTask;
          }
          let JavacTask: _JavacTask$$static;
          interface _JavacTask {
            addTaskListener(a0: TaskListener): void;
            analyze(): java.lang.Iterable<javax.lang.model.element.Element>;
            generate(): java.lang.Iterable<javax.tools.JavaFileObject>;
            getElements(): javax.lang.model.util.Elements;
            getTypeMirror(a0: java.lang.Iterable<source.tree.Tree>): javax.lang.model.type.TypeMirror;
            getTypes(): javax.lang.model.util.Types;
            parse(): java.lang.Iterable<source.tree.CompilationUnitTree>;
            removeTaskListener(a0: TaskListener): void;
            setParameterNameProvider(provider: ParameterNameProvider): void;
            setTaskListener(a0: TaskListener): void;
          }
          interface JavacTask extends CombineTypes<[_JavacTask, javax.tools.JavaCompiler$CompilationTask, java.lang.Object]> {}
          interface _ParameterNameProvider$$static extends ClassLike {
          }
          let ParameterNameProvider: _ParameterNameProvider$$static;
          interface _ParameterNameProvider {
            getParameterName(a0: javax.lang.model.element.VariableElement): ParameterNameProvider$charSequence;
(a0: javax.lang.model.element.VariableElement): ParameterNameProvider$charSequence;
          }
          interface ParameterNameProvider extends CombineTypes<[_ParameterNameProvider, java.lang.Object]> {}
          interface _Plugin$$static extends ClassLike {
          }
          let Plugin: _Plugin$$static;
          interface _Plugin {
            autoStart(): boolean;
            getName(): string;
            init(a0: JavacTask, a1: string[]): void;
            init(a0: JavacTask, ...a1: string[]): void;
          }
          interface Plugin extends CombineTypes<[_Plugin, java.lang.Object]> {}
          interface _SimpleDocTreeVisitor$$static<R,P> extends ClassLike {
            _new(): SimpleDocTreeVisitor<R,P>;
            _new(defaultValue: R): SimpleDocTreeVisitor<R,P>;
          }
          let SimpleDocTreeVisitor: _SimpleDocTreeVisitor$$static<R,P>;
          interface _SimpleDocTreeVisitor<R,P> {
            _defaultAction(node: source.doctree.DocTree, p: P): R;
            visit(node: source.doctree.DocTree, p: P): R;
            visit(nodes: java.lang.Iterable<source.doctree.DocTree>, p: P): R;
            visitAttribute(node: source.doctree.AttributeTree, p: P): R;
            visitAuthor(node: source.doctree.AuthorTree, p: P): R;
            visitComment(node: source.doctree.CommentTree, p: P): R;
            visitDeprecated(node: source.doctree.DeprecatedTree, p: P): R;
            visitDocComment(node: source.doctree.DocCommentTree, p: P): R;
            visitDocRoot(node: source.doctree.DocRootTree, p: P): R;
            visitDocType(node: source.doctree.DocTypeTree, p: P): R;
            visitEndElement(node: source.doctree.EndElementTree, p: P): R;
            visitEntity(node: source.doctree.EntityTree, p: P): R;
            visitErroneous(node: source.doctree.ErroneousTree, p: P): R;
            visitEscape(node: source.doctree.EscapeTree, p: P): R;
            visitHidden(node: source.doctree.HiddenTree, p: P): R;
            visitIdentifier(node: source.doctree.IdentifierTree, p: P): R;
            visitIndex(node: source.doctree.IndexTree, p: P): R;
            visitInheritDoc(node: source.doctree.InheritDocTree, p: P): R;
            visitLink(node: source.doctree.LinkTree, p: P): R;
            visitLiteral(node: source.doctree.LiteralTree, p: P): R;
            visitOther(node: source.doctree.DocTree, p: P): R;
            visitParam(node: source.doctree.ParamTree, p: P): R;
            visitProvides(node: source.doctree.ProvidesTree, p: P): R;
            visitReference(node: source.doctree.ReferenceTree, p: P): R;
            visitReturn(node: source.doctree.ReturnTree, p: P): R;
            visitSee(node: source.doctree.SeeTree, p: P): R;
            visitSerial(node: source.doctree.SerialTree, p: P): R;
            visitSerialData(node: source.doctree.SerialDataTree, p: P): R;
            visitSerialField(node: source.doctree.SerialFieldTree, p: P): R;
            visitSince(node: source.doctree.SinceTree, p: P): R;
            visitSnippet(node: source.doctree.SnippetTree, p: P): R;
            visitSpec(node: source.doctree.SpecTree, p: P): R;
            visitStartElement(node: source.doctree.StartElementTree, p: P): R;
            visitSummary(node: source.doctree.SummaryTree, p: P): R;
            visitSystemProperty(node: source.doctree.SystemPropertyTree, p: P): R;
            visitText(node: source.doctree.TextTree, p: P): R;
            visitThrows(node: source.doctree.ThrowsTree, p: P): R;
            visitUnknownBlockTag(node: source.doctree.UnknownBlockTagTree, p: P): R;
            visitUnknownInlineTag(node: source.doctree.UnknownInlineTagTree, p: P): R;
            visitUses(node: source.doctree.UsesTree, p: P): R;
            visitValue(node: source.doctree.ValueTree, p: P): R;
            visitVersion(node: source.doctree.VersionTree, p: P): R;
            _DEFAULT_VALUE: R;
          }
          interface SimpleDocTreeVisitor<R,P> extends CombineTypes<[_SimpleDocTreeVisitor<R,P>, source.doctree.DocTreeVisitor<R,P>, java.lang.Object]> {}
          interface _SimpleTreeVisitor$$static<R,P> extends ClassLike {
            _new(): SimpleTreeVisitor<R,P>;
            _new(defaultValue: R): SimpleTreeVisitor<R,P>;
          }
          let SimpleTreeVisitor: _SimpleTreeVisitor$$static<R,P>;
          interface _SimpleTreeVisitor<R,P> {
            _defaultAction(node: source.tree.Tree, p: P): R;
            visit(node: source.tree.Tree, p: P): R;
            visit(nodes: java.lang.Iterable<source.tree.Tree>, p: P): R;
            visitAnnotatedType(node: source.tree.AnnotatedTypeTree, p: P): R;
            visitAnnotation(node: source.tree.AnnotationTree, p: P): R;
            visitAnyPattern(node: source.tree.AnyPatternTree, p: P): R;
            visitArrayAccess(node: source.tree.ArrayAccessTree, p: P): R;
            visitArrayType(node: source.tree.ArrayTypeTree, p: P): R;
            visitAssert(node: source.tree.AssertTree, p: P): R;
            visitAssignment(node: source.tree.AssignmentTree, p: P): R;
            visitBinary(node: source.tree.BinaryTree, p: P): R;
            visitBindingPattern(node: source.tree.BindingPatternTree, p: P): R;
            visitBlock(node: source.tree.BlockTree, p: P): R;
            visitBreak(node: source.tree.BreakTree, p: P): R;
            visitCase(node: source.tree.CaseTree, p: P): R;
            visitCatch(node: source.tree.CatchTree, p: P): R;
            visitClass(node: source.tree.ClassTree, p: P): R;
            visitCompilationUnit(node: source.tree.CompilationUnitTree, p: P): R;
            visitCompoundAssignment(node: source.tree.CompoundAssignmentTree, p: P): R;
            visitConditionalExpression(node: source.tree.ConditionalExpressionTree, p: P): R;
            visitConstantCaseLabel(node: source.tree.ConstantCaseLabelTree, p: P): R;
            visitContinue(node: source.tree.ContinueTree, p: P): R;
            visitDeconstructionPattern(node: source.tree.DeconstructionPatternTree, p: P): R;
            visitDefaultCaseLabel(node: source.tree.DefaultCaseLabelTree, p: P): R;
            visitDoWhileLoop(node: source.tree.DoWhileLoopTree, p: P): R;
            visitEmptyStatement(node: source.tree.EmptyStatementTree, p: P): R;
            visitEnhancedForLoop(node: source.tree.EnhancedForLoopTree, p: P): R;
            visitErroneous(node: source.tree.ErroneousTree, p: P): R;
            visitExports(node: source.tree.ExportsTree, p: P): R;
            visitExpressionStatement(node: source.tree.ExpressionStatementTree, p: P): R;
            visitForLoop(node: source.tree.ForLoopTree, p: P): R;
            visitIdentifier(node: source.tree.IdentifierTree, p: P): R;
            visitIf(node: source.tree.IfTree, p: P): R;
            visitImport(node: source.tree.ImportTree, p: P): R;
            visitInstanceOf(node: source.tree.InstanceOfTree, p: P): R;
            visitIntersectionType(node: source.tree.IntersectionTypeTree, p: P): R;
            visitLabeledStatement(node: source.tree.LabeledStatementTree, p: P): R;
            visitLambdaExpression(node: source.tree.LambdaExpressionTree, p: P): R;
            visitLiteral(node: source.tree.LiteralTree, p: P): R;
            visitMemberReference(node: source.tree.MemberReferenceTree, p: P): R;
            visitMemberSelect(node: source.tree.MemberSelectTree, p: P): R;
            visitMethod(node: source.tree.MethodTree, p: P): R;
            visitMethodInvocation(node: source.tree.MethodInvocationTree, p: P): R;
            visitModifiers(node: source.tree.ModifiersTree, p: P): R;
            visitModule(node: source.tree.ModuleTree, p: P): R;
            visitNewArray(node: source.tree.NewArrayTree, p: P): R;
            visitNewClass(node: source.tree.NewClassTree, p: P): R;
            visitOpens(node: source.tree.OpensTree, p: P): R;
            visitOther(node: source.tree.Tree, p: P): R;
            visitPackage(node: source.tree.PackageTree, p: P): R;
            visitParameterizedType(node: source.tree.ParameterizedTypeTree, p: P): R;
            visitParenthesized(node: source.tree.ParenthesizedTree, p: P): R;
            visitPatternCaseLabel(node: source.tree.PatternCaseLabelTree, p: P): R;
            visitPrimitiveType(node: source.tree.PrimitiveTypeTree, p: P): R;
            visitProvides(node: source.tree.ProvidesTree, p: P): R;
            visitRequires(node: source.tree.RequiresTree, p: P): R;
            visitReturn(node: source.tree.ReturnTree, p: P): R;
            visitStringTemplate(node: source.tree.StringTemplateTree, p: P): R;
            visitSwitch(node: source.tree.SwitchTree, p: P): R;
            visitSwitchExpression(node: source.tree.SwitchExpressionTree, p: P): R;
            visitSynchronized(node: source.tree.SynchronizedTree, p: P): R;
            visitThrow(node: source.tree.ThrowTree, p: P): R;
            visitTry(node: source.tree.TryTree, p: P): R;
            visitTypeCast(node: source.tree.TypeCastTree, p: P): R;
            visitTypeParameter(node: source.tree.TypeParameterTree, p: P): R;
            visitUnary(node: source.tree.UnaryTree, p: P): R;
            visitUnionType(node: source.tree.UnionTypeTree, p: P): R;
            visitUses(node: source.tree.UsesTree, p: P): R;
            visitVariable(node: source.tree.VariableTree, p: P): R;
            visitWhileLoop(node: source.tree.WhileLoopTree, p: P): R;
            visitWildcard(node: source.tree.WildcardTree, p: P): R;
            visitYield(node: source.tree.YieldTree, p: P): R;
            _DEFAULT_VALUE: R;
          }
          interface SimpleTreeVisitor<R,P> extends CombineTypes<[_SimpleTreeVisitor<R,P>, source.tree.TreeVisitor<R,P>, java.lang.Object]> {}
          interface _SourcePositions$$static extends ClassLike {
          }
          let SourcePositions: _SourcePositions$$static;
          interface _SourcePositions {
            getEndPosition(a0: source.tree.CompilationUnitTree, a1: source.tree.Tree): long;
            getStartPosition(a0: source.tree.CompilationUnitTree, a1: source.tree.Tree): long;
          }
          interface SourcePositions extends CombineTypes<[_SourcePositions, java.lang.Object]> {}
          interface _TaskEvent$$static extends ClassLike {
            new(kind: TaskEvent$Kind): TaskEvent;
            new(kind: TaskEvent$Kind, sourceFile: javax.tools.JavaFileObject): TaskEvent;
            new(kind: TaskEvent$Kind, unit: source.tree.CompilationUnitTree): TaskEvent;
            new(kind: TaskEvent$Kind, unit: source.tree.CompilationUnitTree, clazz: javax.lang.model.element.TypeElement): TaskEvent;
          }
          let TaskEvent: _TaskEvent$$static;
          interface _TaskEvent {
            getCompilationUnit(): source.tree.CompilationUnitTree;
            getKind(): TaskEvent$Kind;
            getSourceFile(): javax.tools.JavaFileObject;
            getTypeElement(): javax.lang.model.element.TypeElement;
            toString(): string;
            _clazz: javax.lang.model.element.TypeElement;
            _file: javax.tools.JavaFileObject;
            _kind: TaskEvent$Kind;
            _unit: source.tree.CompilationUnitTree;
          }
          interface TaskEvent extends CombineTypes<[_TaskEvent, java.lang.Object]> {}
          interface _TaskEvent$Kind$$static extends ClassLike {
            valueOf(name: string): TaskEvent$Kind;
            values(): TaskEvent$Kind[];
            readonly ANALYZE: TaskEvent$Kind;
            readonly ANNOTATION_PROCESSING: TaskEvent$Kind;
            readonly ANNOTATION_PROCESSING_ROUND: TaskEvent$Kind;
            readonly COMPILATION: TaskEvent$Kind;
            readonly ENTER: TaskEvent$Kind;
            readonly GENERATE: TaskEvent$Kind;
            readonly PARSE: TaskEvent$Kind;
          }
          let TaskEvent$Kind: _TaskEvent$Kind$$static;
          interface _TaskEvent$Kind {
          }
          interface TaskEvent$Kind extends CombineTypes<[_TaskEvent$Kind]> {}
          interface _TaskListener$$static extends ClassLike {
          }
          let TaskListener: _TaskListener$$static;
          interface _TaskListener {
            finished(e: TaskEvent): void;
            started(e: TaskEvent): void;
          }
          interface TaskListener extends CombineTypes<[_TaskListener, java.lang.Object]> {}
          interface _TreePath$$static extends ClassLike {
            getPath(unit: source.tree.CompilationUnitTree, target: source.tree.Tree): TreePath;
            getPath(path: TreePath, target: source.tree.Tree): TreePath;
            new(node: source.tree.CompilationUnitTree): TreePath;
            new(path: TreePath, tree: source.tree.Tree): TreePath;
          }
          let TreePath: _TreePath$$static;
          interface _TreePath {
            getCompilationUnit(): source.tree.CompilationUnitTree;
            getLeaf(): source.tree.Tree;
            getParentPath(): TreePath;
            iterator(): java.util.Iterator<source.tree.Tree>;
            _compilationUnit: source.tree.CompilationUnitTree;
            _leaf: source.tree.Tree;
            _parent: TreePath;
          }
          interface TreePath extends CombineTypes<[_TreePath, java.lang.Iterable<source.tree.Tree>, java.lang.Object]> {}
          interface _TreePathScanner$$static<R,P> extends ClassLike {
            new(): TreePathScanner<R,P>;
          }
          let TreePathScanner: _TreePathScanner$$static<R,P>;
          interface _TreePathScanner<R,P> {
            getCurrentPath(): TreePath;
            scan(path: TreePath, p: P): R;
            scan(tree: source.tree.Tree, p: P): R;
            _path: TreePath;
          }
          interface TreePathScanner<R,P> extends CombineTypes<[_TreePathScanner<R,P>, TreeScanner<R,P>]> {}
          interface _TreeScanner$$static<R,P> extends ClassLike {
            new(): TreeScanner<R,P>;
          }
          let TreeScanner: _TreeScanner$$static<R,P>;
          interface _TreeScanner<R,P> {
            reduce(r1: R, r2: R): R;
            scan(tree: source.tree.Tree, p: P): R;
            scan(nodes: java.lang.Iterable<source.tree.Tree>, p: P): R;
            _scanAndReduce(node: source.tree.Tree, p: P, r: R): R;
            _scanAndReduce(nodes: java.lang.Iterable<source.tree.Tree>, p: P, r: R): R;
            visitAnnotatedType(node: source.tree.AnnotatedTypeTree, p: P): R;
            visitAnnotation(node: source.tree.AnnotationTree, p: P): R;
            visitAnyPattern(node: source.tree.AnyPatternTree, p: P): R;
            visitArrayAccess(node: source.tree.ArrayAccessTree, p: P): R;
            visitArrayType(node: source.tree.ArrayTypeTree, p: P): R;
            visitAssert(node: source.tree.AssertTree, p: P): R;
            visitAssignment(node: source.tree.AssignmentTree, p: P): R;
            visitBinary(node: source.tree.BinaryTree, p: P): R;
            visitBindingPattern(node: source.tree.BindingPatternTree, p: P): R;
            visitBlock(node: source.tree.BlockTree, p: P): R;
            visitBreak(node: source.tree.BreakTree, p: P): R;
            visitCase(node: source.tree.CaseTree, p: P): R;
            visitCatch(node: source.tree.CatchTree, p: P): R;
            visitClass(node: source.tree.ClassTree, p: P): R;
            visitCompilationUnit(node: source.tree.CompilationUnitTree, p: P): R;
            visitCompoundAssignment(node: source.tree.CompoundAssignmentTree, p: P): R;
            visitConditionalExpression(node: source.tree.ConditionalExpressionTree, p: P): R;
            visitConstantCaseLabel(node: source.tree.ConstantCaseLabelTree, p: P): R;
            visitContinue(node: source.tree.ContinueTree, p: P): R;
            visitDeconstructionPattern(node: source.tree.DeconstructionPatternTree, p: P): R;
            visitDefaultCaseLabel(node: source.tree.DefaultCaseLabelTree, p: P): R;
            visitDoWhileLoop(node: source.tree.DoWhileLoopTree, p: P): R;
            visitEmptyStatement(node: source.tree.EmptyStatementTree, p: P): R;
            visitEnhancedForLoop(node: source.tree.EnhancedForLoopTree, p: P): R;
            visitErroneous(node: source.tree.ErroneousTree, p: P): R;
            visitExports(node: source.tree.ExportsTree, p: P): R;
            visitExpressionStatement(node: source.tree.ExpressionStatementTree, p: P): R;
            visitForLoop(node: source.tree.ForLoopTree, p: P): R;
            visitIdentifier(node: source.tree.IdentifierTree, p: P): R;
            visitIf(node: source.tree.IfTree, p: P): R;
            visitImport(node: source.tree.ImportTree, p: P): R;
            visitInstanceOf(node: source.tree.InstanceOfTree, p: P): R;
            visitIntersectionType(node: source.tree.IntersectionTypeTree, p: P): R;
            visitLabeledStatement(node: source.tree.LabeledStatementTree, p: P): R;
            visitLambdaExpression(node: source.tree.LambdaExpressionTree, p: P): R;
            visitLiteral(node: source.tree.LiteralTree, p: P): R;
            visitMemberReference(node: source.tree.MemberReferenceTree, p: P): R;
            visitMemberSelect(node: source.tree.MemberSelectTree, p: P): R;
            visitMethod(node: source.tree.MethodTree, p: P): R;
            visitMethodInvocation(node: source.tree.MethodInvocationTree, p: P): R;
            visitModifiers(node: source.tree.ModifiersTree, p: P): R;
            visitModule(node: source.tree.ModuleTree, p: P): R;
            visitNewArray(node: source.tree.NewArrayTree, p: P): R;
            visitNewClass(node: source.tree.NewClassTree, p: P): R;
            visitOpens(node: source.tree.OpensTree, p: P): R;
            visitOther(node: source.tree.Tree, p: P): R;
            visitPackage(node: source.tree.PackageTree, p: P): R;
            visitParameterizedType(node: source.tree.ParameterizedTypeTree, p: P): R;
            visitParenthesized(node: source.tree.ParenthesizedTree, p: P): R;
            visitPatternCaseLabel(node: source.tree.PatternCaseLabelTree, p: P): R;
            visitPrimitiveType(node: source.tree.PrimitiveTypeTree, p: P): R;
            visitProvides(node: source.tree.ProvidesTree, p: P): R;
            visitRequires(node: source.tree.RequiresTree, p: P): R;
            visitReturn(node: source.tree.ReturnTree, p: P): R;
            visitStringTemplate(node: source.tree.StringTemplateTree, p: P): R;
            visitSwitch(node: source.tree.SwitchTree, p: P): R;
            visitSwitchExpression(node: source.tree.SwitchExpressionTree, p: P): R;
            visitSynchronized(node: source.tree.SynchronizedTree, p: P): R;
            visitThrow(node: source.tree.ThrowTree, p: P): R;
            visitTry(node: source.tree.TryTree, p: P): R;
            visitTypeCast(node: source.tree.TypeCastTree, p: P): R;
            visitTypeParameter(node: source.tree.TypeParameterTree, p: P): R;
            visitUnary(node: source.tree.UnaryTree, p: P): R;
            visitUnionType(node: source.tree.UnionTypeTree, p: P): R;
            visitUses(node: source.tree.UsesTree, p: P): R;
            visitVariable(node: source.tree.VariableTree, p: P): R;
            visitWhileLoop(node: source.tree.WhileLoopTree, p: P): R;
            visitWildcard(node: source.tree.WildcardTree, p: P): R;
            visitYield(node: source.tree.YieldTree, p: P): R;
          }
          interface TreeScanner<R,P> extends CombineTypes<[_TreeScanner<R,P>, source.tree.TreeVisitor<R,P>, java.lang.Object]> {}
          interface _Trees$$static extends ClassLike {
            _getJavacTrees(argType: java.lang.Class<any>, arg: any): Trees;
            instance(task: javax.tools.JavaCompiler$CompilationTask): Trees;
            instance(env: javax.annotation.processing.ProcessingEnvironment): Trees;
            new(): Trees;
          }
          let Trees: _Trees$$static;
          interface _Trees {
            getDocComment(a0: TreePath): string;
            getElement(a0: TreePath): javax.lang.model.element.Element;
            getLub(a0: source.tree.CatchTree): javax.lang.model.type.TypeMirror;
            getOriginalType(a0: javax.lang.model.type.ErrorType): javax.lang.model.type.TypeMirror;
            getPath(a0: source.tree.CompilationUnitTree, a1: source.tree.Tree): TreePath;
            getPath(a0: javax.lang.model.element.Element): TreePath;
            getPath(a0: javax.lang.model.element.Element, a1: javax.lang.model.element.AnnotationMirror): TreePath;
            getPath(a0: javax.lang.model.element.Element, a1: javax.lang.model.element.AnnotationMirror, a2: javax.lang.model.element.AnnotationValue): TreePath;
            getScope(a0: TreePath): source.tree.Scope;
            getSourcePositions(): SourcePositions;
            getTree(a0: javax.lang.model.element.Element): source.tree.Tree;
            getTree(a0: javax.lang.model.element.TypeElement): source.tree.ClassTree;
            getTree(a0: javax.lang.model.element.ExecutableElement): source.tree.MethodTree;
            getTree(a0: javax.lang.model.element.Element, a1: javax.lang.model.element.AnnotationMirror): source.tree.Tree;
            getTree(a0: javax.lang.model.element.Element, a1: javax.lang.model.element.AnnotationMirror, a2: javax.lang.model.element.AnnotationValue): source.tree.Tree;
            getTypeMirror(a0: TreePath): javax.lang.model.type.TypeMirror;
            isAccessible(a0: source.tree.Scope, a1: javax.lang.model.element.TypeElement): boolean;
            isAccessible(a0: source.tree.Scope, a1: javax.lang.model.element.Element, a2: javax.lang.model.type.DeclaredType): boolean;
            printMessage(a0: javax.tools.Diagnostic$Kind, a1: Trees$charSequence, a2: source.tree.Tree, a3: source.tree.CompilationUnitTree): void;
          }
          interface Trees extends CombineTypes<[_Trees, java.lang.Object]> {}
        }
      }
      module tools {
        module doclint {
          interface _DocLint$$static extends ClassLike {
            newDocLint(): DocLint;
            readonly XCHECK_PACKAGE: string;
            readonly XMSGS_CUSTOM_PREFIX: string;
            readonly XMSGS_OPTION: string;
            _docLintProvider: java.util.ServiceLoader$Provider<DocLint>;
            new(): DocLint;
          }
          let DocLint: _DocLint$$static;
          interface _DocLint {
            isValidOption(a0: string): boolean;
(a0: string): boolean;
          }
          interface DocLint extends CombineTypes<[_DocLint, com.sun.source.util.Plugin, java.lang.Object]> {}
          interface _DocLint$NoDocLint$$static extends ClassLike {
          }
          let DocLint$NoDocLint: _DocLint$NoDocLint$$static;
          interface _DocLint$NoDocLint {
            getName(): string;
            init(task: sun.source.util.JavacTask, args: string[]): void;
            init(task: sun.source.util.JavacTask, ...args: string[]): void;
            isValidOption(s: string): boolean;
          }
          interface DocLint$NoDocLint extends CombineTypes<[_DocLint$NoDocLint, com.sun.tools.doclint.DocLint]> {}
        }
        module javac {
          module api {
            interface _BasicJavacTask$$static extends ClassLike {
              instance(context: javac.util.Context): sun.source.util.JavacTask;
              new(c: javac.util.Context, register: boolean): BasicJavacTask;
            }
            let BasicJavacTask: _BasicJavacTask$$static;
            interface _BasicJavacTask {
              addModules(moduleNames: java.lang.Iterable<string>): void;
              addTaskListener(taskListener: sun.source.util.TaskListener): void;
              analyze(): java.lang.Iterable<javax.lang.model.element.Element>;
              call(): boolean;
              call(): any;
              generate(): java.lang.Iterable<javax.tools.JavaFileObject>;
              getContext(): javac.util.Context;
              getElements(): javax.lang.model.util.Elements;
              getTaskListeners(): java.util.Collection<sun.source.util.TaskListener>;
              getTypeMirror(path: java.lang.Iterable<sun.source.tree.Tree>): javax.lang.model.type.TypeMirror;
              getTypes(): javax.lang.model.util.Types;
              initDocLint(docLintOpts: javac.util.List<string>): void;
              _initPlugin(p: sun.source.util.Plugin, args: string[]): void;
              _initPlugin(p: sun.source.util.Plugin, ...args: string[]): void;
              initPlugins(pluginOpts: java.util.Set<javac.util.List<string>>): void;
              parse(): java.lang.Iterable<sun.source.tree.CompilationUnitTree>;
              removeTaskListener(taskListener: sun.source.util.TaskListener): void;
              setLocale(locale: java.util.Locale): void;
              setParameterNameProvider(handler: sun.source.util.ParameterNameProvider): void;
              setProcessors(processors: java.lang.Iterable<javax.annotation.processing.Processor>): void;
              setTaskListener(tl: sun.source.util.TaskListener): void;
              _context: javac.util.Context;
              _options: javac.util.Options;
              _taskListener: sun.source.util.TaskListener;
            }
            interface BasicJavacTask extends CombineTypes<[_BasicJavacTask, com.sun.source.util.JavacTask]> {}
            interface _ClientCodeWrapper$$static extends ClassLike {
              instance(context: javac.util.Context): ClientCodeWrapper;
              _new(context: javac.util.Context): ClientCodeWrapper;
            }
            let ClientCodeWrapper: _ClientCodeWrapper$$static;
            interface _ClientCodeWrapper {
              _isTrusted(o: any): boolean;
              _unwrap(fo: javax.tools.FileObject): javax.tools.FileObject;
              _unwrap(fo: javax.tools.JavaFileObject): javax.tools.JavaFileObject;
              _unwrap(l: sun.source.util.TaskListener): sun.source.util.TaskListener;
              _unwrap(listeners: java.util.Collection<sun.source.util.TaskListener>): java.util.Collection<sun.source.util.TaskListener>;
              _unwrap<T>(diagnostic: javax.tools.Diagnostic<T>): javax.tools.Diagnostic<T>;
              wrap(fm: javax.tools.JavaFileManager): javax.tools.JavaFileManager;
              wrap(fo: javax.tools.FileObject): javax.tools.FileObject;
              wrap(fo: javax.tools.JavaFileObject): javax.tools.JavaFileObject;
              wrap<T>(dl: javax.tools.DiagnosticListener<T>): javax.tools.DiagnosticListener<T>;
              _wrap(tl: sun.source.util.TaskListener): sun.source.util.TaskListener;
              wrapJavaFileObjects(list: java.lang.Iterable<javax.tools.JavaFileObject>): java.lang.Iterable<javax.tools.JavaFileObject>;
              _wrappedToString(wrapperClass: java.lang.Class<any>, wrapped: any): string;
              _trustedClasses: java.util.Map<java.lang.Class<any>,boolean>;
            }
            interface ClientCodeWrapper extends CombineTypes<[_ClientCodeWrapper, java.lang.Object]> {}
            interface _ClientCodeWrapper$DiagnosticSourceUnwrapper$$static extends ClassLike {
              _new(this$0: ClientCodeWrapper, d: javac.util.JCDiagnostic): ClientCodeWrapper$DiagnosticSourceUnwrapper;
            }
            let ClientCodeWrapper$DiagnosticSourceUnwrapper: _ClientCodeWrapper$DiagnosticSourceUnwrapper$$static;
            interface _ClientCodeWrapper$DiagnosticSourceUnwrapper {
              getCode(): string;
              getColumnNumber(): long;
              getEndPosition(): long;
              getKind(): javax.tools.Diagnostic$Kind;
              getLineNumber(): long;
              getMessage(locale: java.util.Locale): string;
              getPosition(): long;
              getSource(): javax.tools.JavaFileObject;
              getSource(): any;
              getStartPosition(): long;
              toString(): string;
              readonly d: javac.util.JCDiagnostic;
              _this$0: ClientCodeWrapper;
            }
            interface ClientCodeWrapper$DiagnosticSourceUnwrapper extends CombineTypes<[_ClientCodeWrapper$DiagnosticSourceUnwrapper, javax.tools.Diagnostic<javax.tools.JavaFileObject>, java.lang.Object]> {}
            interface _ClientCodeWrapper$Trusted$$static extends ClassLike {
            }
            let ClientCodeWrapper$Trusted: _ClientCodeWrapper$Trusted$$static;
            interface _ClientCodeWrapper$Trusted {
            }
            interface ClientCodeWrapper$Trusted extends CombineTypes<[_ClientCodeWrapper$Trusted, java.lang.annotation.Annotation, java.lang.Object]> {}
            interface _ClientCodeWrapper$WrappedDiagnosticListener$$static<T> extends ClassLike {
              _new(this$0: javax.tools.DiagnosticListener<T>): ClientCodeWrapper$WrappedDiagnosticListener<T>;
            }
            let ClientCodeWrapper$WrappedDiagnosticListener: _ClientCodeWrapper$WrappedDiagnosticListener$$static<T>;
            interface _ClientCodeWrapper$WrappedDiagnosticListener<T> {
              report(diagnostic: javax.tools.Diagnostic<T>): void;
              toString(): string;
              _clientDiagnosticListener: javax.tools.DiagnosticListener<T>;
              _this$0: ClientCodeWrapper;
            }
            interface ClientCodeWrapper$WrappedDiagnosticListener<T> extends CombineTypes<[_ClientCodeWrapper$WrappedDiagnosticListener<T>, javax.tools.DiagnosticListener<T>, java.lang.Object]> {}
            interface _ClientCodeWrapper$WrappedFileObject$$static extends ClassLike {
              _new(this$0: ClientCodeWrapper, clientFileObject: javax.tools.FileObject): ClientCodeWrapper$WrappedFileObject;
            }
            let ClientCodeWrapper$WrappedFileObject: _ClientCodeWrapper$WrappedFileObject$$static;
            interface _ClientCodeWrapper$WrappedFileObject {
              delete(): boolean;
              getCharContent(ignoreEncodingErrors: boolean): ClientCodeWrapper$WrappedFileObject$charSequence;
              getLastModified(): long;
              getName(): string;
              openInputStream(): java.io.InputStream;
              openOutputStream(): java.io.OutputStream;
              openReader(ignoreEncodingErrors: boolean): java.io.Reader;
              openWriter(): java.io.Writer;
              toString(): string;
              toUri(): java.net.URI;
              _clientFileObject: javax.tools.FileObject;
              _this$0: ClientCodeWrapper;
            }
            interface ClientCodeWrapper$WrappedFileObject extends CombineTypes<[_ClientCodeWrapper$WrappedFileObject, javax.tools.FileObject, java.lang.Object]> {}
            interface _ClientCodeWrapper$WrappedJavaFileManager$$static extends ClassLike {
              _new(this$0: ClientCodeWrapper, clientJavaFileManager: javax.tools.JavaFileManager): ClientCodeWrapper$WrappedJavaFileManager;
            }
            let ClientCodeWrapper$WrappedJavaFileManager: _ClientCodeWrapper$WrappedJavaFileManager$$static;
            interface _ClientCodeWrapper$WrappedJavaFileManager {
              close(): void;
              contains(location: javax.tools.JavaFileManager$Location, file: javax.tools.FileObject): boolean;
              flush(): void;
              getClassLoader(location: javax.tools.JavaFileManager$Location): java.lang.ClassLoader;
              getFileForInput(location: javax.tools.JavaFileManager$Location, packageName: string, relativeName: string): javax.tools.FileObject;
              getFileForOutput(location: javax.tools.JavaFileManager$Location, packageName: string, relativeName: string, sibling: javax.tools.FileObject): javax.tools.FileObject;
              getFileForOutputForOriginatingFiles(location: javax.tools.JavaFileManager$Location, packageName: string, relativeName: string, originatingFiles: javax.tools.FileObject[]): javax.tools.FileObject;
              getFileForOutputForOriginatingFiles(location: javax.tools.JavaFileManager$Location, packageName: string, relativeName: string, ...originatingFiles: javax.tools.FileObject[]): javax.tools.FileObject;
              getJavaFileForInput(location: javax.tools.JavaFileManager$Location, className: string, kind: javax.tools.JavaFileObject$Kind): javax.tools.JavaFileObject;
              getJavaFileForOutput(location: javax.tools.JavaFileManager$Location, className: string, kind: javax.tools.JavaFileObject$Kind, sibling: javax.tools.FileObject): javax.tools.JavaFileObject;
              getJavaFileForOutputForOriginatingFiles(location: javax.tools.JavaFileManager$Location, className: string, kind: javax.tools.JavaFileObject$Kind, originatingFiles: javax.tools.FileObject[]): javax.tools.JavaFileObject;
              getJavaFileForOutputForOriginatingFiles(location: javax.tools.JavaFileManager$Location, className: string, kind: javax.tools.JavaFileObject$Kind, ...originatingFiles: javax.tools.FileObject[]): javax.tools.JavaFileObject;
              getLocationForModule(location: javax.tools.JavaFileManager$Location, moduleName: string): javax.tools.JavaFileManager$Location;
              getLocationForModule(location: javax.tools.JavaFileManager$Location, fo: javax.tools.JavaFileObject): javax.tools.JavaFileManager$Location;
              getServiceLoader<S>(location: javax.tools.JavaFileManager$Location, service: java.lang.Class<S>): java.util.ServiceLoader<S>;
              handleOption(current: string, remaining: java.util.Iterator<string>): boolean;
              hasLocation(location: javax.tools.JavaFileManager$Location): boolean;
              inferBinaryName(location: javax.tools.JavaFileManager$Location, file: javax.tools.JavaFileObject): string;
              inferModuleName(location: javax.tools.JavaFileManager$Location): string;
              isSameFile(a: javax.tools.FileObject, b: javax.tools.FileObject): boolean;
              isSupportedOption(option: string): int;
              list(location: javax.tools.JavaFileManager$Location, packageName: string, kinds: java.util.Set<javax.tools.JavaFileObject$Kind>, recurse: boolean): java.lang.Iterable<javax.tools.JavaFileObject>;
              listLocationsForModules(location: javax.tools.JavaFileManager$Location): java.lang.Iterable<java.util.Set<javax.tools.JavaFileManager$Location>>;
              toString(): string;
              _clientJavaFileManager: javax.tools.JavaFileManager;
              _this$0: ClientCodeWrapper;
            }
            interface ClientCodeWrapper$WrappedJavaFileManager extends CombineTypes<[_ClientCodeWrapper$WrappedJavaFileManager, javax.tools.JavaFileManager, java.lang.Object]> {}
            interface _ClientCodeWrapper$WrappedJavaFileObject$$static extends ClassLike {
              _new(this$0: ClientCodeWrapper, clientJavaFileObject: javax.tools.JavaFileObject): ClientCodeWrapper$WrappedJavaFileObject;
            }
            let ClientCodeWrapper$WrappedJavaFileObject: _ClientCodeWrapper$WrappedJavaFileObject$$static;
            interface _ClientCodeWrapper$WrappedJavaFileObject {
              getAccessLevel(): javax.lang.model.element.Modifier;
              getKind(): javax.tools.JavaFileObject$Kind;
              getNestingKind(): javax.lang.model.element.NestingKind;
              isNameCompatible(simpleName: string, kind: javax.tools.JavaFileObject$Kind): boolean;
              toString(): string;
              _this$0: ClientCodeWrapper;
            }
            interface ClientCodeWrapper$WrappedJavaFileObject extends CombineTypes<[_ClientCodeWrapper$WrappedJavaFileObject, javax.tools.JavaFileObject, com.sun.tools.javac.api.ClientCodeWrapper$WrappedFileObject]> {}
            interface _ClientCodeWrapper$WrappedStandardJavaFileManager$$static extends ClassLike {
              _new(this$0: ClientCodeWrapper, clientJavaFileManager: javax.tools.StandardJavaFileManager): ClientCodeWrapper$WrappedStandardJavaFileManager;
            }
            let ClientCodeWrapper$WrappedStandardJavaFileManager: _ClientCodeWrapper$WrappedStandardJavaFileManager$$static;
            interface _ClientCodeWrapper$WrappedStandardJavaFileManager {
              asPath(file: javax.tools.FileObject): java.nio.file.Path;
              getJavaFileObjects(files: java.io.File[]): java.lang.Iterable<javax.tools.JavaFileObject>;
              getJavaFileObjects(...files: java.io.File[]): java.lang.Iterable<javax.tools.JavaFileObject>;
              getJavaFileObjects(paths: java.nio.file.Path[]): java.lang.Iterable<javax.tools.JavaFileObject>;
              getJavaFileObjects(...paths: java.nio.file.Path[]): java.lang.Iterable<javax.tools.JavaFileObject>;
              getJavaFileObjects(names: string[]): java.lang.Iterable<javax.tools.JavaFileObject>;
              getJavaFileObjects(...names: string[]): java.lang.Iterable<javax.tools.JavaFileObject>;
              getJavaFileObjectsFromFiles(files: java.lang.Iterable<java.io.File>): java.lang.Iterable<javax.tools.JavaFileObject>;
              getJavaFileObjectsFromPaths(paths: java.util.Collection<java.nio.file.Path>): java.lang.Iterable<javax.tools.JavaFileObject>;
              getJavaFileObjectsFromPaths(paths: java.lang.Iterable<java.nio.file.Path>): java.lang.Iterable<javax.tools.JavaFileObject>;
              getJavaFileObjectsFromStrings(names: java.lang.Iterable<string>): java.lang.Iterable<javax.tools.JavaFileObject>;
              getLocation(location: javax.tools.JavaFileManager$Location): java.lang.Iterable<java.io.File>;
              getLocationAsPaths(location: javax.tools.JavaFileManager$Location): java.lang.Iterable<java.nio.file.Path>;
              setLocation(location: javax.tools.JavaFileManager$Location, files: java.lang.Iterable<java.io.File>): void;
              setLocationForModule(location: javax.tools.JavaFileManager$Location, moduleName: string, paths: java.util.Collection<java.nio.file.Path>): void;
              setLocationFromPaths(location: javax.tools.JavaFileManager$Location, paths: java.util.Collection<java.nio.file.Path>): void;
              setPathFactory(f: javax.tools.StandardJavaFileManager$PathFactory): void;
            }
            interface ClientCodeWrapper$WrappedStandardJavaFileManager extends CombineTypes<[_ClientCodeWrapper$WrappedStandardJavaFileManager, javax.tools.StandardJavaFileManager, com.sun.tools.javac.api.ClientCodeWrapper$WrappedJavaFileManager]> {}
            interface _ClientCodeWrapper$WrappedTaskListener$$static extends ClassLike {
              _new(this$0: ClientCodeWrapper, clientTaskListener: sun.source.util.TaskListener): ClientCodeWrapper$WrappedTaskListener;
            }
            let ClientCodeWrapper$WrappedTaskListener: _ClientCodeWrapper$WrappedTaskListener$$static;
            interface _ClientCodeWrapper$WrappedTaskListener {
              finished(ev: sun.source.util.TaskEvent): void;
              started(ev: sun.source.util.TaskEvent): void;
              toString(): string;
              _clientTaskListener: sun.source.util.TaskListener;
              _this$0: ClientCodeWrapper;
            }
            interface ClientCodeWrapper$WrappedTaskListener extends CombineTypes<[_ClientCodeWrapper$WrappedTaskListener, com.sun.source.util.TaskListener, java.lang.Object]> {}
            interface _DiagnosticFormatter$$static<D> extends ClassLike {
            }
            let DiagnosticFormatter: _DiagnosticFormatter$$static<D>;
            interface _DiagnosticFormatter<D> {
              displaySource(a0: D): boolean;
              format(a0: D, a1: java.util.Locale): string;
              formatKind(a0: D, a1: java.util.Locale): string;
              formatMessage(a0: D, a1: java.util.Locale): string;
              formatPosition(a0: D, a1: DiagnosticFormatter$PositionKind, a2: java.util.Locale): string;
              formatSource(a0: D, a1: boolean, a2: java.util.Locale): string;
              getConfiguration(): DiagnosticFormatter$Configuration;
            }
            interface DiagnosticFormatter<D> extends CombineTypes<[_DiagnosticFormatter<D>, java.lang.Object]> {}
            interface _DiagnosticFormatter$Configuration$$static extends ClassLike {
            }
            let DiagnosticFormatter$Configuration: _DiagnosticFormatter$Configuration$$static;
            interface _DiagnosticFormatter$Configuration {
              getMultilineLimit(a0: DiagnosticFormatter$Configuration$MultilineLimit): int;
              getVisible(): java.util.Set<DiagnosticFormatter$Configuration$DiagnosticPart>;
              setMultilineLimit(a0: DiagnosticFormatter$Configuration$MultilineLimit, a1: int): void;
              setVisible(a0: java.util.Set<DiagnosticFormatter$Configuration$DiagnosticPart>): void;
            }
            interface DiagnosticFormatter$Configuration extends CombineTypes<[_DiagnosticFormatter$Configuration, java.lang.Object]> {}
            interface _DiagnosticFormatter$Configuration$DiagnosticPart$$static extends ClassLike {
              valueOf(name: string): DiagnosticFormatter$Configuration$DiagnosticPart;
              values(): DiagnosticFormatter$Configuration$DiagnosticPart[];
              readonly DETAILS: DiagnosticFormatter$Configuration$DiagnosticPart;
              readonly JLS: DiagnosticFormatter$Configuration$DiagnosticPart;
              readonly SOURCE: DiagnosticFormatter$Configuration$DiagnosticPart;
              readonly SUBDIAGNOSTICS: DiagnosticFormatter$Configuration$DiagnosticPart;
              readonly SUMMARY: DiagnosticFormatter$Configuration$DiagnosticPart;
            }
            let DiagnosticFormatter$Configuration$DiagnosticPart: _DiagnosticFormatter$Configuration$DiagnosticPart$$static;
            interface _DiagnosticFormatter$Configuration$DiagnosticPart {
            }
            interface DiagnosticFormatter$Configuration$DiagnosticPart extends CombineTypes<[_DiagnosticFormatter$Configuration$DiagnosticPart]> {}
            interface _DiagnosticFormatter$Configuration$MultilineLimit$$static extends ClassLike {
              valueOf(name: string): DiagnosticFormatter$Configuration$MultilineLimit;
              values(): DiagnosticFormatter$Configuration$MultilineLimit[];
              readonly DEPTH: DiagnosticFormatter$Configuration$MultilineLimit;
              readonly LENGTH: DiagnosticFormatter$Configuration$MultilineLimit;
            }
            let DiagnosticFormatter$Configuration$MultilineLimit: _DiagnosticFormatter$Configuration$MultilineLimit$$static;
            interface _DiagnosticFormatter$Configuration$MultilineLimit {
            }
            interface DiagnosticFormatter$Configuration$MultilineLimit extends CombineTypes<[_DiagnosticFormatter$Configuration$MultilineLimit]> {}
            interface _DiagnosticFormatter$PositionKind$$static extends ClassLike {
              valueOf(name: string): DiagnosticFormatter$PositionKind;
              values(): DiagnosticFormatter$PositionKind[];
              readonly COLUMN: DiagnosticFormatter$PositionKind;
              readonly END: DiagnosticFormatter$PositionKind;
              readonly LINE: DiagnosticFormatter$PositionKind;
              readonly OFFSET: DiagnosticFormatter$PositionKind;
              readonly START: DiagnosticFormatter$PositionKind;
            }
            let DiagnosticFormatter$PositionKind: _DiagnosticFormatter$PositionKind$$static;
            interface _DiagnosticFormatter$PositionKind {
            }
            interface DiagnosticFormatter$PositionKind extends CombineTypes<[_DiagnosticFormatter$PositionKind]> {}
            interface _Entity$$static extends ClassLike {
              _getCharacters(tree: sun.source.doctree.EntityTree): string;
              _put(name: string, c: char): void;
              _put(name: string, c1: char, c2: char): void;
              _entities: java.util.HashMap<string,string>;
              _new(): Entity;
            }
            let Entity: _Entity$$static;
            interface _Entity {
            }
            interface Entity extends CombineTypes<[_Entity, java.lang.Object]> {}
            interface _Formattable$$static extends ClassLike {
            }
            let Formattable: _Formattable$$static;
            interface _Formattable {
              getKind(): string;
              toString(a0: java.util.Locale, a1: Messages): string;
            }
            interface Formattable extends CombineTypes<[_Formattable, java.lang.Object]> {}
            interface _Formattable$LocalizedString$$static extends ClassLike {
              new(key: string): Formattable$LocalizedString;
            }
            let Formattable$LocalizedString: _Formattable$LocalizedString$$static;
            interface _Formattable$LocalizedString {
              getKind(): string;
              toString(l: java.util.Locale, messages: Messages): string;
              toString(): string;
              _key: string;
            }
            interface Formattable$LocalizedString extends CombineTypes<[_Formattable$LocalizedString, java.lang.Object, com.sun.tools.javac.api.Formattable]> {}
            interface _JavacScope$$static extends ClassLike {
              _create(env: javac.comp.Env<javac.comp.AttrContext>): JavacScope;
              _VALIDATOR: java.util.function.Predicate<javac.code.Symbol>;
            }
            let JavacScope: _JavacScope$$static;
            interface _JavacScope {
              equals(other: any): boolean;
              getEnclosingClass(): javax.lang.model.element.TypeElement;
              getEnclosingMethod(): javax.lang.model.element.ExecutableElement;
              getEnclosingScope(): JavacScope;
              getEnclosingScope(): sun.source.tree.Scope;
              getEnv(): javac.comp.Env<javac.comp.AttrContext>;
              getLocalElements(): java.lang.Iterable<javax.lang.model.element.Element>;
              hashCode(): int;
              isStarImportScope(): boolean;
              toString(): string;
              _env: javac.comp.Env<javac.comp.AttrContext>;
            }
            interface JavacScope extends CombineTypes<[_JavacScope, com.sun.source.tree.Scope, java.lang.Object]> {}
            interface _JavacTaskImpl$$static extends ClassLike {
              _new(context: javac.util.Context): JavacTaskImpl;
            }
            let JavacTaskImpl: _JavacTaskImpl$$static;
            interface _JavacTaskImpl {
              addModules(moduleNames: java.lang.Iterable<string>): void;
              analyze(): java.lang.Iterable<javax.lang.model.element.Element>;
              analyze(classes: java.lang.Iterable<javax.lang.model.element.Element>): java.lang.Iterable<javax.lang.model.element.Element>;
              call(): boolean;
              call(): any;
              _cleanup(): void;
              doCall(): javac.main.Main$Result;
              ensureEntered(): void;
              enter(): java.lang.Iterable<javax.lang.model.element.Element>;
              enter(trees: java.lang.Iterable<sun.source.tree.CompilationUnitTree>): java.lang.Iterable<javax.lang.model.element.Element>;
              generate(): java.lang.Iterable<javax.tools.JavaFileObject>;
              generate(classes: java.lang.Iterable<javax.lang.model.element.Element>): java.lang.Iterable<javax.tools.JavaFileObject>;
              _handleFlowResults(queue: java.util.Queue<javac.comp.Env<javac.comp.AttrContext>>, elems: javac.util.ListBuffer<javax.lang.model.element.Element>): void;
              _invocationHelper<T>(c: java.util.concurrent.Callable<T>): javac.util.Pair<T,java.lang.Throwable>;
              parse(): java.lang.Iterable<sun.source.tree.CompilationUnitTree>;
              _parseInternal(): java.lang.Iterable<sun.source.tree.CompilationUnitTree>;
              parseType(expr: string, scope: javax.lang.model.element.TypeElement): javac.code.Type;
              _prepareCompiler(forParse: boolean): void;
              setLocale(locale: java.util.Locale): void;
              setProcessors(processors: java.lang.Iterable<javax.annotation.processing.Processor>): void;
              _toString<T>(items: java.lang.Iterable<T>, sep: string): string;
              _addModules: javac.util.ListBuffer<string>;
              _args: javac.main.Arguments;
              _compiler: javac.main.JavaCompiler;
              _dcfh: javac.code.DeferredCompletionFailureHandler;
              _fileManager: javax.tools.JavaFileManager;
              _genList: javac.util.ListBuffer<javac.comp.Env<javac.comp.AttrContext>>;
              _locale: java.util.Locale;
              _notYetEntered: java.util.Map<javax.tools.JavaFileObject,javac.tree.JCTree$JCCompilationUnit>;
              _parsed: boolean;
              _processors: java.lang.Iterable<javax.annotation.processing.Processor>;
              _used: java.util.concurrent.atomic.AtomicBoolean;
            }
            interface JavacTaskImpl extends CombineTypes<[_JavacTaskImpl, com.sun.tools.javac.api.BasicJavacTask]> {}
            interface _JavacTaskImpl$Filter$$static extends ClassLike {
              _new(this$0: JavacTaskImpl): JavacTaskImpl$Filter;
            }
            let JavacTaskImpl$Filter: _JavacTaskImpl$Filter$$static;
            interface _JavacTaskImpl$Filter {
              _process(a0: javac.comp.Env<javac.comp.AttrContext>): void;
(a0: javac.comp.Env<javac.comp.AttrContext>): void;
              _run(list: java.util.Queue<javac.comp.Env<javac.comp.AttrContext>>, elements: java.lang.Iterable<javax.lang.model.element.Element>): void;
            }
            interface JavacTaskImpl$Filter extends CombineTypes<[_JavacTaskImpl$Filter, java.lang.Object]> {}
            interface _JavacTaskPool$$static extends ClassLike {
              _EMPTY_QUEUE: java.util.Queue<JavacTaskPool$ReusableContext>;
              _systemProvider: JavacTool;
              new(maxPoolSize: int): JavacTaskPool;
            }
            let JavacTaskPool: _JavacTaskPool$$static;
            interface _JavacTaskPool {
              _cacheSize(): long;
              getTask<Z>(out: java.io.Writer, fileManager: javax.tools.JavaFileManager, diagnosticListener: javax.tools.DiagnosticListener<javax.tools.JavaFileObject>, options: java.lang.Iterable<string>, classes: java.lang.Iterable<string>, compilationUnits: java.lang.Iterable<javax.tools.JavaFileObject>, worker: JavacTaskPool$Worker<Z>): Z;
              printStatistics(out: java.io.PrintStream): void;
              _id: int;
              _maxPoolSize: int;
              _options2Contexts: java.util.Map<java.util.List<string>,java.util.Queue<JavacTaskPool$ReusableContext>>;
              _statNew: int;
              _statPolluted: int;
              _statRemoved: int;
              _statReused: int;
            }
            interface JavacTaskPool extends CombineTypes<[_JavacTaskPool, java.lang.Object]> {}
            interface _JavacTaskPool$ReusableContext$$static extends ClassLike {
              _new(arguments: java.util.List<string>): JavacTaskPool$ReusableContext;
            }
            let JavacTaskPool$ReusableContext: _JavacTaskPool$ReusableContext$$static;
            interface _JavacTaskPool$ReusableContext {
              _clear(): void;
              _drop<T>(k: javac.util.Context$Key<T>): void;
              _drop<T>(c: java.lang.Class<T>): void;
              finished(e: sun.source.util.TaskEvent): void;
              started(e: sun.source.util.TaskEvent): void;
              _arguments: java.util.List<string>;
              _polluted: boolean;
              _pollutionScanner: sun.source.util.TreeScanner<java.lang.Void,javac.code.Symtab>;
              _roots: java.util.Set<sun.source.tree.CompilationUnitTree>;
              _timeStamp: long;
              _useCount: int;
            }
            interface JavacTaskPool$ReusableContext extends CombineTypes<[_JavacTaskPool$ReusableContext, com.sun.source.util.TaskListener, com.sun.tools.javac.util.Context]> {}
            interface _JavacTaskPool$ReusableContext$ReusableJavaCompiler$$static extends ClassLike {
              _factory: javac.util.Context$Factory<javac.main.JavaCompiler>;
              _new(context: javac.util.Context): JavacTaskPool$ReusableContext$ReusableJavaCompiler;
            }
            let JavacTaskPool$ReusableContext$ReusableJavaCompiler: _JavacTaskPool$ReusableContext$ReusableJavaCompiler$$static;
            interface _JavacTaskPool$ReusableContext$ReusableJavaCompiler {
              _checkReusable(): void;
              _clear(): void;
              close(): void;
            }
            interface JavacTaskPool$ReusableContext$ReusableJavaCompiler extends CombineTypes<[_JavacTaskPool$ReusableContext$ReusableJavaCompiler, com.sun.tools.javac.main.JavaCompiler]> {}
            interface _JavacTaskPool$ReusableContext$ReusableLog$$static extends ClassLike {
              _factory: javac.util.Context$Factory<javac.util.Log>;
              _new(context: javac.util.Context): JavacTaskPool$ReusableContext$ReusableLog;
            }
            let JavacTaskPool$ReusableContext$ReusableLog: _JavacTaskPool$ReusableContext$ReusableLog$$static;
            interface _JavacTaskPool$ReusableContext$ReusableLog {
              _clear(): void;
              _context: javac.util.Context;
            }
            interface JavacTaskPool$ReusableContext$ReusableLog extends CombineTypes<[_JavacTaskPool$ReusableContext$ReusableLog, com.sun.tools.javac.util.Log]> {}
            interface _JavacTaskPool$Worker$$static<Z> extends ClassLike {
            }
            let JavacTaskPool$Worker: _JavacTaskPool$Worker$$static<Z>;
            interface _JavacTaskPool$Worker<Z> {
              withTask(a0: sun.source.util.JavacTask): Z;
(a0: sun.source.util.JavacTask): Z;
            }
            interface JavacTaskPool$Worker<Z> extends CombineTypes<[_JavacTaskPool$Worker<Z>, java.lang.Object]> {}
            interface _JavacTool$$static extends ClassLike {
              create(): JavacTool;
              new(): JavacTool;
            }
            let JavacTool: _JavacTool$$static;
            interface _JavacTool {
              getSourceVersions(): java.util.Set<javax.lang.model.SourceVersion>;
              getStandardFileManager(diagnosticListener: javax.tools.DiagnosticListener<javax.tools.JavaFileObject>, locale: java.util.Locale, charset: java.nio.charset.Charset): javac.file.JavacFileManager;
              getStandardFileManager(a0: javax.tools.DiagnosticListener, a1: java.util.Locale, a2: java.nio.charset.Charset): javax.tools.StandardJavaFileManager;
              getTask(out: java.io.Writer, fileManager: javax.tools.JavaFileManager, diagnosticListener: javax.tools.DiagnosticListener<javax.tools.JavaFileObject>, options: java.lang.Iterable<string>, classes: java.lang.Iterable<string>, compilationUnits: java.lang.Iterable<javax.tools.JavaFileObject>): sun.source.util.JavacTask;
              getTask(out: java.io.Writer, fileManager: javax.tools.JavaFileManager, diagnosticListener: javax.tools.DiagnosticListener<javax.tools.JavaFileObject>, options: java.lang.Iterable<string>, classes: java.lang.Iterable<string>, compilationUnits: java.lang.Iterable<javax.tools.JavaFileObject>, context: javac.util.Context): sun.source.util.JavacTask;
              getTask(a0: java.io.Writer, a1: javax.tools.JavaFileManager, a2: javax.tools.DiagnosticListener, a3: java.lang.Iterable, a4: java.lang.Iterable, a5: java.lang.Iterable): javax.tools.JavaCompiler$CompilationTask;
              isSupportedOption(option: string): int;
              name(): string;
              run(_in: java.io.InputStream, out: java.io.OutputStream, err: java.io.OutputStream, arguments: string[]): int;
              run(_in: java.io.InputStream, out: java.io.OutputStream, err: java.io.OutputStream, ...arguments: string[]): int;
            }
            interface JavacTool extends CombineTypes<[_JavacTool, javax.tools.JavaCompiler, java.lang.Object]> {}
            interface _JavacTrees$$static extends ClassLike {
              _asJavaFileObject(fileObject: javax.tools.FileObject): javax.tools.JavaFileObject;
              _checkHtmlKind(fileObject: javax.tools.FileObject): void;
              _checkHtmlKind(fileObject: javax.tools.FileObject, kind: javax.tools.JavaFileObject$Kind): void;
              instance(task: javax.tools.JavaCompiler$CompilationTask): JavacTrees;
              instance(env: javax.annotation.processing.ProcessingEnvironment): JavacTrees;
              instance(context: javac.util.Context): JavacTrees;
              _new(context: javac.util.Context): JavacTrees;
            }
            let JavacTrees: _JavacTrees$$static;
            interface _JavacTrees {
              _attribExprToTree(expr: javac.tree.JCTree$JCExpression, env: javac.comp.Env<javac.comp.AttrContext>, tree: javac.tree.JCTree, copiedClasses: java.util.Map<javac.tree.JCTree$JCClassDecl,javac.tree.JCTree$JCClassDecl>): javac.comp.Env<javac.comp.AttrContext>;
              _attribStatToTree(stat: javac.tree.JCTree, env: javac.comp.Env<javac.comp.AttrContext>, tree: javac.tree.JCTree, copiedClasses: java.util.Map<javac.tree.JCTree$JCClassDecl,javac.tree.JCTree$JCClassDecl>): javac.comp.Env<javac.comp.AttrContext>;
              _attributeDocReference(path: sun.source.util.TreePath, ref: javac.tree.DCTree$DCReference): javac.code.Symbol;
              _attributeParamIdentifier(path: sun.source.util.TreePath, paramTag: javac.tree.DCTree$DCParam): javac.code.Symbol;
              _createCopier(maker: javac.tree.TreeMaker): JavacTrees$Copier;
              _findConstructor(tsym: javac.code.Symbol$ClassSymbol, paramTypes: javac.util.List<javac.code.Type>, strict: boolean): javac.code.Symbol$MethodSymbol;
              _findField(tsym: javac.code.Symbol$ClassSymbol, fieldName: javac.util.Name): javac.code.Symbol$VarSymbol;
              _findMethod(tsym: javac.code.Symbol$ClassSymbol, methodName: javac.util.Name, paramTypes: javac.util.List<javac.code.Type>, strict: boolean): javac.code.Symbol$MethodSymbol;
              _fixLocalClassNames(copiedClasses: java.util.Map<javac.tree.JCTree$JCClassDecl,javac.tree.JCTree$JCClassDecl>, lastEnv: javac.comp.Env<javac.comp.AttrContext>): void;
              _getAttrContext(path: sun.source.util.TreePath): javac.comp.Env<javac.comp.AttrContext>;
              getBreakIterator(): java.text.BreakIterator;
              getCharacters(tree: sun.source.doctree.EntityTree): string;
              getDocComment(path: sun.source.util.TreePath): string;
              getDocCommentTree(path: sun.source.util.TreePath): sun.source.doctree.DocCommentTree;
              getDocCommentTree(e: javax.lang.model.element.Element): sun.source.doctree.DocCommentTree;
              getDocCommentTree(e: javax.lang.model.element.Element, relativeFileName: string): sun.source.doctree.DocCommentTree;
              getDocCommentTree(fileObject: javax.tools.FileObject): sun.source.doctree.DocCommentTree;
              getDocTreeFactory(): javac.tree.DocTreeMaker;
              getDocTreeFactory(): sun.source.util.DocTreeFactory;
              getDocTreePath(fileObject: javax.tools.FileObject, packageElement: javax.lang.model.element.PackageElement): sun.source.util.DocTreePath;
              getElement(path: sun.source.util.TreePath): javac.code.Symbol;
              getElement(path: sun.source.util.DocTreePath): javax.lang.model.element.Element;
              getElement(a0: sun.source.util.TreePath): javax.lang.model.element.Element;
              getFirstSentence(list: java.util.List<sun.source.doctree.DocTree>): java.util.List<sun.source.doctree.DocTree>;
              _getLastChild(tree: sun.source.doctree.DocTree): sun.source.doctree.DocTree;
              getLub(tree: sun.source.tree.CatchTree): javax.lang.model.type.TypeMirror;
              getOriginalType(errorType: javax.lang.model.type.ErrorType): javax.lang.model.type.TypeMirror;
              getPath(unit: sun.source.tree.CompilationUnitTree, node: sun.source.tree.Tree): sun.source.util.TreePath;
              getPath(e: javax.lang.model.element.Element): sun.source.util.TreePath;
              getPath(e: javax.lang.model.element.Element, a: javax.lang.model.element.AnnotationMirror): sun.source.util.TreePath;
              getPath(e: javax.lang.model.element.Element, a: javax.lang.model.element.AnnotationMirror, v: javax.lang.model.element.AnnotationValue): sun.source.util.TreePath;
              getScope(path: sun.source.util.TreePath): JavacScope;
              getScope(a0: sun.source.util.TreePath): sun.source.tree.Scope;
              getSourcePositions(): sun.source.util.DocSourcePositions;
              getSourcePositions(): sun.source.util.SourcePositions;
              getTree(element: javax.lang.model.element.TypeElement): javac.tree.JCTree$JCClassDecl;
              getTree(method: javax.lang.model.element.ExecutableElement): javac.tree.JCTree$JCMethodDecl;
              getTree(element: javax.lang.model.element.Element): javac.tree.JCTree;
              getTree(e: javax.lang.model.element.Element, a: javax.lang.model.element.AnnotationMirror): javac.tree.JCTree;
              getTree(e: javax.lang.model.element.Element, a: javax.lang.model.element.AnnotationMirror, v: javax.lang.model.element.AnnotationValue): javac.tree.JCTree;
              getTree(a0: javax.lang.model.element.Element, a1: javax.lang.model.element.AnnotationMirror, a2: javax.lang.model.element.AnnotationValue): sun.source.tree.Tree;
              getTree(a0: javax.lang.model.element.Element, a1: javax.lang.model.element.AnnotationMirror): sun.source.tree.Tree;
              getTree(a0: javax.lang.model.element.ExecutableElement): sun.source.tree.MethodTree;
              getTree(a0: javax.lang.model.element.TypeElement): sun.source.tree.ClassTree;
              getTree(a0: javax.lang.model.element.Element): sun.source.tree.Tree;
              getType(path: sun.source.util.DocTreePath): javax.lang.model.type.TypeMirror;
              getTypeMirror(path: sun.source.util.TreePath): javax.lang.model.type.TypeMirror;
              _hasParameterTypes(method: javac.code.Symbol$MethodSymbol, paramTypes: javac.util.List<javac.code.Type>, strict: boolean): boolean;
              isAccessible(scope: sun.source.tree.Scope, type: javax.lang.model.element.TypeElement): boolean;
              isAccessible(scope: sun.source.tree.Scope, member: javax.lang.model.element.Element, type: javax.lang.model.type.DeclaredType): boolean;
              _makeTreePath(psym: javac.code.Symbol$PackageSymbol, jfo: javax.tools.JavaFileObject, dcTree: sun.source.doctree.DocCommentTree): sun.source.util.TreePath;
              _prepareFlatnameForClass(env: javac.comp.Env<javac.comp.AttrContext>): java.util.Map<javac.tree.JCTree$JCClassDecl,javac.util.Name>;
              printMessage(kind: javax.tools.Diagnostic$Kind, msg: JavacTrees$charSequence, t: sun.source.tree.Tree, root: sun.source.tree.CompilationUnitTree): void;
              printMessage(kind: javax.tools.Diagnostic$Kind, msg: JavacTrees$charSequence, t: sun.source.doctree.DocTree, c: sun.source.doctree.DocCommentTree, root: sun.source.tree.CompilationUnitTree): void;
              _printMessage(kind: javax.tools.Diagnostic$Kind, msg: JavacTrees$charSequence, pos: javac.util.JCDiagnostic$DiagnosticPosition, root: sun.source.tree.CompilationUnitTree): void;
              _searchField(tsym: javac.code.Symbol$ClassSymbol, fieldName: javac.util.Name, searched: java.util.Set<javac.code.Symbol$ClassSymbol>): javac.code.Symbol$VarSymbol;
              _searchMethod(tsym: javac.code.Symbol$ClassSymbol, methodName: javac.util.Name, paramTypes: javac.util.List<javac.code.Type>, strict: boolean, searched: java.util.Set<javac.code.Symbol$ClassSymbol>): javac.code.Symbol$MethodSymbol;
              setBreakIterator(breakiterator: java.text.BreakIterator): void;
              _attr: javac.comp.Attr;
              _breakIterator: java.text.BreakIterator;
              _chk: javac.comp.Check;
              _docTreeMaker: javac.tree.DocTreeMaker;
              _elements: javac.model.JavacElements;
              _enter: javac.comp.Enter;
              _extraType2OriginalMap: java.util.Map<javac.code.Type,javac.code.Type>;
              _fileManager: javax.tools.JavaFileManager;
              _javacTaskImpl: JavacTaskImpl;
              _log: javac.util.Log;
              _memberEnter: javac.comp.MemberEnter;
              _modules: javac.comp.Modules;
              _names: javac.util.Names;
              _parser: javac.parser.ParserFactory;
              _resolve: javac.comp.Resolve;
              _syms: javac.code.Symtab;
              _treeMaker: javac.tree.TreeMaker;
              _types: javac.code.Types;
            }
            interface JavacTrees extends CombineTypes<[_JavacTrees, com.sun.source.util.DocTrees]> {}
            interface _JavacTrees$Copier$$static extends ClassLike {
              _new(M: javac.tree.TreeMaker): JavacTrees$Copier;
            }
            let JavacTrees$Copier: _JavacTrees$Copier$$static;
            interface _JavacTrees$Copier {
              copy<T>(t: T, leaf: javac.tree.JCTree): T;
              copy(a0: javac.tree.JCTree, a1: any): javac.tree.JCTree;
              visitClass(node: sun.source.tree.ClassTree, p: javac.tree.JCTree): javac.tree.JCTree;
              visitClass(a0: sun.source.tree.ClassTree, a1: any): javac.tree.JCTree;
              visitClass(a0: sun.source.tree.ClassTree, a1: any): any;
              _copiedClasses: java.util.Map<javac.tree.JCTree$JCClassDecl,javac.tree.JCTree$JCClassDecl>;
              _leafCopy: javac.tree.JCTree;
            }
            interface JavacTrees$Copier extends CombineTypes<[_JavacTrees$Copier, javac.tree.TreeCopier<javac.tree.JCTree>]> {}
            interface _JavacTrees$HtmlFileObject$$static extends ClassLike {
              new(fileObject: javax.tools.FileObject): JavacTrees$HtmlFileObject;
            }
            let JavacTrees$HtmlFileObject: _JavacTrees$HtmlFileObject$$static;
            interface _JavacTrees$HtmlFileObject {
              getAccessLevel(): javax.lang.model.element.Modifier;
              getKind(): javax.tools.JavaFileObject$Kind;
              getNestingKind(): javax.lang.model.element.NestingKind;
              isNameCompatible(simpleName: string, kind: javax.tools.JavaFileObject$Kind): boolean;
            }
            interface JavacTrees$HtmlFileObject extends CombineTypes<[_JavacTrees$HtmlFileObject, javax.tools.JavaFileObject, javax.tools.ForwardingFileObject<javax.tools.FileObject>]> {}
            interface _Messages$$static extends ClassLike {
            }
            let Messages: _Messages$$static;
            interface _Messages {
              add(a0: string): void;
              getLocalizedString(a0: java.util.Locale, a1: string, a2: any[]): string;
              getLocalizedString(a0: java.util.Locale, a1: string, ...a2: any[]): string;
            }
            interface Messages extends CombineTypes<[_Messages, java.lang.Object]> {}
            interface _MultiTaskListener$$static extends ClassLike {
              instance(context: javac.util.Context): MultiTaskListener;
              _EMPTY_LISTENERS: sun.source.util.TaskListener[];
              readonly taskListenerKey: javac.util.Context$Key<MultiTaskListener>;
              _new(context: javac.util.Context): MultiTaskListener;
            }
            let MultiTaskListener: _MultiTaskListener$$static;
            interface _MultiTaskListener {
              add(listener: sun.source.util.TaskListener): void;
              clear(): void;
              finished(e: sun.source.util.TaskEvent): void;
              getTaskListeners(): java.util.Collection<sun.source.util.TaskListener>;
              isEmpty(): boolean;
              remove(listener: sun.source.util.TaskListener): void;
              started(e: sun.source.util.TaskEvent): void;
              toString(): string;
              _ccw: ClientCodeWrapper;
              _dcfh: javac.code.DeferredCompletionFailureHandler;
              _listeners: sun.source.util.TaskListener[];
            }
            interface MultiTaskListener extends CombineTypes<[_MultiTaskListener, com.sun.source.util.TaskListener, java.lang.Object]> {}
            interface _WrappingJavaFileManager$$static<M> extends ClassLike {
              _new(fileManager: M): WrappingJavaFileManager<M>;
            }
            let WrappingJavaFileManager: _WrappingJavaFileManager$$static<M>;
            interface _WrappingJavaFileManager<M> {
              contains(location: javax.tools.JavaFileManager$Location, file: javax.tools.FileObject): boolean;
              getFileForInput(location: javax.tools.JavaFileManager$Location, packageName: string, relativeName: string): javax.tools.FileObject;
              getFileForOutput(location: javax.tools.JavaFileManager$Location, packageName: string, relativeName: string, sibling: javax.tools.FileObject): javax.tools.FileObject;
              getJavaFileForInput(location: javax.tools.JavaFileManager$Location, className: string, kind: javax.tools.JavaFileObject$Kind): javax.tools.JavaFileObject;
              getJavaFileForOutput(location: javax.tools.JavaFileManager$Location, className: string, kind: javax.tools.JavaFileObject$Kind, sibling: javax.tools.FileObject): javax.tools.JavaFileObject;
              inferBinaryName(location: javax.tools.JavaFileManager$Location, file: javax.tools.JavaFileObject): string;
              list(location: javax.tools.JavaFileManager$Location, packageName: string, kinds: java.util.Set<javax.tools.JavaFileObject$Kind>, recurse: boolean): java.lang.Iterable<javax.tools.JavaFileObject>;
              _unwrap(fileObject: javax.tools.FileObject): javax.tools.FileObject;
              _unwrap(fileObject: javax.tools.JavaFileObject): javax.tools.JavaFileObject;
              _unwrap(uri: java.net.URI): java.net.URI;
              _wrap(fileObject: javax.tools.FileObject): javax.tools.FileObject;
              _wrap(fileObject: javax.tools.JavaFileObject): javax.tools.JavaFileObject;
              _wrap(fileObjects: java.lang.Iterable<javax.tools.JavaFileObject>): java.lang.Iterable<javax.tools.JavaFileObject>;
            }
            interface WrappingJavaFileManager<M> extends CombineTypes<[_WrappingJavaFileManager<M>, javax.tools.ForwardingJavaFileManager<M>]> {}
          }
          module code {
            interface _AnnoConstruct$$static extends ClassLike {
              _getContainer(annoType: java.lang.Class<java.lang.annotation.Annotation>): java.lang.Class<java.lang.annotation.Annotation>;
              _unpackAttributes(container: Attribute$Compound): Attribute[];
              new(): AnnoConstruct;
            }
            let AnnoConstruct: _AnnoConstruct$$static;
            interface _AnnoConstruct {
              getAnnotation<A>(annoType: java.lang.Class<A>): A;
              getAnnotationMirrors(): javac.util.List<Attribute$Compound>;
(): javac.util.List<Attribute$Compound>;
              getAnnotationMirrors(): java.util.List;
              getAnnotationsByType<A>(annoType: java.lang.Class<A>): A[];
              _getAttribute<A>(annoType: java.lang.Class<A>): Attribute$Compound;
              _getInheritedAnnotations<A>(annoType: java.lang.Class<A>): A[];
              _unpackContained(container: Attribute$Compound): Attribute$Compound[];
            }
            interface AnnoConstruct extends CombineTypes<[_AnnoConstruct, javax.lang.model.AnnotatedConstruct, java.lang.Object]> {}
            interface _Attribute$$static extends ClassLike {
              new(type: Type): Attribute;
            }
            let Attribute: _Attribute$$static;
            interface _Attribute {
              accept(a0: Attribute$Visitor): void;
(a0: Attribute$Visitor): void;
              accept<R, P>(v: javax.lang.model.element.AnnotationValueVisitor<R,P>, p: P): R;
              getPosition(): TypeAnnotationPosition;
              getValue(): any;
              isSynthesized(): boolean;
              type: Type;
            }
            interface Attribute extends CombineTypes<[_Attribute, java.lang.Object, javax.lang.model.element.AnnotationValue]> {}
            interface _Attribute$Array$$static extends ClassLike {
              new(type: Type, values: Attribute[]): Attribute$Array;
              new(type: Type, values: javac.util.List<Attribute>): Attribute$Array;
            }
            let Attribute$Array: _Attribute$Array$$static;
            interface _Attribute$Array {
              accept(v: Attribute$Visitor): void;
              accept<R, P>(v: javax.lang.model.element.AnnotationValueVisitor<R,P>, p: P): R;
              getPosition(): TypeAnnotationPosition;
              getValue(): javac.util.List<Attribute>;
              getValue(): any;
              toString(): string;
              readonly values: Attribute[];
            }
            interface Attribute$Array extends CombineTypes<[_Attribute$Array, com.sun.tools.javac.code.Attribute]> {}
            interface _Attribute$Class$$static extends ClassLike {
              _makeClassType(types: Types, type: Type): Type;
              new(types: Types, type: Type): Attribute$Class;
            }
            let Attribute$Class: _Attribute$Class$$static;
            interface _Attribute$Class {
              accept(v: Attribute$Visitor): void;
              accept<R, P>(v: javax.lang.model.element.AnnotationValueVisitor<R,P>, p: P): R;
              getValue(): Type;
              getValue(): any;
              toString(): string;
              readonly classType: Type;
            }
            interface Attribute$Class extends CombineTypes<[_Attribute$Class, com.sun.tools.javac.code.Attribute]> {}
            interface _Attribute$Compound$$static extends ClassLike {
              new(type: Type, values: javac.util.List<javac.util.Pair<Symbol$MethodSymbol,Attribute>>, position: TypeAnnotationPosition): Attribute$Compound;
              new(type: Type, values: javac.util.List<javac.util.Pair<Symbol$MethodSymbol,Attribute>>): Attribute$Compound;
            }
            let Attribute$Compound: _Attribute$Compound$$static;
            interface _Attribute$Compound {
              accept(v: Attribute$Visitor): void;
              accept<R, P>(v: javax.lang.model.element.AnnotationValueVisitor<R,P>, p: P): R;
              getAnnotationType(): javax.lang.model.type.DeclaredType;
              _getElemPair(member: javac.util.Name): javac.util.Pair<Symbol$MethodSymbol,Attribute>;
              getElementValues(): java.util.Map<Symbol$MethodSymbol,Attribute>;
              _getFirstEmbeddedTC(): Attribute$Compound;
              getPosition(): TypeAnnotationPosition;
              getValue(): Attribute$Compound;
              getValue(): any;
              hasUnknownPosition(): boolean;
              isContainerTypeCompound(): boolean;
              isSynthesized(): boolean;
              member(member: javac.util.Name): Attribute;
              setSynthesized(synthesized: boolean): void;
              toString(): string;
              tryFixPosition(): boolean;
              position: TypeAnnotationPosition;
              _synthesized: boolean;
              readonly values: javac.util.List<javac.util.Pair<Symbol$MethodSymbol,Attribute>>;
            }
            interface Attribute$Compound extends CombineTypes<[_Attribute$Compound, com.sun.tools.javac.code.Attribute, javax.lang.model.element.AnnotationMirror]> {}
            interface _Attribute$Constant$$static extends ClassLike {
              new(type: Type, value: any): Attribute$Constant;
            }
            let Attribute$Constant: _Attribute$Constant$$static;
            interface _Attribute$Constant {
              accept(v: Attribute$Visitor): void;
              accept<R, P>(v: javax.lang.model.element.AnnotationValueVisitor<R,P>, p: P): R;
              getValue(): any;
              toString(): string;
              readonly value: any;
            }
            interface Attribute$Constant extends CombineTypes<[_Attribute$Constant, com.sun.tools.javac.code.Attribute]> {}
            interface _Attribute$Enum$$static extends ClassLike {
              new(type: Type, value: Symbol$VarSymbol): Attribute$Enum;
            }
            let Attribute$Enum: _Attribute$Enum$$static;
            interface _Attribute$Enum {
              accept(v: Attribute$Visitor): void;
              accept<R, P>(v: javax.lang.model.element.AnnotationValueVisitor<R,P>, p: P): R;
              getValue(): Symbol$VarSymbol;
              getValue(): any;
              toString(): string;
              value: Symbol$VarSymbol;
            }
            interface Attribute$Enum extends CombineTypes<[_Attribute$Enum, com.sun.tools.javac.code.Attribute]> {}
            interface _Attribute$Error$$static extends ClassLike {
              new(type: Type): Attribute$Error;
            }
            let Attribute$Error: _Attribute$Error$$static;
            interface _Attribute$Error {
              accept(v: Attribute$Visitor): void;
              accept<R, P>(v: javax.lang.model.element.AnnotationValueVisitor<R,P>, p: P): R;
              getValue(): string;
              getValue(): any;
              toString(): string;
            }
            interface Attribute$Error extends CombineTypes<[_Attribute$Error, com.sun.tools.javac.code.Attribute]> {}
            interface _Attribute$RetentionPolicy$$static extends ClassLike {
              valueOf(name: string): Attribute$RetentionPolicy;
              values(): Attribute$RetentionPolicy[];
              readonly CLASS: Attribute$RetentionPolicy;
              readonly RUNTIME: Attribute$RetentionPolicy;
              readonly SOURCE: Attribute$RetentionPolicy;
            }
            let Attribute$RetentionPolicy: _Attribute$RetentionPolicy$$static;
            interface _Attribute$RetentionPolicy {
            }
            interface Attribute$RetentionPolicy extends CombineTypes<[_Attribute$RetentionPolicy]> {}
            interface _Attribute$TypeCompound$$static extends ClassLike {
              new(compound: Attribute$Compound, position: TypeAnnotationPosition): Attribute$TypeCompound;
              new(type: Type, values: javac.util.List<javac.util.Pair<Symbol$MethodSymbol,Attribute>>, position: TypeAnnotationPosition): Attribute$TypeCompound;
            }
            let Attribute$TypeCompound: _Attribute$TypeCompound$$static;
            interface _Attribute$TypeCompound {
            }
            interface Attribute$TypeCompound extends CombineTypes<[_Attribute$TypeCompound, com.sun.tools.javac.code.Attribute$Compound]> {}
            interface _Attribute$UnresolvedClass$$static extends ClassLike {
              new(type: Type, classType: Type): Attribute$UnresolvedClass;
            }
            let Attribute$UnresolvedClass: _Attribute$UnresolvedClass$$static;
            interface _Attribute$UnresolvedClass {
              classType: Type;
            }
            interface Attribute$UnresolvedClass extends CombineTypes<[_Attribute$UnresolvedClass, com.sun.tools.javac.code.Attribute$Error]> {}
            interface _Attribute$Visitor$$static extends ClassLike {
            }
            let Attribute$Visitor: _Attribute$Visitor$$static;
            interface _Attribute$Visitor {
              visitArray(a0: Attribute$Array): void;
              visitClass(a0: Attribute$Class): void;
              visitCompound(a0: Attribute$Compound): void;
              visitConstant(a0: Attribute$Constant): void;
              visitEnum(a0: Attribute$Enum): void;
              visitError(a0: Attribute$Error): void;
            }
            interface Attribute$Visitor extends CombineTypes<[_Attribute$Visitor, java.lang.Object]> {}
            interface _BoundKind$$static extends ClassLike {
              valueOf(name: string): BoundKind;
              values(): BoundKind[];
              readonly EXTENDS: BoundKind;
              readonly SUPER: BoundKind;
              readonly UNBOUND: BoundKind;
            }
            let BoundKind: _BoundKind$$static;
            interface _BoundKind {
              toString(): string;
              _name: string;
            }
            interface BoundKind extends CombineTypes<[_BoundKind]> {}
            interface _ClassFinder$$static extends ClassLike {
              instance(context: javac.util.Context): ClassFinder;
              _classFinderKey: javac.util.Context$Key<ClassFinder>;
              _new(context: javac.util.Context): ClassFinder;
            }
            let ClassFinder: _ClassFinder$$static;
            interface _ClassFinder {
              _classFileNotFound(c: Symbol$ClassSymbol): Symbol$CompletionFailure;
              _complete(sym: Symbol): void;
              _completeEnclosing(c: Symbol$ClassSymbol): void;
              _completeOwners(o: Symbol): void;
              _extraFileActions(pack: Symbol$PackageSymbol, fe: javax.tools.JavaFileObject): void;
              _fillIn(c: Symbol$ClassSymbol): void;
              _fillIn(p: Symbol$PackageSymbol): void;
              _fillIn(p: Symbol$PackageSymbol, location: javax.tools.JavaFileManager$Location, files: java.lang.Iterable<javax.tools.JavaFileObject>): void;
              getCompleter(): Symbol$Completer;
              _getPackageFileKinds(): java.util.EnumSet<javax.tools.JavaFileObject$Kind>;
              _getSupplementaryFlags(c: Symbol$ClassSymbol): long;
              _includeClassFile(p: Symbol$PackageSymbol, file: javax.tools.JavaFileObject): void;
              _list(location: javax.tools.JavaFileManager$Location, p: Symbol$PackageSymbol, packageName: string, kinds: java.util.Set<javax.tools.JavaFileObject$Kind>): java.lang.Iterable<javax.tools.JavaFileObject>;
              loadClass(msym: Symbol$ModuleSymbol, flatname: javac.util.Name): Symbol$ClassSymbol;
              _newCompletionFailure(c: Symbol$TypeSymbol, diag: java.util.function.Supplier<javac.util.JCDiagnostic>): Symbol$CompletionFailure;
              _preferredFileObject(a: javax.tools.JavaFileObject, b: javax.tools.JavaFileObject): javax.tools.JavaFileObject;
              _scanModulePaths(p: Symbol$PackageSymbol, msym: Symbol$ModuleSymbol): void;
              _scanPlatformPath(p: Symbol$PackageSymbol): void;
              _scanUserPaths(p: Symbol$PackageSymbol, includeSourcePath: boolean): void;
              _annotate: javac.comp.Annotate;
              _cacheCompletionFailure: boolean;
              _cachedCompletionFailure: Symbol$CompletionFailure;
              _completionFailureName: javac.util.Name;
              _currentClassFile: javax.tools.JavaFileObject;
              _currentLoc: javax.tools.JavaFileManager$Location;
              _currentOwner: Symbol;
              _dcfh: DeferredCompletionFailureHandler;
              _dependencies: javac.util.Dependencies;
              _diagFactory: javac.util.JCDiagnostic$Factory;
              _fileManager: javax.tools.JavaFileManager;
              _jrtIndex: javac.file.JRTIndex;
              _log: javac.util.Log;
              _names: javac.util.Names;
              _preferCurrent: boolean;
              _preferSource: boolean;
              _profile: javac.jvm.Profile;
              _reader: javac.jvm.ClassReader;
              sourceCompleter: Symbol$Completer;
              _supplementaryFlags: java.util.Map<Symbol$PackageSymbol,long>;
              _syms: Symtab;
              _thisCompleter: Symbol$Completer;
              _userPathsFirst: boolean;
              _verbose: boolean;
              _verbosePath: boolean;
            }
            interface ClassFinder extends CombineTypes<[_ClassFinder, java.lang.Object]> {}
            interface _ClassFinder$BadClassFile$$static extends ClassLike {
              _createBadClassFileDiagnostic(file: javax.tools.JavaFileObject, diag: javac.util.JCDiagnostic, diagFactory: javac.util.JCDiagnostic$Factory): javac.util.JCDiagnostic;
              _serialVersionUID: long;
              new(sym: Symbol$TypeSymbol, file: javax.tools.JavaFileObject, diag: javac.util.JCDiagnostic, diagFactory: javac.util.JCDiagnostic$Factory, dcfh: DeferredCompletionFailureHandler): ClassFinder$BadClassFile;
            }
            let ClassFinder$BadClassFile: _ClassFinder$BadClassFile$$static;
            interface _ClassFinder$BadClassFile {
            }
            interface ClassFinder$BadClassFile extends CombineTypes<[_ClassFinder$BadClassFile, com.sun.tools.javac.code.Symbol$CompletionFailure]> {}
            interface _ClassFinder$BadEnclosingMethodAttr$$static extends ClassLike {
              _serialVersionUID: long;
              new(sym: Symbol$TypeSymbol, file: javax.tools.JavaFileObject, diag: javac.util.JCDiagnostic, diagFactory: javac.util.JCDiagnostic$Factory, dcfh: DeferredCompletionFailureHandler): ClassFinder$BadEnclosingMethodAttr;
            }
            let ClassFinder$BadEnclosingMethodAttr: _ClassFinder$BadEnclosingMethodAttr$$static;
            interface _ClassFinder$BadEnclosingMethodAttr {
            }
            interface ClassFinder$BadEnclosingMethodAttr extends CombineTypes<[_ClassFinder$BadEnclosingMethodAttr, com.sun.tools.javac.code.ClassFinder$BadClassFile]> {}
            interface _DeferredCompletionFailureHandler$$static extends ClassLike {
              instance(context: javac.util.Context): DeferredCompletionFailureHandler;
              _deferredCompletionFailureHandlerKey: javac.util.Context$Key<DeferredCompletionFailureHandler>;
              _new(context: javac.util.Context): DeferredCompletionFailureHandler;
            }
            let DeferredCompletionFailureHandler: _DeferredCompletionFailureHandler$$static;
            interface _DeferredCompletionFailureHandler {
              classSymbolCompleteFailed(sym: Symbol$ClassSymbol, origCompleter: Symbol$Completer): void;
              classSymbolRemoved(sym: Symbol$ClassSymbol): void;
              handleAPICompletionFailure(cf: Symbol$CompletionFailure): void;
              isDeferredCompleter(c: Symbol$Completer): boolean;
              setHandler(h: DeferredCompletionFailureHandler$Handler): DeferredCompletionFailureHandler$Handler;
              _handler: DeferredCompletionFailureHandler$Handler;
              readonly javacCodeHandler: DeferredCompletionFailureHandler$Handler;
              readonly speculativeCodeHandler: DeferredCompletionFailureHandler$Handler;
              readonly userCodeHandler: DeferredCompletionFailureHandler$Handler;
            }
            interface DeferredCompletionFailureHandler extends CombineTypes<[_DeferredCompletionFailureHandler, java.lang.Object]> {}
            interface _DeferredCompletionFailureHandler$DeferredCompleter$$static extends ClassLike {
              new(a0: DeferredCompletionFailureHandler, origCompleter: Symbol$Completer): DeferredCompletionFailureHandler$DeferredCompleter;
            }
            let DeferredCompletionFailureHandler$DeferredCompleter: _DeferredCompletionFailureHandler$DeferredCompleter$$static;
            interface _DeferredCompletionFailureHandler$DeferredCompleter {
              complete(sym: Symbol): void;
              _origCompleter: Symbol$Completer;
            }
            interface DeferredCompletionFailureHandler$DeferredCompleter extends CombineTypes<[_DeferredCompletionFailureHandler$DeferredCompleter, java.lang.Object, com.sun.tools.javac.code.Symbol$Completer]> {}
            interface _DeferredCompletionFailureHandler$FlipSymbolDescription$$static extends ClassLike {
              new(sym: Symbol$ClassSymbol, completer: Symbol$Completer): DeferredCompletionFailureHandler$FlipSymbolDescription;
            }
            let DeferredCompletionFailureHandler$FlipSymbolDescription: _DeferredCompletionFailureHandler$FlipSymbolDescription$$static;
            interface _DeferredCompletionFailureHandler$FlipSymbolDescription {
              flip(): void;
              completer: Symbol$Completer;
              kind: Kinds$Kind;
              members: Scope$WriteableScope;
              readonly sym: Symbol$ClassSymbol;
              type: Type;
            }
            interface DeferredCompletionFailureHandler$FlipSymbolDescription extends CombineTypes<[_DeferredCompletionFailureHandler$FlipSymbolDescription, java.lang.Object]> {}
            interface _DeferredCompletionFailureHandler$Handler$$static extends ClassLike {
            }
            let DeferredCompletionFailureHandler$Handler: _DeferredCompletionFailureHandler$Handler$$static;
            interface _DeferredCompletionFailureHandler$Handler {
              classSymbolCompleteFailed(a0: Symbol$ClassSymbol, a1: Symbol$Completer): void;
              classSymbolRemoved(a0: Symbol$ClassSymbol): void;
              handleAPICompletionFailure(a0: Symbol$CompletionFailure): void;
              install(): void;
              uninstall(): void;
            }
            interface DeferredCompletionFailureHandler$Handler extends CombineTypes<[_DeferredCompletionFailureHandler$Handler, java.lang.Object]> {}
            interface _DeferredLintHandler$$static extends ClassLike {
              instance(context: javac.util.Context): DeferredLintHandler;
              _IMMEDIATE_POSITION: javac.util.JCDiagnostic$DiagnosticPosition;
              _deferredLintHandlerKey: javac.util.Context$Key<DeferredLintHandler>;
              _new(context: javac.util.Context): DeferredLintHandler;
            }
            let DeferredLintHandler: _DeferredLintHandler$$static;
            interface _DeferredLintHandler {
              flush(pos: javac.util.JCDiagnostic$DiagnosticPosition): void;
              immediate(): javac.util.JCDiagnostic$DiagnosticPosition;
              report(logger: DeferredLintHandler$LintLogger): void;
              setPos(currentPos: javac.util.JCDiagnostic$DiagnosticPosition): javac.util.JCDiagnostic$DiagnosticPosition;
              _currentPos: javac.util.JCDiagnostic$DiagnosticPosition;
              _loggersQueue: java.util.Map<javac.util.JCDiagnostic$DiagnosticPosition,javac.util.ListBuffer<DeferredLintHandler$LintLogger>>;
            }
            interface DeferredLintHandler extends CombineTypes<[_DeferredLintHandler, java.lang.Object]> {}
            interface _DeferredLintHandler$LintLogger$$static extends ClassLike {
            }
            let DeferredLintHandler$LintLogger: _DeferredLintHandler$LintLogger$$static;
            interface _DeferredLintHandler$LintLogger {
              report(): void;
(): void;
            }
            interface DeferredLintHandler$LintLogger extends CombineTypes<[_DeferredLintHandler$LintLogger, java.lang.Object]> {}
            interface _Directive$$static extends ClassLike {
              new(): Directive;
            }
            let Directive: _Directive$$static;
            interface _Directive {
            }
            interface Directive extends CombineTypes<[_Directive, javax.lang.model.element.ModuleElement$Directive, java.lang.Object]> {}
            interface _Directive$ExportsDirective$$static extends ClassLike {
              new(packge: Symbol$PackageSymbol, modules: javac.util.List<Symbol$ModuleSymbol>): Directive$ExportsDirective;
              new(packge: Symbol$PackageSymbol, modules: javac.util.List<Symbol$ModuleSymbol>, flags: java.util.Set<Directive$ExportsFlag>): Directive$ExportsDirective;
            }
            let Directive$ExportsDirective: _Directive$ExportsDirective$$static;
            interface _Directive$ExportsDirective {
              accept<R, P>(v: javax.lang.model.element.ModuleElement$DirectiveVisitor<R,P>, p: P): R;
              getKind(): javax.lang.model.element.ModuleElement$DirectiveKind;
              getPackage(): Symbol$PackageSymbol;
              getPackage(): javax.lang.model.element.PackageElement;
              getTargetModules(): java.util.List<Symbol$ModuleSymbol>;
              toString(): string;
              readonly flags: java.util.Set<Directive$ExportsFlag>;
              readonly modules: javac.util.List<Symbol$ModuleSymbol>;
              readonly packge: Symbol$PackageSymbol;
            }
            interface Directive$ExportsDirective extends CombineTypes<[_Directive$ExportsDirective, com.sun.tools.javac.code.Directive, javax.lang.model.element.ModuleElement$ExportsDirective]> {}
            interface _Directive$ExportsFlag$$static extends ClassLike {
              value(s: java.util.Set<Directive$ExportsFlag>): int;
              valueOf(name: string): Directive$ExportsFlag;
              values(): Directive$ExportsFlag[];
              readonly MANDATED: Directive$ExportsFlag;
              readonly SYNTHETIC: Directive$ExportsFlag;
            }
            let Directive$ExportsFlag: _Directive$ExportsFlag$$static;
            interface _Directive$ExportsFlag {
              readonly value: int;
            }
            interface Directive$ExportsFlag extends CombineTypes<[_Directive$ExportsFlag]> {}
            interface _Directive$OpensDirective$$static extends ClassLike {
              new(packge: Symbol$PackageSymbol, modules: javac.util.List<Symbol$ModuleSymbol>): Directive$OpensDirective;
              new(packge: Symbol$PackageSymbol, modules: javac.util.List<Symbol$ModuleSymbol>, flags: java.util.Set<Directive$OpensFlag>): Directive$OpensDirective;
            }
            let Directive$OpensDirective: _Directive$OpensDirective$$static;
            interface _Directive$OpensDirective {
              accept<R, P>(v: javax.lang.model.element.ModuleElement$DirectiveVisitor<R,P>, p: P): R;
              getKind(): javax.lang.model.element.ModuleElement$DirectiveKind;
              getPackage(): Symbol$PackageSymbol;
              getPackage(): javax.lang.model.element.PackageElement;
              getTargetModules(): java.util.List<Symbol$ModuleSymbol>;
              toString(): string;
              readonly flags: java.util.Set<Directive$OpensFlag>;
              readonly modules: javac.util.List<Symbol$ModuleSymbol>;
              readonly packge: Symbol$PackageSymbol;
            }
            interface Directive$OpensDirective extends CombineTypes<[_Directive$OpensDirective, com.sun.tools.javac.code.Directive, javax.lang.model.element.ModuleElement$OpensDirective]> {}
            interface _Directive$OpensFlag$$static extends ClassLike {
              value(s: java.util.Set<Directive$OpensFlag>): int;
              valueOf(name: string): Directive$OpensFlag;
              values(): Directive$OpensFlag[];
              readonly MANDATED: Directive$OpensFlag;
              readonly SYNTHETIC: Directive$OpensFlag;
            }
            let Directive$OpensFlag: _Directive$OpensFlag$$static;
            interface _Directive$OpensFlag {
              readonly value: int;
            }
            interface Directive$OpensFlag extends CombineTypes<[_Directive$OpensFlag]> {}
            interface _Directive$ProvidesDirective$$static extends ClassLike {
              new(service: Symbol$ClassSymbol, impls: javac.util.List<Symbol$ClassSymbol>): Directive$ProvidesDirective;
            }
            let Directive$ProvidesDirective: _Directive$ProvidesDirective$$static;
            interface _Directive$ProvidesDirective {
              accept<R, P>(v: javax.lang.model.element.ModuleElement$DirectiveVisitor<R,P>, p: P): R;
              equals(obj: any): boolean;
              getImplementations(): javac.util.List<Symbol$ClassSymbol>;
              getImplementations(): java.util.List;
              getKind(): javax.lang.model.element.ModuleElement$DirectiveKind;
              getService(): Symbol$ClassSymbol;
              getService(): javax.lang.model.element.TypeElement;
              hashCode(): int;
              toString(): string;
              readonly impls: javac.util.List<Symbol$ClassSymbol>;
              readonly service: Symbol$ClassSymbol;
            }
            interface Directive$ProvidesDirective extends CombineTypes<[_Directive$ProvidesDirective, com.sun.tools.javac.code.Directive, javax.lang.model.element.ModuleElement$ProvidesDirective]> {}
            interface _Directive$RequiresDirective$$static extends ClassLike {
              new(module: Symbol$ModuleSymbol): Directive$RequiresDirective;
              new(module: Symbol$ModuleSymbol, flags: java.util.Set<Directive$RequiresFlag>): Directive$RequiresDirective;
            }
            let Directive$RequiresDirective: _Directive$RequiresDirective$$static;
            interface _Directive$RequiresDirective {
              accept<R, P>(v: javax.lang.model.element.ModuleElement$DirectiveVisitor<R,P>, p: P): R;
              getDependency(): Symbol$ModuleSymbol;
              getDependency(): javax.lang.model.element.ModuleElement;
              getKind(): javax.lang.model.element.ModuleElement$DirectiveKind;
              isStatic(): boolean;
              isTransitive(): boolean;
              toString(): string;
              readonly flags: java.util.Set<Directive$RequiresFlag>;
              readonly module: Symbol$ModuleSymbol;
            }
            interface Directive$RequiresDirective extends CombineTypes<[_Directive$RequiresDirective, com.sun.tools.javac.code.Directive, javax.lang.model.element.ModuleElement$RequiresDirective]> {}
            interface _Directive$RequiresFlag$$static extends ClassLike {
              value(s: java.util.Set<Directive$RequiresFlag>): int;
              valueOf(name: string): Directive$RequiresFlag;
              values(): Directive$RequiresFlag[];
              readonly EXTRA: Directive$RequiresFlag;
              readonly MANDATED: Directive$RequiresFlag;
              readonly STATIC_PHASE: Directive$RequiresFlag;
              readonly SYNTHETIC: Directive$RequiresFlag;
              readonly TRANSITIVE: Directive$RequiresFlag;
            }
            let Directive$RequiresFlag: _Directive$RequiresFlag$$static;
            interface _Directive$RequiresFlag {
              toString(): string;
              readonly value: int;
            }
            interface Directive$RequiresFlag extends CombineTypes<[_Directive$RequiresFlag]> {}
            interface _Directive$UsesDirective$$static extends ClassLike {
              new(service: Symbol$ClassSymbol): Directive$UsesDirective;
            }
            let Directive$UsesDirective: _Directive$UsesDirective$$static;
            interface _Directive$UsesDirective {
              accept<R, P>(v: javax.lang.model.element.ModuleElement$DirectiveVisitor<R,P>, p: P): R;
              equals(obj: any): boolean;
              getKind(): javax.lang.model.element.ModuleElement$DirectiveKind;
              getService(): Symbol$ClassSymbol;
              getService(): javax.lang.model.element.TypeElement;
              hashCode(): int;
              toString(): string;
              readonly service: Symbol$ClassSymbol;
            }
            interface Directive$UsesDirective extends CombineTypes<[_Directive$UsesDirective, com.sun.tools.javac.code.Directive, javax.lang.model.element.ModuleElement$UsesDirective]> {}
            interface _Flags$$static extends ClassLike {
              asFlagSet(flags: long): java.util.EnumSet<Flags$Flag>;
              asModifierSet(flags: long): java.util.Set<javax.lang.model.element.Modifier>;
              isConstant(symbol: Symbol$VarSymbol): boolean;
              isEnum(symbol: Symbol): boolean;
              isStatic(symbol: Symbol): boolean;
              toSource(flags: long): string;
              toString(flags: long): string;
              readonly ABSTRACT: int;
              readonly ACC_BRIDGE: int;
              readonly ACC_MODULE: int;
              readonly ACC_SUPER: int;
              readonly ACC_VARARGS: int;
              readonly ACYCLIC: int;
              readonly ACYCLIC_ANN: long;
              readonly ANNOTATION: int;
              readonly ANONCONSTR: int;
              readonly ANONCONSTR_BASED: long;
              readonly AUTOMATIC_MODULE: long;
              readonly AUXILIARY: long;
              readonly AccessFlags: int;
              readonly AnnotationTypeElementMask: long;
              readonly BAD_OVERRIDE: long;
              readonly BLOCK: int;
              readonly BODY_ONLY_FINALIZE: long;
              readonly BRIDGE: long;
              readonly CLASH: long;
              readonly CLASS_SEEN: int;
              readonly COMPACT_RECORD_CONSTRUCTOR: long;
              readonly COMPOUND: int;
              readonly ClassFlags: int;
              readonly ConstructorFlags: int;
              readonly DEFAULT: long;
              readonly DEPRECATED: int;
              readonly DEPRECATED_ANNOTATION: long;
              readonly DEPRECATED_REMOVAL: long;
              readonly EFFECTIVELY_FINAL: long;
              readonly ENUM: int;
              readonly EXISTS: int;
              readonly ExtendedClassFlags: long;
              readonly ExtendedMemberClassFlags: long;
              readonly ExtendedMemberStaticClassFlags: long;
              readonly ExtendedStandardFlags: long;
              readonly FINAL: int;
              readonly FROM_SOURCE: int;
              readonly GENERATEDCONSTR: long;
              readonly GENERATED_MEMBER: int;
              readonly HASINIT: int;
              readonly HAS_RESOURCE: long;
              readonly HYPOTHETICAL: long;
              readonly INTERFACE: int;
              readonly InterfaceMethodFlags: int;
              readonly InterfaceMethodMask: long;
              readonly InterfaceVarFlags: int;
              readonly LAMBDA_METHOD: long;
              readonly LOCKED: int;
              readonly LocalClassFlags: int;
              readonly LocalVarFlags: long;
              readonly MANDATED: int;
              readonly MATCH_BINDING: long;
              readonly MATCH_BINDING_TO_OUTER: long;
              readonly MODULE: long;
              readonly MemberClassFlags: int;
              readonly MemberStaticClassFlags: int;
              readonly MethodFlags: int;
              readonly ModifierFlags: long;
              readonly NAME_FILLED: long;
              readonly NATIVE: int;
              readonly NON_SEALED: long;
              readonly NOOUTERTHIS: int;
              readonly NOT_IN_PROFILE: long;
              readonly PARAMETER: long;
              readonly PREVIEW_API: long;
              readonly PREVIEW_REFLECTIVE: long;
              readonly PRIVATE: int;
              readonly PROPRIETARY: long;
              readonly PROTECTED: int;
              readonly PUBLIC: int;
              readonly RECORD: long;
              readonly RECOVERABLE: long;
              readonly ReceiverParamFlags: long;
              readonly RecordMethodFlags: int;
              readonly SEALED: long;
              readonly SIGNATURE_POLYMORPHIC: long;
              readonly SOURCE_SEEN: int;
              readonly STATIC: int;
              readonly STRICTFP: int;
              readonly SUPER_OWNER_ATTRIBUTED: int;
              readonly SYNCHRONIZED: int;
              readonly SYNTHETIC: int;
              readonly SYSTEM_MODULE: long;
              readonly StandardFlags: int;
              readonly StaticLocalFlags: int;
              readonly THROWS: long;
              readonly TRANSIENT: int;
              readonly TYPE_TRANSLATED: long;
              readonly UNATTRIBUTED: int;
              readonly UNINITIALIZED_FIELD: long;
              readonly UNION: long;
              readonly UNNAMED_CLASS: int;
              readonly VALUE_BASED: long;
              readonly VARARGS: long;
              readonly VOLATILE: int;
              readonly VarFlags: int;
              _modifierSets: java.util.Map<long,java.util.Set<javax.lang.model.element.Modifier>>;
            }
            let Flags: _Flags$$static;
            interface _Flags {
            }
            interface Flags extends CombineTypes<[_Flags, java.lang.Object]> {}
            interface _Flags$Flag$$static extends ClassLike {
              valueOf(name: string): Flags$Flag;
              values(): Flags$Flag[];
              readonly ABSTRACT: Flags$Flag;
              readonly ACYCLIC: Flags$Flag;
              readonly ACYCLIC_ANN: Flags$Flag;
              readonly ANNOTATION: Flags$Flag;
              readonly ANONCONSTR: Flags$Flag;
              readonly ANONCONSTR_BASED: Flags$Flag;
              readonly AUTOMATIC_MODULE: Flags$Flag;
              readonly AUXILIARY: Flags$Flag;
              readonly BAD_OVERRIDE: Flags$Flag;
              readonly BLOCK: Flags$Flag;
              readonly BRIDGE: Flags$Flag;
              readonly CLASH: Flags$Flag;
              readonly CLASS_SEEN: Flags$Flag;
              readonly COMPOUND: Flags$Flag;
              readonly DEFAULT: Flags$Flag;
              readonly DEPRECATED: Flags$Flag;
              readonly DEPRECATED_ANNOTATION: Flags$Flag;
              readonly DEPRECATED_REMOVAL: Flags$Flag;
              readonly EFFECTIVELY_FINAL: Flags$Flag;
              readonly ENUM: Flags$Flag;
              readonly EXISTS: Flags$Flag;
              readonly FINAL: Flags$Flag;
              readonly FROM_SOURCE: Flags$Flag;
              readonly GENERATEDCONSTR: Flags$Flag;
              readonly HASINIT: Flags$Flag;
              readonly HAS_RESOURCE: Flags$Flag;
              readonly HYPOTHETICAL: Flags$Flag;
              readonly INTERFACE: Flags$Flag;
              readonly LAMBDA_METHOD: Flags$Flag;
              readonly LOCKED: Flags$Flag;
              readonly MANDATED: Flags$Flag;
              readonly MATCH_BINDING: Flags$Flag;
              readonly MATCH_BINDING_TO_OUTER: Flags$Flag;
              readonly MODULE: Flags$Flag;
              readonly NAME_FILLED: Flags$Flag;
              readonly NATIVE: Flags$Flag;
              readonly NON_SEALED: Flags$Flag;
              readonly NOOUTERTHIS: Flags$Flag;
              readonly NOT_IN_PROFILE: Flags$Flag;
              readonly PARAMETER: Flags$Flag;
              readonly PREVIEW_API: Flags$Flag;
              readonly PREVIEW_REFLECTIVE: Flags$Flag;
              readonly PRIVATE: Flags$Flag;
              readonly PROPRIETARY: Flags$Flag;
              readonly PROTECTED: Flags$Flag;
              readonly PUBLIC: Flags$Flag;
              readonly RECORD: Flags$Flag;
              readonly RECOVERABLE: Flags$Flag;
              readonly SEALED: Flags$Flag;
              readonly SIGNATURE_POLYMORPHIC: Flags$Flag;
              readonly SOURCE_SEEN: Flags$Flag;
              readonly STATIC: Flags$Flag;
              readonly STRICTFP: Flags$Flag;
              readonly SYNCHRONIZED: Flags$Flag;
              readonly SYNTHETIC: Flags$Flag;
              readonly SYSTEM_MODULE: Flags$Flag;
              readonly THROWS: Flags$Flag;
              readonly TRANSIENT: Flags$Flag;
              readonly TYPE_TRANSLATED: Flags$Flag;
              readonly UNATTRIBUTED: Flags$Flag;
              readonly UNION: Flags$Flag;
              readonly UNNAMED_CLASS: Flags$Flag;
              readonly VARARGS: Flags$Flag;
              readonly VOLATILE: Flags$Flag;
            }
            let Flags$Flag: _Flags$Flag$$static;
            interface _Flags$Flag {
              toString(): string;
              _lowercaseName: string;
              _value: long;
            }
            interface Flags$Flag extends CombineTypes<[_Flags$Flag]> {}
            interface _Kinds$$static extends ClassLike {
              kindName(mode: sun.source.tree.MemberReferenceTree$ReferenceMode): Kinds$KindName;
              kindName(sym: Symbol): Kinds$KindName;
              typeKindName(t: Type): Kinds$KindName;
            }
            let Kinds: _Kinds$$static;
            interface _Kinds {
            }
            interface Kinds extends CombineTypes<[_Kinds, java.lang.Object]> {}
            interface _Kinds$Kind$$static extends ClassLike {
              valueOf(name: string): Kinds$Kind;
              values(): Kinds$Kind[];
              readonly ABSENT_MTH: Kinds$Kind;
              readonly ABSENT_TYP: Kinds$Kind;
              readonly ABSENT_VAR: Kinds$Kind;
              readonly AMBIGUOUS: Kinds$Kind;
              readonly BAD_RESTRICTED_TYPE: Kinds$Kind;
              readonly ERR: Kinds$Kind;
              readonly HIDDEN: Kinds$Kind;
              readonly MDL: Kinds$Kind;
              readonly MISSING_ENCL: Kinds$Kind;
              readonly MTH: Kinds$Kind;
              readonly NIL: Kinds$Kind;
              readonly PCK: Kinds$Kind;
              readonly POLY: Kinds$Kind;
              readonly STATICERR: Kinds$Kind;
              readonly TYP: Kinds$Kind;
              readonly VAR: Kinds$Kind;
              readonly WRONG_MTH: Kinds$Kind;
              readonly WRONG_MTHS: Kinds$Kind;
            }
            let Kinds$Kind: _Kinds$Kind$$static;
            interface _Kinds$Kind {
              absentKind(): Kinds$KindName;
              betterThan(other: Kinds$Kind): boolean;
              isResolutionError(): boolean;
              isResolutionTargetError(): boolean;
              isValid(): boolean;
              kindName(): Kinds$KindName;
              matches(kindSelectors: Kinds$KindSelector): boolean;
              toSelector(): Kinds$KindSelector;
              _absentKind: Kinds$KindName;
              _category: Kinds$Kind$Category;
              _kindName: Kinds$KindName;
              _selector: Kinds$KindSelector;
            }
            interface Kinds$Kind extends CombineTypes<[_Kinds$Kind]> {}
            interface _Kinds$Kind$Category$$static extends ClassLike {
              valueOf(name: string): Kinds$Kind$Category;
              values(): Kinds$Kind$Category[];
              readonly BASIC: Kinds$Kind$Category;
              readonly ERROR: Kinds$Kind$Category;
              readonly RESOLUTION: Kinds$Kind$Category;
              readonly RESOLUTION_TARGET: Kinds$Kind$Category;
            }
            let Kinds$Kind$Category: _Kinds$Kind$Category$$static;
            interface _Kinds$Kind$Category {
            }
            interface Kinds$Kind$Category extends CombineTypes<[_Kinds$Kind$Category]> {}
            interface _Kinds$KindName$$static extends ClassLike {
              valueOf(name: string): Kinds$KindName;
              values(): Kinds$KindName[];
              readonly ANNOTATION: Kinds$KindName;
              readonly BOUND: Kinds$KindName;
              readonly CLASS: Kinds$KindName;
              readonly CONSTRUCTOR: Kinds$KindName;
              readonly ENUM: Kinds$KindName;
              readonly INSTANCE_INIT: Kinds$KindName;
              readonly INTERFACE: Kinds$KindName;
              readonly METHOD: Kinds$KindName;
              readonly MODULE: Kinds$KindName;
              readonly PACKAGE: Kinds$KindName;
              readonly RECORD: Kinds$KindName;
              readonly RECORD_COMPONENT: Kinds$KindName;
              readonly STATIC: Kinds$KindName;
              readonly STATIC_INIT: Kinds$KindName;
              readonly TYPEVAR: Kinds$KindName;
              readonly VAL: Kinds$KindName;
              readonly VAR: Kinds$KindName;
            }
            let Kinds$KindName: _Kinds$KindName$$static;
            interface _Kinds$KindName {
              getKind(): string;
              toString(): string;
              toString(locale: java.util.Locale, messages: javac.api.Messages): string;
              _name: string;
            }
            interface Kinds$KindName extends CombineTypes<[_Kinds$KindName, javac.api.Formattable]> {}
            interface _Kinds$KindSelector$$static extends ClassLike {
              of(kindSelectors: Kinds$KindSelector[]): Kinds$KindSelector;
              of(...kindSelectors: Kinds$KindSelector[]): Kinds$KindSelector;
              readonly ASG: Kinds$KindSelector;
              readonly ERR: Kinds$KindSelector;
              readonly MDL: Kinds$KindSelector;
              readonly MTH: Kinds$KindSelector;
              readonly NIL: Kinds$KindSelector;
              readonly PCK: Kinds$KindSelector;
              readonly POLY: Kinds$KindSelector;
              readonly TYP: Kinds$KindSelector;
              readonly TYP_PCK: Kinds$KindSelector;
              readonly VAL: Kinds$KindSelector;
              readonly VAL_MTH: Kinds$KindSelector;
              readonly VAL_POLY: Kinds$KindSelector;
              readonly VAL_TYP: Kinds$KindSelector;
              readonly VAL_TYP_PCK: Kinds$KindSelector;
              readonly VAR: Kinds$KindSelector;
            }
            let Kinds$KindSelector: _Kinds$KindSelector$$static;
            interface _Kinds$KindSelector {
              contains(other: Kinds$KindSelector): boolean;
              kindNames(): java.util.Set<Kinds$KindName>;
              subset(other: Kinds$KindSelector): boolean;
              _data: byte;
            }
            interface Kinds$KindSelector extends CombineTypes<[_Kinds$KindSelector, java.lang.Object]> {}
            interface _Lint$$static extends ClassLike {
              instance(context: javac.util.Context): Lint;
              _lintKey: javac.util.Context$Key<Lint>;
              _map: java.util.Map<string,Lint$LintCategory>;
              _new(context: javac.util.Context): Lint;
              _new(other: Lint): Lint;
            }
            let Lint: _Lint$$static;
            interface _Lint {
              augment(attr: Attribute$Compound): Lint;
              augment(sym: Symbol): Lint;
              isEnabled(lc: Lint$LintCategory): boolean;
              isSuppressed(lc: Lint$LintCategory): boolean;
              suppress(lc: Lint$LintCategory[]): Lint;
              suppress(...lc: Lint$LintCategory[]): Lint;
              toString(): string;
              _augmentor: Lint$AugmentVisitor;
              _suppressedValues: java.util.EnumSet<Lint$LintCategory>;
              _values: java.util.EnumSet<Lint$LintCategory>;
            }
            interface Lint extends CombineTypes<[_Lint, java.lang.Object]> {}
            interface _Lint$AugmentVisitor$$static extends ClassLike {
              _new(context: javac.util.Context): Lint$AugmentVisitor;
            }
            let Lint$AugmentVisitor: _Lint$AugmentVisitor$$static;
            interface _Lint$AugmentVisitor {
              _augment(parent: Lint, attr: Attribute$Compound): Lint;
              _augment(parent: Lint, attrs: javac.util.List<Attribute$Compound>): Lint;
              _initSyms(): void;
              _suppress(lc: Lint$LintCategory): void;
              visitArray(array: Attribute$Array): void;
              visitClass(clazz: Attribute$Class): void;
              visitCompound(compound: Attribute$Compound): void;
              visitConstant(value: Attribute$Constant): void;
              visitEnum(e: Attribute$Enum): void;
              visitError(e: Attribute$Error): void;
              _context: javac.util.Context;
              _lint: Lint;
              _parent: Lint;
              _syms: Symtab;
            }
            interface Lint$AugmentVisitor extends CombineTypes<[_Lint$AugmentVisitor, com.sun.tools.javac.code.Attribute$Visitor, java.lang.Object]> {}
            interface _Lint$LintCategory$$static extends ClassLike {
              _get(option: string): Lint$LintCategory;
              valueOf(name: string): Lint$LintCategory;
              values(): Lint$LintCategory[];
              readonly AUXILIARYCLASS: Lint$LintCategory;
              readonly CAST: Lint$LintCategory;
              readonly CLASSFILE: Lint$LintCategory;
              readonly DEPRECATION: Lint$LintCategory;
              readonly DEP_ANN: Lint$LintCategory;
              readonly DIVZERO: Lint$LintCategory;
              readonly EMPTY: Lint$LintCategory;
              readonly EXPORTS: Lint$LintCategory;
              readonly FALLTHROUGH: Lint$LintCategory;
              readonly FINALLY: Lint$LintCategory;
              readonly LOSSY_CONVERSIONS: Lint$LintCategory;
              readonly MISSING_EXPLICIT_CTOR: Lint$LintCategory;
              readonly MODULE: Lint$LintCategory;
              readonly OPENS: Lint$LintCategory;
              readonly OPTIONS: Lint$LintCategory;
              readonly OUTPUT_FILE_CLASH: Lint$LintCategory;
              readonly OVERLOADS: Lint$LintCategory;
              readonly OVERRIDES: Lint$LintCategory;
              readonly PATH: Lint$LintCategory;
              readonly PREVIEW: Lint$LintCategory;
              readonly PROCESSING: Lint$LintCategory;
              readonly RAW: Lint$LintCategory;
              readonly REMOVAL: Lint$LintCategory;
              readonly REQUIRES_AUTOMATIC: Lint$LintCategory;
              readonly REQUIRES_TRANSITIVE_AUTOMATIC: Lint$LintCategory;
              readonly SERIAL: Lint$LintCategory;
              readonly STATIC: Lint$LintCategory;
              readonly STRICTFP: Lint$LintCategory;
              readonly SYNCHRONIZATION: Lint$LintCategory;
              readonly TEXT_BLOCKS: Lint$LintCategory;
              readonly THIS_ESCAPE: Lint$LintCategory;
              readonly TRY: Lint$LintCategory;
              readonly UNCHECKED: Lint$LintCategory;
              readonly VARARGS: Lint$LintCategory;
            }
            let Lint$LintCategory: _Lint$LintCategory$$static;
            interface _Lint$LintCategory {
              readonly hidden: boolean;
              readonly option: string;
            }
            interface Lint$LintCategory extends CombineTypes<[_Lint$LintCategory]> {}
            interface _MissingInfoHandler$$static extends ClassLike {
              instance(context: javac.util.Context): MissingInfoHandler;
              _missingInfoHandlerWrapperKey: javac.util.Context$Key<MissingInfoHandler>;
              _new(context: javac.util.Context): MissingInfoHandler;
            }
            let MissingInfoHandler: _MissingInfoHandler$$static;
            interface _MissingInfoHandler {
              getParameterName(parameter: Symbol$ParamSymbol): javac.util.Name;
              setDelegate(delegate: sun.source.util.ParameterNameProvider): void;
              _names: javac.util.Names;
              _parameterNameProvider: sun.source.util.ParameterNameProvider;
            }
            interface MissingInfoHandler extends CombineTypes<[_MissingInfoHandler, java.lang.Object]> {}
            interface _ModuleFinder$$static extends ClassLike {
              instance(context: javac.util.Context): ModuleFinder;
              _moduleFinderKey: javac.util.Context$Key<ModuleFinder>;
              _new(context: javac.util.Context): ModuleFinder;
            }
            let ModuleFinder: _ModuleFinder$$static;
            interface _ModuleFinder {
              findAllModules(): javac.util.List<Symbol$ModuleSymbol>;
              findModule(name: javac.util.Name): Symbol$ModuleSymbol;
              findModule(msym: Symbol$ModuleSymbol): Symbol$ModuleSymbol;
              _findModuleInfo(msym: Symbol$ModuleSymbol): void;
              findSingleModule(): Symbol$ModuleSymbol;
              _getDescription(l: javax.tools.StandardLocation): javac.util.JCDiagnostic$Fragment;
              _getModuleInfoFromLocation(location: javax.tools.JavaFileManager$Location, kind: javax.tools.JavaFileObject$Kind): javax.tools.JavaFileObject;
              _preferredFileObject(fo1: javax.tools.JavaFileObject, fo2: javax.tools.JavaFileObject): javax.tools.JavaFileObject;
              _readModule(fo: javax.tools.JavaFileObject): Symbol$ModuleSymbol;
              _readModuleName(jfo: javax.tools.JavaFileObject): string;
              _scanModulePath(toFind: Symbol$ModuleSymbol): javac.util.List<Symbol$ModuleSymbol>;
              _classFinder: ClassFinder;
              _dcfh: DeferredCompletionFailureHandler;
              _diags: javac.util.JCDiagnostic$Factory;
              _fileManager: javax.tools.JavaFileManager;
              _log: javac.util.Log;
              _moduleLocationIterator: ModuleFinder$ModuleLocationIterator;
              moduleNameFromSourceReader: ModuleFinder$ModuleNameFromSourceReader;
              _moduleNameReader: javac.jvm.ModuleNameReader;
              _names: javac.util.Names;
              _syms: Symtab;
            }
            interface ModuleFinder extends CombineTypes<[_ModuleFinder, java.lang.Object]> {}
            interface _ModuleFinder$ModuleLocationIterator$$static extends ClassLike {
              _new(this$0: ModuleFinder): ModuleFinder$ModuleLocationIterator;
            }
            let ModuleFinder$ModuleLocationIterator: _ModuleFinder$ModuleLocationIterator$$static;
            interface _ModuleFinder$ModuleLocationIterator {
              hasNext(): boolean;
              next(): java.util.Set<javax.tools.JavaFileManager$Location>;
              next(): any;
              _innerIter: java.util.Iterator<java.util.Set<javax.tools.JavaFileManager$Location>>;
              _next: java.util.Set<javax.tools.JavaFileManager$Location>;
              _outer: javax.tools.StandardLocation;
              _outerIter: java.util.Iterator<javax.tools.StandardLocation>;
              _this$0: ModuleFinder;
            }
            interface ModuleFinder$ModuleLocationIterator extends CombineTypes<[_ModuleFinder$ModuleLocationIterator, java.util.Iterator<java.util.Set<javax.tools.JavaFileManager$Location>>, java.lang.Object]> {}
            interface _ModuleFinder$ModuleNameFromSourceReader$$static extends ClassLike {
            }
            let ModuleFinder$ModuleNameFromSourceReader: _ModuleFinder$ModuleNameFromSourceReader$$static;
            interface _ModuleFinder$ModuleNameFromSourceReader {
              readModuleName(a0: javax.tools.JavaFileObject): javac.util.Name;
(a0: javax.tools.JavaFileObject): javac.util.Name;
            }
            interface ModuleFinder$ModuleNameFromSourceReader extends CombineTypes<[_ModuleFinder$ModuleNameFromSourceReader, java.lang.Object]> {}
            interface _Preview$$static extends ClassLike {
              instance(context: javac.util.Context): Preview;
              _previewKey: javac.util.Context$Key<Preview>;
              _new(context: javac.util.Context): Preview;
            }
            let Preview: _Preview$$static;
            interface _Preview {
              checkSourceLevel(pos: javac.util.JCDiagnostic$DiagnosticPosition, feature: Source$Feature): void;
              clear(): void;
              declaredUsingPreviewFeature(sym: Symbol): boolean;
              disabledError(feature: Source$Feature): javac.util.JCDiagnostic$Error;
              disabledError(classfile: javax.tools.JavaFileObject, majorVersion: int): javac.util.JCDiagnostic$Error;
              _initMajorVersionToSourceMap(): java.util.Map<int,Source>;
              isEnabled(): boolean;
              isPreview(feature: Source$Feature): boolean;
              markUsesPreview(pos: javac.util.JCDiagnostic$DiagnosticPosition): void;
              participatesInPreview(syms: Symtab, s: Symbol, previewSymbol: Symbol): boolean;
              reportDeferredDiagnostics(): void;
              reportPreviewWarning(pos: javac.util.JCDiagnostic$DiagnosticPosition, warnKey: javac.util.JCDiagnostic$Warning): void;
              usesPreview(file: javax.tools.JavaFileObject): boolean;
              warnPreview(pos: int, feature: Source$Feature): void;
              warnPreview(pos: javac.util.JCDiagnostic$DiagnosticPosition, feature: Source$Feature): void;
              warnPreview(classfile: javax.tools.JavaFileObject, majorVersion: int): void;
              _enabled: boolean;
              _forcePreview: boolean;
              _lint: Lint;
              _log: javac.util.Log;
              _majorVersionToSource: java.util.Map<int,Source>;
              _names: javac.util.Names;
              _previewHandler: javac.util.MandatoryWarningHandler;
              _source: Source;
              _sourcesWithPreviewFeatures: java.util.Set<javax.tools.JavaFileObject>;
            }
            interface Preview extends CombineTypes<[_Preview, java.lang.Object]> {}
            interface _Printer$$static extends ClassLike {
              createStandardPrinter(messages: javac.api.Messages): Printer;
              _PRIME: int;
              _new(): Printer;
            }
            let Printer: _Printer$$static;
            interface _Printer {
              _capturedVarId(a0: Type$CapturedType, a1: java.util.Locale): string;
              _className(t: Type$ClassType, longform: boolean, locale: java.util.Locale): string;
              _localize(a0: java.util.Locale, a1: string, a2: any[]): string;
              _localize(a0: java.util.Locale, a1: string, ...a2: any[]): string;
              _printAnnotations(t: Type): string;
              _printAnnotations(t: Type, prefix: boolean): string;
              _printBaseElementType(t: Type, sb: Printer$stringBuilder, locale: java.util.Locale): void;
              _printBrackets(t: Type, sb: Printer$stringBuilder, locale: java.util.Locale): void;
              _printMethodArgs(args: javac.util.List<Type>, varArgs: boolean, locale: java.util.Locale): string;
              visit(t: Type, locale: java.util.Locale): string;
              visit(s: Symbol, locale: java.util.Locale): string;
              visitArrayType(t: Type$ArrayType, locale: java.util.Locale): string;
              visitArrayType(a0: Type$ArrayType, a1: any): any;
              visitCapturedType(t: Type$CapturedType, locale: java.util.Locale): string;
              visitCapturedType(a0: Type$CapturedType, a1: any): any;
              visitClassSymbol(sym: Symbol$ClassSymbol, locale: java.util.Locale): string;
              visitClassSymbol(a0: Symbol$ClassSymbol, a1: any): any;
              visitClassType(t: Type$ClassType, locale: java.util.Locale): string;
              visitClassType(a0: Type$ClassType, a1: any): any;
              visitErrorType(t: Type$ErrorType, locale: java.util.Locale): string;
              visitErrorType(a0: Type$ErrorType, a1: any): any;
              visitForAll(t: Type$ForAll, locale: java.util.Locale): string;
              visitForAll(a0: Type$ForAll, a1: any): any;
              visitMethodSymbol(s: Symbol$MethodSymbol, locale: java.util.Locale): string;
              visitMethodSymbol(a0: Symbol$MethodSymbol, a1: any): any;
              visitMethodType(t: Type$MethodType, locale: java.util.Locale): string;
              visitMethodType(a0: Type$MethodType, a1: any): any;
              visitModuleType(t: Type$ModuleType, locale: java.util.Locale): string;
              visitModuleType(a0: Type$ModuleType, a1: any): any;
              visitOperatorSymbol(s: Symbol$OperatorSymbol, locale: java.util.Locale): string;
              visitOperatorSymbol(a0: Symbol$OperatorSymbol, a1: any): any;
              visitPackageSymbol(s: Symbol$PackageSymbol, locale: java.util.Locale): string;
              visitPackageSymbol(a0: Symbol$PackageSymbol, a1: any): any;
              visitPackageType(t: Type$PackageType, locale: java.util.Locale): string;
              visitPackageType(a0: Type$PackageType, a1: any): any;
              visitSymbol(s: Symbol, locale: java.util.Locale): string;
              visitSymbol(a0: Symbol, a1: any): any;
              visitSymbols(ts: javac.util.List<Symbol>, locale: java.util.Locale): string;
              visitType(t: Type, locale: java.util.Locale): string;
              visitType(a0: Type, a1: any): any;
              visitTypeSymbol(s: Symbol$TypeSymbol, locale: java.util.Locale): string;
              visitTypeSymbol(a0: Symbol$TypeSymbol, a1: any): any;
              visitTypeVar(t: Type$TypeVar, locale: java.util.Locale): string;
              visitTypeVar(a0: Type$TypeVar, a1: any): any;
              visitTypes(ts: javac.util.List<Type>, locale: java.util.Locale): string;
              visitUndetVar(t: Type$UndetVar, locale: java.util.Locale): string;
              visitUndetVar(a0: Type$UndetVar, a1: any): any;
              visitVarSymbol(s: Symbol$VarSymbol, locale: java.util.Locale): string;
              visitVarSymbol(a0: Symbol$VarSymbol, a1: any): any;
              visitWildcardType(t: Type$WildcardType, locale: java.util.Locale): string;
              visitWildcardType(a0: Type$WildcardType, a1: any): any;
              _seenCaptured: javac.util.List<Type>;
            }
            interface Printer extends CombineTypes<[_Printer, Symbol$Visitor<string,java.util.Locale>, java.lang.Object, Type$Visitor<string,java.util.Locale>]> {}
            interface _Scope$$static extends ClassLike {
              _noFilter: java.util.function.Predicate<Symbol>;
              _new(owner: Symbol): Scope;
            }
            let Scope: _Scope$$static;
            interface _Scope {
              anyMatch(filter: java.util.function.Predicate<Symbol>): boolean;
              findFirst(name: javac.util.Name): Symbol;
              findFirst(name: javac.util.Name, sf: java.util.function.Predicate<Symbol>): Symbol;
              getOrigin(a0: Symbol): Scope;
              getSymbols(): java.lang.Iterable<Symbol>;
              getSymbols(sf: java.util.function.Predicate<Symbol>): java.lang.Iterable<Symbol>;
              getSymbols(lookupKind: Scope$LookupKind): java.lang.Iterable<Symbol>;
              getSymbols(a0: java.util.function.Predicate<Symbol>, a1: Scope$LookupKind): java.lang.Iterable<Symbol>;
              getSymbolsByName(name: javac.util.Name): java.lang.Iterable<Symbol>;
              getSymbolsByName(name: javac.util.Name, sf: java.util.function.Predicate<Symbol>): java.lang.Iterable<Symbol>;
              getSymbolsByName(name: javac.util.Name, lookupKind: Scope$LookupKind): java.lang.Iterable<Symbol>;
              getSymbolsByName(a0: javac.util.Name, a1: java.util.function.Predicate<Symbol>, a2: Scope$LookupKind): java.lang.Iterable<Symbol>;
              includes(sym: Symbol): boolean;
              includes(sym: Symbol, lookupKind: Scope$LookupKind): boolean;
              isEmpty(): boolean;
              isStaticallyImported(a0: Symbol): boolean;
              _listeners: Scope$ScopeListenerList;
              readonly owner: Symbol;
            }
            interface Scope extends CombineTypes<[_Scope, java.lang.Object]> {}
            interface _Scope$CompoundScope$$static extends ClassLike {
              new(owner: Symbol): Scope$CompoundScope;
            }
            let Scope$CompoundScope: _Scope$CompoundScope$$static;
            interface _Scope$CompoundScope {
              appendSubScope(that: Scope): void;
              getMark(): int;
              getOrigin(sym: Symbol): Scope;
              getSymbols(sf: java.util.function.Predicate<Symbol>, lookupKind: Scope$LookupKind): java.lang.Iterable<Symbol>;
              getSymbolsByName(name: javac.util.Name, sf: java.util.function.Predicate<Symbol>, lookupKind: Scope$LookupKind): java.lang.Iterable<Symbol>;
              isStaticallyImported(sym: Symbol): boolean;
              prependSubScope(that: Scope): void;
              symbolAdded(sym: Symbol, s: Scope): void;
              symbolRemoved(sym: Symbol, s: Scope): void;
              toString(): string;
              _mark: int;
              _subScopes: javac.util.ListBuffer<Scope>;
            }
            interface Scope$CompoundScope extends CombineTypes<[_Scope$CompoundScope, com.sun.tools.javac.code.Scope$ScopeListener, com.sun.tools.javac.code.Scope]> {}
            interface _Scope$Entry$$static extends ClassLike {
              new(sym: Symbol, shadowed: Scope$Entry, nextSibling: Scope$Entry, scope: Scope$ScopeImpl): Scope$Entry;
            }
            let Scope$Entry: _Scope$Entry$$static;
            interface _Scope$Entry {
              next(): Scope$Entry;
              next(sf: java.util.function.Predicate<Symbol>): Scope$Entry;
              nextSibling: Scope$Entry;
              prevSibling: Scope$Entry;
              scope: Scope$ScopeImpl;
              _shadowed: Scope$Entry;
              sym: Symbol;
            }
            interface Scope$Entry extends CombineTypes<[_Scope$Entry, java.lang.Object]> {}
            interface _Scope$ErrorScope$$static extends ClassLike {
              _new(next: Scope$ScopeImpl, errSymbol: Symbol, table: Scope$Entry[]): Scope$ErrorScope;
              new(errSymbol: Symbol): Scope$ErrorScope;
            }
            let Scope$ErrorScope: _Scope$ErrorScope$$static;
            interface _Scope$ErrorScope {
              anyMatch(a0: java.util.function.Predicate): boolean;
              dup(newOwner: Symbol): Scope$WriteableScope;
              dupUnshared(newOwner: Symbol): Scope$WriteableScope;
              enter(a0: Symbol): void;
              enterIfAbsent(a0: Symbol): void;
              findFirst(a0: javac.util.Name, a1: java.util.function.Predicate): Symbol;
              getOrigin(a0: Symbol): Scope;
              getSymbols(a0: java.util.function.Predicate, a1: Scope$LookupKind): java.lang.Iterable;
              getSymbolsByName(a0: javac.util.Name, a1: java.util.function.Predicate, a2: Scope$LookupKind): java.lang.Iterable;
              includes(a0: Symbol): boolean;
              isStaticallyImported(a0: Symbol): boolean;
              leave(): Scope$WriteableScope;
              lookup(name: javac.util.Name): Scope$Entry;
              remove(a0: Symbol): void;
              toString(): string;
            }
            interface Scope$ErrorScope extends CombineTypes<[_Scope$ErrorScope, com.sun.tools.javac.code.Scope$ScopeImpl]> {}
            interface _Scope$FilterImportScope$$static extends ClassLike {
              new(types: Types, origin: Scope, filterName: javac.util.Name, filter: Scope$ImportFilter, imp: javac.tree.JCTree$JCImport, cfHandler: java.util.function.BiConsumer<javac.tree.JCTree$JCImport,Symbol$CompletionFailure>): Scope$FilterImportScope;
            }
            let Scope$FilterImportScope: _Scope$FilterImportScope$$static;
            interface _Scope$FilterImportScope {
              getOrigin(byName: Symbol): Scope;
              getSymbols(sf: java.util.function.Predicate<Symbol>, lookupKind: Scope$LookupKind): java.lang.Iterable<Symbol>;
              getSymbolsByName(name: javac.util.Name, sf: java.util.function.Predicate<Symbol>, lookupKind: Scope$LookupKind): java.lang.Iterable<Symbol>;
              isStaticallyImported(byName: Symbol): boolean;
              isStaticallyImported(): boolean;
              _cfHandler: java.util.function.BiConsumer<javac.tree.JCTree$JCImport,Symbol$CompletionFailure>;
              _filter: Scope$ImportFilter;
              _filterName: javac.util.Name;
              _imp: javac.tree.JCTree$JCImport;
              _origin: Scope;
              _types: Types;
            }
            interface Scope$FilterImportScope extends CombineTypes<[_Scope$FilterImportScope, com.sun.tools.javac.code.Scope]> {}
            interface _Scope$FilterImportScope$SymbolImporter$$static extends ClassLike {
              new(this$0: Scope$FilterImportScope, inspectSuperTypes: boolean): Scope$FilterImportScope$SymbolImporter;
            }
            let Scope$FilterImportScope$SymbolImporter: _Scope$FilterImportScope$SymbolImporter$$static;
            interface _Scope$FilterImportScope$SymbolImporter {
              _doLookup(a0: Symbol$TypeSymbol): java.lang.Iterable<Symbol>;
(a0: Symbol$TypeSymbol): java.lang.Iterable<Symbol>;
              _importFrom(tsym: Symbol$TypeSymbol, results: javac.util.List<java.lang.Iterable<Symbol>>): javac.util.List<java.lang.Iterable<Symbol>>;
              _delegates: javac.util.List<java.lang.Iterable<Symbol>>;
              _inspectSuperTypes: boolean;
              _processed: java.util.Set<Symbol>;
              _this$0: Scope$FilterImportScope;
            }
            interface Scope$FilterImportScope$SymbolImporter extends CombineTypes<[_Scope$FilterImportScope$SymbolImporter, java.lang.Object]> {}
            interface _Scope$ImportFilter$$static extends ClassLike {
            }
            let Scope$ImportFilter: _Scope$ImportFilter$$static;
            interface _Scope$ImportFilter {
              accepts(a0: Scope, a1: Symbol): boolean;
(a0: Scope, a1: Symbol): boolean;
            }
            interface Scope$ImportFilter extends CombineTypes<[_Scope$ImportFilter, java.lang.Object]> {}
            interface _Scope$ImportScope$$static extends ClassLike {
              new(owner: Symbol): Scope$ImportScope;
            }
            let Scope$ImportScope: _Scope$ImportScope$$static;
            interface _Scope$ImportScope {
              finalizeScope(): void;
              _finalizeSingleScope(impScope: Scope): Scope;
            }
            interface Scope$ImportScope extends CombineTypes<[_Scope$ImportScope, com.sun.tools.javac.code.Scope$CompoundScope]> {}
            interface _Scope$LookupKind$$static extends ClassLike {
              valueOf(name: string): Scope$LookupKind;
              values(): Scope$LookupKind[];
              readonly NON_RECURSIVE: Scope$LookupKind;
              readonly RECURSIVE: Scope$LookupKind;
            }
            let Scope$LookupKind: _Scope$LookupKind$$static;
            interface _Scope$LookupKind {
            }
            interface Scope$LookupKind extends CombineTypes<[_Scope$LookupKind]> {}
            interface _Scope$NamedImportScope$$static extends ClassLike {
              new(owner: Symbol): Scope$NamedImportScope;
            }
            let Scope$NamedImportScope: _Scope$NamedImportScope$$static;
            interface _Scope$NamedImportScope {
              _appendScope(newScope: Scope, name: javac.util.Name): Scope;
              finalizeScope(): void;
              getSymbolsByName(name: javac.util.Name, sf: java.util.function.Predicate<Symbol>, lookupKind: Scope$LookupKind): java.lang.Iterable<Symbol>;
              importByName(types: Types, origin: Scope, name: javac.util.Name, filter: Scope$ImportFilter, imp: javac.tree.JCTree$JCImport, cfHandler: java.util.function.BiConsumer<javac.tree.JCTree$JCImport,Symbol$CompletionFailure>): Scope;
              importType(delegate: Scope, origin: Scope, sym: Symbol): Scope;
              _name2Scopes: java.util.Map<javac.util.Name,Scope[]>;
            }
            interface Scope$NamedImportScope extends CombineTypes<[_Scope$NamedImportScope, com.sun.tools.javac.code.Scope$ImportScope]> {}
            interface _Scope$NamedImportScope$SingleEntryScope$$static extends ClassLike {
              new(owner: Symbol, sym: Symbol, origin: Scope): Scope$NamedImportScope$SingleEntryScope;
            }
            let Scope$NamedImportScope$SingleEntryScope: _Scope$NamedImportScope$SingleEntryScope$$static;
            interface _Scope$NamedImportScope$SingleEntryScope {
              getOrigin(byName: Symbol): Scope;
              getSymbols(sf: java.util.function.Predicate<Symbol>, lookupKind: Scope$LookupKind): java.lang.Iterable<Symbol>;
              getSymbolsByName(name: javac.util.Name, sf: java.util.function.Predicate<Symbol>, lookupKind: Scope$LookupKind): java.lang.Iterable<Symbol>;
              isStaticallyImported(byName: Symbol): boolean;
              _content: javac.util.List<Symbol>;
              _origin: Scope;
              _sym: Symbol;
            }
            interface Scope$NamedImportScope$SingleEntryScope extends CombineTypes<[_Scope$NamedImportScope$SingleEntryScope, com.sun.tools.javac.code.Scope]> {}
            interface _Scope$ScopeImpl$$static extends ClassLike {
              _INITIAL_SIZE: int;
              _sentinel: Scope$Entry;
              new(owner: Symbol): Scope$ScopeImpl;
            }
            let Scope$ScopeImpl: _Scope$ScopeImpl$$static;
            interface _Scope$ScopeImpl {
              anyMatch(sf: java.util.function.Predicate<Symbol>): boolean;
              _dble(): void;
              dup(newOwner: Symbol): Scope$WriteableScope;
              dupUnshared(newOwner: Symbol): Scope$WriteableScope;
              enter(sym: Symbol): void;
              enterIfAbsent(sym: Symbol): void;
              findFirst(name: javac.util.Name, sf: java.util.function.Predicate<Symbol>): Symbol;
              _getIndex(name: javac.util.Name): int;
              getOrigin(s: Symbol): Scope;
              getSymbols(sf: java.util.function.Predicate<Symbol>, lookupKind: Scope$LookupKind): java.lang.Iterable<Symbol>;
              getSymbolsByName(name: javac.util.Name, sf: java.util.function.Predicate<Symbol>, lookupKind: Scope$LookupKind): java.lang.Iterable<Symbol>;
              includes(c: Symbol): boolean;
              isStaticallyImported(s: Symbol): boolean;
              leave(): Scope$WriteableScope;
              _lookup(name: javac.util.Name): Scope$Entry;
              _lookup(name: javac.util.Name, sf: java.util.function.Predicate<Symbol>): Scope$Entry;
              remove(sym: Symbol): void;
              toString(): string;
              elems: Scope$Entry;
              _hashMask: int;
              _nelems: int;
              next: Scope$ScopeImpl;
              _removeCount: int;
              _shared: boolean;
              _table: Scope$Entry[];
            }
            interface Scope$ScopeImpl extends CombineTypes<[_Scope$ScopeImpl, com.sun.tools.javac.code.Scope$WriteableScope]> {}
            interface _Scope$ScopeListener$$static extends ClassLike {
            }
            let Scope$ScopeListener: _Scope$ScopeListener$$static;
            interface _Scope$ScopeListener {
              symbolAdded(a0: Symbol, a1: Scope): void;
              symbolRemoved(a0: Symbol, a1: Scope): void;
            }
            interface Scope$ScopeListener extends CombineTypes<[_Scope$ScopeListener, java.lang.Object]> {}
            interface _Scope$ScopeListenerList$$static extends ClassLike {
              new(): Scope$ScopeListenerList;
            }
            let Scope$ScopeListenerList: _Scope$ScopeListenerList$$static;
            interface _Scope$ScopeListenerList {
              _add(sl: Scope$ScopeListener): void;
              _symbolAdded(sym: Symbol, scope: Scope): void;
              _symbolRemoved(sym: Symbol, scope: Scope): void;
              _walkReferences(sym: Symbol, scope: Scope, isRemove: boolean): void;
              _listeners: javac.util.List<java.lang.ref.WeakReference<Scope$ScopeListener>>;
            }
            interface Scope$ScopeListenerList extends CombineTypes<[_Scope$ScopeListenerList, java.lang.Object]> {}
            interface _Scope$StarImportScope$$static extends ClassLike {
              new(owner: Symbol): Scope$StarImportScope;
            }
            let Scope$StarImportScope: _Scope$StarImportScope$$static;
            interface _Scope$StarImportScope {
              importAll(types: Types, origin: Scope, filter: Scope$ImportFilter, imp: javac.tree.JCTree$JCImport, cfHandler: java.util.function.BiConsumer<javac.tree.JCTree$JCImport,Symbol$CompletionFailure>): void;
              isFilled(): boolean;
            }
            interface Scope$StarImportScope extends CombineTypes<[_Scope$StarImportScope, com.sun.tools.javac.code.Scope$ImportScope]> {}
            interface _Scope$WriteableScope$$static extends ClassLike {
              create(owner: Symbol): Scope$WriteableScope;
              new(owner: Symbol): Scope$WriteableScope;
            }
            let Scope$WriteableScope: _Scope$WriteableScope$$static;
            interface _Scope$WriteableScope {
              dup(): Scope$WriteableScope;
              dup(a0: Symbol): Scope$WriteableScope;
              dupUnshared(): Scope$WriteableScope;
              dupUnshared(a0: Symbol): Scope$WriteableScope;
              enter(a0: Symbol): void;
              enterIfAbsent(a0: Symbol): void;
              leave(): Scope$WriteableScope;
              remove(a0: Symbol): void;
            }
            interface Scope$WriteableScope extends CombineTypes<[_Scope$WriteableScope, com.sun.tools.javac.code.Scope]> {}
            interface _Source$$static extends ClassLike {
              instance(context: javac.util.Context): Source;
              lookup(name: string): Source;
              toSourceVersion(source: Source): javax.lang.model.SourceVersion;
              valueOf(name: string): Source;
              values(): Source[];
              readonly DEFAULT: Source;
              readonly JDK10: Source;
              readonly JDK11: Source;
              readonly JDK12: Source;
              readonly JDK13: Source;
              readonly JDK14: Source;
              readonly JDK15: Source;
              readonly JDK16: Source;
              readonly JDK17: Source;
              readonly JDK18: Source;
              readonly JDK19: Source;
              readonly JDK1_2: Source;
              readonly JDK1_3: Source;
              readonly JDK1_4: Source;
              readonly JDK20: Source;
              readonly JDK21: Source;
              readonly JDK5: Source;
              readonly JDK6: Source;
              readonly JDK7: Source;
              readonly JDK8: Source;
              readonly JDK9: Source;
              _MAX: Source;
              readonly MIN: Source;
              _sourceKey: javac.util.Context$Key<Source>;
              _tab: java.util.Map<string,Source>;
            }
            let Source: _Source$$static;
            interface _Source {
              isSupported(): boolean;
              requiredTarget(): javac.jvm.Target;
              readonly name: string;
            }
            interface Source extends CombineTypes<[_Source]> {}
            interface _Source$Feature$$static extends ClassLike {
              valueOf(name: string): Source$Feature;
              values(): Source$Feature[];
              readonly CASE_NULL: Source$Feature;
              readonly DEPRECATION_ON_IMPORT: Source$Feature;
              readonly DIAMOND_WITH_ANONYMOUS_CLASS_CREATION: Source$Feature;
              readonly EFFECTIVELY_FINAL_VARIABLES_IN_TRY_WITH_RESOURCES: Source$Feature;
              readonly IMPORT_ON_DEMAND_OBSERVABLE_PACKAGES: Source$Feature;
              readonly LOCAL_VARIABLE_TYPE_INFERENCE: Source$Feature;
              readonly MODULES: Source$Feature;
              readonly NO_TARGET_ANNOTATION_APPLICABILITY: Source$Feature;
              readonly PATTERN_MATCHING_IN_INSTANCEOF: Source$Feature;
              readonly PATTERN_SWITCH: Source$Feature;
              readonly PRIVATE_INTERFACE_METHODS: Source$Feature;
              readonly PRIVATE_SAFE_VARARGS: Source$Feature;
              readonly RECORDS: Source$Feature;
              readonly RECORD_PATTERNS: Source$Feature;
              readonly REDUNDANT_STRICTFP: Source$Feature;
              readonly REIFIABLE_TYPES_INSTANCEOF: Source$Feature;
              readonly SEALED_CLASSES: Source$Feature;
              readonly STRING_TEMPLATES: Source$Feature;
              readonly SWITCH_EXPRESSION: Source$Feature;
              readonly SWITCH_MULTIPLE_CASE_LABELS: Source$Feature;
              readonly SWITCH_RULE: Source$Feature;
              readonly TEXT_BLOCKS: Source$Feature;
              readonly UNCONDITIONAL_PATTERN_IN_INSTANCEOF: Source$Feature;
              readonly UNDERSCORE_IDENTIFIER: Source$Feature;
              readonly UNNAMED_CLASSES: Source$Feature;
              readonly UNNAMED_VARIABLES: Source$Feature;
              readonly VAR_SYNTAX_IMPLICIT_LAMBDAS: Source$Feature;
              readonly WARN_ON_ILLEGAL_UTF8: Source$Feature;
            }
            let Source$Feature: _Source$Feature$$static;
            interface _Source$Feature {
              allowedInSource(source: Source): boolean;
              error(sourceName: string): javac.util.JCDiagnostic$Error;
              fragment(sourceName: string): javac.util.JCDiagnostic$Fragment;
              isPlural(): boolean;
              nameFragment(): javac.util.JCDiagnostic$Fragment;
              _maxLevel: Source;
              _minLevel: Source;
              _optFragment: javac.util.JCDiagnostic$Fragment;
              _optKind: Source$Feature$DiagKind;
            }
            interface Source$Feature extends CombineTypes<[_Source$Feature]> {}
            interface _Source$Feature$DiagKind$$static extends ClassLike {
              valueOf(name: string): Source$Feature$DiagKind;
              values(): Source$Feature$DiagKind[];
              readonly NORMAL: Source$Feature$DiagKind;
              readonly PLURAL: Source$Feature$DiagKind;
            }
            let Source$Feature$DiagKind: _Source$Feature$DiagKind$$static;
            interface _Source$Feature$DiagKind {
            }
            interface Source$Feature$DiagKind extends CombineTypes<[_Source$Feature$DiagKind]> {}
            interface _Symbol$$static extends ClassLike {
              new(kind: Kinds$Kind, flags: long, a2: javac.util.Name, name: Type, type: Symbol): Symbol;
            }
            let Symbol: _Symbol$$static;
            interface _Symbol {
              accept<R, P>(v: Symbol$Visitor<R,P>, p: P): R;
              annotationsPendingCompletion(): boolean;
              apiComplete(): void;
              appendAttributes(l: javac.util.List<Attribute$Compound>): void;
              appendClassInitTypeAttributes(l: javac.util.List<Attribute$TypeCompound>): void;
              appendInitTypeAttributes(l: javac.util.List<Attribute$TypeCompound>): void;
              appendUniqueTypeAttributes(l: javac.util.List<Attribute$TypeCompound>): void;
              asMemberOf(site: Type, types: Types): Symbol;
              asType(): Type;
              asType(): javax.lang.model.type.TypeMirror;
              attribute(anno: Symbol): Attribute$Compound;
              baseSymbol(): Symbol;
              clone(newOwner: Symbol): Symbol;
              complete(): void;
              enclClass(): Symbol$ClassSymbol;
              erasure(types: Types): Type;
              exists(): boolean;
              externalType(types: Types): Type;
              flags(): long;
              flatName(): javac.util.Name;
              getAnnotationMirrors(): javac.util.List<Attribute$Compound>;
              getAnnotationMirrors(): java.util.List;
              getClassInitTypeAttributes(): javac.util.List<Attribute$TypeCompound>;
              getDeclarationAttributes(): javac.util.List<Attribute$Compound>;
              getEnclosedElements(): java.util.List<Symbol>;
              getEnclosingElement(): Symbol;
              getEnclosingElement(): javax.lang.model.element.Element;
              getInitTypeAttributes(): javac.util.List<Attribute$TypeCompound>;
              getKind(): javax.lang.model.element.ElementKind;
              getMetadata(): SymbolMetadata;
              getModifiers(): java.util.Set<javax.lang.model.element.Modifier>;
              getQualifiedName(): javac.util.Name;
              getRawAttributes(): javac.util.List<Attribute$Compound>;
              getRawTypeAttributes(): javac.util.List<Attribute$TypeCompound>;
              getSimpleName(): javac.util.Name;
              getSimpleName(): javax.lang.model.element.Name;
              getTypeParameters(): javac.util.List<Symbol$TypeVariableSymbol>;
              hasAnnotations(): boolean;
              hasDeprecatedAnnotation(): boolean;
              hasOuterInstance(): boolean;
              hasTypeAnnotations(): boolean;
              _hiddenIn(clazz: Symbol$ClassSymbol, types: Types): boolean;
              _hiddenInInternal(currentClass: Symbol$ClassSymbol, types: Types): Symbol;
              _initedMetadata(): SymbolMetadata;
              isAbstract(): boolean;
              isAccessibleIn(clazz: Symbol, types: Types): boolean;
              isAnonymous(): boolean;
              isCompleted(): boolean;
              isConstructor(): boolean;
              isDeprecatableViaAnnotation(): boolean;
              isDeprecated(): boolean;
              isDeprecatedForRemoval(): boolean;
              isDirectlyOrIndirectlyLocal(): boolean;
              isDynamic(): boolean;
              isEnclosedBy(clazz: Symbol$ClassSymbol): boolean;
              isEnum(): boolean;
              isFinal(): boolean;
              isInheritedIn(clazz: Symbol, types: Types): boolean;
              isInner(): boolean;
              isInterface(): boolean;
              isMemberOf(clazz: Symbol$TypeSymbol, types: Types): boolean;
              isNonSealed(): boolean;
              isPreviewApi(): boolean;
              isPrivate(): boolean;
              isPublic(): boolean;
              isSealed(): boolean;
              isStatic(): boolean;
              isSubClass(base: Symbol, types: Types): boolean;
              location(): Symbol;
              location(site: Type, types: Types): Symbol;
              members(): Scope$WriteableScope;
              outermostClass(): Symbol$ClassSymbol;
              overrides(_other: Symbol, origin: Symbol$TypeSymbol, types: Types, checkResult: boolean): boolean;
              packge(): Symbol$PackageSymbol;
              poolTag(): int;
              prependAttributes(l: javac.util.List<Attribute$Compound>): void;
              resetAnnotations(): void;
              setAttributes(other: Symbol): void;
              setClassInitTypeAttributes(l: javac.util.List<Attribute$TypeCompound>): void;
              setDeclarationAttributes(a: javac.util.List<Attribute$Compound>): void;
              setInitTypeAttributes(l: javac.util.List<Attribute$TypeCompound>): void;
              setTypeAttributes(a: javac.util.List<Attribute$TypeCompound>): void;
              toString(): string;
              completer: Symbol$Completer;
              erasure_field: Type;
              flags_field: long;
              kind: Kinds$Kind;
              _metadata: SymbolMetadata;
              name: javac.util.Name;
              owner: Symbol;
              type: Type;
            }
            interface Symbol extends CombineTypes<[_Symbol, com.sun.tools.javac.code.AnnoConstruct, javax.lang.model.element.Element, com.sun.tools.javac.jvm.PoolConstant]> {}
            interface _Symbol$BindingSymbol$$static extends ClassLike {
              new(flags: long, a1: javac.util.Name, name: Type, type: Symbol): Symbol$BindingSymbol;
            }
            let Symbol$BindingSymbol: _Symbol$BindingSymbol$$static;
            interface _Symbol$BindingSymbol {
              _aliases(): javac.util.List<Symbol$BindingSymbol>;
              isAliasFor(b: Symbol$BindingSymbol): boolean;
              isPreserved(): boolean;
              preserveBinding(): void;
            }
            interface Symbol$BindingSymbol extends CombineTypes<[_Symbol$BindingSymbol, com.sun.tools.javac.code.Symbol$VarSymbol]> {}
            interface _Symbol$ClassSymbol$$static extends ClassLike {
              new(flags: long, a1: javac.util.Name, name: Type, type: Symbol): Symbol$ClassSymbol;
              new(flags: long, a1: javac.util.Name, name: Symbol): Symbol$ClassSymbol;
            }
            let Symbol$ClassSymbol: _Symbol$ClassSymbol$$static;
            interface _Symbol$ClassSymbol {
              accept<R, P>(v: javax.lang.model.element.ElementVisitor<R,P>, p: P): R;
              accept<R, P>(v: Symbol$Visitor<R,P>, p: P): R;
              addPermittedSubclass(csym: Symbol$ClassSymbol, pos: int): void;
              className(): string;
              clearAnnotationMetadata(): void;
              clearPermittedSubclasses(): void;
              complete(): void;
              createRecordComponent(existing: Symbol$RecordComponent, rcDecl: javac.tree.JCTree$JCVariableDecl, varSym: Symbol$VarSymbol): Symbol$RecordComponent;
              erasure(types: Types): Type;
              findRecordComponentToRemove(_var: javac.tree.JCTree$JCVariableDecl): Symbol$RecordComponent;
              flags(): long;
              flatName(): javac.util.Name;
              getAnnotationTypeMetadata(): javac.comp.Annotate$AnnotationTypeMetadata;
              _getAttribute<A>(annoType: java.lang.Class<A>): Attribute$Compound;
              getEnclosedElements(): javac.util.List<Symbol>;
              getEnclosedElements(): java.util.List;
              _getInheritedAnnotations<A>(annoType: java.lang.Class<A>): A[];
              getInterfaces(): javac.util.List<Type>;
              getInterfaces(): java.util.List;
              getKind(): javax.lang.model.element.ElementKind;
              getModifiers(): java.util.Set<javax.lang.model.element.Modifier>;
              getNestingKind(): javax.lang.model.element.NestingKind;
              getPermittedSubclasses(): javac.util.List<Type>;
              getPermittedSubclasses(): java.util.List;
              getQualifiedName(): javac.util.Name;
              getQualifiedName(): javax.lang.model.element.Name;
              getRawAttributes(): javac.util.List<Attribute$Compound>;
              getRawTypeAttributes(): javac.util.List<Attribute$TypeCompound>;
              getRecordComponent(field: Symbol$VarSymbol): Symbol$RecordComponent;
              getRecordComponents(): javac.util.List<Symbol$RecordComponent>;
              getRecordComponents(): java.util.List;
              getSimpleName(): javac.util.Name;
              getSimpleName(): javax.lang.model.element.Name;
              _getSuperClassToSearchForAnnotations(): Symbol$ClassSymbol;
              getSuperclass(): Type;
              getSuperclass(): javax.lang.model.type.TypeMirror;
              getTypeParameters(): java.util.List;
              isAnnotationType(): boolean;
              isPermittedSubclass(csym: Symbol): boolean;
              isRecord(): boolean;
              isSubClass(base: Symbol, types: Types): boolean;
              isUnnamed(): boolean;
              markAbstractIfNeeded(types: Types): void;
              members(): Scope$WriteableScope;
              reset(): void;
              setAnnotationTypeMetadata(a: javac.comp.Annotate$AnnotationTypeMetadata): void;
              setPermittedSubclasses(permittedSubs: javac.util.List<Symbol>): void;
              setRecordComponents(recordComponents: javac.util.List<Symbol$RecordComponent>): void;
              toString(): string;
              _annotationTypeMetadata: javac.comp.Annotate$AnnotationTypeMetadata;
              classfile: javax.tools.JavaFileObject;
              flatname: javac.util.Name;
              fullname: javac.util.Name;
              isPermittedExplicit: boolean;
              members_field: Scope$WriteableScope;
              _permitted: java.util.List<Symbol$ClassSymbol$PermittedClassWithPos>;
              _recordComponents: javac.util.List<Symbol$RecordComponent>;
              sourcefile: javax.tools.JavaFileObject;
              trans_local: javac.util.List<Symbol$ClassSymbol>;
            }
            interface Symbol$ClassSymbol extends CombineTypes<[_Symbol$ClassSymbol, com.sun.tools.javac.code.Symbol$TypeSymbol, javax.lang.model.element.TypeElement]> {}
            interface _Symbol$ClassSymbol$PermittedClassWithPos$$static extends ClassLike {
            }
            let Symbol$ClassSymbol$PermittedClassWithPos: _Symbol$ClassSymbol$PermittedClassWithPos$$static;
            interface _Symbol$ClassSymbol$PermittedClassWithPos {
              equals(o: any): boolean;
              hashCode(): int;
              permittedClass(): Symbol;
              pos(): int;
              toString(): string;
            }
            interface Symbol$ClassSymbol$PermittedClassWithPos extends CombineTypes<[_Symbol$ClassSymbol$PermittedClassWithPos, java.lang.Record]> {}
            interface _Symbol$Completer$$static extends ClassLike {
              readonly NULL_COMPLETER: Symbol$Completer;
            }
            let Symbol$Completer: _Symbol$Completer$$static;
            interface _Symbol$Completer {
              complete(a0: Symbol): void;
(a0: Symbol): void;
              isTerminal(): boolean;
            }
            interface Symbol$Completer extends CombineTypes<[_Symbol$Completer, java.lang.Object]> {}
            interface _Symbol$CompletionFailure$$static extends ClassLike {
              _serialVersionUID: long;
              new(sym: Symbol, diagSupplier: java.util.function.Supplier<javac.util.JCDiagnostic>, dcfh: DeferredCompletionFailureHandler): Symbol$CompletionFailure;
            }
            let Symbol$CompletionFailure: _Symbol$CompletionFailure$$static;
            interface _Symbol$CompletionFailure {
              getDetailValue(): javac.util.JCDiagnostic;
              getDiagnostic(): javac.util.JCDiagnostic;
              getMessage(): string;
              initCause(cause: java.lang.Throwable): Symbol$CompletionFailure;
              initCause(a0: java.lang.Throwable): java.lang.Throwable;
              resetDiagnostic(diagSupplier: java.util.function.Supplier<javac.util.JCDiagnostic>): void;
              readonly dcfh: DeferredCompletionFailureHandler;
              _diag: javac.util.JCDiagnostic;
              _diagSupplier: java.util.function.Supplier<javac.util.JCDiagnostic>;
              sym: Symbol;
            }
            interface Symbol$CompletionFailure extends CombineTypes<[_Symbol$CompletionFailure, java.lang.RuntimeException]> {}
            interface _Symbol$DelegatedSymbol$$static<T> extends ClassLike {
              new(other: T): Symbol$DelegatedSymbol<T>;
            }
            let Symbol$DelegatedSymbol: _Symbol$DelegatedSymbol$$static<T>;
            interface _Symbol$DelegatedSymbol<T> {
              accept<R, P>(v: javax.lang.model.element.ElementVisitor<R,P>, p: P): R;
              accept<R, P>(v: Symbol$Visitor<R,P>, p: P): R;
              asMemberOf(site: Type, types: Types): Symbol;
              asType(): javax.lang.model.type.TypeMirror;
              baseSymbol(): Symbol;
              complete(): void;
              enclClass(): Symbol$ClassSymbol;
              erasure(types: Types): Type;
              externalType(types: Types): Type;
              flatName(): javac.util.Name;
              getAnnotationMirrors(): java.util.List;
              getEnclosingElement(): javax.lang.model.element.Element;
              getQualifiedName(): javac.util.Name;
              getSimpleName(): javax.lang.model.element.Name;
              getUnderlyingSymbol(): T;
              hasOuterInstance(): boolean;
              isConstructor(): boolean;
              isDirectlyOrIndirectlyLocal(): boolean;
              isEnclosedBy(clazz: Symbol$ClassSymbol): boolean;
              isInheritedIn(clazz: Symbol, types: Types): boolean;
              isInner(): boolean;
              isMemberOf(clazz: Symbol$TypeSymbol, types: Types): boolean;
              isSubClass(base: Symbol, types: Types): boolean;
              location(): Symbol;
              location(site: Type, types: Types): Symbol;
              members(): Scope$WriteableScope;
              outermostClass(): Symbol$ClassSymbol;
              packge(): Symbol$PackageSymbol;
              toString(): string;
              _other: T;
            }
            interface Symbol$DelegatedSymbol<T> extends CombineTypes<[_Symbol$DelegatedSymbol<T>, Symbol]> {}
            interface _Symbol$DynamicMethodSymbol$$static extends ClassLike {
              new(name: javac.util.Name, owner: Symbol, bsm: Symbol$MethodHandleSymbol, type: Type, staticArgs: javac.jvm.PoolConstant$LoadableConstant[]): Symbol$DynamicMethodSymbol;
            }
            let Symbol$DynamicMethodSymbol: _Symbol$DynamicMethodSymbol$$static;
            interface _Symbol$DynamicMethodSymbol {
              bootstrapMethod(): Symbol$MethodHandleSymbol;
              bootstrapMethod(): javac.jvm.PoolConstant$LoadableConstant;
              dynamicType(): Type;
              dynamicType(): javac.jvm.PoolConstant;
              isDynamic(): boolean;
              name(): javac.util.Name;
              poolTag(): int;
              staticArgs(): javac.jvm.PoolConstant$LoadableConstant[];
              bsm: Symbol$MethodHandleSymbol;
              staticArgs: javac.jvm.PoolConstant$LoadableConstant[];
            }
            interface Symbol$DynamicMethodSymbol extends CombineTypes<[_Symbol$DynamicMethodSymbol, com.sun.tools.javac.code.Symbol$MethodSymbol, com.sun.tools.javac.jvm.PoolConstant$Dynamic]> {}
            interface _Symbol$DynamicVarSymbol$$static extends ClassLike {
              new(name: javac.util.Name, owner: Symbol, bsm: Symbol$MethodHandleSymbol, type: Type, staticArgs: javac.jvm.PoolConstant$LoadableConstant[]): Symbol$DynamicVarSymbol;
            }
            let Symbol$DynamicVarSymbol: _Symbol$DynamicVarSymbol$$static;
            interface _Symbol$DynamicVarSymbol {
              bootstrapMethod(): javac.jvm.PoolConstant$LoadableConstant;
              dynamicType(): javac.jvm.PoolConstant;
              isDynamic(): boolean;
              name(): javac.util.Name;
              poolTag(): int;
              staticArgs(): javac.jvm.PoolConstant$LoadableConstant[];
              bsm: Symbol$MethodHandleSymbol;
              staticArgs: javac.jvm.PoolConstant$LoadableConstant[];
            }
            interface Symbol$DynamicVarSymbol extends CombineTypes<[_Symbol$DynamicVarSymbol, com.sun.tools.javac.code.Symbol$VarSymbol, com.sun.tools.javac.jvm.PoolConstant$Dynamic, com.sun.tools.javac.jvm.PoolConstant$LoadableConstant]> {}
            interface _Symbol$MethodHandleSymbol$$static extends ClassLike {
              new(msym: Symbol): Symbol$MethodHandleSymbol;
              new(msym: Symbol, getter: boolean): Symbol$MethodHandleSymbol;
            }
            let Symbol$MethodHandleSymbol: _Symbol$MethodHandleSymbol$$static;
            interface _Symbol$MethodHandleSymbol {
              _allowPrivateInvokeVirtual(): boolean;
              asHandle(): Symbol$MethodHandleSymbol;
              baseSymbol(): Symbol;
              isHandle(): boolean;
              poolKey(types: Types): any;
              poolTag(): int;
              referenceKind(): int;
              _getter: boolean;
              _refSym: Symbol;
            }
            interface Symbol$MethodHandleSymbol extends CombineTypes<[_Symbol$MethodHandleSymbol, com.sun.tools.javac.code.Symbol$MethodSymbol, com.sun.tools.javac.jvm.PoolConstant$LoadableConstant]> {}
            interface _Symbol$MethodSymbol$$static extends ClassLike {
              readonly implementation_filter: java.util.function.Predicate<Symbol>;
              new(flags: long, a1: javac.util.Name, name: Type, type: Symbol): Symbol$MethodSymbol;
            }
            let Symbol$MethodSymbol: _Symbol$MethodSymbol$$static;
            interface _Symbol$MethodSymbol {
              accept<R, P>(v: javax.lang.model.element.ElementVisitor<R,P>, p: P): R;
              accept<R, P>(v: Symbol$Visitor<R,P>, p: P): R;
              asHandle(): Symbol$MethodHandleSymbol;
              asMemberOf(site: Type, types: Types): Symbol;
              asType(): javax.lang.model.type.TypeMirror;
              binaryImplementation(origin: Symbol$ClassSymbol, types: Types): Symbol$MethodSymbol;
              binaryOverrides(_other: Symbol, origin: Symbol$TypeSymbol, types: Types): boolean;
              clone(newOwner: Symbol): Symbol$MethodSymbol;
              clone(a0: Symbol): Symbol;
              getAnnotationMirrors(): java.util.List;
              getDefaultValue(): Attribute;
              getDefaultValue(): javax.lang.model.element.AnnotationValue;
              getEnclosingElement(): javax.lang.model.element.Element;
              getKind(): javax.lang.model.element.ElementKind;
              getModifiers(): java.util.Set<javax.lang.model.element.Modifier>;
              getParameters(): javac.util.List<Symbol$VarSymbol>;
              getParameters(): java.util.List;
              getReceiverType(): Type;
              getReceiverType(): javax.lang.model.type.TypeMirror;
              getReturnType(): Type;
              getReturnType(): javax.lang.model.type.TypeMirror;
              getSimpleName(): javax.lang.model.element.Name;
              getThrownTypes(): javac.util.List<Type>;
              getThrownTypes(): java.util.List;
              getTypeParameters(): java.util.List;
              implementation(origin: Symbol$TypeSymbol, types: Types, checkResult: boolean): Symbol$MethodSymbol;
              implementation(origin: Symbol$TypeSymbol, types: Types, checkResult: boolean, implFilter: java.util.function.Predicate<Symbol>): Symbol$MethodSymbol;
              implemented(c: Symbol$TypeSymbol, types: Types): Symbol;
              implementedIn(c: Symbol$TypeSymbol, types: Types): Symbol;
              isDefault(): boolean;
              isHandle(): boolean;
              isInheritedIn(clazz: Symbol, types: Types): boolean;
              isLambdaMethod(): boolean;
              _isOverridableIn(origin: Symbol$TypeSymbol): boolean;
              isStaticOrInstanceInit(): boolean;
              isVarArgs(): boolean;
              originalEnclosingMethod(): Symbol$MethodSymbol;
              overrides(_other: Symbol, origin: Symbol$TypeSymbol, types: Types, checkResult: boolean): boolean;
              overrides(_other: Symbol, origin: Symbol$TypeSymbol, types: Types, checkResult: boolean, requireConcreteIfInherited: boolean): boolean;
              params(): javac.util.List<Symbol$VarSymbol>;
              poolTag(): int;
              toString(): string;
              capturedLocals: javac.util.List<Symbol$VarSymbol>;
              code: javac.jvm.Code;
              defaultValue: Attribute;
              extraParams: javac.util.List<Symbol$VarSymbol>;
              params: javac.util.List<Symbol$VarSymbol>;
            }
            interface Symbol$MethodSymbol extends CombineTypes<[_Symbol$MethodSymbol, javax.lang.model.element.ExecutableElement, com.sun.tools.javac.code.Symbol]> {}
            interface _Symbol$ModuleFlags$$static extends ClassLike {
              value(s: java.util.Set<Symbol$ModuleFlags>): int;
              valueOf(name: string): Symbol$ModuleFlags;
              values(): Symbol$ModuleFlags[];
              readonly MANDATED: Symbol$ModuleFlags;
              readonly OPEN: Symbol$ModuleFlags;
              readonly SYNTHETIC: Symbol$ModuleFlags;
            }
            let Symbol$ModuleFlags: _Symbol$ModuleFlags$$static;
            interface _Symbol$ModuleFlags {
              readonly value: int;
            }
            interface Symbol$ModuleFlags extends CombineTypes<[_Symbol$ModuleFlags]> {}
            interface _Symbol$ModuleResolutionFlags$$static extends ClassLike {
              value(s: java.util.Set<Symbol$ModuleResolutionFlags>): int;
              valueOf(name: string): Symbol$ModuleResolutionFlags;
              values(): Symbol$ModuleResolutionFlags[];
              readonly DO_NOT_RESOLVE_BY_DEFAULT: Symbol$ModuleResolutionFlags;
              readonly WARN_DEPRECATED: Symbol$ModuleResolutionFlags;
              readonly WARN_DEPRECATED_REMOVAL: Symbol$ModuleResolutionFlags;
              readonly WARN_INCUBATING: Symbol$ModuleResolutionFlags;
            }
            let Symbol$ModuleResolutionFlags: _Symbol$ModuleResolutionFlags$$static;
            interface _Symbol$ModuleResolutionFlags {
              readonly value: int;
            }
            interface Symbol$ModuleResolutionFlags extends CombineTypes<[_Symbol$ModuleResolutionFlags]> {}
            interface _Symbol$ModuleSymbol$$static extends ClassLike {
              create(name: javac.util.Name, module_info: javac.util.Name): Symbol$ModuleSymbol;
              new(name: javac.util.Name, owner: Symbol): Symbol$ModuleSymbol;
            }
            let Symbol$ModuleSymbol: _Symbol$ModuleSymbol$$static;
            interface _Symbol$ModuleSymbol {
              accept<R, P>(v: javax.lang.model.element.ElementVisitor<R,P>, p: P): R;
              completeUsesProvides(): void;
              getDirectives(): java.util.List<javax.lang.model.element.ModuleElement$Directive>;
              getEnclosedElements(): javac.util.List<Symbol>;
              getEnclosedElements(): java.util.List;
              getKind(): javax.lang.model.element.ElementKind;
              getQualifiedName(): javax.lang.model.element.Name;
              getSimpleName(): javac.util.Name;
              getSimpleName(): javax.lang.model.element.Name;
              isDeprecated(): boolean;
              isNoModule(): boolean;
              isOpen(): boolean;
              isUnnamed(): boolean;
              outermostClass(): Symbol$ClassSymbol;
              poolTag(): int;
              reset(): void;
              toString(): string;
              classLocation: javax.tools.JavaFileManager$Location;
              directives: javac.util.List<Directive>;
              enclosedPackages: javac.util.List<Symbol>;
              exports: javac.util.List<Directive$ExportsDirective>;
              readonly flags: java.util.Set<Symbol$ModuleFlags>;
              module_info: Symbol$ClassSymbol;
              opens: javac.util.List<Directive$OpensDirective>;
              patchLocation: javax.tools.JavaFileManager$Location;
              patchOutputLocation: javax.tools.JavaFileManager$Location;
              provides: javac.util.List<Directive$ProvidesDirective>;
              readModules: java.util.Set<Symbol$ModuleSymbol>;
              requires: javac.util.List<Directive$RequiresDirective>;
              readonly resolutionFlags: java.util.Set<Symbol$ModuleResolutionFlags>;
              sourceLocation: javax.tools.JavaFileManager$Location;
              unnamedPackage: Symbol$PackageSymbol;
              uses: javac.util.List<Directive$UsesDirective>;
              usesProvidesCompleter: Symbol$Completer;
              version: javac.util.Name;
              visiblePackages: java.util.Map<javac.util.Name,Symbol$PackageSymbol>;
            }
            interface Symbol$ModuleSymbol extends CombineTypes<[_Symbol$ModuleSymbol, javax.lang.model.element.ModuleElement, com.sun.tools.javac.code.Symbol$TypeSymbol]> {}
            interface _Symbol$OperatorSymbol$$static extends ClassLike {
              new(name: javac.util.Name, type: Type, opcode: int, owner: Symbol): Symbol$OperatorSymbol;
            }
            let Symbol$OperatorSymbol: _Symbol$OperatorSymbol$$static;
            interface _Symbol$OperatorSymbol {
              accept<R, P>(v: Symbol$Visitor<R,P>, p: P): R;
              getAccessCode(tag: javac.tree.JCTree$Tag): int;
              _accessCode: int;
              opcode: int;
            }
            interface Symbol$OperatorSymbol extends CombineTypes<[_Symbol$OperatorSymbol, com.sun.tools.javac.code.Symbol$MethodSymbol]> {}
            interface _Symbol$OperatorSymbol$AccessCode$$static extends ClassLike {
              _from(tag: javac.tree.JCTree$Tag, opcode: int): int;
              getFromCode(code: int): Symbol$OperatorSymbol$AccessCode;
              valueOf(name: string): Symbol$OperatorSymbol$AccessCode;
              values(): Symbol$OperatorSymbol$AccessCode[];
              readonly ASSIGN: Symbol$OperatorSymbol$AccessCode;
              readonly DEREF: Symbol$OperatorSymbol$AccessCode;
              readonly FIRSTASGOP: Symbol$OperatorSymbol$AccessCode;
              readonly POSTDEC: Symbol$OperatorSymbol$AccessCode;
              readonly POSTINC: Symbol$OperatorSymbol$AccessCode;
              readonly PREDEC: Symbol$OperatorSymbol$AccessCode;
              readonly PREINC: Symbol$OperatorSymbol$AccessCode;
              readonly UNKNOWN: Symbol$OperatorSymbol$AccessCode;
              readonly numberOfAccessCodes: int;
            }
            let Symbol$OperatorSymbol$AccessCode: _Symbol$OperatorSymbol$AccessCode$$static;
            interface _Symbol$OperatorSymbol$AccessCode {
              readonly code: int;
              readonly tag: javac.tree.JCTree$Tag;
            }
            interface Symbol$OperatorSymbol$AccessCode extends CombineTypes<[_Symbol$OperatorSymbol$AccessCode]> {}
            interface _Symbol$PackageSymbol$$static extends ClassLike {
              new(name: javac.util.Name, type: Type, owner: Symbol): Symbol$PackageSymbol;
              new(name: javac.util.Name, owner: Symbol): Symbol$PackageSymbol;
            }
            let Symbol$PackageSymbol: _Symbol$PackageSymbol$$static;
            interface _Symbol$PackageSymbol {
              accept<R, P>(v: javax.lang.model.element.ElementVisitor<R,P>, p: P): R;
              accept<R, P>(v: Symbol$Visitor<R,P>, p: P): R;
              exists(): boolean;
              flags(): long;
              getEnclosingElement(): Symbol;
              getEnclosingElement(): javax.lang.model.element.Element;
              getKind(): javax.lang.model.element.ElementKind;
              getQualifiedName(): javac.util.Name;
              getQualifiedName(): javax.lang.model.element.Name;
              getRawAttributes(): javac.util.List<Attribute$Compound>;
              isUnnamed(): boolean;
              members(): Scope$WriteableScope;
              _mergeAttributes(): void;
              poolTag(): int;
              reset(): void;
              toString(): string;
              fullname: javac.util.Name;
              members_field: Scope$WriteableScope;
              modle: Symbol$ModuleSymbol;
              package_info: Symbol$ClassSymbol;
              sourcefile: javax.tools.JavaFileObject;
            }
            interface Symbol$PackageSymbol extends CombineTypes<[_Symbol$PackageSymbol, com.sun.tools.javac.code.Symbol$TypeSymbol, javax.lang.model.element.PackageElement]> {}
            interface _Symbol$ParamSymbol$$static extends ClassLike {
              new(flags: long, a1: javac.util.Name, name: Type, type: Symbol): Symbol$ParamSymbol;
            }
            let Symbol$ParamSymbol: _Symbol$ParamSymbol$$static;
            interface _Symbol$ParamSymbol {
              getSimpleName(): javac.util.Name;
              getSimpleName(): javax.lang.model.element.Name;
            }
            interface Symbol$ParamSymbol extends CombineTypes<[_Symbol$ParamSymbol, com.sun.tools.javac.code.Symbol$VarSymbol]> {}
            interface _Symbol$RecordComponent$$static extends ClassLike {
              new(name: javac.util.Name, type: Type, owner: Symbol): Symbol$RecordComponent;
              new(field: Symbol$VarSymbol, ast: javac.tree.JCTree$JCVariableDecl): Symbol$RecordComponent;
              new(field: Symbol$VarSymbol, ast: javac.tree.JCTree$JCVariableDecl, isVarargs: boolean): Symbol$RecordComponent;
            }
            let Symbol$RecordComponent: _Symbol$RecordComponent$$static;
            interface _Symbol$RecordComponent {
              accept<R, P>(v: javax.lang.model.element.ElementVisitor<R,P>, p: P): R;
              declarationFor(): javac.tree.JCTree$JCVariableDecl;
              getAccessor(): javax.lang.model.element.ExecutableElement;
              getKind(): javax.lang.model.element.ElementKind;
              getOriginalAnnos(): javac.util.List<javac.tree.JCTree$JCAnnotation>;
              isVarargs(): boolean;
              accessor: Symbol$MethodSymbol;
              accessorMeth: javac.tree.JCTree$JCMethodDecl;
              _ast: javac.tree.JCTree$JCVariableDecl;
              _isVarargs: boolean;
              _pos: int;
            }
            interface Symbol$RecordComponent extends CombineTypes<[_Symbol$RecordComponent, com.sun.tools.javac.code.Symbol$VarSymbol, javax.lang.model.element.RecordComponentElement]> {}
            interface _Symbol$RootPackageSymbol$$static extends ClassLike {
              new(name: javac.util.Name, owner: Symbol, missingInfoHandler: MissingInfoHandler, allowPrivateInvokeVirtual: boolean): Symbol$RootPackageSymbol;
            }
            let Symbol$RootPackageSymbol: _Symbol$RootPackageSymbol$$static;
            interface _Symbol$RootPackageSymbol {
              readonly allowPrivateInvokeVirtual: boolean;
              readonly missingInfoHandler: MissingInfoHandler;
            }
            interface Symbol$RootPackageSymbol extends CombineTypes<[_Symbol$RootPackageSymbol, com.sun.tools.javac.code.Symbol$PackageSymbol]> {}
            interface _Symbol$TypeSymbol$$static extends ClassLike {
              formFlatName(name: javac.util.Name, owner: Symbol): javac.util.Name;
              formFullName(name: javac.util.Name, owner: Symbol): javac.util.Name;
              new(kind: Kinds$Kind, flags: long, a2: javac.util.Name, name: Type, type: Symbol): Symbol$TypeSymbol;
            }
            let Symbol$TypeSymbol: _Symbol$TypeSymbol$$static;
            interface _Symbol$TypeSymbol {
              accept<R, P>(v: Symbol$Visitor<R,P>, p: P): R;
              asType(): javax.lang.model.type.TypeMirror;
              getAnnotationMirrors(): java.util.List;
              getAnnotationTypeMetadata(): javac.comp.Annotate$AnnotationTypeMetadata;
              getEnclosedElements(): javac.util.List<Symbol>;
              getEnclosedElements(): java.util.List;
              getEnclosingElement(): javax.lang.model.element.Element;
              getSimpleName(): javax.lang.model.element.Name;
              isAnnotationType(): boolean;
              precedes(that: Symbol$TypeSymbol, types: Types): boolean;
            }
            interface Symbol$TypeSymbol extends CombineTypes<[_Symbol$TypeSymbol, com.sun.tools.javac.code.Symbol]> {}
            interface _Symbol$TypeVariableSymbol$$static extends ClassLike {
              new(flags: long, a1: javac.util.Name, name: Type, type: Symbol): Symbol$TypeVariableSymbol;
            }
            let Symbol$TypeVariableSymbol: _Symbol$TypeVariableSymbol$$static;
            interface _Symbol$TypeVariableSymbol {
              accept<R, P>(v: javax.lang.model.element.ElementVisitor<R,P>, p: P): R;
              getAnnotationMirrors(): javac.util.List<Attribute$Compound>;
              getAnnotationMirrors(): java.util.List;
              getAttribute<A>(annoType: java.lang.Class<A>): Attribute$Compound;
              getBounds(): javac.util.List<Type>;
              getBounds(): java.util.List;
              getGenericElement(): Symbol;
              getGenericElement(): javax.lang.model.element.Element;
              getKind(): javax.lang.model.element.ElementKind;
              _isCurrentSymbolsAnnotation(anno: Attribute$TypeCompound, index: int): boolean;
            }
            interface Symbol$TypeVariableSymbol extends CombineTypes<[_Symbol$TypeVariableSymbol, com.sun.tools.javac.code.Symbol$TypeSymbol, javax.lang.model.element.TypeParameterElement]> {}
            interface _Symbol$VarSymbol$$static extends ClassLike {
              new(flags: long, a1: javac.util.Name, name: Type, type: Symbol): Symbol$VarSymbol;
            }
            let Symbol$VarSymbol: _Symbol$VarSymbol$$static;
            interface _Symbol$VarSymbol {
              accept<R, P>(v: javax.lang.model.element.ElementVisitor<R,P>, p: P): R;
              accept<R, P>(v: Symbol$Visitor<R,P>, p: P): R;
              asMemberOf(site: Type, types: Types): Symbol;
              asMethodHandle(getter: boolean): Symbol$MethodHandleSymbol;
              asType(): javax.lang.model.type.TypeMirror;
              clone(newOwner: Symbol): Symbol$VarSymbol;
              clone(a0: Symbol): Symbol;
              getAnnotationMirrors(): java.util.List;
              getConstValue(): any;
              getConstantValue(): any;
              getEnclosingElement(): javax.lang.model.element.Element;
              getKind(): javax.lang.model.element.ElementKind;
              getSimpleName(): javax.lang.model.element.Name;
              isExceptionParameter(): boolean;
              isResourceVariable(): boolean;
              isUnnamedVariable(): boolean;
              poolTag(): int;
              setData(data: any): void;
              setLazyConstValue(env: javac.comp.Env<javac.comp.AttrContext>, attr: javac.comp.Attr, variable: javac.tree.JCTree$JCVariableDecl): void;
              toString(): string;
              adr: int;
              _data: any;
              pos: int;
            }
            interface Symbol$VarSymbol extends CombineTypes<[_Symbol$VarSymbol, javax.lang.model.element.VariableElement, com.sun.tools.javac.code.Symbol]> {}
            interface _Symbol$Visitor$$static<R,P> extends ClassLike {
            }
            let Symbol$Visitor: _Symbol$Visitor$$static<R,P>;
            interface _Symbol$Visitor<R,P> {
              visitClassSymbol(a0: Symbol$ClassSymbol, a1: P): R;
              visitMethodSymbol(a0: Symbol$MethodSymbol, a1: P): R;
              visitOperatorSymbol(a0: Symbol$OperatorSymbol, a1: P): R;
              visitPackageSymbol(a0: Symbol$PackageSymbol, a1: P): R;
              visitSymbol(a0: Symbol, a1: P): R;
              visitTypeSymbol(a0: Symbol$TypeSymbol, a1: P): R;
              visitVarSymbol(a0: Symbol$VarSymbol, a1: P): R;
            }
            interface Symbol$Visitor<R,P> extends CombineTypes<[_Symbol$Visitor<R,P>, java.lang.Object]> {}
            interface _SymbolMetadata$$static extends ClassLike {
              _DECL_IN_PROGRESS: javac.util.List<Attribute$Compound>;
              _DECL_NOT_STARTED: javac.util.List<Attribute$Compound>;
              new(sym: Symbol): SymbolMetadata;
            }
            let SymbolMetadata: _SymbolMetadata$$static;
            interface _SymbolMetadata {
              append(l: javac.util.List<Attribute$Compound>): SymbolMetadata;
              appendClassInitTypeAttributes(l: javac.util.List<Attribute$TypeCompound>): SymbolMetadata;
              appendInitTypeAttributes(l: javac.util.List<Attribute$TypeCompound>): SymbolMetadata;
              appendUniqueTypes(l: javac.util.List<Attribute$TypeCompound>): SymbolMetadata;
              _filterDeclSentinels(a: javac.util.List<Attribute$Compound>): javac.util.List<Attribute$Compound>;
              getClassInitTypeAttributes(): javac.util.List<Attribute$TypeCompound>;
              getDeclarationAttributes(): javac.util.List<Attribute$Compound>;
              getInitTypeAttributes(): javac.util.List<Attribute$TypeCompound>;
              getTypeAttributes(): javac.util.List<Attribute$TypeCompound>;
              isEmpty(): boolean;
              _isStarted(): boolean;
              isTypesEmpty(): boolean;
              pendingCompletion(): boolean;
              prepend(l: javac.util.List<Attribute$Compound>): SymbolMetadata;
              removeDeclarationMetadata(compound: Attribute$Compound): void;
              _removeFromCompoundList(l: javac.util.List<Attribute$Compound>, compound: Attribute$Compound): javac.util.List<Attribute$Compound>;
              reset(): SymbolMetadata;
              setAttributes(other: SymbolMetadata): void;
              setClassInitTypeAttributes(a: javac.util.List<Attribute$TypeCompound>): void;
              setDeclarationAttributes(a: javac.util.List<Attribute$Compound>): void;
              setInitTypeAttributes(a: javac.util.List<Attribute$TypeCompound>): void;
              setTypeAttributes(a: javac.util.List<Attribute$TypeCompound>): void;
              _attributes: javac.util.List<Attribute$Compound>;
              _clinit_type_attributes: javac.util.List<Attribute$TypeCompound>;
              _init_type_attributes: javac.util.List<Attribute$TypeCompound>;
              _sym: Symbol;
              _type_attributes: javac.util.List<Attribute$TypeCompound>;
            }
            interface SymbolMetadata extends CombineTypes<[_SymbolMetadata, java.lang.Object]> {}
            interface _Symtab$$static extends ClassLike {
              instance(context: javac.util.Context): Symtab;
              _EMPTY: java.util.Map<Symbol$ModuleSymbol,Symbol$ClassSymbol>;
              _symtabKey: javac.util.Context$Key<Symtab>;
              _new(context: javac.util.Context): Symtab;
            }
            let Symtab: _Symtab$$static;
            interface _Symtab {
              _addRootPackageFor(module: Symbol$ModuleSymbol): void;
              defineClass(name: javac.util.Name, owner: Symbol): Symbol$ClassSymbol;
              _doEnterClass(msym: Symbol$ModuleSymbol, cs: Symbol$ClassSymbol): void;
              _doEnterPackage(msym: Symbol$ModuleSymbol, pack: Symbol$PackageSymbol): void;
              _enterClass(s: string): Type;
              enterClass(msym: Symbol$ModuleSymbol, name: javac.util.Name, owner: Symbol$TypeSymbol): Symbol$ClassSymbol;
              enterClass(msym: Symbol$ModuleSymbol, flatname: javac.util.Name): Symbol$ClassSymbol;
              enterModule(name: javac.util.Name): Symbol$ModuleSymbol;
              enterPackage(currModule: Symbol$ModuleSymbol, fullname: javac.util.Name): Symbol$PackageSymbol;
              _enterSyntheticAnnotation(name: string): Type;
              getAllClasses(): java.lang.Iterable<Symbol$ClassSymbol>;
              getAllModules(): java.util.Collection<Symbol$ModuleSymbol>;
              getClass(msym: Symbol$ModuleSymbol, flatName: javac.util.Name): Symbol$ClassSymbol;
              getClassField(type: Type, types: Types): Symbol$VarSymbol;
              getClassesForName(candidate: javac.util.Name): java.lang.Iterable<Symbol$ClassSymbol>;
              getModule(name: javac.util.Name): Symbol$ModuleSymbol;
              getPackage(module: Symbol$ModuleSymbol, fullname: javac.util.Name): Symbol$PackageSymbol;
              getPackagesForName(candidate: javac.util.Name): java.lang.Iterable<Symbol$PackageSymbol>;
              inferModule(packageName: javac.util.Name): Symbol$ModuleSymbol;
              initType(type: Type, c: Symbol$ClassSymbol): void;
              initType(type: Type, name: string): void;
              initType(type: Type, name: string, bname: string): void;
              listPackageModules(packageName: javac.util.Name): javac.util.List<Symbol$ModuleSymbol>;
              lookupPackage(msym: Symbol$ModuleSymbol, flatName: javac.util.Name): Symbol$PackageSymbol;
              _lookupPackage(msym: Symbol$ModuleSymbol, flatName: javac.util.Name, onlyExisting: boolean): Symbol$PackageSymbol;
              packageExists(msym: Symbol$ModuleSymbol, fullname: javac.util.Name): boolean;
              removeClass(msym: Symbol$ModuleSymbol, flatName: javac.util.Name): void;
              synthesizeBoxTypeIfMissing(type: Type): void;
              synthesizeEmptyInterfaceIfMissing(type: Type): void;
              readonly annotationTargetType: Type;
              readonly annotationType: Type;
              readonly arrayClass: Symbol$ClassSymbol;
              readonly arrayCloneMethod: Symbol$MethodSymbol;
              readonly arraysType: Type;
              readonly assertionErrorType: Type;
              readonly autoCloseableClose: Symbol$MethodSymbol;
              readonly autoCloseableType: Type;
              readonly booleanType: Type$JCPrimitiveType;
              readonly botType: Type;
              readonly boundClass: Symbol$ClassSymbol;
              readonly boxedName: javac.util.Name[];
              readonly byteType: Type$JCPrimitiveType;
              readonly charType: Type$JCPrimitiveType;
              readonly classDescType: Type;
              _classFields: java.util.Map<Types$UniqueType,Symbol$VarSymbol>;
              readonly classLoaderType: Type;
              readonly classNotFoundExceptionType: Type;
              readonly classType: Type;
              _classes: java.util.Map<javac.util.Name,java.util.Map<Symbol$ModuleSymbol,Symbol$ClassSymbol>>;
              readonly cloneNotSupportedExceptionType: Type;
              readonly cloneableType: Type;
              readonly collectionsType: Type;
              readonly comparableType: Type;
              readonly comparatorType: Type;
              readonly constantBootstrapsType: Type;
              readonly deprecatedType: Type;
              readonly documentedType: Type;
              readonly doubleType: Type$JCPrimitiveType;
              readonly elementTypeType: Type;
              readonly enumDescType: Type;
              readonly enumFinalFinalize: Symbol$MethodSymbol;
              readonly enumSym: Symbol$TypeSymbol;
              readonly errModule: Symbol$ModuleSymbol;
              readonly errSymbol: Symbol$ClassSymbol;
              readonly errType: Type;
              readonly errorType: Type;
              readonly exceptionType: Type;
              readonly externalizableType: Type;
              readonly floatType: Type$JCPrimitiveType;
              readonly functionalInterfaceType: Type;
              readonly illegalArgumentExceptionType: Type;
              readonly incompatibleClassChangeErrorType: Type;
              readonly inheritedType: Type;
              _initialCompleter: Symbol$Completer;
              readonly intType: Type$JCPrimitiveType;
              readonly interruptedExceptionType: Type;
              readonly ioExceptionType: Type;
              readonly iterableType: Type;
              readonly iteratorType: Type;
              readonly java_base: Symbol$ModuleSymbol;
              readonly lambdaMetafactory: Type;
              readonly lengthVar: Symbol$VarSymbol;
              readonly linkageType: Type;
              readonly listType: Type;
              readonly longType: Type$JCPrimitiveType;
              readonly matchExceptionType: Type;
              _messages: javac.util.JavacMessages;
              readonly methodClass: Symbol$ClassSymbol;
              readonly methodHandleLookupType: Type;
              readonly methodHandleType: Type;
              readonly methodHandlesType: Type;
              readonly methodTypeType: Type;
              _moduleCompleter: Symbol$Completer;
              _modules: java.util.Map<javac.util.Name,Symbol$ModuleSymbol>;
              _names: javac.util.Names;
              readonly nativeHeaderType: Type;
              readonly noClassDefFoundErrorType: Type;
              readonly noModule: Symbol$ModuleSymbol;
              readonly noSuchFieldErrorType: Type;
              readonly noSymbol: Symbol$TypeSymbol;
              readonly objectInputStreamType: Type;
              readonly objectMethodsType: Type;
              readonly objectOutputStreamType: Type;
              readonly objectStreamExceptionType: Type;
              readonly objectStreamFieldType: Type;
              readonly objectType: Type;
              readonly objectsType: Type;
              readonly overrideType: Type;
              _packages: java.util.Map<javac.util.Name,java.util.Map<Symbol$ModuleSymbol,Symbol$PackageSymbol>>;
              readonly predefClass: Symbol$ClassSymbol;
              readonly previewFeatureInternalType: Type;
              readonly previewFeatureType: Type;
              readonly processorType: Type;
              readonly profileType: Type;
              readonly proprietaryType: Type;
              readonly recordType: Type;
              readonly repeatableType: Type;
              readonly retentionType: Type;
              readonly rootPackage: Symbol$PackageSymbol;
              readonly runtimeExceptionType: Type;
              readonly serializableType: Type;
              readonly serializedLambdaType: Type;
              readonly shortType: Type$JCPrimitiveType;
              readonly stringBufferType: Type;
              readonly stringBuilderType: Type;
              readonly stringConcatFactory: Type;
              readonly stringTemplateType: Type;
              readonly stringType: Type;
              readonly supplierType: Type;
              readonly suppressWarningsType: Type;
              readonly switchBootstrapsType: Type;
              readonly systemType: Type;
              readonly templateRuntimeType: Type;
              readonly throwableType: Type;
              readonly trustMeType: Type;
              readonly typeDescriptorType: Type;
              readonly typeOfTag: Type[];
              readonly unknownSymbol: Symbol$ClassSymbol;
              readonly unknownType: Type;
              readonly unnamedModule: Symbol$ModuleSymbol;
              readonly valueBasedInternalType: Type;
              readonly valueBasedType: Type;
              readonly varHandleType: Type;
              readonly voidType: Type$JCVoidType;
            }
            interface Symtab extends CombineTypes<[_Symtab, java.lang.Object]> {}
            interface _TargetType$$static extends ClassLike {
              fromTargetTypeValue(tag: int): TargetType;
              isValidTargetTypeValue(tag: int): boolean;
              valueOf(name: string): TargetType;
              values(): TargetType[];
              readonly CAST: TargetType;
              readonly CLASS_EXTENDS: TargetType;
              readonly CLASS_TYPE_PARAMETER: TargetType;
              readonly CLASS_TYPE_PARAMETER_BOUND: TargetType;
              readonly CONSTRUCTOR_INVOCATION_TYPE_ARGUMENT: TargetType;
              readonly CONSTRUCTOR_REFERENCE: TargetType;
              readonly CONSTRUCTOR_REFERENCE_TYPE_ARGUMENT: TargetType;
              readonly EXCEPTION_PARAMETER: TargetType;
              readonly FIELD: TargetType;
              readonly INSTANCEOF: TargetType;
              readonly LOCAL_VARIABLE: TargetType;
              _MAXIMUM_TARGET_TYPE_VALUE: int;
              readonly METHOD_FORMAL_PARAMETER: TargetType;
              readonly METHOD_INVOCATION_TYPE_ARGUMENT: TargetType;
              readonly METHOD_RECEIVER: TargetType;
              readonly METHOD_REFERENCE: TargetType;
              readonly METHOD_REFERENCE_TYPE_ARGUMENT: TargetType;
              readonly METHOD_RETURN: TargetType;
              readonly METHOD_TYPE_PARAMETER: TargetType;
              readonly METHOD_TYPE_PARAMETER_BOUND: TargetType;
              readonly NEW: TargetType;
              readonly RESOURCE_VARIABLE: TargetType;
              readonly THROWS: TargetType;
              readonly UNKNOWN: TargetType;
              _targets: TargetType[];
            }
            let TargetType: _TargetType$$static;
            interface _TargetType {
              isLocal(): boolean;
              targetTypeValue(): int;
              _isLocal: boolean;
              _targetTypeValue: int;
            }
            interface TargetType extends CombineTypes<[_TargetType]> {}
            interface _Type$$static extends ClassLike {
              baseTypes(ts: javac.util.List<Type>): javac.util.List<Type>;
              contains(ts: javac.util.List<Type>, t: Type): boolean;
              containsAny(ts1: javac.util.List<Type>, ts2: javac.util.List<Type>): boolean;
              filter(ts: javac.util.List<Type>, tf: java.util.function.Predicate<Type>): javac.util.List<Type>;
              getModelTypes(ts: javac.util.List<Type>): javac.util.List<Type>;
              isErroneous(ts: javac.util.List<Type>): boolean;
              toString(ts: javac.util.List<Type>): string;
              moreInfo: boolean;
              readonly noType: Type$JCNoType;
              readonly recoveryType: Type$JCNoType;
              _stripMetadata: Types$TypeMapping<java.lang.Void>;
              readonly stuckType: Type$JCNoType;
              new(tsym: Symbol$TypeSymbol, metadata: javac.util.List<TypeMetadata>): Type;
            }
            let Type: _Type$$static;
            interface _Type {
              accept<R, S>(v: Type$Visitor<R,S>, s: S): R;
              accept<R, P>(v: javax.lang.model.type.TypeVisitor<R,P>, p: P): R;
              addMetadata(md: TypeMetadata): Type;
              allparams(): javac.util.List<Type>;
              annotatedType(annos: javac.util.List<Attribute$TypeCompound>): Type;
              _appendAnnotationsString(sb: Type$stringBuilder, prefix: boolean): void;
              _appendAnnotationsString(sb: Type$stringBuilder): void;
              argtypes(varargs: boolean): string;
              asElement(): Symbol$TypeSymbol;
              asMethodType(): Type$MethodType;
              baseType(): Type;
              _cloneWithMetadata(metadata: javac.util.List<TypeMetadata>): Type;
              complete(): void;
              constType(constValue: any): Type;
              constValue(): any;
              contains(t: Type): boolean;
              containsAny(ts: javac.util.List<Type>): boolean;
              dropMetadata(metadataClass: java.lang.Class<TypeMetadata>): Type;
              equals(t: any): boolean;
              equalsIgnoreMetadata(t: Type): boolean;
              getAnnotation<A>(annotationType: java.lang.Class<A>): A;
              getAnnotationMirrors(): javac.util.List<Attribute$TypeCompound>;
              getAnnotationMirrors(): java.util.List;
              getAnnotationsByType<A>(annotationType: java.lang.Class<A>): A[];
              getEnclosingType(): Type;
              getKind(): javax.lang.model.type.TypeKind;
              getLowerBound(): Type;
              getMetadata(): javac.util.List<TypeMetadata>;
              getMetadata<M>(metadataClass: java.lang.Class<M>): M;
              getMetadata<M, Z>(metadataClass: java.lang.Class<M>, metadataFunc: java.util.function.Function<M,Z>, defaultValue: Z): Z;
              getModelType(): Type;
              getOriginalType(): Type;
              getParameterTypes(): javac.util.List<Type>;
              getReceiverType(): Type;
              getReturnType(): Type;
              getTag(): TypeTag;
(): TypeTag;
              getThrownTypes(): javac.util.List<Type>;
              getTypeArguments(): javac.util.List<Type>;
              getUpperBound(): Type;
              hasTag(tag: TypeTag): boolean;
              hashCode(): int;
              isAnnotated(): boolean;
              isCompound(): boolean;
              isErroneous(): boolean;
              isExtendsBound(): boolean;
              isFalse(): boolean;
              isFinal(): boolean;
              isIntegral(): boolean;
              isInterface(): boolean;
              isIntersection(): boolean;
              isNullOrReference(): boolean;
              isNumeric(): boolean;
              isParameterized(): boolean;
              isPartial(): boolean;
              isPrimitive(): boolean;
              isPrimitiveOrVoid(): boolean;
              isRaw(): boolean;
              isReference(): boolean;
              isSuperBound(): boolean;
              isTrue(): boolean;
              isUnbound(): boolean;
              isUnion(): boolean;
              map<Z>(mapping: Types$TypeMapping<Z>, arg: Z): Type;
              map<Z>(mapping: Types$TypeMapping<Z>): Type;
              _needsStripping(): boolean;
              poolKey(types: Types): any;
              poolTag(): int;
              preannotatedType(): Type;
              stringValue(): string;
              stripMetadata(): Type;
              stripMetadataIfNeeded(): Type;
              toString(): string;
              _typeNoMetadata(): Type;
              withTypeVar(t: Type): Type;
              _metadata: javac.util.List<TypeMetadata>;
              tsym: Symbol$TypeSymbol;
            }
            interface Type extends CombineTypes<[_Type, javax.lang.model.type.TypeMirror, com.sun.tools.javac.code.AnnoConstruct, com.sun.tools.javac.jvm.PoolConstant]> {}
            interface _Type$ArrayType$$static extends ClassLike {
              new(elemtype: Type, arrayClass: Symbol$TypeSymbol): Type$ArrayType;
              new(elemtype: Type, arrayClass: Symbol$TypeSymbol, metadata: javac.util.List<TypeMetadata>): Type$ArrayType;
              new(that: Type$ArrayType): Type$ArrayType;
            }
            let Type$ArrayType: _Type$ArrayType$$static;
            interface _Type$ArrayType {
              accept<R, S>(v: Type$Visitor<R,S>, s: S): R;
              accept<R, P>(v: javax.lang.model.type.TypeVisitor<R,P>, p: P): R;
              allparams(): javac.util.List<Type>;
              _cloneWithMetadata(md: javac.util.List<TypeMetadata>): Type$ArrayType;
              _cloneWithMetadata(a0: javac.util.List): Type;
              complete(): void;
              contains(elem: Type): boolean;
              equals(obj: any): boolean;
              getAnnotationMirrors(): java.util.List;
              getComponentType(): Type;
              getComponentType(): javax.lang.model.type.TypeMirror;
              getKind(): javax.lang.model.type.TypeKind;
              getTag(): TypeTag;
              hashCode(): int;
              isErroneous(): boolean;
              isNullOrReference(): boolean;
              isParameterized(): boolean;
              isRaw(): boolean;
              isReference(): boolean;
              isVarargs(): boolean;
              makeVarargs(): Type$ArrayType;
              poolTag(): int;
              toString(): string;
              elemtype: Type;
            }
            interface Type$ArrayType extends CombineTypes<[_Type$ArrayType, javax.lang.model.type.ArrayType, com.sun.tools.javac.code.Type, com.sun.tools.javac.jvm.PoolConstant$LoadableConstant]> {}
            interface _Type$BottomType$$static extends ClassLike {
              new(): Type$BottomType;
            }
            let Type$BottomType: _Type$BottomType$$static;
            interface _Type$BottomType {
              accept<R, P>(v: javax.lang.model.type.TypeVisitor<R,P>, p: P): R;
              constType(value: any): Type;
              getAnnotationMirrors(): java.util.List;
              getKind(): javax.lang.model.type.TypeKind;
              getTag(): TypeTag;
              isCompound(): boolean;
              isNullOrReference(): boolean;
              stringValue(): string;
            }
            interface Type$BottomType extends CombineTypes<[_Type$BottomType, javax.lang.model.type.NullType, com.sun.tools.javac.code.Type]> {}
            interface _Type$CapturedType$$static extends ClassLike {
              new(name: javac.util.Name, owner: Symbol, upper: Type, lower: Type, wildcard: Type$WildcardType): Type$CapturedType;
              new(tsym: Symbol$TypeSymbol, bound: Type, upper: Type, lower: Type, wildcard: Type$WildcardType, metadata: javac.util.List<TypeMetadata>): Type$CapturedType;
            }
            let Type$CapturedType: _Type$CapturedType$$static;
            interface _Type$CapturedType {
              accept<R, S>(v: Type$Visitor<R,S>, s: S): R;
              _cloneWithMetadata(md: javac.util.List<TypeMetadata>): Type$CapturedType;
              _cloneWithMetadata(a0: javac.util.List): Type$TypeVar;
              _cloneWithMetadata(a0: javac.util.List): Type;
              isCaptured(): boolean;
              toString(): string;
              wildcard: Type$WildcardType;
            }
            interface Type$CapturedType extends CombineTypes<[_Type$CapturedType, com.sun.tools.javac.code.Type$TypeVar]> {}
            interface _Type$ClassType$$static extends ClassLike {
              new(outer: Type, typarams: javac.util.List<Type>, tsym: Symbol$TypeSymbol): Type$ClassType;
              new(outer: Type, typarams: javac.util.List<Type>, tsym: Symbol$TypeSymbol, metadata: javac.util.List<TypeMetadata>): Type$ClassType;
            }
            let Type$ClassType: _Type$ClassType$$static;
            interface _Type$ClassType {
              accept<R, S>(v: Type$Visitor<R,S>, s: S): R;
              accept<R, P>(v: javax.lang.model.type.TypeVisitor<R,P>, p: P): R;
              allparams(): javac.util.List<Type>;
              asElement(): javax.lang.model.element.Element;
              _className(sym: Symbol, longform: boolean): string;
              _cloneWithMetadata(md: javac.util.List<TypeMetadata>): Type$ClassType;
              _cloneWithMetadata(a0: javac.util.List): Type;
              complete(): void;
              constType(constValue: any): Type;
              contains(elem: Type): boolean;
              getAnnotationMirrors(): java.util.List;
              getEnclosingType(): Type;
              getEnclosingType(): javax.lang.model.type.TypeMirror;
              getKind(): javax.lang.model.type.TypeKind;
              getTag(): TypeTag;
              getTypeArguments(): javac.util.List<Type>;
              getTypeArguments(): java.util.List;
              hasErasedSupertypes(): boolean;
              isErroneous(): boolean;
              isNullOrReference(): boolean;
              isParameterized(): boolean;
              isRaw(): boolean;
              isReference(): boolean;
              poolTag(): int;
              setEnclosingType(outer: Type): void;
              toString(): string;
              all_interfaces_field: javac.util.List<Type>;
              allparams_field: javac.util.List<Type>;
              interfaces_field: javac.util.List<Type>;
              _outer_field: Type;
              _rank_field: int;
              supertype_field: Type;
              typarams_field: javac.util.List<Type>;
            }
            interface Type$ClassType extends CombineTypes<[_Type$ClassType, javax.lang.model.type.ErrorType, javax.lang.model.type.DeclaredType, com.sun.tools.javac.code.Type, com.sun.tools.javac.jvm.PoolConstant$LoadableConstant]> {}
            interface _Type$DelegatedType$$static extends ClassLike {
              new(tag: TypeTag, qtype: Type): Type$DelegatedType;
              new(tag: TypeTag, qtype: Type, metadata: javac.util.List<TypeMetadata>): Type$DelegatedType;
            }
            let Type$DelegatedType: _Type$DelegatedType$$static;
            interface _Type$DelegatedType {
              allparams(): javac.util.List<Type>;
              getAnnotationMirrors(): java.util.List;
              getEnclosingType(): Type;
              getParameterTypes(): javac.util.List<Type>;
              getReceiverType(): Type;
              getReturnType(): Type;
              getTag(): TypeTag;
              getThrownTypes(): javac.util.List<Type>;
              getTypeArguments(): javac.util.List<Type>;
              getUpperBound(): Type;
              isErroneous(): boolean;
              toString(): string;
              qtype: Type;
              tag: TypeTag;
            }
            interface Type$DelegatedType extends CombineTypes<[_Type$DelegatedType, com.sun.tools.javac.code.Type]> {}
            interface _Type$ErasedClassType$$static extends ClassLike {
              new(outer: Type, tsym: Symbol$TypeSymbol, metadata: javac.util.List<TypeMetadata>): Type$ErasedClassType;
            }
            let Type$ErasedClassType: _Type$ErasedClassType$$static;
            interface _Type$ErasedClassType {
              hasErasedSupertypes(): boolean;
            }
            interface Type$ErasedClassType extends CombineTypes<[_Type$ErasedClassType, com.sun.tools.javac.code.Type$ClassType]> {}
            interface _Type$ErrorType$$static extends ClassLike {
              new(c: Symbol$ClassSymbol, originalType: Type): Type$ErrorType;
              new(originalType: Type, tsym: Symbol$TypeSymbol): Type$ErrorType;
              new(name: javac.util.Name, container: Symbol$TypeSymbol, originalType: Type): Type$ErrorType;
            }
            let Type$ErrorType: _Type$ErrorType$$static;
            interface _Type$ErrorType {
              accept<R, S>(v: Type$Visitor<R,S>, s: S): R;
              accept<R, P>(v: javax.lang.model.type.TypeVisitor<R,P>, p: P): R;
              allparams(): javac.util.List<Type>;
              asSub(sym: Symbol): Type;
              _cloneWithMetadata(md: javac.util.List<TypeMetadata>): Type$ErrorType;
              _cloneWithMetadata(a0: javac.util.List): Type$ClassType;
              _cloneWithMetadata(a0: javac.util.List): Type;
              constType(constValue: any): Type;
              getEnclosingType(): Type;
              getEnclosingType(): javax.lang.model.type.TypeMirror;
              getKind(): javax.lang.model.type.TypeKind;
              getOriginalType(): Type;
              getReturnType(): Type;
              getTag(): TypeTag;
              getTypeArguments(): javac.util.List<Type>;
              getTypeArguments(): java.util.List;
              isCompound(): boolean;
              isErroneous(): boolean;
              isGenType(t: Type): boolean;
              isInterface(): boolean;
              isNullOrReference(): boolean;
              isPartial(): boolean;
              isReference(): boolean;
              _originalType: Type;
            }
            interface Type$ErrorType extends CombineTypes<[_Type$ErrorType, javax.lang.model.type.ErrorType, com.sun.tools.javac.code.Type$ClassType]> {}
            interface _Type$ForAll$$static extends ClassLike {
              new(tvars: javac.util.List<Type>, qtype: Type): Type$ForAll;
            }
            let Type$ForAll: _Type$ForAll$$static;
            interface _Type$ForAll {
              accept<R, S>(v: Type$Visitor<R,S>, s: S): R;
              accept<R, P>(v: javax.lang.model.type.TypeVisitor<R,P>, p: P): R;
              asMethodType(): Type$MethodType;
              complete(): void;
              contains(elem: Type): boolean;
              getKind(): javax.lang.model.type.TypeKind;
              getParameterTypes(): java.util.List;
              getReceiverType(): javax.lang.model.type.TypeMirror;
              getReturnType(): javax.lang.model.type.TypeMirror;
              getThrownTypes(): java.util.List;
              getTypeArguments(): javac.util.List<Type>;
              getTypeVariables(): javac.util.List<Type$TypeVar>;
              getTypeVariables(): java.util.List;
              isErroneous(): boolean;
              toString(): string;
              tvars: javac.util.List<Type>;
            }
            interface Type$ForAll extends CombineTypes<[_Type$ForAll, com.sun.tools.javac.code.Type$DelegatedType, javax.lang.model.type.ExecutableType]> {}
            interface _Type$IntersectionClassType$$static extends ClassLike {
              new(bounds: javac.util.List<Type>, csym: Symbol$ClassSymbol, allInterfaces: boolean): Type$IntersectionClassType;
            }
            let Type$IntersectionClassType: _Type$IntersectionClassType$$static;
            interface _Type$IntersectionClassType {
              accept<R, P>(v: javax.lang.model.type.TypeVisitor<R,P>, p: P): R;
              getBounds(): java.util.List<javax.lang.model.type.TypeMirror>;
              getComponents(): javac.util.List<Type>;
              getExplicitComponents(): javac.util.List<Type>;
              getKind(): javax.lang.model.type.TypeKind;
              isCompound(): boolean;
              isIntersection(): boolean;
              allInterfaces: boolean;
            }
            interface Type$IntersectionClassType extends CombineTypes<[_Type$IntersectionClassType, javax.lang.model.type.IntersectionType, com.sun.tools.javac.code.Type$ClassType]> {}
            interface _Type$JCNoType$$static extends ClassLike {
              new(): Type$JCNoType;
            }
            let Type$JCNoType: _Type$JCNoType$$static;
            interface _Type$JCNoType {
              accept<R, P>(v: javax.lang.model.type.TypeVisitor<R,P>, p: P): R;
              getAnnotationMirrors(): java.util.List;
              getKind(): javax.lang.model.type.TypeKind;
              getTag(): TypeTag;
              isCompound(): boolean;
            }
            interface Type$JCNoType extends CombineTypes<[_Type$JCNoType, javax.lang.model.type.NoType, com.sun.tools.javac.code.Type]> {}
            interface _Type$JCPrimitiveType$$static extends ClassLike {
              new(tag: TypeTag, tsym: Symbol$TypeSymbol): Type$JCPrimitiveType;
            }
            let Type$JCPrimitiveType: _Type$JCPrimitiveType$$static;
            interface _Type$JCPrimitiveType {
              accept<R, P>(v: javax.lang.model.type.TypeVisitor<R,P>, p: P): R;
              _cloneWithMetadata(md: javac.util.List<TypeMetadata>): Type$JCPrimitiveType;
              _cloneWithMetadata(a0: javac.util.List): Type;
              constType(constValue: any): Type;
              getAnnotationMirrors(): java.util.List;
              getKind(): javax.lang.model.type.TypeKind;
              getTag(): TypeTag;
              isFalse(): boolean;
              isIntegral(): boolean;
              isNumeric(): boolean;
              isPrimitive(): boolean;
              isPrimitiveOrVoid(): boolean;
              isTrue(): boolean;
              stringValue(): string;
              _tag: TypeTag;
            }
            interface Type$JCPrimitiveType extends CombineTypes<[_Type$JCPrimitiveType, javax.lang.model.type.PrimitiveType, com.sun.tools.javac.code.Type]> {}
            interface _Type$JCVoidType$$static extends ClassLike {
              new(): Type$JCVoidType;
            }
            let Type$JCVoidType: _Type$JCVoidType$$static;
            interface _Type$JCVoidType {
              accept<R, P>(v: javax.lang.model.type.TypeVisitor<R,P>, p: P): R;
              getAnnotationMirrors(): java.util.List;
              getKind(): javax.lang.model.type.TypeKind;
              getTag(): TypeTag;
              isCompound(): boolean;
              isPrimitiveOrVoid(): boolean;
            }
            interface Type$JCVoidType extends CombineTypes<[_Type$JCVoidType, javax.lang.model.type.NoType, com.sun.tools.javac.code.Type]> {}
            interface _Type$MethodType$$static extends ClassLike {
              new(argtypes: javac.util.List<Type>, restype: Type, thrown: javac.util.List<Type>, methodClass: Symbol$TypeSymbol): Type$MethodType;
            }
            let Type$MethodType: _Type$MethodType$$static;
            interface _Type$MethodType {
              accept<R, S>(v: Type$Visitor<R,S>, s: S): R;
              accept<R, P>(v: javax.lang.model.type.TypeVisitor<R,P>, p: P): R;
              asElement(): Symbol$TypeSymbol;
              asMethodType(): Type$MethodType;
              complete(): void;
              contains(elem: Type): boolean;
              getAnnotationMirrors(): java.util.List;
              getKind(): javax.lang.model.type.TypeKind;
              getParameterTypes(): javac.util.List<Type>;
              getParameterTypes(): java.util.List;
              getReceiverType(): Type;
              getReceiverType(): javax.lang.model.type.TypeMirror;
              getReturnType(): Type;
              getReturnType(): javax.lang.model.type.TypeMirror;
              getTag(): TypeTag;
              getThrownTypes(): javac.util.List<Type>;
              getThrownTypes(): java.util.List;
              getTypeVariables(): javac.util.List<Type$TypeVar>;
              getTypeVariables(): java.util.List;
              isErroneous(): boolean;
              poolTag(): int;
              toString(): string;
              argtypes: javac.util.List<Type>;
              recvtype: Type;
              restype: Type;
              thrown: javac.util.List<Type>;
            }
            interface Type$MethodType extends CombineTypes<[_Type$MethodType, javax.lang.model.type.ExecutableType, com.sun.tools.javac.code.Type, com.sun.tools.javac.jvm.PoolConstant$LoadableConstant]> {}
            interface _Type$ModuleType$$static extends ClassLike {
              _new(tsym: Symbol$ModuleSymbol): Type$ModuleType;
            }
            let Type$ModuleType: _Type$ModuleType$$static;
            interface _Type$ModuleType {
              accept<R, S>(v: Type$Visitor<R,S>, s: S): R;
              accept<R, P>(v: javax.lang.model.type.TypeVisitor<R,P>, p: P): R;
              annotatedType(annos: javac.util.List<Attribute$TypeCompound>): Type$ModuleType;
              annotatedType(a0: javac.util.List): Type;
              getAnnotationMirrors(): java.util.List;
              getKind(): javax.lang.model.type.TypeKind;
              getTag(): TypeTag;
              toString(): string;
            }
            interface Type$ModuleType extends CombineTypes<[_Type$ModuleType, javax.lang.model.type.NoType, com.sun.tools.javac.code.Type]> {}
            interface _Type$PackageType$$static extends ClassLike {
              _new(tsym: Symbol$PackageSymbol): Type$PackageType;
            }
            let Type$PackageType: _Type$PackageType$$static;
            interface _Type$PackageType {
              accept<R, S>(v: Type$Visitor<R,S>, s: S): R;
              accept<R, P>(v: javax.lang.model.type.TypeVisitor<R,P>, p: P): R;
              getAnnotationMirrors(): java.util.List;
              getKind(): javax.lang.model.type.TypeKind;
              getTag(): TypeTag;
              toString(): string;
            }
            interface Type$PackageType extends CombineTypes<[_Type$PackageType, javax.lang.model.type.NoType, com.sun.tools.javac.code.Type]> {}
            interface _Type$StructuralTypeMapping$$static<S> extends ClassLike {
              new(): Type$StructuralTypeMapping<S>;
            }
            let Type$StructuralTypeMapping: _Type$StructuralTypeMapping$$static<S>;
            interface _Type$StructuralTypeMapping<S> {
              visitArrayType(t: Type$ArrayType, s: S): Type;
              visitArrayType(a0: Type$ArrayType, a1: any): any;
              visitClassType(t: Type$ClassType, s: S): Type;
              visitClassType(a0: Type$ClassType, a1: any): any;
              visitForAll(t: Type$ForAll, s: S): Type;
              visitForAll(a0: Type$ForAll, a1: any): any;
              visitMethodType(t: Type$MethodType, s: S): Type;
              visitMethodType(a0: Type$MethodType, a1: any): any;
              visitWildcardType(wt: Type$WildcardType, s: S): Type;
              visitWildcardType(a0: Type$WildcardType, a1: any): any;
            }
            interface Type$StructuralTypeMapping<S> extends CombineTypes<[_Type$StructuralTypeMapping<S>, Types$TypeMapping<S>]> {}
            interface _Type$TypeVar$$static extends ClassLike {
              new(name: javac.util.Name, owner: Symbol, lower: Type): Type$TypeVar;
              new(tsym: Symbol$TypeSymbol, bound: Type, lower: Type): Type$TypeVar;
              new(tsym: Symbol$TypeSymbol, bound: Type, lower: Type, metadata: javac.util.List<TypeMetadata>): Type$TypeVar;
            }
            let Type$TypeVar: _Type$TypeVar$$static;
            interface _Type$TypeVar {
              accept<R, S>(v: Type$Visitor<R,S>, s: S): R;
              accept<R, P>(v: javax.lang.model.type.TypeVisitor<R,P>, p: P): R;
              asElement(): javax.lang.model.element.Element;
              _cloneWithMetadata(md: javac.util.List<TypeMetadata>): Type$TypeVar;
              _cloneWithMetadata(a0: javac.util.List): Type;
              getAnnotationMirrors(): java.util.List;
              getKind(): javax.lang.model.type.TypeKind;
              getLowerBound(): Type;
              getLowerBound(): javax.lang.model.type.TypeMirror;
              getTag(): TypeTag;
              getUpperBound(): Type;
              getUpperBound(): javax.lang.model.type.TypeMirror;
              isCaptured(): boolean;
              isNullOrReference(): boolean;
              isReference(): boolean;
              setUpperBound(bound: Type): void;
              __bound: Type;
              lower: Type;
              _rank_field: int;
            }
            interface Type$TypeVar extends CombineTypes<[_Type$TypeVar, javax.lang.model.type.TypeVariable, com.sun.tools.javac.code.Type]> {}
            interface _Type$UndetVar$$static extends ClassLike {
              new(origin: Type$TypeVar, listener: Type$UndetVar$UndetVarListener, types: Types): Type$UndetVar;
            }
            let Type$UndetVar: _Type$UndetVar$$static;
            interface _Type$UndetVar {
              accept<R, S>(v: Type$Visitor<R,S>, s: S): R;
              addBound(ib: Type$UndetVar$InferenceBound, bound: Type, types: Types): void;
              _addBound(ib: Type$UndetVar$InferenceBound, bound: Type, types: Types, update: boolean): void;
              baseType(): Type;
              debugString(): string;
              dup(types: Types): Type$UndetVar;
              dupTo(uv2: Type$UndetVar, types: Types): void;
              getBounds(ibs: Type$UndetVar$InferenceBound[]): javac.util.List<Type>;
              getBounds(...ibs: Type$UndetVar$InferenceBound[]): javac.util.List<Type>;
              getDeclaredBounds(): javac.util.List<Type>;
              getInst(): Type;
              isCaptured(): boolean;
              isPartial(): boolean;
              isThrows(): boolean;
              _notifyBoundChange(ib: Type$UndetVar$InferenceBound, bound: Type, update: boolean): void;
              setBounds(ib: Type$UndetVar$InferenceBound, newBounds: javac.util.List<Type>): void;
              setInst(inst: Type): void;
              setNormal(): void;
              setThrow(): void;
              substBounds(from: javac.util.List<Type>, to: javac.util.List<Type>, types: Types): void;
              toString(): string;
              _bounds: java.util.Map<Type$UndetVar$InferenceBound,javac.util.List<Type>>;
              declaredCount: int;
              incorporationActions: java.util.ArrayDeque<javac.comp.Infer$IncorporationAction>;
              _inst: Type;
              _kind: Type$UndetVar$Kind;
              listener: Type$UndetVar$UndetVarListener;
              _toTypeVarMap: Types$TypeMapping<java.lang.Void>;
            }
            interface Type$UndetVar extends CombineTypes<[_Type$UndetVar, com.sun.tools.javac.code.Type$DelegatedType]> {}
            interface _Type$UndetVar$InferenceBound$$static extends ClassLike {
              valueOf(name: string): Type$UndetVar$InferenceBound;
              values(): Type$UndetVar$InferenceBound[];
              readonly EQ: Type$UndetVar$InferenceBound;
              readonly LOWER: Type$UndetVar$InferenceBound;
              readonly UPPER: Type$UndetVar$InferenceBound;
            }
            let Type$UndetVar$InferenceBound: _Type$UndetVar$InferenceBound$$static;
            interface _Type$UndetVar$InferenceBound {
              complement(): Type$UndetVar$InferenceBound;
(): Type$UndetVar$InferenceBound;
              lessThan(that: Type$UndetVar$InferenceBound): boolean;
            }
            interface Type$UndetVar$InferenceBound extends CombineTypes<[_Type$UndetVar$InferenceBound]> {}
            interface _Type$UndetVar$Kind$$static extends ClassLike {
              valueOf(name: string): Type$UndetVar$Kind;
              values(): Type$UndetVar$Kind[];
              readonly CAPTURED: Type$UndetVar$Kind;
              readonly NORMAL: Type$UndetVar$Kind;
              readonly THROWS: Type$UndetVar$Kind;
            }
            let Type$UndetVar$Kind: _Type$UndetVar$Kind$$static;
            interface _Type$UndetVar$Kind {
            }
            interface Type$UndetVar$Kind extends CombineTypes<[_Type$UndetVar$Kind]> {}
            interface _Type$UndetVar$UndetVarListener$$static extends ClassLike {
            }
            let Type$UndetVar$UndetVarListener: _Type$UndetVar$UndetVarListener$$static;
            interface _Type$UndetVar$UndetVarListener {
              varBoundChanged(a0: Type$UndetVar, a1: Type$UndetVar$InferenceBound, a2: Type, a3: boolean): void;
(a0: Type$UndetVar, a1: Type$UndetVar$InferenceBound, a2: Type, a3: boolean): void;
              varInstantiated(uv: Type$UndetVar): void;
            }
            interface Type$UndetVar$UndetVarListener extends CombineTypes<[_Type$UndetVar$UndetVarListener, java.lang.Object]> {}
            interface _Type$UnionClassType$$static extends ClassLike {
              new(ct: Type$ClassType, alternatives: javac.util.List<Type>): Type$UnionClassType;
            }
            let Type$UnionClassType: _Type$UnionClassType$$static;
            interface _Type$UnionClassType {
              accept<R, P>(v: javax.lang.model.type.TypeVisitor<R,P>, p: P): R;
              getAlternativeTypes(): java.lang.Iterable<Type>;
              getAlternatives(): java.util.List<javax.lang.model.type.TypeMirror>;
              getKind(): javax.lang.model.type.TypeKind;
              getLub(): Type;
              isCompound(): boolean;
              isUnion(): boolean;
              _alternatives_field: javac.util.List<Type>;
            }
            interface Type$UnionClassType extends CombineTypes<[_Type$UnionClassType, javax.lang.model.type.UnionType, com.sun.tools.javac.code.Type$ClassType]> {}
            interface _Type$UnknownType$$static extends ClassLike {
              new(): Type$UnknownType;
            }
            let Type$UnknownType: _Type$UnknownType$$static;
            interface _Type$UnknownType {
              accept<R, P>(v: javax.lang.model.type.TypeVisitor<R,P>, p: P): R;
              getAnnotationMirrors(): java.util.List;
              getTag(): TypeTag;
              isPartial(): boolean;
            }
            interface Type$UnknownType extends CombineTypes<[_Type$UnknownType, com.sun.tools.javac.code.Type]> {}
            interface _Type$Visitor$$static<R,S> extends ClassLike {
            }
            let Type$Visitor: _Type$Visitor$$static<R,S>;
            interface _Type$Visitor<R,S> {
              visitArrayType(a0: Type$ArrayType, a1: S): R;
              visitCapturedType(a0: Type$CapturedType, a1: S): R;
              visitClassType(a0: Type$ClassType, a1: S): R;
              visitErrorType(a0: Type$ErrorType, a1: S): R;
              visitForAll(a0: Type$ForAll, a1: S): R;
              visitMethodType(a0: Type$MethodType, a1: S): R;
              visitModuleType(a0: Type$ModuleType, a1: S): R;
              visitPackageType(a0: Type$PackageType, a1: S): R;
              visitType(a0: Type, a1: S): R;
              visitTypeVar(a0: Type$TypeVar, a1: S): R;
              visitUndetVar(a0: Type$UndetVar, a1: S): R;
              visitWildcardType(a0: Type$WildcardType, a1: S): R;
            }
            interface Type$Visitor<R,S> extends CombineTypes<[_Type$Visitor<R,S>, java.lang.Object]> {}
            interface _Type$WildcardType$$static extends ClassLike {
              new(type: Type, kind: BoundKind, tsym: Symbol$TypeSymbol): Type$WildcardType;
              new(type: Type, kind: BoundKind, tsym: Symbol$TypeSymbol, metadata: javac.util.List<TypeMetadata>): Type$WildcardType;
              new(type: Type, kind: BoundKind, tsym: Symbol$TypeSymbol, bound: Type$TypeVar): Type$WildcardType;
              new(type: Type, kind: BoundKind, tsym: Symbol$TypeSymbol, bound: Type$TypeVar, metadata: javac.util.List<TypeMetadata>): Type$WildcardType;
            }
            let Type$WildcardType: _Type$WildcardType$$static;
            interface _Type$WildcardType {
              accept<R, S>(v: Type$Visitor<R,S>, s: S): R;
              accept<R, P>(v: javax.lang.model.type.TypeVisitor<R,P>, p: P): R;
              _cloneWithMetadata(md: javac.util.List<TypeMetadata>): Type$WildcardType;
              _cloneWithMetadata(a0: javac.util.List): Type;
              contains(t: Type): boolean;
              getAnnotationMirrors(): java.util.List;
              getExtendsBound(): Type;
              getExtendsBound(): javax.lang.model.type.TypeMirror;
              getKind(): javax.lang.model.type.TypeKind;
              getSuperBound(): Type;
              getSuperBound(): javax.lang.model.type.TypeMirror;
              getTag(): TypeTag;
              isExtendsBound(): boolean;
              isNullOrReference(): boolean;
              isReference(): boolean;
              isSuperBound(): boolean;
              isUnbound(): boolean;
              toString(): string;
              withTypeVar(t: Type): Type;
              bound: Type$TypeVar;
              _isPrintingBound: boolean;
              kind: BoundKind;
              type: Type;
            }
            interface Type$WildcardType extends CombineTypes<[_Type$WildcardType, javax.lang.model.type.WildcardType, com.sun.tools.javac.code.Type]> {}
            interface _TypeAnnotationPosition$$static extends ClassLike {
              classExtends(location: javac.util.List<TypeAnnotationPosition$TypePathEntry>, onLambda: javac.tree.JCTree$JCLambda, type_index: int, pos: int): TypeAnnotationPosition;
              classExtends(location: javac.util.List<TypeAnnotationPosition$TypePathEntry>, onLambda: javac.tree.JCTree$JCLambda, pos: int): TypeAnnotationPosition;
              classExtends(location: javac.util.List<TypeAnnotationPosition$TypePathEntry>, type_index: int): TypeAnnotationPosition;
              classExtends(type_index: int, pos: int): TypeAnnotationPosition;
              classExtends(pos: int): TypeAnnotationPosition;
              constructorInvocationTypeArg(location: javac.util.List<TypeAnnotationPosition$TypePathEntry>, onLambda: javac.tree.JCTree$JCLambda, type_index: int, pos: int): TypeAnnotationPosition;
              constructorInvocationTypeArg(location: javac.util.List<TypeAnnotationPosition$TypePathEntry>, type_index: int): TypeAnnotationPosition;
              constructorRef(location: javac.util.List<TypeAnnotationPosition$TypePathEntry>, onLambda: javac.tree.JCTree$JCLambda, pos: int): TypeAnnotationPosition;
              constructorRef(location: javac.util.List<TypeAnnotationPosition$TypePathEntry>): TypeAnnotationPosition;
              constructorRefTypeArg(location: javac.util.List<TypeAnnotationPosition$TypePathEntry>, onLambda: javac.tree.JCTree$JCLambda, type_index: int, pos: int): TypeAnnotationPosition;
              constructorRefTypeArg(location: javac.util.List<TypeAnnotationPosition$TypePathEntry>, type_index: int): TypeAnnotationPosition;
              exceptionParameter(location: javac.util.List<TypeAnnotationPosition$TypePathEntry>, onLambda: javac.tree.JCTree$JCLambda, pos: int): TypeAnnotationPosition;
              exceptionParameter(onLambda: javac.tree.JCTree$JCLambda, pos: int): TypeAnnotationPosition;
              exceptionParameter(location: javac.util.List<TypeAnnotationPosition$TypePathEntry>): TypeAnnotationPosition;
              field(location: javac.util.List<TypeAnnotationPosition$TypePathEntry>, onLambda: javac.tree.JCTree$JCLambda, pos: int): TypeAnnotationPosition;
              field(location: javac.util.List<TypeAnnotationPosition$TypePathEntry>): TypeAnnotationPosition;
              field(pos: int): TypeAnnotationPosition;
              getBinaryFromTypePath(locs: java.util.List<TypeAnnotationPosition$TypePathEntry>): javac.util.List<int>;
              getTypePathFromBinary(list: java.util.List<int>): javac.util.List<TypeAnnotationPosition$TypePathEntry>;
              instanceOf(location: javac.util.List<TypeAnnotationPosition$TypePathEntry>, onLambda: javac.tree.JCTree$JCLambda, pos: int): TypeAnnotationPosition;
              instanceOf(location: javac.util.List<TypeAnnotationPosition$TypePathEntry>): TypeAnnotationPosition;
              localVariable(location: javac.util.List<TypeAnnotationPosition$TypePathEntry>, onLambda: javac.tree.JCTree$JCLambda, pos: int): TypeAnnotationPosition;
              localVariable(onLambda: javac.tree.JCTree$JCLambda, pos: int): TypeAnnotationPosition;
              localVariable(location: javac.util.List<TypeAnnotationPosition$TypePathEntry>): TypeAnnotationPosition;
              methodInvocationTypeArg(location: javac.util.List<TypeAnnotationPosition$TypePathEntry>, onLambda: javac.tree.JCTree$JCLambda, type_index: int, pos: int): TypeAnnotationPosition;
              methodInvocationTypeArg(location: javac.util.List<TypeAnnotationPosition$TypePathEntry>, type_index: int): TypeAnnotationPosition;
              methodParameter(location: javac.util.List<TypeAnnotationPosition$TypePathEntry>, onLambda: javac.tree.JCTree$JCLambda, parameter_index: int, pos: int): TypeAnnotationPosition;
              methodParameter(onLambda: javac.tree.JCTree$JCLambda, parameter_index: int, pos: int): TypeAnnotationPosition;
              methodParameter(parameter_index: int, pos: int): TypeAnnotationPosition;
              methodParameter(location: javac.util.List<TypeAnnotationPosition$TypePathEntry>, parameter_index: int): TypeAnnotationPosition;
              methodReceiver(location: javac.util.List<TypeAnnotationPosition$TypePathEntry>, onLambda: javac.tree.JCTree$JCLambda, pos: int): TypeAnnotationPosition;
              methodReceiver(location: javac.util.List<TypeAnnotationPosition$TypePathEntry>): TypeAnnotationPosition;
              methodReceiver(pos: int): TypeAnnotationPosition;
              methodRef(location: javac.util.List<TypeAnnotationPosition$TypePathEntry>, onLambda: javac.tree.JCTree$JCLambda, pos: int): TypeAnnotationPosition;
              methodRef(location: javac.util.List<TypeAnnotationPosition$TypePathEntry>): TypeAnnotationPosition;
              methodRefTypeArg(location: javac.util.List<TypeAnnotationPosition$TypePathEntry>, onLambda: javac.tree.JCTree$JCLambda, type_index: int, pos: int): TypeAnnotationPosition;
              methodRefTypeArg(location: javac.util.List<TypeAnnotationPosition$TypePathEntry>, type_index: int): TypeAnnotationPosition;
              methodReturn(location: javac.util.List<TypeAnnotationPosition$TypePathEntry>, onLambda: javac.tree.JCTree$JCLambda, pos: int): TypeAnnotationPosition;
              methodReturn(location: javac.util.List<TypeAnnotationPosition$TypePathEntry>): TypeAnnotationPosition;
              methodReturn(pos: int): TypeAnnotationPosition;
              methodThrows(location: javac.util.List<TypeAnnotationPosition$TypePathEntry>, onLambda: javac.tree.JCTree$JCLambda, type_index: int, pos: int): TypeAnnotationPosition;
              methodThrows(location: javac.util.List<TypeAnnotationPosition$TypePathEntry>, type_index: int): TypeAnnotationPosition;
              methodTypeParameter(location: javac.util.List<TypeAnnotationPosition$TypePathEntry>, onLambda: javac.tree.JCTree$JCLambda, parameter_index: int, pos: int): TypeAnnotationPosition;
              methodTypeParameter(location: javac.util.List<TypeAnnotationPosition$TypePathEntry>, parameter_index: int): TypeAnnotationPosition;
              methodTypeParameterBound(location: javac.util.List<TypeAnnotationPosition$TypePathEntry>, onLambda: javac.tree.JCTree$JCLambda, parameter_index: int, bound_index: int, pos: int): TypeAnnotationPosition;
              methodTypeParameterBound(location: javac.util.List<TypeAnnotationPosition$TypePathEntry>, parameter_index: int, bound_index: int): TypeAnnotationPosition;
              newObj(location: javac.util.List<TypeAnnotationPosition$TypePathEntry>, onLambda: javac.tree.JCTree$JCLambda, pos: int): TypeAnnotationPosition;
              newObj(pos: int): TypeAnnotationPosition;
              newObj(location: javac.util.List<TypeAnnotationPosition$TypePathEntry>): TypeAnnotationPosition;
              resourceVariable(location: javac.util.List<TypeAnnotationPosition$TypePathEntry>, onLambda: javac.tree.JCTree$JCLambda, pos: int): TypeAnnotationPosition;
              resourceVariable(onLambda: javac.tree.JCTree$JCLambda, pos: int): TypeAnnotationPosition;
              resourceVariable(location: javac.util.List<TypeAnnotationPosition$TypePathEntry>): TypeAnnotationPosition;
              typeCast(location: javac.util.List<TypeAnnotationPosition$TypePathEntry>, onLambda: javac.tree.JCTree$JCLambda, type_index: int, pos: int): TypeAnnotationPosition;
              typeCast(location: javac.util.List<TypeAnnotationPosition$TypePathEntry>, type_index: int): TypeAnnotationPosition;
              typeParameter(location: javac.util.List<TypeAnnotationPosition$TypePathEntry>, onLambda: javac.tree.JCTree$JCLambda, parameter_index: int, pos: int): TypeAnnotationPosition;
              typeParameter(location: javac.util.List<TypeAnnotationPosition$TypePathEntry>, parameter_index: int): TypeAnnotationPosition;
              typeParameterBound(location: javac.util.List<TypeAnnotationPosition$TypePathEntry>, onLambda: javac.tree.JCTree$JCLambda, parameter_index: int, bound_index: int, pos: int): TypeAnnotationPosition;
              typeParameterBound(location: javac.util.List<TypeAnnotationPosition$TypePathEntry>, parameter_index: int, bound_index: int): TypeAnnotationPosition;
              readonly emptyPath: javac.util.List<TypeAnnotationPosition$TypePathEntry>;
              readonly unknown: TypeAnnotationPosition;
            }
            let TypeAnnotationPosition: _TypeAnnotationPosition$$static;
            interface _TypeAnnotationPosition {
              emitToClassfile(): boolean;
              getCatchType(): int;
              getExceptionIndex(): int;
              getStartPos(): int;
              hasCatchType(): boolean;
              hasExceptionIndex(): boolean;
              matchesPos(pos: int): boolean;
              setCatchInfo(catchType: int, startPos: int): void;
              setExceptionIndex(exception_index: int): void;
              toString(): string;
              updatePosOffset(to: int): void;
              readonly bound_index: int;
              _exceptionStartPos: int;
              _exception_index: int;
              isValidOffset: boolean;
              location: javac.util.List<TypeAnnotationPosition$TypePathEntry>;
              lvarIndex: int[];
              lvarLength: int[];
              lvarOffset: int[];
              offset: int;
              readonly onLambda: javac.tree.JCTree$JCLambda;
              parameter_index: int;
              readonly pos: int;
              readonly type: TargetType;
              readonly type_index: int;
            }
            interface TypeAnnotationPosition extends CombineTypes<[_TypeAnnotationPosition, java.lang.Object]> {}
            interface _TypeAnnotationPosition$TypePathEntry$$static extends ClassLike {
              fromBinary(tag: int, arg: int): TypeAnnotationPosition$TypePathEntry;
              readonly ARRAY: TypeAnnotationPosition$TypePathEntry;
              readonly INNER_TYPE: TypeAnnotationPosition$TypePathEntry;
              readonly WILDCARD: TypeAnnotationPosition$TypePathEntry;
              readonly bytesPerEntry: int;
              new(tag: TypeAnnotationPosition$TypePathEntryKind, arg: int): TypeAnnotationPosition$TypePathEntry;
            }
            let TypeAnnotationPosition$TypePathEntry: _TypeAnnotationPosition$TypePathEntry$$static;
            interface _TypeAnnotationPosition$TypePathEntry {
              equals(other: any): boolean;
              hashCode(): int;
              toString(): string;
              readonly arg: int;
              readonly tag: TypeAnnotationPosition$TypePathEntryKind;
            }
            interface TypeAnnotationPosition$TypePathEntry extends CombineTypes<[_TypeAnnotationPosition$TypePathEntry, java.lang.Object]> {}
            interface _TypeAnnotationPosition$TypePathEntryKind$$static extends ClassLike {
              valueOf(name: string): TypeAnnotationPosition$TypePathEntryKind;
              values(): TypeAnnotationPosition$TypePathEntryKind[];
              readonly ARRAY: TypeAnnotationPosition$TypePathEntryKind;
              readonly INNER_TYPE: TypeAnnotationPosition$TypePathEntryKind;
              readonly TYPE_ARGUMENT: TypeAnnotationPosition$TypePathEntryKind;
              readonly WILDCARD: TypeAnnotationPosition$TypePathEntryKind;
            }
            let TypeAnnotationPosition$TypePathEntryKind: _TypeAnnotationPosition$TypePathEntryKind$$static;
            interface _TypeAnnotationPosition$TypePathEntryKind {
              readonly tag: int;
            }
            interface TypeAnnotationPosition$TypePathEntryKind extends CombineTypes<[_TypeAnnotationPosition$TypePathEntryKind]> {}
            interface _TypeAnnotations$$static extends ClassLike {
              instance(context: javac.util.Context): TypeAnnotations;
              _typeAnnosKey: javac.util.Context$Key<TypeAnnotations>;
              _new(context: javac.util.Context): TypeAnnotations;
            }
            let TypeAnnotations: _TypeAnnotations$$static;
            interface _TypeAnnotations {
              annotationTargetType(pos: javac.tree.JCTree, a: Attribute$Compound, s: Symbol): TypeAnnotations$AnnotationType;
              annotationTargets(tsym: Symbol$TypeSymbol): javac.util.List<Attribute>;
              _combineAnnotationType(at1: TypeAnnotations$AnnotationType, at2: TypeAnnotations$AnnotationType): TypeAnnotations$AnnotationType;
              organizeTypeAnnotationsBodies(tree: javac.tree.JCTree$JCClassDecl): void;
              organizeTypeAnnotationsSignatures(env: javac.comp.Env<javac.comp.AttrContext>, tree: javac.tree.JCTree$JCClassDecl): void;
              _targetToAnnotationType(pos: javac.tree.JCTree, anno: Attribute$Compound, a: Attribute, s: Symbol): TypeAnnotations$AnnotationType;
              validateTypeAnnotationsSignatures(env: javac.comp.Env<javac.comp.AttrContext>, tree: javac.tree.JCTree$JCClassDecl): void;
              _annotate: javac.comp.Annotate;
              _attr: javac.comp.Attr;
              _log: javac.util.Log;
              _names: javac.util.Names;
              _syms: Symtab;
            }
            interface TypeAnnotations extends CombineTypes<[_TypeAnnotations, java.lang.Object]> {}
            interface _TypeAnnotations$AnnotationType$$static extends ClassLike {
              valueOf(name: string): TypeAnnotations$AnnotationType;
              values(): TypeAnnotations$AnnotationType[];
              readonly BOTH: TypeAnnotations$AnnotationType;
              readonly DECLARATION: TypeAnnotations$AnnotationType;
              readonly NONE: TypeAnnotations$AnnotationType;
              readonly TYPE: TypeAnnotations$AnnotationType;
            }
            let TypeAnnotations$AnnotationType: _TypeAnnotations$AnnotationType$$static;
            interface _TypeAnnotations$AnnotationType {
            }
            interface TypeAnnotations$AnnotationType extends CombineTypes<[_TypeAnnotations$AnnotationType]> {}
            interface _TypeAnnotations$TypeAnnotationPositions$$static extends ClassLike {
              _new(a0: TypeAnnotations, sigOnly: boolean): TypeAnnotations$TypeAnnotationPositions;
            }
            let TypeAnnotations$TypeAnnotationPositions: _TypeAnnotations$TypeAnnotationPositions$$static;
            interface _TypeAnnotations$TypeAnnotationPositions {
              _appendTypeAnnotationsToOwner(sym: Symbol, typeAnnotations: javac.util.List<Attribute$TypeCompound>): void;
              _arrayElemTypeTree(typetree: javac.tree.JCTree): javac.tree.JCTree;
              _findPosition(tree: javac.tree.JCTree, frame: javac.tree.JCTree, annotations: javac.util.List<javac.tree.JCTree$JCAnnotation>): void;
              _locateNestedTypes(type: Type, depth: javac.util.ListBuffer<TypeAnnotationPosition$TypePathEntry>): javac.util.ListBuffer<TypeAnnotationPosition$TypePathEntry>;
              _methodParamIndex(path: javac.util.List<javac.tree.JCTree>, param: javac.tree.JCTree): int;
              _peek2(): javac.tree.JCTree;
              _pop(): javac.tree.JCTree;
              _propagateNewClassAnnotationsToOwner(tree: javac.tree.JCTree$JCNewClass): void;
              _push(t: javac.tree.JCTree): void;
              _resolveFrame(tree: javac.tree.JCTree, frame: javac.tree.JCTree, path: javac.util.List<javac.tree.JCTree>, currentLambda: javac.tree.JCTree$JCLambda, outer_type_index: int, location: javac.util.ListBuffer<TypeAnnotationPosition$TypePathEntry>): TypeAnnotationPosition;
              _rewriteArrayType(typetree: javac.tree.JCTree, type: Type$ArrayType, annotations: javac.util.List<Attribute$TypeCompound>, onlyTypeAnnotations: javac.util.List<Attribute$TypeCompound>, pos: TypeAnnotationPosition): Type;
              scan(tree: javac.tree.JCTree): void;
              _separateAnnotationsKinds(pos: javac.tree.JCTree, typetree: javac.tree.JCTree, type: Type, sym: Symbol, typeAnnotationPosition: TypeAnnotationPosition): void;
              _setTypeAnnotationPos(annotations: javac.util.List<javac.tree.JCTree$JCAnnotation>, position: TypeAnnotationPosition): void;
              toString(): string;
              _toTypeCompound(a: Attribute$Compound, p: TypeAnnotationPosition): Attribute$TypeCompound;
              _typeWithAnnotations(typetree: javac.tree.JCTree, type: Type, annotations: javac.util.List<Attribute$TypeCompound>, onlyTypeAnnotations: javac.util.List<Attribute$TypeCompound>, pos: TypeAnnotationPosition): Type;
              _typeWithAnnotations(type: Type, stopAt: Type, annotations: javac.util.List<Attribute$TypeCompound>): Type;
              visitAnnotatedType(tree: javac.tree.JCTree$JCAnnotatedType): void;
              visitBlock(tree: javac.tree.JCTree$JCBlock): void;
              visitClassDef(tree: javac.tree.JCTree$JCClassDecl): void;
              visitLambda(tree: javac.tree.JCTree$JCLambda): void;
              visitMethodDef(tree: javac.tree.JCTree$JCMethodDecl): void;
              visitNewArray(tree: javac.tree.JCTree$JCNewArray): void;
              visitNewClass(tree: javac.tree.JCTree$JCNewClass): void;
              visitTypeParameter(tree: javac.tree.JCTree$JCTypeParameter): void;
              visitVarDef(tree: javac.tree.JCTree$JCVariableDecl): void;
              _currentLambda: javac.tree.JCTree$JCLambda;
              _frames: javac.util.List<javac.tree.JCTree>;
              _isInClass: boolean;
              _sigOnly: boolean;
              _this$0: TypeAnnotations;
            }
            interface TypeAnnotations$TypeAnnotationPositions extends CombineTypes<[_TypeAnnotations$TypeAnnotationPositions, com.sun.tools.javac.tree.TreeScanner]> {}
            interface _TypeMetadata$$static extends ClassLike {
            }
            let TypeMetadata: _TypeMetadata$$static;
            interface _TypeMetadata {
            }
            interface TypeMetadata extends CombineTypes<[_TypeMetadata, java.lang.Object]> {}
            interface _TypeMetadata$Annotations$$static extends ClassLike {
              _new(): TypeMetadata$Annotations;
              _new(annotations: javac.util.List<Attribute$TypeCompound>): TypeMetadata$Annotations;
              new(annotationBuffer: javac.util.ListBuffer<Attribute$TypeCompound>): TypeMetadata$Annotations;
            }
            let TypeMetadata$Annotations: _TypeMetadata$Annotations$$static;
            interface _TypeMetadata$Annotations {
              annotationBuffer(): javac.util.ListBuffer<Attribute$TypeCompound>;
              _annotations(): javac.util.List<Attribute$TypeCompound>;
              equals(o: any): boolean;
              hashCode(): int;
              toString(): string;
            }
            interface TypeMetadata$Annotations extends CombineTypes<[_TypeMetadata$Annotations, com.sun.tools.javac.code.TypeMetadata, java.lang.Record]> {}
            interface _TypeMetadata$ConstantValue$$static extends ClassLike {
              new(value: any): TypeMetadata$ConstantValue;
            }
            let TypeMetadata$ConstantValue: _TypeMetadata$ConstantValue$$static;
            interface _TypeMetadata$ConstantValue {
              equals(o: any): boolean;
              hashCode(): int;
              toString(): string;
              value(): any;
            }
            interface TypeMetadata$ConstantValue extends CombineTypes<[_TypeMetadata$ConstantValue, com.sun.tools.javac.code.TypeMetadata, java.lang.Record]> {}
            interface _TypeTag$$static extends ClassLike {
              getTypeTagCount(): int;
              valueOf(name: string): TypeTag;
              values(): TypeTag[];
              readonly ARRAY: TypeTag;
              readonly BOOLEAN: TypeTag;
              readonly BOT: TypeTag;
              readonly BYTE: TypeTag;
              readonly CHAR: TypeTag;
              readonly CLASS: TypeTag;
              readonly DEFERRED: TypeTag;
              readonly DOUBLE: TypeTag;
              readonly ERROR: TypeTag;
              readonly FLOAT: TypeTag;
              readonly FORALL: TypeTag;
              readonly INT: TypeTag;
              readonly LONG: TypeTag;
              readonly METHOD: TypeTag;
              readonly MODULE: TypeTag;
              readonly NONE: TypeTag;
              readonly PACKAGE: TypeTag;
              readonly SHORT: TypeTag;
              readonly TYPEVAR: TypeTag;
              readonly UNDETVAR: TypeTag;
              readonly UNINITIALIZED_OBJECT: TypeTag;
              readonly UNINITIALIZED_THIS: TypeTag;
              readonly UNKNOWN: TypeTag;
              readonly VOID: TypeTag;
              readonly WILDCARD: TypeTag;
            }
            let TypeTag: _TypeTag$$static;
            interface _TypeTag {
              checkRange(value: int): boolean;
              getKindLiteral(): sun.source.tree.Tree$Kind;
              getPrimitiveTypeKind(): javax.lang.model.type.TypeKind;
              isStrictSubRangeOf(tag: TypeTag): boolean;
              isSubRangeOf(tag: TypeTag): boolean;
              _isPrimitive: boolean;
              _numericClass: int;
              _superClasses: int;
            }
            interface TypeTag extends CombineTypes<[_TypeTag]> {}
            interface _TypeTag$NumericClasses$$static extends ClassLike {
              readonly BYTE_CLASS: int;
              _BYTE_SUPERCLASSES: int;
              readonly CHAR_CLASS: int;
              _CHAR_SUPERCLASSES: int;
              readonly DOUBLE_CLASS: int;
              readonly FLOAT_CLASS: int;
              _FLOAT_SUPERCLASSES: int;
              readonly INT_CLASS: int;
              _INT_SUPERCLASSES: int;
              readonly LONG_CLASS: int;
              _LONG_SUPERCLASSES: int;
              readonly SHORT_CLASS: int;
              _SHORT_SUPERCLASSES: int;
              new(): TypeTag$NumericClasses;
            }
            let TypeTag$NumericClasses: _TypeTag$NumericClasses$$static;
            interface _TypeTag$NumericClasses {
            }
            interface TypeTag$NumericClasses extends CombineTypes<[_TypeTag$NumericClasses, java.lang.Object]> {}
            interface _Types$$static extends ClassLike {
              instance(context: javac.util.Context): Types;
              _hashCodeStrictVisitor: Types$HashCodeVisitor;
              _hashCodeVisitor: Types$HashCodeVisitor;
              _newInstanceFun: Types$TypeMapping<java.lang.Void>;
              _typesKey: javac.util.Context$Key<Types>;
              _new(context: javac.util.Context): Types;
            }
            let Types: _Types$$static;
            interface _Types {
              adapt(source: Type, target: Type, from: javac.util.ListBuffer<Type>, to: javac.util.ListBuffer<Type>): void;
              _adaptSelf(t: Type, from: javac.util.ListBuffer<Type>, to: javac.util.ListBuffer<Type>): void;
              _appendTyparamString(t: Type$TypeVar, buf: Types$stringBuilder): void;
              _areDisjoint(ts: Symbol$ClassSymbol, ss: Symbol$ClassSymbol): boolean;
              _arraySuperType(): Type;
              asEnclosingSuper(t: Type, sym: Symbol): Type;
              asOuterSuper(t: Type, sym: Symbol): Type;
              asSub(t: Type, sym: Symbol): Type;
              asSuper(t: Type, sym: Symbol): Type;
              boxedClass(t: Type): Symbol$ClassSymbol;
              boxedTypeOrType(t: Type): Type;
              capture(ts: javac.util.List<Type>): javac.util.List<Type>;
              capture(t: Type): Type;
              captures(t: Type): javac.util.List<Type>;
              _checkUnsafeVarargsConversion(t: Type, s: Type, warn: javac.util.Warner): void;
              classBound(t: Type): Type;
              closure(t: Type): javac.util.List<Type>;
              closureCollector(minClosure: boolean, shouldSkip: java.util.function.BiPredicate<Type,Type>): java.util.stream.Collector<Type,Types$ClosureHolder,javac.util.List<Type>>;
              _closureMin(cl: javac.util.List<Type>): javac.util.List<Type>;
              _compoundMin(cl: javac.util.List<Type>): Type;
              constantType(c: javac.jvm.PoolConstant$LoadableConstant): Type;
              containedBy(t: Type, s: Type): boolean;
              _containsType(ts: javac.util.List<Type>, ss: javac.util.List<Type>): boolean;
              containsType(t: Type, s: Type): boolean;
              containsTypeEquivalent(ts: javac.util.List<Type>, ss: javac.util.List<Type>): boolean;
              _containsTypeEquivalent(t: Type, s: Type): boolean;
              covariantReturnType(t: Type, s: Type, warner: javac.util.Warner): boolean;
              createErrorType(originalType: Type): Type;
              createErrorType(c: Symbol$ClassSymbol, originalType: Type): Type;
              createErrorType(name: javac.util.Name, container: Symbol$TypeSymbol, originalType: Type): Type;
              createMethodTypeWithParameters(original: Type, newParams: javac.util.List<Type>): Type;
              createMethodTypeWithReturn(original: Type, newReturn: Type): Type;
              createMethodTypeWithThrown(original: Type, newThrown: javac.util.List<Type>): Type;
              cvarLowerBound(t: Type): Type;
              cvarLowerBounds(ts: javac.util.List<Type>): javac.util.List<Type>;
              cvarUpperBound(t: Type): Type;
              dimensions(t: Type): int;
              directSupertypes(t: Type): javac.util.List<Type>;
              disjointType(t: Type, s: Type): boolean;
              disjointTypes(ts: javac.util.List<Type>, ss: javac.util.List<Type>): boolean;
              elemtype(t: Type): Type;
              elemtypeOrType(t: Type): Type;
              _eraseNotNeeded(t: Type): boolean;
              _erasedSupertypes(t: Type): javac.util.List<Type>;
              erasure(t: Type): Type;
              _erasure(t: Type, recurse: boolean): Type;
              erasure(ts: javac.util.List<Type>): javac.util.List<Type>;
              erasureRecursive(t: Type): Type;
              erasureRecursive(ts: javac.util.List<Type>): javac.util.List<Type>;
              findDescriptorSymbol(origin: Symbol$TypeSymbol): Symbol;
              findDescriptorType(origin: Type): Type;
              firstUnimplementedAbstract(sym: Symbol$ClassSymbol): Symbol$MethodSymbol;
              _firstUnimplementedAbstractImpl(impl: Symbol$ClassSymbol, c: Symbol$ClassSymbol): Symbol$MethodSymbol;
              freshTypeVariables(types: javac.util.List<Type>): javac.util.List<Type>;
              functionalInterfaceBridges(origin: Symbol$TypeSymbol): javac.util.List<Symbol>;
              getBounds(t: Type$TypeVar): javac.util.List<Type>;
              getRetention(a: Attribute$Compound): Attribute$RetentionPolicy;
              getRetention(sym: Symbol$TypeSymbol): Attribute$RetentionPolicy;
              _giveWarning(from: Type, to: Type): boolean;
              glb(ts: javac.util.List<Type>): Type;
              glb(t: Type, s: Type): Type;
              _glbFlattened(flatBounds: javac.util.List<Type>, errT: Type): Type;
              hasSameArgs(t: Type, s: Type): boolean;
              hasSameArgs(t: Type, s: Type, strict: boolean): boolean;
              _hasSameArgs(t: Type, s: Type, hasSameArgs: Types$TypeRelation): boolean;
              hasSameBounds(t: Type$ForAll, s: Type$ForAll): boolean;
              hashCode(t: Type): int;
              hashCode(t: Type, strict: boolean): int;
              implementation(ms: Symbol$MethodSymbol, origin: Symbol$TypeSymbol, checkResult: boolean, implFilter: java.util.function.Predicate<Symbol>): Symbol$MethodSymbol;
              insert(cl: javac.util.List<Type>, t: Type, shouldSkip: java.util.function.BiPredicate<Type,Type>): javac.util.List<Type>;
              insert(cl: javac.util.List<Type>, t: Type): javac.util.List<Type>;
              interfaceCandidates(site: Type, ms: Symbol$MethodSymbol): javac.util.List<Symbol$MethodSymbol>;
              interfaces(t: Type): javac.util.List<Type>;
              intersect(cl1: javac.util.List<Type>, cl2: javac.util.List<Type>): javac.util.List<Type>;
              isArray(t: Type): boolean;
              isAssignable(t: Type, s: Type): boolean;
              isAssignable(t: Type, s: Type, warn: javac.util.Warner): boolean;
              isCaptureOf(s: Type, t: Type$WildcardType): boolean;
              isCastable(t: Type, s: Type): boolean;
              isCastable(t: Type, s: Type, warn: javac.util.Warner): boolean;
              isConvertible(t: Type, s: Type, warn: javac.util.Warner): boolean;
              isConvertible(t: Type, s: Type): boolean;
              isDerivedRaw(t: Type): boolean;
              isDerivedRaw(ts: javac.util.List<Type>): boolean;
              isDerivedRawInternal(t: Type): boolean;
              isDirectSuperInterface(isym: Symbol$TypeSymbol, origin: Symbol$TypeSymbol): boolean;
              isFunctionalInterface(tsym: Symbol$TypeSymbol): boolean;
              isFunctionalInterface(site: Type): boolean;
              isReifiable(t: Type): boolean;
              isSameType(t: Type, s: Type): boolean;
              isSameTypes(ts: javac.util.List<Type>, ss: javac.util.List<Type>): boolean;
              isSameWildcard(t: Type$WildcardType, s: Type): boolean;
              isSignaturePolymorphic(msym: Symbol$MethodSymbol): boolean;
              isSubSignature(t: Type, s: Type): boolean;
              isSubtype(t: Type, s: Type): boolean;
              isSubtype(t: Type, s: Type, capture: boolean): boolean;
              isSubtypeNoCapture(t: Type, s: Type): boolean;
              isSubtypeUnchecked(t: Type, s: Type): boolean;
              isSubtypeUnchecked(t: Type, s: Type, warn: javac.util.Warner): boolean;
              isSubtypeUnchecked(t: Type, ts: javac.util.List<Type>, warn: javac.util.Warner): boolean;
              _isSubtypeUncheckedInternal(t: Type, s: Type, capture: boolean, warn: javac.util.Warner): boolean;
              isSubtypes(ts: javac.util.List<Type>, ss: javac.util.List<Type>): boolean;
              isSubtypesUnchecked(ts: javac.util.List<Type>, ss: javac.util.List<Type>, warn: javac.util.Warner): boolean;
              isSuperType(t: Type, s: Type): boolean;
              isUnbounded(t: Type): boolean;
              lub(ts: javac.util.List<Type>): Type;
              lub(ts: Type[]): Type;
              lub(...ts: Type[]): Type;
              makeArrayType(t: Type): Type$ArrayType;
              _makeExtendsWildcard(bound: Type, formal: Type$TypeVar): Type$WildcardType;
              makeFunctionalInterfaceClass(env: javac.comp.Env<javac.comp.AttrContext>, name: javac.util.Name, target: Type, cflags: long): Symbol$ClassSymbol;
              makeIntersectionType(bounds: javac.util.List<Type>): Type$IntersectionClassType;
              makeIntersectionType(bounds: javac.util.List<Type>, allInterfaces: boolean): Type$IntersectionClassType;
              _makeSuperWildcard(bound: Type, formal: Type$TypeVar): Type$WildcardType;
              memberType(t: Type, sym: Symbol): Type;
              membersClosure(site: Type, skipInterface: boolean): Scope$CompoundScope;
              _merge(c1: Type, c2: Type): Type;
              mergeAbstracts(ambiguousInOrder: javac.util.List<Symbol>, site: Type, sigCheck: boolean): java.util.Optional<Symbol>;
              newInstances(tvars: javac.util.List<Type>): javac.util.List<Type>;
              newRound(): void;
              notSoftSubtype(t: Type, s: Type): boolean;
              overrideEquivalent(t: Type, s: Type): boolean;
              overridesObjectMethod(origin: Symbol$TypeSymbol, msym: Symbol): boolean;
              _pendingBridges(origin: Symbol$ClassSymbol, s: Symbol$TypeSymbol): boolean;
              prune(methods: javac.util.List<Symbol$MethodSymbol>): javac.util.List<Symbol$MethodSymbol>;
              rank(t: Type): int;
              _relaxBound(t: Type): Type;
              removeWildcards(site: Type): Type;
              resultSubtype(t: Type, s: Type, warner: javac.util.Warner): boolean;
              returnTypeSubstitutable(r1: Type, r2: Type): boolean;
              returnTypeSubstitutable(r1: Type, r2: Type, r2res: Type, warner: javac.util.Warner): boolean;
              _rewriteQuantifiers(t: Type, high: boolean, rewriteTypeVars: boolean): Type;
              setBounds(t: Type$TypeVar, bounds: javac.util.List<Type>): void;
              setBounds(t: Type$TypeVar, bounds: javac.util.List<Type>, allInterfaces: boolean): void;
              _sideCast(from: Type, to: Type, warn: javac.util.Warner): boolean;
              _sideCastFinal(from: Type, to: Type, warn: javac.util.Warner): boolean;
              skipTypeVars(site: Type, capture: boolean): Type;
              subst(ts: javac.util.List<Type>, from: javac.util.List<Type>, to: javac.util.List<Type>): javac.util.List<Type>;
              subst(t: Type, from: javac.util.List<Type>, to: javac.util.List<Type>): Type;
              substBound(t: Type$TypeVar, from: javac.util.List<Type>, to: javac.util.List<Type>): Type$TypeVar;
              substBounds(tvars: javac.util.List<Type>, from: javac.util.List<Type>, to: javac.util.List<Type>): javac.util.List<Type>;
              _superClosure(t: Type, s: Type): javac.util.List<Type>;
              supertype(t: Type): Type;
              toString(t: Type, locale: java.util.Locale): string;
              toString(t: Symbol, locale: java.util.Locale): string;
              toString(t: Type): string;
              _typaramsString(tvars: javac.util.List<Type>): string;
              unboxedType(t: Type): Type;
              unboxedTypeOrType(t: Type): Type;
              union(cl1: javac.util.List<Type>, cl2: javac.util.List<Type>, shouldSkip: java.util.function.BiPredicate<Type,Type>): javac.util.List<Type>;
              union(cl1: javac.util.List<Type>, cl2: javac.util.List<Type>): javac.util.List<Type>;
              upward(t: Type, vars: javac.util.List<Type>): Type;
              wildLowerBound(t: Type): Type;
              wildUpperBound(t: Type): Type;
              _arraySuperType: Type;
              _asSub: Types$SimpleVisitor<Type,Symbol>;
              _asSuper: Types$SimpleVisitor<Type,Symbol>;
              _basicClosureSkip: java.util.function.BiPredicate<Type,Type>;
              _bridgeFilter: java.util.function.Predicate<Symbol>;
              candidatesCache: Types$CandidatesCache;
              _capturedName: javac.util.Name;
              _chk: javac.comp.Check;
              _classBound: Types$UnaryVisitor<Type>;
              _closureCache: java.util.Map<Type,javac.util.List<Type>>;
              _containsType: Types$TypeRelation;
              _cvarLowerBoundMapping: Types$TypeMapping<java.lang.Void>;
              _descCache: Types$DescriptorCache;
              _diags: javac.util.JCDiagnostic$Factory;
              _directSupertypes: Types$UnaryVisitor<javac.util.List<Type>>;
              _disjointType: Types$TypeRelation;
              _elemTypeFun: Types$TypeMapping<java.lang.Void>;
              _enter: javac.comp.Enter;
              _erasure: Types$TypeMapping<boolean>;
              _hasSameArgs_nonstrict: Types$TypeRelation;
              _hasSameArgs_strict: Types$TypeRelation;
              _implCache: Types$ImplementationCache;
              _interfaces: Types$UnaryVisitor<javac.util.List<Type>>;
              _isCastable: Types$TypeRelation;
              _isDerivedRawCache: java.util.Map<Type,boolean>;
              _isReifiable: Types$UnaryVisitor<boolean>;
              _isSameTypeVisitor: Types$TypeRelation;
              _isSubtype: Types$TypeRelation;
              _isUnbounded: Types$UnaryVisitor<boolean>;
              _memberType: Types$SimpleVisitor<Type,Symbol>;
              _membersCache: Types$MembersClosureCache;
              _mergeCache: java.util.Set<Types$TypePair>;
              _messages: javac.util.JavacMessages;
              _methodWithParameters: Types$MapVisitor<javac.util.List<Type>>;
              _methodWithReturn: Types$MapVisitor<Type>;
              _methodWithThrown: Types$MapVisitor<javac.util.List<Type>>;
              _names: javac.util.Names;
              readonly noWarnings: javac.util.Warner;
              _supertype: Types$UnaryVisitor<Type>;
              _syms: Symtab;
              _warnStack: javac.util.List<javac.util.Warner>;
            }
            interface Types extends CombineTypes<[_Types, java.lang.Object]> {}
            interface _Types$AdaptFailure$$static extends ClassLike {
              _serialVersionUID: long;
              new(): Types$AdaptFailure;
            }
            let Types$AdaptFailure: _Types$AdaptFailure$$static;
            interface _Types$AdaptFailure {
            }
            interface Types$AdaptFailure extends CombineTypes<[_Types$AdaptFailure, java.lang.RuntimeException]> {}
            interface _Types$Adapter$$static extends ClassLike {
              _new(this$0: javac.util.ListBuffer<Type>, from: javac.util.ListBuffer<Type>): Types$Adapter;
            }
            let Types$Adapter: _Types$Adapter$$static;
            interface _Types$Adapter {
              adapt(source: Type, target: Type): void;
              _adaptRecursive(source: Type, target: Type): void;
              _adaptRecursive(source: javac.util.List<Type>, target: javac.util.List<Type>): void;
              visitArrayType(source: Type$ArrayType, target: Type): java.lang.Void;
              visitArrayType(a0: Type$ArrayType, a1: any): any;
              visitClassType(source: Type$ClassType, target: Type): java.lang.Void;
              visitClassType(a0: Type$ClassType, a1: any): any;
              visitType(source: Type, target: Type): java.lang.Void;
              visitType(a0: Type, a1: any): any;
              visitTypeVar(source: Type$TypeVar, target: Type): java.lang.Void;
              visitTypeVar(a0: Type$TypeVar, a1: any): any;
              visitWildcardType(source: Type$WildcardType, target: Type): java.lang.Void;
              visitWildcardType(a0: Type$WildcardType, a1: any): any;
              _cache: java.util.Set<Types$TypePair>;
              _from: javac.util.ListBuffer<Type>;
              _mapping: java.util.Map<Symbol,Type>;
              _this$0: Types;
              _to: javac.util.ListBuffer<Type>;
            }
            interface Types$Adapter extends CombineTypes<[_Types$Adapter, Types$SimpleVisitor<java.lang.Void,Type>]> {}
            interface _Types$CandidatesCache$$static extends ClassLike {
              new(this$0: Types): Types$CandidatesCache;
            }
            let Types$CandidatesCache: _Types$CandidatesCache$$static;
            interface _Types$CandidatesCache {
              get(e: Types$CandidatesCache$Entry): javac.util.List<Symbol$MethodSymbol>;
              put(e: Types$CandidatesCache$Entry, msymbols: javac.util.List<Symbol$MethodSymbol>): void;
              cache: java.util.Map<Types$CandidatesCache$Entry,javac.util.List<Symbol$MethodSymbol>>;
              _this$0: Types;
            }
            interface Types$CandidatesCache extends CombineTypes<[_Types$CandidatesCache, java.lang.Object]> {}
            interface _Types$CandidatesCache$Entry$$static extends ClassLike {
              _new(this$1: Types$CandidatesCache, site: Type, msym: Symbol$MethodSymbol): Types$CandidatesCache$Entry;
            }
            let Types$CandidatesCache$Entry: _Types$CandidatesCache$Entry$$static;
            interface _Types$CandidatesCache$Entry {
              equals(obj: any): boolean;
              hashCode(): int;
              _msym: Symbol$MethodSymbol;
              _site: Type;
              _this$1: Types$CandidatesCache;
            }
            interface Types$CandidatesCache$Entry extends CombineTypes<[_Types$CandidatesCache$Entry, java.lang.Object]> {}
            interface _Types$CaptureScanner$$static extends ClassLike {
              _new(this$0: Types): Types$CaptureScanner;
            }
            let Types$CaptureScanner: _Types$CaptureScanner$$static;
            interface _Types$CaptureScanner {
              visitArrayType(t: Type$ArrayType, seen: java.util.Set<Type>): java.lang.Void;
              visitArrayType(a0: Type$ArrayType, a1: any): any;
              visitCapturedType(t: Type$CapturedType, seen: java.util.Set<Type>): java.lang.Void;
              visitCapturedType(a0: Type$CapturedType, a1: any): any;
              visitClassType(t: Type$ClassType, seen: java.util.Set<Type>): java.lang.Void;
              visitClassType(a0: Type$ClassType, a1: any): any;
              visitType(t: Type, types: java.util.Set<Type>): java.lang.Void;
              visitType(a0: Type, a1: any): any;
              visitTypeVar(t: Type$TypeVar, seen: java.util.Set<Type>): java.lang.Void;
              visitTypeVar(a0: Type$TypeVar, a1: any): any;
              visitWildcardType(t: Type$WildcardType, seen: java.util.Set<Type>): java.lang.Void;
              visitWildcardType(a0: Type$WildcardType, a1: any): any;
              _this$0: Types;
            }
            interface Types$CaptureScanner extends CombineTypes<[_Types$CaptureScanner, Types$SimpleVisitor<java.lang.Void,java.util.Set<Type>>]> {}
            interface _Types$ClosureHolder$$static extends ClassLike {
              _new(this$0: boolean, minClosure: java.util.function.BiPredicate<Type,Type>): Types$ClosureHolder;
            }
            let Types$ClosureHolder: _Types$ClosureHolder$$static;
            interface _Types$ClosureHolder {
              _add(type: Type): void;
              _closure(): javac.util.List<Type>;
              _merge(other: Types$ClosureHolder): Types$ClosureHolder;
              _closure: javac.util.List<Type>;
              _minClosure: boolean;
              _shouldSkip: java.util.function.BiPredicate<Type,Type>;
              _this$0: Types;
            }
            interface Types$ClosureHolder extends CombineTypes<[_Types$ClosureHolder, java.lang.Object]> {}
            interface _Types$DefaultSymbolVisitor$$static<R,S> extends ClassLike {
              new(): Types$DefaultSymbolVisitor<R,S>;
            }
            let Types$DefaultSymbolVisitor: _Types$DefaultSymbolVisitor$$static<R,S>;
            interface _Types$DefaultSymbolVisitor<R,S> {
              visit(s: Symbol, arg: S): R;
              visitClassSymbol(s: Symbol$ClassSymbol, arg: S): R;
              visitMethodSymbol(s: Symbol$MethodSymbol, arg: S): R;
              visitOperatorSymbol(s: Symbol$OperatorSymbol, arg: S): R;
              visitPackageSymbol(s: Symbol$PackageSymbol, arg: S): R;
              visitTypeSymbol(s: Symbol$TypeSymbol, arg: S): R;
              visitVarSymbol(s: Symbol$VarSymbol, arg: S): R;
            }
            interface Types$DefaultSymbolVisitor<R,S> extends CombineTypes<[_Types$DefaultSymbolVisitor<R,S>, Symbol$Visitor<R,S>, java.lang.Object]> {}
            interface _Types$DefaultTypeVisitor$$static<R,S> extends ClassLike {
              new(): Types$DefaultTypeVisitor<R,S>;
            }
            let Types$DefaultTypeVisitor: _Types$DefaultTypeVisitor$$static<R,S>;
            interface _Types$DefaultTypeVisitor<R,S> {
              visit(t: Type, s: S): R;
              visitArrayType(t: Type$ArrayType, s: S): R;
              visitCapturedType(t: Type$CapturedType, s: S): R;
              visitClassType(t: Type$ClassType, s: S): R;
              visitErrorType(t: Type$ErrorType, s: S): R;
              visitForAll(t: Type$ForAll, s: S): R;
              visitMethodType(t: Type$MethodType, s: S): R;
              visitModuleType(t: Type$ModuleType, s: S): R;
              visitPackageType(t: Type$PackageType, s: S): R;
              visitTypeVar(t: Type$TypeVar, s: S): R;
              visitUndetVar(t: Type$UndetVar, s: S): R;
              visitWildcardType(t: Type$WildcardType, s: S): R;
            }
            interface Types$DefaultTypeVisitor<R,S> extends CombineTypes<[_Types$DefaultTypeVisitor<R,S>, Type$Visitor<R,S>, java.lang.Object]> {}
            interface _Types$DescriptorCache$$static extends ClassLike {
              _new(this$0: Types): Types$DescriptorCache;
            }
            let Types$DescriptorCache: _Types$DescriptorCache$$static;
            interface _Types$DescriptorCache {
              _failure(msg: string, args: any[]): Types$FunctionDescriptorLookupError;
              _failure(msg: string, ...args: any[]): Types$FunctionDescriptorLookupError;
              _failure(diag: javac.util.JCDiagnostic): Types$FunctionDescriptorLookupError;
              findDescriptorInternal(origin: Symbol$TypeSymbol, membersCache: Scope$CompoundScope): Types$DescriptorCache$FunctionDescriptor;
              _get(origin: Symbol$TypeSymbol): Types$DescriptorCache$FunctionDescriptor;
              _mergeDescriptors(origin: Symbol$TypeSymbol, methodSyms: javac.util.List<Symbol>): Types$DescriptorCache$FunctionDescriptor;
              __map: java.util.WeakHashMap<Symbol$TypeSymbol,Types$DescriptorCache$Entry>;
              _this$0: Types;
            }
            interface Types$DescriptorCache extends CombineTypes<[_Types$DescriptorCache, java.lang.Object]> {}
            interface _Types$DescriptorCache$Entry$$static extends ClassLike {
              new(this$1: Types$DescriptorCache, cachedDescRes: Types$DescriptorCache$FunctionDescriptor, prevMark: int): Types$DescriptorCache$Entry;
            }
            let Types$DescriptorCache$Entry: _Types$DescriptorCache$Entry$$static;
            interface _Types$DescriptorCache$Entry {
              _matches(mark: int): boolean;
              _cachedDescRes: Types$DescriptorCache$FunctionDescriptor;
              _prevMark: int;
            }
            interface Types$DescriptorCache$Entry extends CombineTypes<[_Types$DescriptorCache$Entry, java.lang.Object]> {}
            interface _Types$DescriptorCache$FunctionDescriptor$$static extends ClassLike {
              _new(this$1: Types$DescriptorCache, descSym: Symbol): Types$DescriptorCache$FunctionDescriptor;
            }
            let Types$DescriptorCache$FunctionDescriptor: _Types$DescriptorCache$FunctionDescriptor$$static;
            interface _Types$DescriptorCache$FunctionDescriptor {
              getSymbol(): Symbol;
              getType(site: Type): Type;
              _descSym: Symbol;
              _this$1: Types$DescriptorCache;
            }
            interface Types$DescriptorCache$FunctionDescriptor extends CombineTypes<[_Types$DescriptorCache$FunctionDescriptor, java.lang.Object]> {}
            interface _Types$DescriptorFilter$$static extends ClassLike {
              _new(this$0: Types, origin: Symbol$TypeSymbol): Types$DescriptorFilter;
            }
            let Types$DescriptorFilter: _Types$DescriptorFilter$$static;
            interface _Types$DescriptorFilter {
              test(sym: Symbol): boolean;
              test(a0: any): boolean;
              _origin: Symbol$TypeSymbol;
              _this$0: Types;
            }
            interface Types$DescriptorFilter extends CombineTypes<[_Types$DescriptorFilter, java.lang.Object, java.util.function.Predicate<Symbol>]> {}
            interface _Types$FunctionDescriptorLookupError$$static extends ClassLike {
              _serialVersionUID: long;
              _new(): Types$FunctionDescriptorLookupError;
            }
            let Types$FunctionDescriptorLookupError: _Types$FunctionDescriptorLookupError$$static;
            interface _Types$FunctionDescriptorLookupError {
              fillInStackTrace(): java.lang.Throwable;
              getDiagnostic(): javac.util.JCDiagnostic;
              _setMessage(diag: javac.util.JCDiagnostic): Types$FunctionDescriptorLookupError;
              _diagnostic: javac.util.JCDiagnostic;
            }
            interface Types$FunctionDescriptorLookupError extends CombineTypes<[_Types$FunctionDescriptorLookupError, java.lang.RuntimeException]> {}
            interface _Types$HasSameArgs$$static extends ClassLike {
              new(a0: Types, strict: boolean): Types$HasSameArgs;
            }
            let Types$HasSameArgs: _Types$HasSameArgs$$static;
            interface _Types$HasSameArgs {
              visitErrorType(t: Type$ErrorType, s: Type): boolean;
              visitErrorType(a0: Type$ErrorType, a1: any): any;
              visitForAll(t: Type$ForAll, s: Type): boolean;
              visitForAll(a0: Type$ForAll, a1: any): any;
              visitMethodType(t: Type$MethodType, s: Type): boolean;
              visitMethodType(a0: Type$MethodType, a1: any): any;
              visitType(t: Type, s: Type): boolean;
              visitType(a0: Type, a1: any): any;
              _strict: boolean;
              _this$0: Types;
            }
            interface Types$HasSameArgs extends CombineTypes<[_Types$HasSameArgs, com.sun.tools.javac.code.Types$TypeRelation]> {}
            interface _Types$HashCodeVisitor$$static extends ClassLike {
            }
            let Types$HashCodeVisitor: _Types$HashCodeVisitor$$static;
            interface _Types$HashCodeVisitor {
              visitArrayType(t: Type$ArrayType, ignored: java.lang.Void): int;
              visitArrayType(a0: Type$ArrayType, a1: any): any;
              visitClassType(t: Type$ClassType, ignored: java.lang.Void): int;
              visitClassType(a0: Type$ClassType, a1: any): any;
              visitErrorType(t: Type$ErrorType, ignored: java.lang.Void): int;
              visitErrorType(a0: Type$ErrorType, a1: any): any;
              visitMethodType(t: Type$MethodType, ignored: java.lang.Void): int;
              visitMethodType(a0: Type$MethodType, a1: any): any;
              visitType(t: Type, ignored: java.lang.Void): int;
              visitType(a0: Type, a1: any): any;
              visitTypeVar(t: Type$TypeVar, ignored: java.lang.Void): int;
              visitTypeVar(a0: Type$TypeVar, a1: any): any;
              visitUndetVar(t: Type$UndetVar, ignored: java.lang.Void): int;
              visitUndetVar(a0: Type$UndetVar, a1: any): any;
              visitWildcardType(t: Type$WildcardType, ignored: java.lang.Void): int;
              visitWildcardType(a0: Type$WildcardType, a1: any): any;
            }
            interface Types$HashCodeVisitor extends CombineTypes<[_Types$HashCodeVisitor, Types$UnaryVisitor<int>]> {}
            interface _Types$ImplementationCache$$static extends ClassLike {
              _new(this$0: Types): Types$ImplementationCache;
            }
            let Types$ImplementationCache: _Types$ImplementationCache$$static;
            interface _Types$ImplementationCache {
              _get(ms: Symbol$MethodSymbol, origin: Symbol$TypeSymbol, checkResult: boolean, implFilter: java.util.function.Predicate<Symbol>): Symbol$MethodSymbol;
              _implementationInternal(ms: Symbol$MethodSymbol, origin: Symbol$TypeSymbol, checkResult: boolean, implFilter: java.util.function.Predicate<Symbol>): Symbol$MethodSymbol;
              __map: java.util.WeakHashMap<Symbol$MethodSymbol,java.lang.ref.SoftReference<java.util.Map<Symbol$TypeSymbol,Types$ImplementationCache$Entry>>>;
              _this$0: Types;
            }
            interface Types$ImplementationCache extends CombineTypes<[_Types$ImplementationCache, java.lang.Object]> {}
            interface _Types$ImplementationCache$Entry$$static extends ClassLike {
              new(this$1: Symbol$MethodSymbol, cachedImpl: java.util.function.Predicate<Symbol>, scopeFilter: boolean, checkResult: int): Types$ImplementationCache$Entry;
            }
            let Types$ImplementationCache$Entry: _Types$ImplementationCache$Entry$$static;
            interface _Types$ImplementationCache$Entry {
              _matches(scopeFilter: java.util.function.Predicate<Symbol>, checkResult: boolean, mark: int): boolean;
              _cachedImpl: Symbol$MethodSymbol;
              _checkResult: boolean;
              _implFilter: java.util.function.Predicate<Symbol>;
              _prevMark: int;
            }
            interface Types$ImplementationCache$Entry extends CombineTypes<[_Types$ImplementationCache$Entry, java.lang.Object]> {}
            interface _Types$MapVisitor$$static<S> extends ClassLike {
              new(): Types$MapVisitor<S>;
            }
            let Types$MapVisitor: _Types$MapVisitor$$static<S>;
            interface _Types$MapVisitor<S> {
              visit(t: Type): Type;
              visitType(t: Type, s: S): Type;
              visitType(a0: Type, a1: any): any;
            }
            interface Types$MapVisitor<S> extends CombineTypes<[_Types$MapVisitor<S>, Types$DefaultTypeVisitor<Type,S>]> {}
            interface _Types$MembersClosureCache$$static extends ClassLike {
              _new(this$0: Types): Types$MembersClosureCache;
            }
            let Types$MembersClosureCache: _Types$MembersClosureCache$$static;
            interface _Types$MembersClosureCache {
              visitClassType(t: Type$ClassType, _unused: java.lang.Void): Scope$CompoundScope;
              visitClassType(a0: Type$ClassType, a1: any): any;
              visitType(t: Type, _unused: java.lang.Void): Scope$CompoundScope;
              visitType(a0: Type, a1: any): any;
              visitTypeVar(t: Type$TypeVar, _unused: java.lang.Void): Scope$CompoundScope;
              visitTypeVar(a0: Type$TypeVar, a1: any): any;
              __map: java.util.Map<Symbol$TypeSymbol,Scope$CompoundScope>;
              _nilScope: Scope$CompoundScope;
              _seenTypes: java.util.Set<Symbol$TypeSymbol>;
              _this$0: Types;
            }
            interface Types$MembersClosureCache extends CombineTypes<[_Types$MembersClosureCache, Types$SimpleVisitor<Scope$CompoundScope,java.lang.Void>]> {}
            interface _Types$MembersClosureCache$MembersScope$$static extends ClassLike {
              new(this$1: Types$MembersClosureCache, scope: Scope$CompoundScope): Types$MembersClosureCache$MembersScope;
            }
            let Types$MembersClosureCache$MembersScope: _Types$MembersClosureCache$MembersScope$$static;
            interface _Types$MembersClosureCache$MembersScope {
              _combine(sf: java.util.function.Predicate<Symbol>): java.util.function.Predicate<Symbol>;
              getMark(): int;
              getSymbols(sf: java.util.function.Predicate<Symbol>, lookupKind: Scope$LookupKind): java.lang.Iterable<Symbol>;
              getSymbolsByName(name: javac.util.Name, sf: java.util.function.Predicate<Symbol>, lookupKind: Scope$LookupKind): java.lang.Iterable<Symbol>;
              _scope: Scope$CompoundScope;
            }
            interface Types$MembersClosureCache$MembersScope extends CombineTypes<[_Types$MembersClosureCache$MembersScope, com.sun.tools.javac.code.Scope$CompoundScope]> {}
            interface _Types$MethodFilter$$static extends ClassLike {
              _new(a0: Types, msym: Symbol, site: Type): Types$MethodFilter;
            }
            let Types$MethodFilter: _Types$MethodFilter$$static;
            interface _Types$MethodFilter {
              test(s: Symbol): boolean;
              test(a0: any): boolean;
              _msym: Symbol;
              _site: Type;
              _this$0: Types;
            }
            interface Types$MethodFilter extends CombineTypes<[_Types$MethodFilter, java.lang.Object, java.util.function.Predicate<Symbol>]> {}
            interface _Types$MostSpecificReturnCheck$$static extends ClassLike {
              valueOf(name: string): Types$MostSpecificReturnCheck;
              values(): Types$MostSpecificReturnCheck[];
              readonly BASIC: Types$MostSpecificReturnCheck;
              readonly RTS: Types$MostSpecificReturnCheck;
            }
            let Types$MostSpecificReturnCheck: _Types$MostSpecificReturnCheck$$static;
            interface _Types$MostSpecificReturnCheck {
              test(a0: Type, a1: Type, a2: Types): boolean;
(a0: Type, a1: Type, a2: Types): boolean;
            }
            interface Types$MostSpecificReturnCheck extends CombineTypes<[_Types$MostSpecificReturnCheck]> {}
            interface _Types$ProjectionKind$$static extends ClassLike {
              valueOf(name: string): Types$ProjectionKind;
              values(): Types$ProjectionKind[];
              readonly DOWNWARDS: Types$ProjectionKind;
              readonly UPWARDS: Types$ProjectionKind;
            }
            let Types$ProjectionKind: _Types$ProjectionKind$$static;
            interface _Types$ProjectionKind {
              _complement(): Types$ProjectionKind;
(): Types$ProjectionKind;
            }
            interface Types$ProjectionKind extends CombineTypes<[_Types$ProjectionKind]> {}
            interface _Types$Rewriter$$static extends ClassLike {
              _new(this$0: Types, high: boolean, rewriteTypeVars: boolean): Types$Rewriter;
            }
            let Types$Rewriter: _Types$Rewriter$$static;
            interface _Types$Rewriter {
              _B(t: Type): Type;
              _rewriteAsWildcardType(bound: Type, formal: Type$TypeVar, bk: BoundKind): Type;
              visitCapturedType(t: Type$CapturedType, s: java.lang.Void): Type;
              visitCapturedType(a0: Type$CapturedType, a1: any): any;
              visitClassType(t: Type$ClassType, s: java.lang.Void): Type;
              visitClassType(a0: Type$ClassType, a1: any): any;
              visitType(t: Type, s: java.lang.Void): Type;
              visitType(a0: Type, a1: any): any;
              visitTypeVar(t: Type$TypeVar, s: java.lang.Void): Type;
              visitTypeVar(a0: Type$TypeVar, a1: any): any;
              visitWildcardType(t: Type$WildcardType, s: java.lang.Void): Type;
              visitWildcardType(a0: Type$WildcardType, a1: any): any;
              _high: boolean;
              _rewriteTypeVars: boolean;
              _this$0: Types;
            }
            interface Types$Rewriter extends CombineTypes<[_Types$Rewriter, Types$UnaryVisitor<Type>]> {}
            interface _Types$SignatureGenerator$$static extends ClassLike {
              _new(types: Types): Types$SignatureGenerator;
            }
            let Types$SignatureGenerator: _Types$SignatureGenerator$$static;
            interface _Types$SignatureGenerator {
              _append(a0: char): void;
              _append(a0: byte[]): void;
              _append(a0: javac.util.Name): void;
              assembleClassSig(type: Type): void;
              assembleParamsSig(typarams: javac.util.List<Type>): void;
              assembleSig(type: Type): void;
              assembleSig(types: javac.util.List<Type>): void;
              _classReference(c: Symbol$ClassSymbol): void;
              hasTypeVar(l: javac.util.List<Type>): boolean;
              _reportIllegalSignature(t: Type): void;
              _types: Types;
            }
            interface Types$SignatureGenerator extends CombineTypes<[_Types$SignatureGenerator, java.lang.Object]> {}
            interface _Types$SignatureGenerator$InvalidSignatureException$$static extends ClassLike {
              _serialVersionUID: long;
              _new(type: Type): Types$SignatureGenerator$InvalidSignatureException;
            }
            let Types$SignatureGenerator$InvalidSignatureException: _Types$SignatureGenerator$InvalidSignatureException$$static;
            interface _Types$SignatureGenerator$InvalidSignatureException {
              fillInStackTrace(): java.lang.Throwable;
              type(): Type;
              _type: Type;
            }
            interface Types$SignatureGenerator$InvalidSignatureException extends CombineTypes<[_Types$SignatureGenerator$InvalidSignatureException, java.lang.RuntimeException]> {}
            interface _Types$SimpleVisitor$$static<R,S> extends ClassLike {
              new(): Types$SimpleVisitor<R,S>;
            }
            let Types$SimpleVisitor: _Types$SimpleVisitor$$static<R,S>;
            interface _Types$SimpleVisitor<R,S> {
              visitCapturedType(t: Type$CapturedType, s: S): R;
              visitForAll(t: Type$ForAll, s: S): R;
              visitUndetVar(t: Type$UndetVar, s: S): R;
            }
            interface Types$SimpleVisitor<R,S> extends CombineTypes<[_Types$SimpleVisitor<R,S>, Types$DefaultTypeVisitor<R,S>]> {}
            interface _Types$Subst$$static extends ClassLike {
              new(a0: javac.util.List<Type>, from: javac.util.List<Type>): Types$Subst;
            }
            let Types$Subst: _Types$Subst$$static;
            interface _Types$Subst {
              visitClassType(t: Type$ClassType, ignored: java.lang.Void): Type;
              visitClassType(a0: Type$ClassType, a1: any): Type;
              visitClassType(a0: Type$ClassType, a1: any): any;
              visitForAll(t: Type$ForAll, ignored: java.lang.Void): Type;
              visitForAll(a0: Type$ForAll, a1: any): Type;
              visitForAll(a0: Type$ForAll, a1: any): any;
              visitTypeVar(t: Type$TypeVar, ignored: java.lang.Void): Type;
              visitTypeVar(a0: Type$TypeVar, a1: any): any;
              visitWildcardType(t: Type$WildcardType, ignored: java.lang.Void): Type;
              visitWildcardType(a0: Type$WildcardType, a1: any): Type;
              visitWildcardType(a0: Type$WildcardType, a1: any): any;
              _from: javac.util.List<Type>;
              _this$0: Types;
              _to: javac.util.List<Type>;
            }
            interface Types$Subst extends CombineTypes<[_Types$Subst, Type$StructuralTypeMapping<java.lang.Void>]> {}
            interface _Types$TypeMapping$$static<S> extends ClassLike {
              new(): Types$TypeMapping<S>;
            }
            let Types$TypeMapping: _Types$TypeMapping$$static<S>;
            interface _Types$TypeMapping<S> {
              apply(type: Type): Type;
              apply(a0: any): any;
              _visit(ts: javac.util.List<Type>, s: S): javac.util.List<Type>;
              visitCapturedType(t: Type$CapturedType, s: S): Type;
              visitCapturedType(a0: Type$CapturedType, a1: any): any;
            }
            interface Types$TypeMapping<S> extends CombineTypes<[_Types$TypeMapping<S>, java.util.function.Function<Type,Type>, Types$MapVisitor<S>]> {}
            interface _Types$TypePair$$static extends ClassLike {
              _new(this$0: Types, t1: Type, t2: Type): Types$TypePair;
            }
            let Types$TypePair: _Types$TypePair$$static;
            interface _Types$TypePair {
              equals(obj: any): boolean;
              hashCode(): int;
              _t1: Type;
              _t2: Type;
              _this$0: Types;
            }
            interface Types$TypePair extends CombineTypes<[_Types$TypePair, java.lang.Object]> {}
            interface _Types$TypeProjection$$static extends ClassLike {
              new(this$0: javac.util.List<Type>): Types$TypeProjection;
            }
            let Types$TypeProjection: _Types$TypeProjection$$static;
            interface _Types$TypeProjection {
              _mapTypeArgument(site: Type, declaredBound: Type, t: Type, pkind: Types$ProjectionKind): Type;
              visitArrayType(t: Type$ArrayType, s: Types$ProjectionKind): Type;
              visitArrayType(a0: Type$ArrayType, a1: any): any;
              visitClassType(t: Type$ClassType, pkind: Types$ProjectionKind): Type;
              visitClassType(a0: Type$ClassType, a1: any): any;
              visitTypeVar(t: Type$TypeVar, pkind: Types$ProjectionKind): Type;
              visitTypeVar(a0: Type$TypeVar, a1: any): any;
              _seen: java.util.Set<Type>;
              _this$0: Types;
              _vars: javac.util.List<Type>;
            }
            interface Types$TypeProjection extends CombineTypes<[_Types$TypeProjection, Types$TypeMapping<Types$ProjectionKind>]> {}
            interface _Types$TypeProjection$TypeArgumentProjection$$static extends ClassLike {
              _new(this$1: Types$TypeProjection, site: Type, declaredBound: Type): Types$TypeProjection$TypeArgumentProjection;
            }
            let Types$TypeProjection$TypeArgumentProjection: _Types$TypeProjection$TypeArgumentProjection$$static;
            interface _Types$TypeProjection$TypeArgumentProjection {
              _makeWildcard(bound: Type, bk: BoundKind): Type;
              visitType(t: Type, pkind: Types$ProjectionKind): Type;
              visitType(a0: Type, a1: any): Type;
              visitType(a0: Type, a1: any): any;
              visitWildcardType(wt: Type$WildcardType, pkind: Types$ProjectionKind): Type;
              visitWildcardType(a0: Type$WildcardType, a1: any): any;
              _declaredBound: Type;
              _site: Type;
              _this$1: Types$TypeProjection;
            }
            interface Types$TypeProjection$TypeArgumentProjection extends CombineTypes<[_Types$TypeProjection$TypeArgumentProjection, Types$TypeMapping<Types$ProjectionKind>]> {}
            interface _Types$TypeRelation$$static extends ClassLike {
              new(): Types$TypeRelation;
            }
            let Types$TypeRelation: _Types$TypeRelation$$static;
            interface _Types$TypeRelation {
            }
            interface Types$TypeRelation extends CombineTypes<[_Types$TypeRelation, Types$SimpleVisitor<boolean,Type>]> {}
            interface _Types$UnaryVisitor$$static<R> extends ClassLike {
              new(): Types$UnaryVisitor<R>;
            }
            let Types$UnaryVisitor: _Types$UnaryVisitor$$static<R>;
            interface _Types$UnaryVisitor<R> {
              visit(t: Type): R;
            }
            interface Types$UnaryVisitor<R> extends CombineTypes<[_Types$UnaryVisitor<R>, Types$SimpleVisitor<R,java.lang.Void>]> {}
            interface _Types$UniqueType$$static extends ClassLike {
              new(type: Type, types: Types): Types$UniqueType;
            }
            let Types$UniqueType: _Types$UniqueType$$static;
            interface _Types$UniqueType {
              equals(obj: any): boolean;
              hashCode(): int;
              toString(): string;
              readonly type: Type;
              _types: Types;
            }
            interface Types$UniqueType extends CombineTypes<[_Types$UniqueType, java.lang.Object]> {}
          }
          module comp {
            interface _Analyzer$$static extends ClassLike {
              instance(context: javac.util.Context): Analyzer;
              _analyzerKey: javac.util.Context$Key<Analyzer>;
              _new(context: javac.util.Context): Analyzer;
            }
            let Analyzer: _Analyzer$$static;
            interface _Analyzer {
              _analyze(statement: javac.tree.JCTree$JCStatement, env: Env<AttrContext>): void;
              _analyzeIfNeeded(tree: javac.tree.JCTree, env: Env<AttrContext>): void;
              _copyEnvIfNeeded(tree: javac.tree.JCTree, env: Env<AttrContext>): Env<AttrContext>;
              _doAnalysis(rewriting: Analyzer$RewritingContext): void;
              flush(flushEnv: Env<AttrContext>): void;
              _allowDiamondWithAnonymousClassCreation: boolean;
              _analyzerModes: java.util.EnumSet<Analyzer$AnalyzerMode>;
              _analyzers: Analyzer$StatementAnalyzer<javac.tree.JCTree,javac.tree.JCTree>[];
              _argumentAttr: ArgumentAttr;
              _attr: Attr;
              _copier: Analyzer$AnalyzerCopier;
              _deferredAnalysisHelper: Analyzer$DeferredAnalysisHelper;
              _deferredAttr: DeferredAttr;
              _flushDeferredHelper: Analyzer$DeferredAnalysisHelper;
              _log: javac.util.Log;
              _make: javac.tree.TreeMaker;
              _queueDeferredHelper: Analyzer$DeferredAnalysisHelper;
              _types: javac.code.Types;
            }
            interface Analyzer extends CombineTypes<[_Analyzer, java.lang.Object]> {}
            interface _Analyzer$AnalyzerCopier$$static extends ClassLike {
              new(this$0: Analyzer): Analyzer$AnalyzerCopier;
            }
            let Analyzer$AnalyzerCopier: _Analyzer$AnalyzerCopier$$static;
            interface _Analyzer$AnalyzerCopier {
              visitLambdaExpression(node: sun.source.tree.LambdaExpressionTree, _unused: java.lang.Void): javac.tree.JCTree;
              visitLambdaExpression(a0: sun.source.tree.LambdaExpressionTree, a1: any): javac.tree.JCTree;
              visitLambdaExpression(a0: sun.source.tree.LambdaExpressionTree, a1: any): any;
              visitNewClass(node: sun.source.tree.NewClassTree, aVoid: java.lang.Void): javac.tree.JCTree;
              visitNewClass(a0: sun.source.tree.NewClassTree, a1: any): javac.tree.JCTree;
              visitNewClass(a0: sun.source.tree.NewClassTree, a1: any): any;
            }
            interface Analyzer$AnalyzerCopier extends CombineTypes<[_Analyzer$AnalyzerCopier, javac.tree.TreeCopier<java.lang.Void>]> {}
            interface _Analyzer$AnalyzerMode$$static extends ClassLike {
              _getAnalyzerModes(opt: string, source: javac.code.Source): java.util.EnumSet<Analyzer$AnalyzerMode>;
              valueOf(name: string): Analyzer$AnalyzerMode;
              values(): Analyzer$AnalyzerMode[];
              readonly DIAMOND: Analyzer$AnalyzerMode;
              readonly LAMBDA: Analyzer$AnalyzerMode;
              readonly LOCAL: Analyzer$AnalyzerMode;
              readonly METHOD: Analyzer$AnalyzerMode;
            }
            let Analyzer$AnalyzerMode: _Analyzer$AnalyzerMode$$static;
            interface _Analyzer$AnalyzerMode {
              _feature: javac.code.Source$Feature;
              _opt: string;
            }
            interface Analyzer$AnalyzerMode extends CombineTypes<[_Analyzer$AnalyzerMode]> {}
            interface _Analyzer$DeferredAnalysisHelper$$static extends ClassLike {
            }
            let Analyzer$DeferredAnalysisHelper: _Analyzer$DeferredAnalysisHelper$$static;
            interface _Analyzer$DeferredAnalysisHelper {
              flush(a0: Env<AttrContext>): void;
              queue(a0: Analyzer$RewritingContext): void;
            }
            interface Analyzer$DeferredAnalysisHelper extends CombineTypes<[_Analyzer$DeferredAnalysisHelper, java.lang.Object]> {}
            interface _Analyzer$DiamondInitializer$$static extends ClassLike {
              _new(this$0: Analyzer): Analyzer$DiamondInitializer;
            }
            let Analyzer$DiamondInitializer: _Analyzer$DiamondInitializer$$static;
            interface _Analyzer$DiamondInitializer {
              _match(tree: javac.tree.JCTree$JCNewClass): boolean;
              _match(a0: javac.tree.JCTree): boolean;
              _process(oldTree: javac.tree.JCTree$JCNewClass, newTree: javac.tree.JCTree$JCNewClass, hasErrors: boolean): void;
              _process(a0: javac.tree.JCTree, a1: javac.tree.JCTree, a2: boolean): void;
              _rewrite(oldTree: javac.tree.JCTree$JCNewClass): javac.util.List<javac.tree.JCTree$JCNewClass>;
              _rewrite(a0: javac.tree.JCTree): javac.util.List;
              _this$0: Analyzer;
            }
            interface Analyzer$DiamondInitializer extends CombineTypes<[_Analyzer$DiamondInitializer, Analyzer$StatementAnalyzer<javac.tree.JCTree$JCNewClass,javac.tree.JCTree$JCNewClass>]> {}
            interface _Analyzer$LambdaAnalyzer$$static extends ClassLike {
              _new(this$0: Analyzer): Analyzer$LambdaAnalyzer;
            }
            let Analyzer$LambdaAnalyzer: _Analyzer$LambdaAnalyzer$$static;
            interface _Analyzer$LambdaAnalyzer {
              _decls(decl: javac.tree.JCTree$JCClassDecl): javac.util.List<javac.tree.JCTree>;
              _match(tree: javac.tree.JCTree$JCNewClass): boolean;
              _match(a0: javac.tree.JCTree): boolean;
              _process(oldTree: javac.tree.JCTree$JCNewClass, newTree: javac.tree.JCTree$JCLambda, hasErrors: boolean): void;
              _process(a0: javac.tree.JCTree, a1: javac.tree.JCTree, a2: boolean): void;
              _rewrite(oldTree: javac.tree.JCTree$JCNewClass): javac.util.List<javac.tree.JCTree$JCLambda>;
              _rewrite(a0: javac.tree.JCTree): javac.util.List;
              _this$0: Analyzer;
            }
            interface Analyzer$LambdaAnalyzer extends CombineTypes<[_Analyzer$LambdaAnalyzer, Analyzer$StatementAnalyzer<javac.tree.JCTree$JCNewClass,javac.tree.JCTree$JCLambda>]> {}
            interface _Analyzer$RedundantLocalVarTypeAnalyzer$$static extends ClassLike {
              _new(this$0: Analyzer): Analyzer$RedundantLocalVarTypeAnalyzer;
            }
            let Analyzer$RedundantLocalVarTypeAnalyzer: _Analyzer$RedundantLocalVarTypeAnalyzer$$static;
            interface _Analyzer$RedundantLocalVarTypeAnalyzer {
              _match(tree: javac.tree.JCTree$JCVariableDecl): boolean;
              _match(a0: javac.tree.JCTree): boolean;
              _process(oldTree: javac.tree.JCTree$JCVariableDecl, newTree: javac.tree.JCTree$JCVariableDecl, hasErrors: boolean): void;
              _process(a0: javac.tree.JCTree, a1: javac.tree.JCTree, a2: boolean): void;
              _rewrite(oldTree: javac.tree.JCTree$JCVariableDecl): javac.util.List<javac.tree.JCTree$JCVariableDecl>;
              _rewrite(a0: javac.tree.JCTree): javac.util.List;
              _this$0: Analyzer;
            }
            interface Analyzer$RedundantLocalVarTypeAnalyzer extends CombineTypes<[_Analyzer$RedundantLocalVarTypeAnalyzer, Analyzer$RedundantLocalVarTypeAnalyzerBase<javac.tree.JCTree$JCVariableDecl>]> {}
            interface _Analyzer$RedundantLocalVarTypeAnalyzerBase$$static<X> extends ClassLike {
              _new(this$0: Analyzer, tag: javac.tree.JCTree$Tag): Analyzer$RedundantLocalVarTypeAnalyzerBase<X>;
            }
            let Analyzer$RedundantLocalVarTypeAnalyzerBase: _Analyzer$RedundantLocalVarTypeAnalyzerBase$$static<X>;
            interface _Analyzer$RedundantLocalVarTypeAnalyzerBase<X> {
              _isImplicitlyTyped(decl: javac.tree.JCTree$JCVariableDecl): boolean;
              _processVar(oldTree: javac.tree.JCTree$JCVariableDecl, newTree: javac.tree.JCTree$JCVariableDecl, hasErrors: boolean): void;
              _rewriteVarType(oldTree: javac.tree.JCTree$JCVariableDecl): javac.tree.JCTree$JCVariableDecl;
              _this$0: Analyzer;
            }
            interface Analyzer$RedundantLocalVarTypeAnalyzerBase<X> extends CombineTypes<[_Analyzer$RedundantLocalVarTypeAnalyzerBase<X>, Analyzer$StatementAnalyzer<X,X>]> {}
            interface _Analyzer$RedundantLocalVarTypeAnalyzerForEach$$static extends ClassLike {
              _new(this$0: Analyzer): Analyzer$RedundantLocalVarTypeAnalyzerForEach;
            }
            let Analyzer$RedundantLocalVarTypeAnalyzerForEach: _Analyzer$RedundantLocalVarTypeAnalyzerForEach$$static;
            interface _Analyzer$RedundantLocalVarTypeAnalyzerForEach {
              _match(tree: javac.tree.JCTree$JCEnhancedForLoop): boolean;
              _match(a0: javac.tree.JCTree): boolean;
              _process(oldTree: javac.tree.JCTree$JCEnhancedForLoop, newTree: javac.tree.JCTree$JCEnhancedForLoop, hasErrors: boolean): void;
              _process(a0: javac.tree.JCTree, a1: javac.tree.JCTree, a2: boolean): void;
              _rewrite(oldTree: javac.tree.JCTree$JCEnhancedForLoop): javac.util.List<javac.tree.JCTree$JCEnhancedForLoop>;
              _rewrite(a0: javac.tree.JCTree): javac.util.List;
              _this$0: Analyzer;
            }
            interface Analyzer$RedundantLocalVarTypeAnalyzerForEach extends CombineTypes<[_Analyzer$RedundantLocalVarTypeAnalyzerForEach, Analyzer$RedundantLocalVarTypeAnalyzerBase<javac.tree.JCTree$JCEnhancedForLoop>]> {}
            interface _Analyzer$RedundantTypeArgAnalyzer$$static extends ClassLike {
              _new(this$0: Analyzer): Analyzer$RedundantTypeArgAnalyzer;
            }
            let Analyzer$RedundantTypeArgAnalyzer: _Analyzer$RedundantTypeArgAnalyzer$$static;
            interface _Analyzer$RedundantTypeArgAnalyzer {
              _match(tree: javac.tree.JCTree$JCMethodInvocation): boolean;
              _match(a0: javac.tree.JCTree): boolean;
              _process(oldTree: javac.tree.JCTree$JCMethodInvocation, newTree: javac.tree.JCTree$JCMethodInvocation, hasErrors: boolean): void;
              _process(a0: javac.tree.JCTree, a1: javac.tree.JCTree, a2: boolean): void;
              _rewrite(oldTree: javac.tree.JCTree$JCMethodInvocation): javac.util.List<javac.tree.JCTree$JCMethodInvocation>;
              _rewrite(a0: javac.tree.JCTree): javac.util.List;
              _this$0: Analyzer;
            }
            interface Analyzer$RedundantTypeArgAnalyzer extends CombineTypes<[_Analyzer$RedundantTypeArgAnalyzer, Analyzer$StatementAnalyzer<javac.tree.JCTree$JCMethodInvocation,javac.tree.JCTree$JCMethodInvocation>]> {}
            interface _Analyzer$RewritingContext$$static extends ClassLike {
              _new(this$0: javac.tree.JCTree, originalTree: javac.tree.JCTree, oldTree: javac.tree.JCTree, replacement: Analyzer$StatementAnalyzer<javac.tree.JCTree,javac.tree.JCTree>, analyzer: Env<AttrContext>): Analyzer$RewritingContext;
            }
            let Analyzer$RewritingContext: _Analyzer$RewritingContext$$static;
            interface _Analyzer$RewritingContext {
              _diagHandler(): javac.util.Log$DeferredDiagnosticHandler;
              _analyzer: Analyzer$StatementAnalyzer<javac.tree.JCTree,javac.tree.JCTree>;
              _env: Env<AttrContext>;
              _erroneous: boolean;
              _oldTree: javac.tree.JCTree;
              _originalTree: javac.tree.JCTree;
              _replacement: javac.tree.JCTree;
              _this$0: Analyzer;
            }
            interface Analyzer$RewritingContext extends CombineTypes<[_Analyzer$RewritingContext, java.lang.Object]> {}
            interface _Analyzer$StatementAnalyzer$$static<S,T> extends ClassLike {
              _new(this$0: Analyzer, mode: Analyzer$AnalyzerMode, tag: javac.tree.JCTree$Tag): Analyzer$StatementAnalyzer<S,T>;
            }
            let Analyzer$StatementAnalyzer: _Analyzer$StatementAnalyzer$$static<S,T>;
            interface _Analyzer$StatementAnalyzer<S,T> {
              _isEnabled(): boolean;
              _match(a0: S): boolean;
              _process(a0: S, a1: T, a2: boolean): void;
              _rewrite(a0: S): javac.util.List<T>;
              _mode: Analyzer$AnalyzerMode;
              _tag: javac.tree.JCTree$Tag;
              _this$0: Analyzer;
            }
            interface Analyzer$StatementAnalyzer<S,T> extends CombineTypes<[_Analyzer$StatementAnalyzer<S,T>, java.lang.Object]> {}
            interface _Analyzer$StatementScanner$$static extends ClassLike {
              _new(this$0: javac.tree.JCTree, originalTree: Env<AttrContext>): Analyzer$StatementScanner;
            }
            let Analyzer$StatementScanner: _Analyzer$StatementScanner$$static;
            interface _Analyzer$StatementScanner {
              scan(): void;
              scan(tree: javac.tree.JCTree): void;
              visitBlock(tree: javac.tree.JCTree$JCBlock): void;
              visitClassDef(tree: javac.tree.JCTree$JCClassDecl): void;
              visitDoLoop(tree: javac.tree.JCTree$JCDoWhileLoop): void;
              visitForLoop(tree: javac.tree.JCTree$JCForLoop): void;
              visitForeachLoop(tree: javac.tree.JCTree$JCEnhancedForLoop): void;
              visitIf(tree: javac.tree.JCTree$JCIf): void;
              visitLambda(tree: javac.tree.JCTree$JCLambda): void;
              visitMethodDef(tree: javac.tree.JCTree$JCMethodDecl): void;
              visitSwitch(tree: javac.tree.JCTree$JCSwitch): void;
              visitTry(tree: javac.tree.JCTree$JCTry): void;
              visitWhileLoop(tree: javac.tree.JCTree$JCWhileLoop): void;
              _env: Env<AttrContext>;
              _originalTree: javac.tree.JCTree;
              _rewritings: javac.util.ListBuffer<Analyzer$RewritingContext>;
              _this$0: Analyzer;
            }
            interface Analyzer$StatementScanner extends CombineTypes<[_Analyzer$StatementScanner, com.sun.tools.javac.tree.TreeScanner]> {}
            interface _Analyzer$TreeRewriter$$static extends ClassLike {
              _new(this$0: Analyzer, rewriting: Analyzer$RewritingContext, wrappedTree: javac.tree.JCTree): Analyzer$TreeRewriter;
            }
            let Analyzer$TreeRewriter: _Analyzer$TreeRewriter$$static;
            interface _Analyzer$TreeRewriter {
              copy<Z>(tree: Z, _unused: java.lang.Void): Z;
              copy(a0: javac.tree.JCTree, a1: any): javac.tree.JCTree;
              visitVariable(node: sun.source.tree.VariableTree, p: java.lang.Void): javac.tree.JCTree;
              visitVariable(a0: sun.source.tree.VariableTree, a1: any): javac.tree.JCTree;
              visitVariable(a0: sun.source.tree.VariableTree, a1: any): any;
              _rewriting: Analyzer$RewritingContext;
              _wrappedTree: javac.tree.JCTree;
            }
            interface Analyzer$TreeRewriter extends CombineTypes<[_Analyzer$TreeRewriter, com.sun.tools.javac.comp.Analyzer$AnalyzerCopier]> {}
            interface _Annotate$$static extends ClassLike {
              instance(context: javac.util.Context): Annotate;
              _annotateKey: javac.util.Context$Key<Annotate>;
              _new(context: javac.util.Context): Annotate;
            }
            let Annotate: _Annotate$$static;
            interface _Annotate {
              afterTypes(a: java.lang.Runnable): void;
              annotateDefaultValueLater(defaultValue: javac.tree.JCTree$JCExpression, localEnv: Env<AttrContext>, m: javac.code.Symbol$MethodSymbol, deferPos: javac.util.JCDiagnostic$DiagnosticPosition): void;
              annotateLater(annotations: javac.util.List<javac.tree.JCTree$JCAnnotation>, localEnv: Env<AttrContext>, s: javac.code.Symbol, deferPos: javac.util.JCDiagnostic$DiagnosticPosition): void;
              _annotateNow<T>(toAnnotate: javac.code.Symbol, withAnnotations: javac.util.List<javac.tree.JCTree$JCAnnotation>, env: Env<AttrContext>, typeAnnotations: boolean, isTypeParam: boolean): void;
              annotateTypeParameterSecondStage(tree: javac.tree.JCTree, annotations: javac.util.List<javac.tree.JCTree$JCAnnotation>): void;
              annotateTypeSecondStage(tree: javac.tree.JCTree, annotations: javac.util.List<javac.tree.JCTree$JCAnnotation>, storeAt: javac.code.Type): void;
              annotationTypeSourceCompleter(): Annotate$AnnotationTypeCompleter;
              _annotationValueInfo(pt: javac.code.Type): Attr$ResultInfo;
              annotationsBlocked(): boolean;
              attributeAnnotation(tree: javac.tree.JCTree$JCAnnotation, expectedAnnotationType: javac.code.Type, env: Env<AttrContext>): javac.code.Attribute$Compound;
              _attributeAnnotationNameValuePair(nameValuePair: javac.tree.JCTree$JCExpression, thisAnnotationType: javac.code.Type, badAnnotation: boolean, env: Env<AttrContext>, elidedValue: boolean): javac.util.Pair<javac.code.Symbol$MethodSymbol,javac.code.Attribute>;
              _attributeAnnotationType(env: Env<AttrContext>): void;
              _attributeAnnotationValue(expectedElementType: javac.code.Type, tree: javac.tree.JCTree$JCExpression, env: Env<AttrContext>): javac.code.Attribute;
              _attributeAnnotationValues(a: javac.tree.JCTree$JCAnnotation, expected: javac.code.Type, env: Env<AttrContext>): javac.util.List<javac.util.Pair<javac.code.Symbol$MethodSymbol,javac.code.Attribute>>;
              attributeTypeAnnotation(a: javac.tree.JCTree$JCAnnotation, expectedAnnotationType: javac.code.Type, env: Env<AttrContext>): javac.code.Attribute$TypeCompound;
              blockAnnotations(): void;
              _doneFlushing(): void;
              _enterDefaultValue(defaultValue: javac.tree.JCTree$JCExpression, localEnv: Env<AttrContext>, m: javac.code.Symbol$MethodSymbol): void;
              enterDone(): void;
              enterTypeAnnotations(annotations: javac.util.List<javac.tree.JCTree$JCAnnotation>, env: Env<AttrContext>, s: javac.code.Symbol, deferPos: javac.util.JCDiagnostic$DiagnosticPosition, isTypeParam: boolean): void;
              _extractContainingType(ca: javac.code.Attribute$Compound, pos: javac.util.JCDiagnostic$DiagnosticPosition, annoDecl: javac.code.Symbol$TypeSymbol): javac.code.Type;
              _filterSame(t: javac.code.Type, s: javac.code.Type): javac.code.Type;
              flush(): void;
              fromAnnotations(annotations: javac.util.List<javac.tree.JCTree$JCAnnotation>): javac.util.List<javac.code.Attribute$TypeCompound>;
              _getAnnotationArrayValue(expectedElementType: javac.code.Type, tree: javac.tree.JCTree$JCExpression, env: Env<AttrContext>): javac.code.Attribute;
              _getAnnotationClassValue(expectedElementType: javac.code.Type, tree: javac.tree.JCTree$JCExpression, env: Env<AttrContext>): javac.code.Attribute;
              _getAnnotationEnumValue(expectedElementType: javac.code.Type, tree: javac.tree.JCTree$JCExpression, env: Env<AttrContext>): javac.code.Attribute;
              _getAnnotationPrimitiveValue(expectedElementType: javac.code.Type, tree: javac.tree.JCTree$JCExpression, env: Env<AttrContext>): javac.code.Attribute;
              _getContainingType(currentAnno: javac.code.Attribute$Compound, pos: javac.util.JCDiagnostic$DiagnosticPosition, reportError: boolean): javac.code.Type;
              _isAttributeTrue(attr: javac.code.Attribute): boolean;
              _isFlushing(): boolean;
              _makeContainerAnnotation<T>(toBeReplaced: javac.util.List<T>, ctx: Annotate$AnnotationContext<T>, sym: javac.code.Symbol, isTypeParam: boolean): T;
              newRound(): void;
              normal(r: java.lang.Runnable): void;
              _processRepeatedAnnotations<T>(annotations: javac.util.List<T>, ctx: Annotate$AnnotationContext<T>, on: javac.code.Symbol, isTypeParam: boolean): T;
              queueScanTreeAndTypeAnnotate(tree: javac.tree.JCTree, env: Env<AttrContext>, sym: javac.code.Symbol, deferPos: javac.util.JCDiagnostic$DiagnosticPosition): void;
              setQueues(nue: Annotate$Queues): Annotate$Queues;
              _startFlushing(): void;
              typeAnnotation(a: java.lang.Runnable): void;
              unblockAnnotations(): void;
              unblockAnnotationsNoFlush(): void;
              unfinishedDefaultValue(): javac.code.Attribute;
              validate(a: java.lang.Runnable): void;
              _validateContainer(targetContainerType: javac.code.Type, originalAnnoType: javac.code.Type, pos: javac.util.JCDiagnostic$DiagnosticPosition): javac.code.Symbol$MethodSymbol;
              _afterTypesQ: javac.util.ListBuffer<java.lang.Runnable>;
              _attr: Attr;
              _blockCount: int;
              _cfolder: ConstFold;
              _chk: Check;
              _deferredLintHandler: javac.code.DeferredLintHandler;
              _enter: Enter;
              _flushCount: int;
              _lint: javac.code.Lint;
              _log: javac.util.Log;
              _make: javac.tree.TreeMaker;
              _names: javac.util.Names;
              _q: javac.util.ListBuffer<java.lang.Runnable>;
              _resolve: Resolve;
              _sourceName: string;
              _syms: javac.code.Symtab;
              _theSourceCompleter: Annotate$AnnotationTypeCompleter;
              _theUnfinishedDefaultValue: javac.code.Attribute;
              _typeEnvs: TypeEnvs;
              _types: javac.code.Types;
              _typesQ: javac.util.ListBuffer<java.lang.Runnable>;
              _validateQ: javac.util.ListBuffer<java.lang.Runnable>;
            }
            interface Annotate extends CombineTypes<[_Annotate, java.lang.Object]> {}
            interface _Annotate$AnnotationContext$$static<T> extends ClassLike {
              new(a0: Env<AttrContext>, env: java.util.Map<javac.code.Symbol$TypeSymbol,javac.util.ListBuffer<T>>, annotated: java.util.Map<T,javac.util.JCDiagnostic$DiagnosticPosition>, pos: boolean): Annotate$AnnotationContext<T>;
            }
            let Annotate$AnnotationContext: _Annotate$AnnotationContext$$static<T>;
            interface _Annotate$AnnotationContext<T> {
              readonly annotated: java.util.Map<javac.code.Symbol$TypeSymbol,javac.util.ListBuffer<T>>;
              readonly env: Env<AttrContext>;
              readonly isTypeCompound: boolean;
              readonly pos: java.util.Map<T,javac.util.JCDiagnostic$DiagnosticPosition>;
            }
            interface Annotate$AnnotationContext<T> extends CombineTypes<[_Annotate$AnnotationContext<T>, java.lang.Object]> {}
            interface _Annotate$AnnotationTypeCompleter$$static extends ClassLike {
            }
            let Annotate$AnnotationTypeCompleter: _Annotate$AnnotationTypeCompleter$$static;
            interface _Annotate$AnnotationTypeCompleter {
              complete(a0: javac.code.Symbol$ClassSymbol): void;
(a0: javac.code.Symbol$ClassSymbol): void;
            }
            interface Annotate$AnnotationTypeCompleter extends CombineTypes<[_Annotate$AnnotationTypeCompleter, java.lang.Object]> {}
            interface _Annotate$AnnotationTypeMetadata$$static extends ClassLike {
              notAnAnnotationType(): Annotate$AnnotationTypeMetadata;
              _NOT_AN_ANNOTATION_TYPE: Annotate$AnnotationTypeMetadata;
              new(metaDataFor: javac.code.Symbol$ClassSymbol, annotationTypeCompleter: Annotate$AnnotationTypeCompleter): Annotate$AnnotationTypeMetadata;
            }
            let Annotate$AnnotationTypeMetadata: _Annotate$AnnotationTypeMetadata$$static;
            interface _Annotate$AnnotationTypeMetadata {
              complete(): void;
              getAnnotationElements(): java.util.Set<javac.code.Symbol$MethodSymbol>;
              getAnnotationElementsWithDefault(): java.util.Set<javac.code.Symbol$MethodSymbol>;
              getRepeatable(): javac.code.Attribute$Compound;
              getTarget(): javac.code.Attribute$Compound;
              _init(): void;
              isMetadataForAnnotationType(): boolean;
              setRepeatable(repeatable: javac.code.Attribute$Compound): void;
              setTarget(target: javac.code.Attribute$Compound): void;
              toString(): string;
              _annotationTypeCompleter: Annotate$AnnotationTypeCompleter;
              _metaDataFor: javac.code.Symbol$ClassSymbol;
              _repeatable: javac.code.Attribute$Compound;
              _target: javac.code.Attribute$Compound;
            }
            interface Annotate$AnnotationTypeMetadata extends CombineTypes<[_Annotate$AnnotationTypeMetadata, java.lang.Object]> {}
            interface _Annotate$AnnotationTypeVisitor$$static extends ClassLike {
              new(this$0: Annotate, attr: Attr, check: Check, tab: javac.code.Symtab, typeEnvs: TypeEnvs): Annotate$AnnotationTypeVisitor;
            }
            let Annotate$AnnotationTypeVisitor: _Annotate$AnnotationTypeVisitor$$static;
            interface _Annotate$AnnotationTypeVisitor {
              getRepeatable(): javac.code.Attribute$Compound;
              getTarget(): javac.code.Attribute$Compound;
              scanAnnotationType(decl: javac.tree.JCTree$JCClassDecl): void;
              visitAnnotation(tree: javac.tree.JCTree$JCAnnotation): void;
              visitClassDef(tree: javac.tree.JCTree$JCClassDecl): void;
              _attr: Attr;
              _check: Check;
              _env: Env<AttrContext>;
              _repeatable: javac.code.Attribute$Compound;
              _tab: javac.code.Symtab;
              _target: javac.code.Attribute$Compound;
              _this$0: Annotate;
              _typeEnvs: TypeEnvs;
            }
            interface Annotate$AnnotationTypeVisitor extends CombineTypes<[_Annotate$AnnotationTypeVisitor, com.sun.tools.javac.tree.TreeScanner]> {}
            interface _Annotate$AnnotationValueContext$$static extends ClassLike {
              _new(this$0: Annotate, enclosingContext: Check$CheckContext): Annotate$AnnotationValueContext;
            }
            let Annotate$AnnotationValueContext: _Annotate$AnnotationValueContext$$static;
            interface _Annotate$AnnotationValueContext {
              compatible(found: javac.code.Type, req: javac.code.Type, warn: javac.util.Warner): boolean;
            }
            interface Annotate$AnnotationValueContext extends CombineTypes<[_Annotate$AnnotationValueContext, com.sun.tools.javac.comp.Check$NestedCheckContext]> {}
            interface _Annotate$Queues$$static extends ClassLike {
              new(): Annotate$Queues;
              new(q: javac.util.ListBuffer<java.lang.Runnable>, validateQ: javac.util.ListBuffer<java.lang.Runnable>, typesQ: javac.util.ListBuffer<java.lang.Runnable>, afterTypesQ: javac.util.ListBuffer<java.lang.Runnable>): Annotate$Queues;
            }
            let Annotate$Queues: _Annotate$Queues$$static;
            interface _Annotate$Queues {
              _afterTypesQ: javac.util.ListBuffer<java.lang.Runnable>;
              _q: javac.util.ListBuffer<java.lang.Runnable>;
              _typesQ: javac.util.ListBuffer<java.lang.Runnable>;
              _validateQ: javac.util.ListBuffer<java.lang.Runnable>;
            }
            interface Annotate$Queues extends CombineTypes<[_Annotate$Queues, java.lang.Object]> {}
            interface _Annotate$TypeAnnotate$$static extends ClassLike {
              new(a0: Env<AttrContext>, env: javac.code.Symbol, sym: javac.util.JCDiagnostic$DiagnosticPosition): Annotate$TypeAnnotate;
            }
            let Annotate$TypeAnnotate: _Annotate$TypeAnnotate$$static;
            interface _Annotate$TypeAnnotate {
              visitAnnotatedType(tree: javac.tree.JCTree$JCAnnotatedType): void;
              visitBindingPattern(tree: javac.tree.JCTree$JCBindingPattern): void;
              visitClassDef(tree: javac.tree.JCTree$JCClassDecl): void;
              visitMethodDef(tree: javac.tree.JCTree$JCMethodDecl): void;
              visitNewArray(tree: javac.tree.JCTree$JCNewArray): void;
              visitNewClass(tree: javac.tree.JCTree$JCNewClass): void;
              visitTypeParameter(tree: javac.tree.JCTree$JCTypeParameter): void;
              visitVarDef(tree: javac.tree.JCTree$JCVariableDecl): void;
              _deferPos: javac.util.JCDiagnostic$DiagnosticPosition;
              _env: Env<AttrContext>;
              _sym: javac.code.Symbol;
              _this$0: Annotate;
            }
            interface Annotate$TypeAnnotate extends CombineTypes<[_Annotate$TypeAnnotate, com.sun.tools.javac.tree.TreeScanner]> {}
            interface _ArgumentAttr$$static extends ClassLike {
              instance(context: javac.util.Context): ArgumentAttr;
              _methodAttrKey: javac.util.Context$Key<ArgumentAttr>;
              _new(context: javac.util.Context): ArgumentAttr;
            }
            let ArgumentAttr: _ArgumentAttr$$static;
            interface _ArgumentAttr {
              _attribArg(tree: javac.tree.JCTree, env: Env<AttrContext>): javac.code.Type;
              _checkSpeculative(expr: javac.tree.JCTree, resultInfo: Attr$ResultInfo): javac.code.Type;
              _checkSpeculative(pos: javac.util.JCDiagnostic$DiagnosticPosition, t: javac.code.Type, resultInfo: Attr$ResultInfo): javac.code.Type;
              _processArg<T, Z>(that: T, argumentTypeFactory: java.util.function.Function<T,Z>): void;
              _processArg<T, Z>(that: T, argumentTypeFactory: java.util.function.Supplier<Z>): void;
              _setResult(tree: javac.tree.JCTree$JCExpression, type: javac.code.Type): void;
              visitApply(that: javac.tree.JCTree$JCMethodInvocation): void;
              visitConditional(that: javac.tree.JCTree$JCConditional): void;
              visitLambda(that: javac.tree.JCTree$JCLambda): void;
              visitNewClass(that: javac.tree.JCTree$JCNewClass): void;
              visitParens(that: javac.tree.JCTree$JCParens): void;
              visitReference(tree: javac.tree.JCTree$JCMemberReference): void;
              visitSwitchExpression(that: javac.tree.JCTree$JCSwitchExpression): void;
              visitTree(that: javac.tree.JCTree): void;
              _withLocalCacheContext(): ArgumentAttr$LocalCacheContext;
              _argumentTypeCache: java.util.Map<ArgumentAttr$UniquePos,ArgumentAttr$ArgumentType<any>>;
              _attr: Attr;
              _deferredAttr: DeferredAttr;
              _diags: javac.util.JCDiagnostic$Factory;
              _env: Env<AttrContext>;
              _log: javac.util.Log;
              _result: javac.code.Type;
              _syms: javac.code.Symtab;
            }
            interface ArgumentAttr extends CombineTypes<[_ArgumentAttr, com.sun.tools.javac.tree.JCTree$Visitor]> {}
            interface _ArgumentAttr$ArgumentType$$static<T> extends ClassLike {
              new(this$0: javac.tree.JCTree$JCExpression, tree: Env<AttrContext>, env: T, speculativeTree: java.util.Map<Attr$ResultInfo,javac.code.Type>): ArgumentAttr$ArgumentType<T>;
            }
            let ArgumentAttr$ArgumentType: _ArgumentAttr$ArgumentType$$static<T>;
            interface _ArgumentAttr$ArgumentType<T> {
              complete(resultInfo: Attr$ResultInfo, deferredAttrContext: DeferredAttr$DeferredAttrContext): javac.code.Type;
              _dup(a0: T, a1: Env<AttrContext>): ArgumentAttr$ArgumentType<T>;
              _overloadCheck(a0: Attr$ResultInfo, a1: DeferredAttr$DeferredAttrContext): javac.code.Type;
              _speculativeTree(deferredAttrContext: DeferredAttr$DeferredAttrContext): javac.tree.JCTree;
              _speculativeType(msym: javac.code.Symbol, phase: Resolve$MethodResolutionPhase): javac.code.Type;
              _speculativeTree: T;
              _speculativeTypes: java.util.Map<Attr$ResultInfo,javac.code.Type>;
              _this$0: ArgumentAttr;
            }
            interface ArgumentAttr$ArgumentType<T> extends CombineTypes<[_ArgumentAttr$ArgumentType<T>, DeferredAttr$DeferredType]> {}
            interface _ArgumentAttr$ConditionalType$$static extends ClassLike {
              _new(this$0: javac.tree.JCTree$JCExpression, tree: Env<AttrContext>, env: javac.tree.JCTree$JCConditional): ArgumentAttr$ConditionalType;
              _new(this$0: javac.tree.JCTree$JCExpression, tree: Env<AttrContext>, env: javac.tree.JCTree$JCConditional, speculativeCond: java.util.Map<Attr$ResultInfo,javac.code.Type>): ArgumentAttr$ConditionalType;
            }
            let ArgumentAttr$ConditionalType: _ArgumentAttr$ConditionalType$$static;
            interface _ArgumentAttr$ConditionalType {
              _dup(tree: javac.tree.JCTree$JCConditional, env: Env<AttrContext>): ArgumentAttr$ArgumentType<javac.tree.JCTree$JCConditional>;
              _dup(a0: javac.tree.JCTree$JCExpression, a1: Env): ArgumentAttr$ArgumentType;
              _overloadCheck(resultInfo: Attr$ResultInfo, deferredAttrContext: DeferredAttr$DeferredAttrContext): javac.code.Type;
              _this$0: ArgumentAttr;
            }
            interface ArgumentAttr$ConditionalType extends CombineTypes<[_ArgumentAttr$ConditionalType, ArgumentAttr$ArgumentType<javac.tree.JCTree$JCConditional>]> {}
            interface _ArgumentAttr$ExplicitLambdaType$$static extends ClassLike {
              _new(this$0: javac.tree.JCTree$JCLambda, originalLambda: Env<AttrContext>, env: javac.tree.JCTree$JCLambda): ArgumentAttr$ExplicitLambdaType;
              _new(this$0: javac.tree.JCTree$JCLambda, originalLambda: Env<AttrContext>, env: javac.tree.JCTree$JCLambda, speculativeLambda: java.util.Map<Attr$ResultInfo,javac.code.Type>): ArgumentAttr$ExplicitLambdaType;
            }
            let ArgumentAttr$ExplicitLambdaType: _ArgumentAttr$ExplicitLambdaType$$static;
            interface _ArgumentAttr$ExplicitLambdaType {
              _argtypes(): javac.util.List<javac.code.Type>;
              _checkLambdaCompatible(descriptor: javac.code.Type, resultInfo: Attr$ResultInfo): void;
              _checkReturnInStatementLambda(ret: javac.tree.JCTree$JCReturn, resultInfo: Attr$ResultInfo): void;
              _dup(tree: javac.tree.JCTree$JCLambda, env: Env<AttrContext>): ArgumentAttr$ArgumentType<javac.tree.JCTree$JCLambda>;
              _dup(a0: javac.tree.JCTree$JCExpression, a1: Env): ArgumentAttr$ArgumentType;
              _getReturnType(ret: javac.tree.JCTree$JCReturn): javac.code.Type;
              _overloadCheck(resultInfo: Attr$ResultInfo, deferredAttrContext: DeferredAttr$DeferredAttrContext): javac.code.Type;
              _returnExpressions(): javac.util.List<javac.tree.JCTree$JCReturn>;
              _argtypes: java.util.Optional<javac.util.List<javac.code.Type>>;
              _returnExpressions: java.util.Optional<javac.util.List<javac.tree.JCTree$JCReturn>>;
              _this$0: ArgumentAttr;
            }
            interface ArgumentAttr$ExplicitLambdaType extends CombineTypes<[_ArgumentAttr$ExplicitLambdaType, ArgumentAttr$ArgumentType<javac.tree.JCTree$JCLambda>]> {}
            interface _ArgumentAttr$LocalCacheContext$$static extends ClassLike {
              new(this$0: ArgumentAttr): ArgumentAttr$LocalCacheContext;
            }
            let ArgumentAttr$LocalCacheContext: _ArgumentAttr$LocalCacheContext$$static;
            interface _ArgumentAttr$LocalCacheContext {
              leave(): void;
              _prevCache: java.util.Map<ArgumentAttr$UniquePos,ArgumentAttr$ArgumentType<any>>;
              _this$0: ArgumentAttr;
            }
            interface ArgumentAttr$LocalCacheContext extends CombineTypes<[_ArgumentAttr$LocalCacheContext, java.lang.Object]> {}
            interface _ArgumentAttr$ParensType$$static extends ClassLike {
              _new(this$0: javac.tree.JCTree$JCExpression, tree: Env<AttrContext>, env: javac.tree.JCTree$JCParens): ArgumentAttr$ParensType;
              _new(this$0: javac.tree.JCTree$JCExpression, tree: Env<AttrContext>, env: javac.tree.JCTree$JCParens, speculativeParens: java.util.Map<Attr$ResultInfo,javac.code.Type>): ArgumentAttr$ParensType;
            }
            let ArgumentAttr$ParensType: _ArgumentAttr$ParensType$$static;
            interface _ArgumentAttr$ParensType {
              _dup(tree: javac.tree.JCTree$JCParens, env: Env<AttrContext>): ArgumentAttr$ArgumentType<javac.tree.JCTree$JCParens>;
              _dup(a0: javac.tree.JCTree$JCExpression, a1: Env): ArgumentAttr$ArgumentType;
              _overloadCheck(resultInfo: Attr$ResultInfo, deferredAttrContext: DeferredAttr$DeferredAttrContext): javac.code.Type;
              _this$0: ArgumentAttr;
            }
            interface ArgumentAttr$ParensType extends CombineTypes<[_ArgumentAttr$ParensType, ArgumentAttr$ArgumentType<javac.tree.JCTree$JCParens>]> {}
            interface _ArgumentAttr$ResolvedConstructorType$$static extends ClassLike {
              new(this$0: javac.tree.JCTree$JCExpression, tree: Env<AttrContext>, env: javac.tree.JCTree$JCNewClass): ArgumentAttr$ResolvedConstructorType;
              new(this$0: javac.tree.JCTree$JCExpression, tree: Env<AttrContext>, env: javac.tree.JCTree$JCNewClass, speculativeTree: java.util.Map<Attr$ResultInfo,javac.code.Type>): ArgumentAttr$ResolvedConstructorType;
            }
            let ArgumentAttr$ResolvedConstructorType: _ArgumentAttr$ResolvedConstructorType$$static;
            interface _ArgumentAttr$ResolvedConstructorType {
              _dup(tree: javac.tree.JCTree$JCNewClass, env: Env<AttrContext>): ArgumentAttr$ArgumentType<javac.tree.JCTree$JCNewClass>;
              _dup(a0: javac.tree.JCTree$JCExpression, a1: Env): ArgumentAttr$ArgumentType;
              _methodType(): javac.code.Type;
              _resultInfo(resultInfo: Attr$ResultInfo): Attr$ResultInfo;
              _this$0: ArgumentAttr;
            }
            interface ArgumentAttr$ResolvedConstructorType extends CombineTypes<[_ArgumentAttr$ResolvedConstructorType, ArgumentAttr$ResolvedMemberType<javac.tree.JCTree$JCNewClass>]> {}
            interface _ArgumentAttr$ResolvedMemberType$$static<E> extends ClassLike {
              new(this$0: javac.tree.JCTree$JCExpression, tree: Env<AttrContext>, env: E, speculativeMethod: java.util.Map<Attr$ResultInfo,javac.code.Type>): ArgumentAttr$ResolvedMemberType<E>;
            }
            let ArgumentAttr$ResolvedMemberType: _ArgumentAttr$ResolvedMemberType$$static<E>;
            interface _ArgumentAttr$ResolvedMemberType<E> {
              _methodType(): javac.code.Type;
              _overloadCheck(resultInfo: Attr$ResultInfo, deferredAttrContext: DeferredAttr$DeferredAttrContext): javac.code.Type;
              _resultInfo(a0: Attr$ResultInfo): Attr$ResultInfo;
            }
            interface ArgumentAttr$ResolvedMemberType<E> extends CombineTypes<[_ArgumentAttr$ResolvedMemberType<E>, ArgumentAttr$ArgumentType<E>]> {}
            interface _ArgumentAttr$ResolvedMethodType$$static extends ClassLike {
              new(this$0: javac.tree.JCTree$JCExpression, tree: Env<AttrContext>, env: javac.tree.JCTree$JCMethodInvocation): ArgumentAttr$ResolvedMethodType;
              new(this$0: javac.tree.JCTree$JCExpression, tree: Env<AttrContext>, env: javac.tree.JCTree$JCMethodInvocation, speculativeTree: java.util.Map<Attr$ResultInfo,javac.code.Type>): ArgumentAttr$ResolvedMethodType;
            }
            let ArgumentAttr$ResolvedMethodType: _ArgumentAttr$ResolvedMethodType$$static;
            interface _ArgumentAttr$ResolvedMethodType {
              _dup(tree: javac.tree.JCTree$JCMethodInvocation, env: Env<AttrContext>): ArgumentAttr$ArgumentType<javac.tree.JCTree$JCMethodInvocation>;
              _dup(a0: javac.tree.JCTree$JCExpression, a1: Env): ArgumentAttr$ArgumentType;
              _methodType(): javac.code.Type;
              _resultInfo(resultInfo: Attr$ResultInfo): Attr$ResultInfo;
              _this$0: ArgumentAttr;
            }
            interface ArgumentAttr$ResolvedMethodType extends CombineTypes<[_ArgumentAttr$ResolvedMethodType, ArgumentAttr$ResolvedMemberType<javac.tree.JCTree$JCMethodInvocation>]> {}
            interface _ArgumentAttr$SwitchExpressionType$$static extends ClassLike {
              _new(this$0: javac.tree.JCTree$JCExpression, tree: Env<AttrContext>, env: javac.tree.JCTree$JCSwitchExpression): ArgumentAttr$SwitchExpressionType;
              _new(this$0: javac.tree.JCTree$JCExpression, tree: Env<AttrContext>, env: javac.tree.JCTree$JCSwitchExpression, speculativeCond: java.util.Map<Attr$ResultInfo,javac.code.Type>): ArgumentAttr$SwitchExpressionType;
            }
            let ArgumentAttr$SwitchExpressionType: _ArgumentAttr$SwitchExpressionType$$static;
            interface _ArgumentAttr$SwitchExpressionType {
              _dup(tree: javac.tree.JCTree$JCSwitchExpression, env: Env<AttrContext>): ArgumentAttr$ArgumentType<javac.tree.JCTree$JCSwitchExpression>;
              _dup(a0: javac.tree.JCTree$JCExpression, a1: Env): ArgumentAttr$ArgumentType;
              _overloadCheck(resultInfo: Attr$ResultInfo, deferredAttrContext: DeferredAttr$DeferredAttrContext): javac.code.Type;
              _yieldExpressions(): javac.util.List<javac.tree.JCTree$JCYield>;
              _this$0: ArgumentAttr;
              _yieldExpressions: java.util.Optional<javac.util.List<javac.tree.JCTree$JCYield>>;
            }
            interface ArgumentAttr$SwitchExpressionType extends CombineTypes<[_ArgumentAttr$SwitchExpressionType, ArgumentAttr$ArgumentType<javac.tree.JCTree$JCSwitchExpression>]> {}
            interface _ArgumentAttr$UniquePos$$static extends ClassLike {
              _new(this$0: ArgumentAttr, tree: javac.tree.JCTree): ArgumentAttr$UniquePos;
            }
            let ArgumentAttr$UniquePos: _ArgumentAttr$UniquePos$$static;
            interface _ArgumentAttr$UniquePos {
              equals(obj: any): boolean;
              hashCode(): int;
              toString(): string;
              _pos: int;
              _source: javac.util.DiagnosticSource;
            }
            interface ArgumentAttr$UniquePos extends CombineTypes<[_ArgumentAttr$UniquePos, java.lang.Object]> {}
            interface _Attr$$static extends ClassLike {
              _addVars(stats: javac.util.List<javac.tree.JCTree$JCStatement>, switchScope: javac.code.Scope$WriteableScope): void;
              instance(context: javac.util.Context): Attr;
              _isType(sym: javac.code.Symbol): boolean;
              _attrKey: javac.util.Context$Key<Attr>;
              _primitiveTags: javac.code.TypeTag[];
              _new(context: javac.util.Context): Attr;
            }
            let Attr: _Attr$$static;
            interface _Attr {
              _addBindings2Scope(introducingStatement: javac.tree.JCTree$JCStatement, bindings: javac.util.List<javac.code.Symbol$BindingSymbol>): void;
              _adjustMethodReturnType(msym: javac.code.Symbol, qualifierType: javac.code.Type, methodName: javac.util.Name, argtypes: javac.util.List<javac.code.Type>, restype: javac.code.Type): javac.code.Type;
              attrib(env: Env<AttrContext>): void;
              _attribAnnotationTypes(annotations: javac.util.List<javac.tree.JCTree$JCAnnotation>, env: Env<AttrContext>): void;
              _attribAnyTypes(trees: javac.util.List<javac.tree.JCTree$JCExpression>, env: Env<AttrContext>): javac.util.List<javac.code.Type>;
              _attribArgs(initialKind: javac.code.Kinds$KindSelector, trees: javac.util.List<javac.tree.JCTree$JCExpression>, env: Env<AttrContext>, argtypes: javac.util.ListBuffer<javac.code.Type>): javac.code.Kinds$KindSelector;
              _attribBase(tree: javac.tree.JCTree, env: Env<AttrContext>, classExpected: boolean, interfaceExpected: boolean, checkExtensible: boolean): javac.code.Type;
              attribClass(pos: javac.util.JCDiagnostic$DiagnosticPosition, c: javac.code.Symbol$ClassSymbol): void;
              _attribClass(c: javac.code.Symbol$ClassSymbol): void;
              _attribClassBody(env: Env<AttrContext>, c: javac.code.Symbol$ClassSymbol): void;
              attribExpr(tree: javac.tree.JCTree, env: Env<AttrContext>, pt: javac.code.Type): javac.code.Type;
              attribExpr(tree: javac.tree.JCTree, env: Env<AttrContext>): javac.code.Type;
              attribExprToTree(expr: javac.tree.JCTree, env: Env<AttrContext>, tree: javac.tree.JCTree): Env<AttrContext>;
              _attribExprs(trees: javac.util.List<javac.tree.JCTree$JCExpression>, env: Env<AttrContext>, pt: javac.code.Type): javac.util.List<javac.code.Type>;
              attribIdent(tree: javac.tree.JCTree, topLevel: javac.tree.JCTree$JCCompilationUnit): javac.code.Symbol;
              attribIdent(tree: javac.tree.JCTree, env: Env<AttrContext>): javac.code.Symbol;
              _attribIdentAsEnumType(env: Env<AttrContext>, id: javac.tree.JCTree$JCIdent): javac.code.Type;
              attribImportQualifier(tree: javac.tree.JCTree$JCImport, env: Env<AttrContext>): javac.code.Type;
              attribLazyConstantValue(env: Env<AttrContext>, variable: javac.tree.JCTree$JCVariableDecl, type: javac.code.Type): any;
              attribModule(pos: javac.util.JCDiagnostic$DiagnosticPosition, m: javac.code.Symbol$ModuleSymbol): void;
              _attribModule(m: javac.code.Symbol$ModuleSymbol): void;
              attribPackage(pos: javac.util.JCDiagnostic$DiagnosticPosition, p: javac.code.Symbol$PackageSymbol): void;
              _attribPackage(p: javac.code.Symbol$PackageSymbol): void;
              attribStat(tree: javac.tree.JCTree, env: Env<AttrContext>): javac.code.Type;
              attribStatToTree(stmt: javac.tree.JCTree, env: Env<AttrContext>, tree: javac.tree.JCTree): Env<AttrContext>;
              _attribStats<T>(trees: javac.util.List<T>, env: Env<AttrContext>): void;
              _attribToTree(root: javac.tree.JCTree, env: Env<AttrContext>, tree: javac.tree.JCTree, resultInfo: Attr$ResultInfo): Env<AttrContext>;
              _attribTree(tree: javac.tree.JCTree, env: Env<AttrContext>, resultInfo: Attr$ResultInfo): javac.code.Type;
              attribType(node: javac.tree.JCTree, sym: javac.code.Symbol$TypeSymbol): javac.code.Type;
              attribType(tree: javac.tree.JCTree, env: Env<AttrContext>): javac.code.Type;
              _attribType(tree: javac.tree.JCTree, env: Env<AttrContext>, pt: javac.code.Type): javac.code.Type;
              _attribTypeVariables(typarams: javac.util.List<javac.tree.JCTree$JCTypeParameter>, env: Env<AttrContext>, checkCyclic: boolean): void;
              _attribTypes(trees: javac.util.List<javac.tree.JCTree$JCExpression>, env: Env<AttrContext>): javac.util.List<javac.code.Type>;
              _attribWithLint(sym: javac.code.Symbol$TypeSymbol, attrib: java.util.function.Consumer<Env<AttrContext>>): void;
              _bindingEnv(env: Env<AttrContext>, bindings: javac.util.List<javac.code.Symbol$BindingSymbol>): Env<AttrContext>;
              _bindingEnv(env: Env<AttrContext>, newTree: javac.tree.JCTree, bindings: javac.util.List<javac.code.Symbol$BindingSymbol>): Env<AttrContext>;
              _breakTreeFound(env: Env<AttrContext>): void;
              _breaksTo(env: Env<AttrContext>, loop: javac.tree.JCTree, body: javac.tree.JCTree): boolean;
              _canInferLocalVarType(tree: javac.tree.JCTree$JCVariableDecl): javac.util.JCDiagnostic$Fragment;
              _capture(type: javac.code.Type): javac.code.Type;
              _caseLabelResultInfo(seltype: javac.code.Type): Attr$ResultInfo;
              _check(tree: javac.tree.JCTree, found: javac.code.Type, ownkind: javac.code.Kinds$KindSelector, resultInfo: Attr$ResultInfo): javac.code.Type;
              _checkAccessibleTypes(pos: javac.util.JCDiagnostic$DiagnosticPosition, env: Env<AttrContext>, inferenceContext: InferenceContext, ts: javac.code.Type[]): void;
              _checkAccessibleTypes(pos: javac.util.JCDiagnostic$DiagnosticPosition, env: Env<AttrContext>, inferenceContext: InferenceContext, ...ts: javac.code.Type[]): void;
              _checkAccessibleTypes(pos: javac.util.JCDiagnostic$DiagnosticPosition, env: Env<AttrContext>, inferenceContext: InferenceContext, ts: javac.util.List<javac.code.Type>): void;
              _checkAssignable(pos: javac.util.JCDiagnostic$DiagnosticPosition, v: javac.code.Symbol$VarSymbol, base: javac.tree.JCTree, env: Env<AttrContext>): void;
              _checkAutoCloseable(pos: javac.util.JCDiagnostic$DiagnosticPosition, env: Env<AttrContext>, resource: javac.code.Type): void;
              _checkBase(t: javac.code.Type, tree: javac.tree.JCTree, env: Env<AttrContext>, classExpected: boolean, interfaceExpected: boolean, checkExtensible: boolean): javac.code.Type;
              _checkCastablePattern(pos: javac.util.JCDiagnostic$DiagnosticPosition, exprType: javac.code.Type, pattType: javac.code.Type): boolean;
              _checkEnumInitializer(tree: javac.tree.JCTree, env: Env<AttrContext>, v: javac.code.Symbol$VarSymbol): void;
              _checkExConstraints(thrownByFuncExpr: javac.util.List<javac.code.Type>, thrownAtFuncType: javac.util.List<javac.code.Type>, inferenceContext: InferenceContext): boolean;
              _checkFirstConstructorStat(tree: javac.tree.JCTree$JCMethodInvocation, enclMethod: javac.tree.JCTree$JCMethodDecl, error: boolean): boolean;
              _checkId(tree: javac.tree.JCTree, site: javac.code.Type, sym: javac.code.Symbol, env: Env<AttrContext>, resultInfo: Attr$ResultInfo): javac.code.Type;
              _checkIdInternal(tree: javac.tree.JCTree, site: javac.code.Type, sym: javac.code.Symbol, pt: javac.code.Type, env: Env<AttrContext>, resultInfo: Attr$ResultInfo): javac.code.Type;
              _checkInit(tree: javac.tree.JCTree, env: Env<AttrContext>, v: javac.code.Symbol$VarSymbol, onlyWarning: boolean): void;
              _checkIntersection(tree: javac.tree.JCTree, bounds: javac.util.List<javac.tree.JCTree$JCExpression>): javac.code.Type;
              _checkLambdaCompatible(tree: javac.tree.JCTree$JCLambda, descriptor: javac.code.Type, checkContext: Check$CheckContext): void;
              checkMethod(site: javac.code.Type, sym: javac.code.Symbol, resultInfo: Attr$ResultInfo, env: Env<AttrContext>, argtrees: javac.util.List<javac.tree.JCTree$JCExpression>, argtypes: javac.util.List<javac.code.Type>, typeargtypes: javac.util.List<javac.code.Type>): javac.code.Type;
              _checkMethodIdInternal(tree: javac.tree.JCTree, site: javac.code.Type, sym: javac.code.Symbol, env: Env<AttrContext>, resultInfo: Attr$ResultInfo): javac.code.Type;
              _checkReferenceCompatible(tree: javac.tree.JCTree$JCMemberReference, descriptor: javac.code.Type, refType: javac.code.Type, checkContext: Check$CheckContext, speculativeAttr: boolean): void;
              coerce(etype: javac.code.Type, ttype: javac.code.Type): javac.code.Type;
              _condType(positions: javac.util.List<javac.util.JCDiagnostic$DiagnosticPosition>, condTypes: javac.util.List<javac.code.Type>): javac.code.Type;
              _conditionalContext(checkContext: Check$CheckContext): Check$CheckContext;
              _copyEnv(env: Env<AttrContext>): Env<AttrContext>;
              _copyScope(sc: javac.code.Scope$WriteableScope): javac.code.Scope$WriteableScope;
              _diamondContext(clazz: javac.tree.JCTree$JCNewClass, tsym: javac.code.Symbol$TypeSymbol, checkContext: Check$CheckContext): Check$CheckContext;
              _enclosingInitEnv(env: Env<AttrContext>): Env<AttrContext>;
              _enumConstant(tree: javac.tree.JCTree, enumType: javac.code.Type): javac.code.Symbol;
              _fallbackDescriptorType(tree: javac.tree.JCTree$JCExpression): javac.code.Type;
              _findJumpTarget(pos: javac.util.JCDiagnostic$DiagnosticPosition, tag: javac.tree.JCTree$Tag, label: javac.util.Name, env: Env<AttrContext>): javac.tree.JCTree;
              _findJumpTargetNoError(tag: javac.tree.JCTree$Tag, label: javac.util.Name, env: Env<AttrContext>): javac.util.Pair<javac.tree.JCTree,javac.util.JCDiagnostic$Error>;
              _getDiagnosticPosition(tree: javac.tree.JCTree$JCClassDecl, t: javac.code.Type): javac.util.JCDiagnostic$DiagnosticPosition;
              _getTargetInfo(that: javac.tree.JCTree$JCPolyExpression, resultInfo: Attr$ResultInfo, explicitParamTypes: javac.util.List<javac.code.Type>): Attr$TargetInfo;
              _handleLoopConditionBindings(condBindings: MatchBindingsComputer$MatchBindings, loop: javac.tree.JCTree$JCStatement, loopBody: javac.tree.JCTree$JCStatement): void;
              _handleSwitch(switchTree: javac.tree.JCTree, selector: javac.tree.JCTree$JCExpression, cases: javac.util.List<javac.tree.JCTree$JCCase>, attribCase: java.util.function.BiConsumer<javac.tree.JCTree$JCCase,Env<AttrContext>>): void;
              _isAssignableAsBlankFinal(v: javac.code.Symbol$VarSymbol, env: Env<AttrContext>): boolean;
              _isBooleanOrNumeric(env: Env<AttrContext>, tree: javac.tree.JCTree$JCExpression): boolean;
              _isNonArgsMethodInObject(name: javac.util.Name): boolean;
              _isStaticEnumField(v: javac.code.Symbol$VarSymbol): boolean;
              _isStaticReference(tree: javac.tree.JCTree): boolean;
              _isValueBased(t: javac.code.Type): boolean;
              _lambdaBodyResult(that: javac.tree.JCTree$JCLambda, descriptor: javac.code.Type, resultInfo: Attr$ResultInfo): Attr$ResultInfo;
              lambdaEnv(that: javac.tree.JCTree$JCLambda, env: Env<AttrContext>): Env<AttrContext>;
              _litType(tag: javac.code.TypeTag): javac.code.Type;
              makeNullCheck(arg: javac.tree.JCTree$JCExpression): javac.tree.JCTree$JCExpression;
              _memberReferenceQualifierResult(tree: javac.tree.JCTree$JCMemberReference): Attr$ResultInfo;
              _newMethodTemplate(restype: javac.code.Type, argtypes: javac.util.List<javac.code.Type>, typeargtypes: javac.util.List<javac.code.Type>): javac.code.Type;
              _pkind(): javac.code.Kinds$KindSelector;
              postAttr(tree: javac.tree.JCTree): void;
              _preFlow(tree: javac.tree.JCTree): void;
              _preFlow(tree: javac.tree.JCTree$JCLambda): void;
              _primitiveOrBoxed(t: javac.code.Type): boolean;
              _pt(): javac.code.Type;
              removeClinit(sym: javac.code.Symbol$ClassSymbol): javac.code.Symbol$MethodSymbol;
              _selectSym(tree: javac.tree.JCTree$JCFieldAccess, location: javac.code.Symbol, site: javac.code.Type, env: Env<AttrContext>, resultInfo: Attr$ResultInfo): javac.code.Symbol;
              _setFunctionalInfo(env: Env<AttrContext>, fExpr: javac.tree.JCTree$JCFunctionalExpression, pt: javac.code.Type, descriptorType: javac.code.Type, primaryTarget: javac.code.Type, checkContext: Check$CheckContext): void;
              setPackageSymbols(pid: javac.tree.JCTree$JCExpression, pkg: javac.code.Symbol): void;
              _setSyntheticVariableType(tree: javac.tree.JCTree$JCVariableDecl, type: javac.code.Type): void;
              _switchExpressionContext(checkContext: Check$CheckContext): Check$CheckContext;
              _thisSym(pos: javac.util.JCDiagnostic$DiagnosticPosition, env: Env<AttrContext>): javac.code.Symbol;
              validateTypeAnnotations(tree: javac.tree.JCTree, sigOnly: boolean): void;
              visitAnnotatedType(tree: javac.tree.JCTree$JCAnnotatedType): void;
              visitAnnotation(tree: javac.tree.JCTree$JCAnnotation): void;
              _visitAnonymousClassDefinition(tree: javac.tree.JCTree$JCNewClass, clazz: javac.tree.JCTree$JCExpression, clazztype: javac.code.Type, cdef: javac.tree.JCTree$JCClassDecl, localEnv: Env<AttrContext>, argtypes: javac.util.List<javac.code.Type>, typeargtypes: javac.util.List<javac.code.Type>, pkind: javac.code.Kinds$KindSelector): void;
              visitAnyPattern(tree: javac.tree.JCTree$JCAnyPattern): void;
              visitApply(tree: javac.tree.JCTree$JCMethodInvocation): void;
              visitAssert(tree: javac.tree.JCTree$JCAssert): void;
              visitAssign(tree: javac.tree.JCTree$JCAssign): void;
              visitAssignop(tree: javac.tree.JCTree$JCAssignOp): void;
              visitBinary(tree: javac.tree.JCTree$JCBinary): void;
              visitBindingPattern(tree: javac.tree.JCTree$JCBindingPattern): void;
              visitBlock(tree: javac.tree.JCTree$JCBlock): void;
              visitBreak(tree: javac.tree.JCTree$JCBreak): void;
              visitClassDef(tree: javac.tree.JCTree$JCClassDecl): void;
              visitConditional(tree: javac.tree.JCTree$JCConditional): void;
              visitContinue(tree: javac.tree.JCTree$JCContinue): void;
              visitDoLoop(tree: javac.tree.JCTree$JCDoWhileLoop): void;
              visitErroneous(tree: javac.tree.JCTree$JCErroneous): void;
              visitExec(tree: javac.tree.JCTree$JCExpressionStatement): void;
              visitForLoop(tree: javac.tree.JCTree$JCForLoop): void;
              visitForeachLoop(tree: javac.tree.JCTree$JCEnhancedForLoop): void;
              visitIdent(tree: javac.tree.JCTree$JCIdent): void;
              visitIf(tree: javac.tree.JCTree$JCIf): void;
              visitImport(tree: javac.tree.JCTree$JCImport): void;
              visitIndexed(tree: javac.tree.JCTree$JCArrayAccess): void;
              visitLabelled(tree: javac.tree.JCTree$JCLabeledStatement): void;
              visitLambda(that: javac.tree.JCTree$JCLambda): void;
              visitLiteral(tree: javac.tree.JCTree$JCLiteral): void;
              visitMethodDef(tree: javac.tree.JCTree$JCMethodDecl): void;
              visitModifiers(tree: javac.tree.JCTree$JCModifiers): void;
              visitModuleDef(tree: javac.tree.JCTree$JCModuleDecl): void;
              visitNewArray(tree: javac.tree.JCTree$JCNewArray): void;
              visitNewClass(tree: javac.tree.JCTree$JCNewClass): void;
              visitParens(tree: javac.tree.JCTree$JCParens): void;
              visitRecordPattern(tree: javac.tree.JCTree$JCRecordPattern): void;
              visitReference(that: javac.tree.JCTree$JCMemberReference): void;
              visitReturn(tree: javac.tree.JCTree$JCReturn): void;
              visitSelect(tree: javac.tree.JCTree$JCFieldAccess): void;
              visitSkip(tree: javac.tree.JCTree$JCSkip): void;
              visitStringTemplate(tree: javac.tree.JCTree$JCStringTemplate): void;
              visitSwitch(tree: javac.tree.JCTree$JCSwitch): void;
              visitSwitchExpression(tree: javac.tree.JCTree$JCSwitchExpression): void;
              visitSynchronized(tree: javac.tree.JCTree$JCSynchronized): void;
              visitThrow(tree: javac.tree.JCTree$JCThrow): void;
              visitTree(tree: javac.tree.JCTree): void;
              visitTry(tree: javac.tree.JCTree$JCTry): void;
              visitTypeApply(tree: javac.tree.JCTree$JCTypeApply): void;
              visitTypeArray(tree: javac.tree.JCTree$JCArrayTypeTree): void;
              visitTypeCast(tree: javac.tree.JCTree$JCTypeCast): void;
              visitTypeIdent(tree: javac.tree.JCTree$JCPrimitiveTypeTree): void;
              visitTypeIntersection(tree: javac.tree.JCTree$JCTypeIntersection): void;
              visitTypeParameter(tree: javac.tree.JCTree$JCTypeParameter): void;
              visitTypeTest(tree: javac.tree.JCTree$JCInstanceOf): void;
              visitTypeUnion(tree: javac.tree.JCTree$JCTypeUnion): void;
              visitUnary(tree: javac.tree.JCTree$JCUnary): void;
              visitVarDef(tree: javac.tree.JCTree$JCVariableDecl): void;
              visitWhileLoop(tree: javac.tree.JCTree$JCWhileLoop): void;
              visitWildcard(tree: javac.tree.JCTree$JCWildcard): void;
              visitYield(tree: javac.tree.JCTree$JCYield): void;
              _allowPatternSwitch: boolean;
              _allowRecords: boolean;
              _allowReifiableTypesInInstanceof: boolean;
              _allowUnconditionalPatternsInstanceOf: boolean;
              _analyzer: Analyzer;
              _annotate: Annotate;
              _argumentAttr: ArgumentAttr;
              _attrRecover: AttrRecover;
              _breakTree: javac.tree.JCTree;
              _cfolder: ConstFold;
              _chk: Check;
              _clinits: java.util.Map<javac.code.Symbol$ClassSymbol,javac.code.Symbol$MethodSymbol>;
              _deferredAttr: DeferredAttr;
              _deferredLintHandler: javac.code.DeferredLintHandler;
              _dependencies: javac.util.Dependencies;
              _diags: javac.util.JCDiagnostic$Factory;
              _enter: Enter;
              _env: Env<AttrContext>;
              _flow: Flow;
              _identAttributer: sun.source.tree.TreeVisitor<javac.code.Symbol,Env<AttrContext>>;
              _infer: Infer;
              _log: javac.util.Log;
              _make: javac.tree.TreeMaker;
              _matchBindings: MatchBindingsComputer$MatchBindings;
              _matchBindingsComputer: MatchBindingsComputer;
              _memberEnter: MemberEnter;
              _methodAttrInfo: Attr$ResultInfo;
              _names: javac.util.Names;
              _operators: Operators;
              _preview: javac.code.Preview;
              _recoveryInfo: Attr$ResultInfo;
              _removeClassParams: javac.tree.TreeTranslator;
              _result: javac.code.Type;
              _resultInfo: Attr$ResultInfo;
              _rs: Resolve;
              _sourceName: string;
              _statInfo: Attr$ResultInfo;
              _syms: javac.code.Symtab;
              _target: javac.jvm.Target;
              _targetChecker: javac.code.Types$MapVisitor<javac.util.JCDiagnostic$DiagnosticPosition>;
              _typeAnnotations: javac.code.TypeAnnotations;
              _typeEnter: TypeEnter;
              _typeEnvs: TypeEnvs;
              _types: javac.code.Types;
              _unknownExprInfo: Attr$ResultInfo;
              _unknownTypeExprInfo: Attr$ResultInfo;
              _unknownTypeInfo: Attr$ResultInfo;
              _useBeforeDeclarationWarning: boolean;
              _varAssignmentInfo: Attr$ResultInfo;
            }
            interface Attr extends CombineTypes<[_Attr, com.sun.tools.javac.tree.JCTree$Visitor]> {}
            interface _Attr$BreakAttr$$static extends ClassLike {
              _serialVersionUID: long;
            }
            let Attr$BreakAttr: _Attr$BreakAttr$$static;
            interface _Attr$BreakAttr {
              _env: Env<AttrContext>;
            }
            interface Attr$BreakAttr extends CombineTypes<[_Attr$BreakAttr, java.lang.RuntimeException]> {}
            interface _Attr$CheckMode$$static extends ClassLike {
              valueOf(name: string): Attr$CheckMode;
              values(): Attr$CheckMode[];
              readonly NORMAL: Attr$CheckMode;
              readonly NO_INFERENCE_HOOK: Attr$CheckMode;
              readonly NO_TREE_UPDATE: Attr$CheckMode;
            }
            let Attr$CheckMode: _Attr$CheckMode$$static;
            interface _Attr$CheckMode {
              installPostInferenceHook(): boolean;
              updateTreeType(): boolean;
            }
            interface Attr$CheckMode extends CombineTypes<[_Attr$CheckMode]> {}
            interface _Attr$ExpressionLambdaReturnContext$$static extends ClassLike {
              _new(this$0: Attr, expr: javac.tree.JCTree$JCExpression, enclosingContext: Check$CheckContext): Attr$ExpressionLambdaReturnContext;
            }
            let Attr$ExpressionLambdaReturnContext: _Attr$ExpressionLambdaReturnContext$$static;
            interface _Attr$ExpressionLambdaReturnContext {
              compatible(found: javac.code.Type, req: javac.code.Type, warn: javac.util.Warner): boolean;
              report(pos: javac.util.JCDiagnostic$DiagnosticPosition, details: javac.util.JCDiagnostic): void;
              _expStmtExpected: boolean;
              _expr: javac.tree.JCTree$JCExpression;
              _this$0: Attr;
            }
            interface Attr$ExpressionLambdaReturnContext extends CombineTypes<[_Attr$ExpressionLambdaReturnContext, com.sun.tools.javac.comp.Attr$FunctionalReturnContext]> {}
            interface _Attr$FunctionalReturnContext$$static extends ClassLike {
              _new(this$0: Attr, enclosingContext: Check$CheckContext): Attr$FunctionalReturnContext;
            }
            let Attr$FunctionalReturnContext: _Attr$FunctionalReturnContext$$static;
            interface _Attr$FunctionalReturnContext {
              compatible(found: javac.code.Type, req: javac.code.Type, warn: javac.util.Warner): boolean;
              report(pos: javac.util.JCDiagnostic$DiagnosticPosition, details: javac.util.JCDiagnostic): void;
              _this$0: Attr;
            }
            interface Attr$FunctionalReturnContext extends CombineTypes<[_Attr$FunctionalReturnContext, com.sun.tools.javac.comp.Check$NestedCheckContext]> {}
            interface _Attr$IdentAttributer$$static extends ClassLike {
            }
            let Attr$IdentAttributer: _Attr$IdentAttributer$$static;
            interface _Attr$IdentAttributer {
              visitIdentifier(node: sun.source.tree.IdentifierTree, env: Env<AttrContext>): javac.code.Symbol;
              visitIdentifier(a0: sun.source.tree.IdentifierTree, a1: any): any;
              visitMemberSelect(node: sun.source.tree.MemberSelectTree, env: Env<AttrContext>): javac.code.Symbol;
              visitMemberSelect(a0: sun.source.tree.MemberSelectTree, a1: any): any;
              _this$0: Attr;
            }
            interface Attr$IdentAttributer extends CombineTypes<[_Attr$IdentAttributer, sun.source.util.SimpleTreeVisitor<javac.code.Symbol,Env<AttrContext>>]> {}
            interface _Attr$LocalInitScanner$$static extends ClassLike {
              _new(): Attr$LocalInitScanner;
            }
            let Attr$LocalInitScanner: _Attr$LocalInitScanner$$static;
            interface _Attr$LocalInitScanner {
              visitApply(tree: javac.tree.JCTree$JCMethodInvocation): void;
              visitLambda(tree: javac.tree.JCTree$JCLambda): void;
              visitNewArray(tree: javac.tree.JCTree$JCNewArray): void;
              visitNewClass(tree: javac.tree.JCTree$JCNewClass): void;
              visitReference(tree: javac.tree.JCTree$JCMemberReference): void;
              visitTypeCast(tree: javac.tree.JCTree$JCTypeCast): void;
              _badInferenceMsg: javac.util.JCDiagnostic$Fragment;
              _needsTarget: boolean;
            }
            interface Attr$LocalInitScanner extends CombineTypes<[_Attr$LocalInitScanner, com.sun.tools.javac.tree.TreeScanner]> {}
            interface _Attr$MethodAttrInfo$$static extends ClassLike {
              new(this$0: Attr): Attr$MethodAttrInfo;
              new(this$0: Attr, checkContext: Check$CheckContext): Attr$MethodAttrInfo;
            }
            let Attr$MethodAttrInfo: _Attr$MethodAttrInfo$$static;
            interface _Attr$MethodAttrInfo {
              _dup(newPt: javac.code.Type): Attr$ResultInfo;
              _dup(newContext: Check$CheckContext): Attr$ResultInfo;
              _dup(newPt: javac.code.Type, newContext: Check$CheckContext): Attr$ResultInfo;
              _dup(newPt: javac.code.Type, newContext: Check$CheckContext, newMode: Attr$CheckMode): Attr$ResultInfo;
              _dup(newMode: Attr$CheckMode): Attr$ResultInfo;
              _needsArgumentAttr(tree: javac.tree.JCTree): boolean;
              _this$0: Attr;
            }
            interface Attr$MethodAttrInfo extends CombineTypes<[_Attr$MethodAttrInfo, com.sun.tools.javac.comp.Attr$ResultInfo]> {}
            interface _Attr$PostAttrAnalyzer$$static extends ClassLike {
              _new(this$0: Attr): Attr$PostAttrAnalyzer;
            }
            let Attr$PostAttrAnalyzer: _Attr$PostAttrAnalyzer$$static;
            interface _Attr$PostAttrAnalyzer {
              _dummyMethodType(md: javac.tree.JCTree$JCMethodDecl): javac.code.Type;
              _dummyMethodType(): javac.code.Type;
              _initTypeIfNeeded(that: javac.tree.JCTree): void;
              scan(tree: javac.tree.JCTree): void;
              visitAssignop(that: javac.tree.JCTree$JCAssignOp): void;
              visitBinary(that: javac.tree.JCTree$JCBinary): void;
              visitBindingPattern(that: javac.tree.JCTree$JCBindingPattern): void;
              visitClassDef(that: javac.tree.JCTree$JCClassDecl): void;
              visitIdent(that: javac.tree.JCTree$JCIdent): void;
              visitMethodDef(that: javac.tree.JCTree$JCMethodDecl): void;
              visitNewClass(that: javac.tree.JCTree$JCNewClass): void;
              visitReference(that: javac.tree.JCTree$JCMemberReference): void;
              visitSelect(that: javac.tree.JCTree$JCFieldAccess): void;
              visitUnary(that: javac.tree.JCTree$JCUnary): void;
              visitVarDef(that: javac.tree.JCTree$JCVariableDecl): void;
              _this$0: Attr;
            }
            interface Attr$PostAttrAnalyzer extends CombineTypes<[_Attr$PostAttrAnalyzer, com.sun.tools.javac.tree.TreeScanner]> {}
            interface _Attr$RecoveryInfo$$static extends ClassLike {
              new(this$0: Attr, deferredAttrContext: DeferredAttr$DeferredAttrContext): Attr$RecoveryInfo;
              new(this$0: Attr, deferredAttrContext: DeferredAttr$DeferredAttrContext, pt: javac.code.Type): Attr$RecoveryInfo;
            }
            let Attr$RecoveryInfo: _Attr$RecoveryInfo$$static;
            interface _Attr$RecoveryInfo {
            }
            interface Attr$RecoveryInfo extends CombineTypes<[_Attr$RecoveryInfo, com.sun.tools.javac.comp.Attr$ResultInfo]> {}
            interface _Attr$ResultInfo$$static extends ClassLike {
              _new(this$0: Attr, pkind: javac.code.Kinds$KindSelector, pt: javac.code.Type): Attr$ResultInfo;
              _new(this$0: Attr, pkind: javac.code.Kinds$KindSelector, pt: javac.code.Type, checkMode: Attr$CheckMode): Attr$ResultInfo;
              _new(this$0: Attr, pkind: javac.code.Kinds$KindSelector, pt: javac.code.Type, checkContext: Check$CheckContext): Attr$ResultInfo;
              _new(this$0: Attr, pkind: javac.code.Kinds$KindSelector, pt: javac.code.Type, checkContext: Check$CheckContext, checkMode: Attr$CheckMode): Attr$ResultInfo;
            }
            let Attr$ResultInfo: _Attr$ResultInfo$$static;
            interface _Attr$ResultInfo {
              _check(pos: javac.util.JCDiagnostic$DiagnosticPosition, found: javac.code.Type): javac.code.Type;
              _dup(newPt: javac.code.Type): Attr$ResultInfo;
              _dup(newContext: Check$CheckContext): Attr$ResultInfo;
              _dup(newPt: javac.code.Type, newContext: Check$CheckContext): Attr$ResultInfo;
              _dup(newPt: javac.code.Type, newContext: Check$CheckContext, newMode: Attr$CheckMode): Attr$ResultInfo;
              _dup(newMode: Attr$CheckMode): Attr$ResultInfo;
              _needsArgumentAttr(tree: javac.tree.JCTree): boolean;
              toString(): string;
              _checkContext: Check$CheckContext;
              _checkMode: Attr$CheckMode;
              _pkind: javac.code.Kinds$KindSelector;
              _pt: javac.code.Type;
              _this$0: Attr;
            }
            interface Attr$ResultInfo extends CombineTypes<[_Attr$ResultInfo, java.lang.Object]> {}
            interface _Attr$TargetInfo$$static extends ClassLike {
              new(this$0: Attr, target: javac.code.Type, descriptor: javac.code.Type): Attr$TargetInfo;
            }
            let Attr$TargetInfo: _Attr$TargetInfo$$static;
            interface _Attr$TargetInfo {
              _descriptor: javac.code.Type;
              _target: javac.code.Type;
            }
            interface Attr$TargetInfo extends CombineTypes<[_Attr$TargetInfo, java.lang.Object]> {}
            interface _Attr$TypeAnnotationsValidator$$static extends ClassLike {
              new(a0: Attr, sigOnly: boolean): Attr$TypeAnnotationsValidator;
            }
            let Attr$TypeAnnotationsValidator: _Attr$TypeAnnotationsValidator$$static;
            interface _Attr$TypeAnnotationsValidator {
              _checkForDeclarationAnnotations(annotations: javac.util.List<javac.tree.JCTree$JCAnnotation>, sym: javac.code.Symbol): void;
              _validateAnnotatedType(errtree: javac.tree.JCTree, type: javac.code.Type): void;
              visitAnnotatedType(tree: javac.tree.JCTree$JCAnnotatedType): void;
              visitAnnotation(tree: javac.tree.JCTree$JCAnnotation): void;
              visitBlock(tree: javac.tree.JCTree$JCBlock): void;
              visitClassDef(tree: javac.tree.JCTree$JCClassDecl): void;
              visitMethodDef(tree: javac.tree.JCTree$JCMethodDecl): void;
              visitNewArray(tree: javac.tree.JCTree$JCNewArray): void;
              visitNewClass(tree: javac.tree.JCTree$JCNewClass): void;
              visitTypeCast(tree: javac.tree.JCTree$JCTypeCast): void;
              visitTypeParameter(tree: javac.tree.JCTree$JCTypeParameter): void;
              visitTypeTest(tree: javac.tree.JCTree$JCInstanceOf): void;
              visitVarDef(tree: javac.tree.JCTree$JCVariableDecl): void;
              _sigOnly: boolean;
              _this$0: Attr;
            }
            interface Attr$TypeAnnotationsValidator extends CombineTypes<[_Attr$TypeAnnotationsValidator, com.sun.tools.javac.tree.TreeScanner]> {}
            interface _AttrContext$$static extends ClassLike {
              new(): AttrContext;
            }
            let AttrContext: _AttrContext$$static;
            interface _AttrContext {
              _dup(scope: javac.code.Scope$WriteableScope): AttrContext;
              _dup(): AttrContext;
              getLocalElements(): java.lang.Iterable<javac.code.Symbol>;
              _lastResolveVarargs(): boolean;
              toString(): string;
              _allowProtectedAccess: boolean;
              _attributionMode: DeferredAttr$AttributionMode;
              _constructorArgs: boolean;
              _defaultSuperCallSite: javac.code.Type;
              _enclVar: javac.code.Symbol;
              _isAnonymousDiamond: boolean;
              _isLambda: boolean;
              _isNewClass: boolean;
              _isSelfCall: boolean;
              _isSerializable: boolean;
              _isSerializableLambda: boolean;
              _lint: javac.code.Lint;
              _pendingResolutionPhase: Resolve$MethodResolutionPhase;
              _preferredTreeForDiagnostics: javac.tree.JCTree;
              _returnResult: Attr$ResultInfo;
              _scope: javac.code.Scope$WriteableScope;
              _selectSuper: boolean;
              _staticLevel: int;
              _visitingServiceImplementation: boolean;
              _yieldResult: Attr$ResultInfo;
            }
            interface AttrContext extends CombineTypes<[_AttrContext, java.lang.Object]> {}
            interface _AttrContextEnv$$static extends ClassLike {
              new(tree: javac.tree.JCTree, info: AttrContext): AttrContextEnv;
            }
            let AttrContextEnv: _AttrContextEnv$$static;
            interface _AttrContextEnv {
            }
            interface AttrContextEnv extends CombineTypes<[_AttrContextEnv, Env<AttrContext>]> {}
            interface _AttrRecover$$static extends ClassLike {
              instance(context: javac.util.Context): AttrRecover;
              _attrRepairKey: javac.util.Context$Key<AttrRecover>;
              _new(context: javac.util.Context): AttrRecover;
            }
            let AttrRecover: _AttrRecover$$static;
            interface _AttrRecover {
              _basicMethodInvocationRecovery(tree: javac.tree.JCTree, site: javac.code.Type, sym: javac.code.Symbol, env: Env<AttrContext>, resultInfo: Attr$ResultInfo): javac.code.Type;
              doRecovery(): void;
              _recoverMethodInvocation(tree: javac.tree.JCTree, site: javac.code.Type, sym: javac.code.Symbol, env: Env<AttrContext>, resultInfo: Attr$ResultInfo): javac.code.Type;
              _wrongMethodSymbolCandidate(errSymbol: javac.code.Symbol$TypeSymbol, candSym: javac.code.Symbol, diag: javac.util.JCDiagnostic): void;
              _attr: Attr;
              _deferredAttr: DeferredAttr;
              _make: javac.tree.TreeMaker;
              _names: javac.util.Names;
              _recoveryTodo: javac.util.ListBuffer<AttrRecover$RecoverTodo>;
              _syms: javac.code.Symtab;
              _types: javac.code.Types;
            }
            interface AttrRecover extends CombineTypes<[_AttrRecover, java.lang.Object]> {}
            interface _AttrRecover$RecoverTodo$$static extends ClassLike {
              new(tree: javac.tree.JCTree, site: javac.code.Type, errSym: javac.code.Symbol, candSym: javac.code.Symbol, env: Env<AttrContext>, resultInfo: Attr$ResultInfo): AttrRecover$RecoverTodo;
            }
            let AttrRecover$RecoverTodo: _AttrRecover$RecoverTodo$$static;
            interface _AttrRecover$RecoverTodo {
              readonly candSym: javac.code.Symbol;
              readonly env: Env<AttrContext>;
              readonly errSym: javac.code.Symbol;
              readonly resultInfo: Attr$ResultInfo;
              readonly site: javac.code.Type;
              readonly tree: javac.tree.JCTree;
            }
            interface AttrRecover$RecoverTodo extends CombineTypes<[_AttrRecover$RecoverTodo, java.lang.Object]> {}
            interface _AttrRecover$RecoveryErrorType$$static extends ClassLike {
              new(original: javac.code.Type$ErrorType, candidateSymbol: javac.code.Symbol): AttrRecover$RecoveryErrorType;
            }
            let AttrRecover$RecoveryErrorType: _AttrRecover$RecoveryErrorType$$static;
            interface _AttrRecover$RecoveryErrorType {
              readonly candidateSymbol: javac.code.Symbol;
            }
            interface AttrRecover$RecoveryErrorType extends CombineTypes<[_AttrRecover$RecoveryErrorType, com.sun.tools.javac.code.Type$ErrorType]> {}
            interface _Check$$static extends ClassLike {
              instance(context: javac.util.Context): Check;
              _protection(flags: long): int;
              _FIRST: int;
              _SECOND: int;
              _checkKey: javac.util.Context$Key<Check>;
              _denotableChecker: javac.code.Types$SimpleVisitor<boolean,java.lang.Void>;
              _ignoreAnnotatedCasts: boolean;
              _new(context: javac.util.Context): Check;
            }
            let Check: _Check$$static;
            interface _Check {
              _annotationApplicable(a: javac.tree.JCTree$JCAnnotation, s: javac.code.Symbol): boolean;
              _asTypeParam(t: javac.code.Type): any;
              _assertConvertible(tree: javac.tree.JCTree, actual: javac.code.Type, formal: javac.code.Type, warn: javac.util.Warner): void;
              _belongsToRestrictedPackage(sym: javac.code.Symbol): boolean;
              _buildResponsiblePredicate(site: javac.code.Type, methodGroups: javac.util.List<java.util.Collection<javac.code.Symbol$MethodSymbol>>): java.util.function.BiPredicate<javac.code.Symbol$MethodSymbol,javac.code.Symbol$MethodSymbol>;
              _cannotOverride(m: javac.code.Symbol$MethodSymbol, other: javac.code.Symbol$MethodSymbol): javac.util.JCDiagnostic$Fragment;
              castWarner(pos: javac.util.JCDiagnostic$DiagnosticPosition, found: javac.code.Type, expected: javac.code.Type): javac.util.Warner;
              _checkAccessFromSerializableElement(tree: javac.tree.JCTree, isLambda: boolean): void;
              _checkAllDefined(pos: javac.util.JCDiagnostic$DiagnosticPosition, c: javac.code.Symbol$ClassSymbol): void;
              _checkAnnotationResType(pos: javac.util.JCDiagnostic$DiagnosticPosition, type: javac.code.Type): void;
              checkCanonical(tree: javac.tree.JCTree): void;
              _checkCastable(pos: javac.util.JCDiagnostic$DiagnosticPosition, found: javac.code.Type, req: javac.code.Type): javac.code.Type;
              _checkCastable(pos: javac.util.JCDiagnostic$DiagnosticPosition, found: javac.code.Type, req: javac.code.Type, checkContext: Check$CheckContext): javac.code.Type;
              _checkClassBounds(pos: javac.util.JCDiagnostic$DiagnosticPosition, type: javac.code.Type): void;
              _checkClassBounds(pos: javac.util.JCDiagnostic$DiagnosticPosition, seensofar: java.util.Map<javac.code.Symbol$TypeSymbol,javac.code.Type>, type: javac.code.Type): void;
              _checkClassOrArrayType(pos: javac.util.JCDiagnostic$DiagnosticPosition, t: javac.code.Type): javac.code.Type;
              _checkClassOverrideEqualsAndHash(pos: javac.util.JCDiagnostic$DiagnosticPosition, someClass: javac.code.Symbol$ClassSymbol): void;
              checkClassOverrideEqualsAndHashIfNeeded(pos: javac.util.JCDiagnostic$DiagnosticPosition, someClass: javac.code.Symbol$ClassSymbol): void;
              _checkClassType(pos: javac.util.JCDiagnostic$DiagnosticPosition, t: javac.code.Type): javac.code.Type;
              _checkClassType(pos: javac.util.JCDiagnostic$DiagnosticPosition, t: javac.code.Type, noBounds: boolean): javac.code.Type;
              _checkCommonOverriderIn(s1: javac.code.Symbol, s2: javac.code.Symbol, site: javac.code.Type): boolean;
              checkCompatibleAbstracts(pos: javac.util.JCDiagnostic$DiagnosticPosition, t1: javac.code.Type, t2: javac.code.Type, site: javac.code.Type): boolean;
              checkCompatibleConcretes(pos: javac.util.JCDiagnostic$DiagnosticPosition, site: javac.code.Type): void;
              _checkCompatibleSupertypes(pos: javac.util.JCDiagnostic$DiagnosticPosition, c: javac.code.Type): void;
              _checkConstructorRefType(pos: javac.util.JCDiagnostic$DiagnosticPosition, t: javac.code.Type): javac.code.Type;
              _checkCyclicConstructor(tree: javac.tree.JCTree$JCClassDecl, ctor: javac.code.Symbol, callMap: java.util.Map<javac.code.Symbol,javac.code.Symbol>): void;
              _checkCyclicConstructors(tree: javac.tree.JCTree$JCClassDecl): void;
              _checkDefaultConstructor(c: javac.code.Symbol$ClassSymbol, pos: javac.util.JCDiagnostic$DiagnosticPosition): void;
              _checkDefaultMethodClashes(pos: javac.util.JCDiagnostic$DiagnosticPosition, site: javac.code.Type): void;
              checkDenotable(t: javac.code.Type): boolean;
              _checkDeprecated(pos: javac.util.JCDiagnostic$DiagnosticPosition, other: javac.code.Symbol, s: javac.code.Symbol): void;
              _checkDeprecated(pos: java.util.function.Supplier<javac.util.JCDiagnostic$DiagnosticPosition>, other: javac.code.Symbol, s: javac.code.Symbol): void;
              _checkDeprecatedAnnotation(pos: javac.util.JCDiagnostic$DiagnosticPosition, s: javac.code.Symbol): void;
              _checkDiamond(tree: javac.tree.JCTree$JCNewClass, t: javac.code.Type): javac.code.Type;
              _checkDiamondDenotable(t: javac.code.Type$ClassType): javac.util.List<javac.code.Type>;
              _checkDisjoint(pos: javac.util.JCDiagnostic$DiagnosticPosition, flags: long, a2: long, set1: long): boolean;
              _checkDivZero(pos: javac.util.JCDiagnostic$DiagnosticPosition, operator: javac.code.Symbol, operand: javac.code.Type): void;
              _checkEmptyIf(tree: javac.tree.JCTree$JCIf): void;
              _checkExtends(a: javac.code.Type, bound: javac.code.Type): boolean;
              _checkFlags(pos: javac.util.JCDiagnostic$DiagnosticPosition, flags: long, a2: javac.code.Symbol, sym: javac.tree.JCTree): long;
              _checkForBadAuxiliaryClassAccess(pos: javac.util.JCDiagnostic$DiagnosticPosition, env: Env<AttrContext>, c: javac.code.Symbol$ClassSymbol): void;
              checkFunctionalInterface(tree: javac.tree.JCTree$JCClassDecl, cs: javac.code.Symbol$ClassSymbol): void;
              checkHasMain(pos: javac.util.JCDiagnostic$DiagnosticPosition, c: javac.code.Symbol$ClassSymbol): void;
              _checkHideClashes(pos: javac.util.JCDiagnostic$DiagnosticPosition, site: javac.code.Type, sym: javac.code.Symbol$MethodSymbol): void;
              _checkImplementations(tree: javac.tree.JCTree$JCClassDecl): void;
              _checkImplementations(tree: javac.tree.JCTree, origin: javac.code.Symbol$ClassSymbol, ic: javac.code.Symbol$ClassSymbol): void;
              checkImportedPackagesObservable(toplevel: javac.tree.JCTree$JCCompilationUnit): void;
              checkImportsResolvable(toplevel: javac.tree.JCTree$JCCompilationUnit): void;
              _checkImportsUnique(toplevel: javac.tree.JCTree$JCCompilationUnit): void;
              checkLeaksNotAccessible(env: Env<AttrContext>, check: javac.tree.JCTree$JCClassDecl): void;
              _checkLocalVarType(pos: javac.util.JCDiagnostic$DiagnosticPosition, t: javac.code.Type, name: javac.util.Name): javac.code.Type;
              _checkLossOfPrecision(pos: javac.util.JCDiagnostic$DiagnosticPosition, found: javac.code.Type, req: javac.code.Type): void;
              _checkMethod(mtype: javac.code.Type, sym: javac.code.Symbol, env: Env<AttrContext>, argtrees: javac.util.List<javac.tree.JCTree$JCExpression>, argtypes: javac.util.List<javac.code.Type>, useVarargs: boolean, inferenceContext: InferenceContext): javac.code.Type;
              _checkModuleExists(pos: javac.util.JCDiagnostic$DiagnosticPosition, msym: javac.code.Symbol$ModuleSymbol): void;
              checkModuleName(tree: javac.tree.JCTree$JCModuleDecl): void;
              _checkModuleRequires(pos: javac.util.JCDiagnostic$DiagnosticPosition, rd: javac.code.Directive$RequiresDirective): void;
              _checkNameClash(origin: javac.code.Symbol$ClassSymbol, s1: javac.code.Symbol, s2: javac.code.Symbol): boolean;
              _checkNonCyclic(pos: javac.util.JCDiagnostic$DiagnosticPosition, t: javac.code.Type): void;
              _checkNonCyclic(pos: javac.util.JCDiagnostic$DiagnosticPosition, t: javac.code.Type$TypeVar): void;
              _checkNonCyclic1(pos: javac.util.JCDiagnostic$DiagnosticPosition, t: javac.code.Type, seen: javac.util.List<javac.code.Type$TypeVar>): void;
              _checkNonCyclicDecl(tree: javac.tree.JCTree$JCClassDecl): void;
              _checkNonCyclicElements(tree: javac.tree.JCTree$JCClassDecl): void;
              _checkNonCyclicElementsInternal(pos: javac.util.JCDiagnostic$DiagnosticPosition, tsym: javac.code.Symbol$TypeSymbol): void;
              _checkNonCyclicInternal(pos: javac.util.JCDiagnostic$DiagnosticPosition, t: javac.code.Type): boolean;
              _checkNonVoid(pos: javac.util.JCDiagnostic$DiagnosticPosition, t: javac.code.Type): javac.code.Type;
              _checkNotRepeated(pos: javac.util.JCDiagnostic$DiagnosticPosition, it: javac.code.Type, its: java.util.Set<javac.code.Symbol>): void;
              _checkNullOrRefType(pos: javac.util.JCDiagnostic$DiagnosticPosition, t: javac.code.Type): javac.code.Type;
              _checkOverride(tree: javac.tree.JCTree, m: javac.code.Symbol$MethodSymbol, other: javac.code.Symbol$MethodSymbol, origin: javac.code.Symbol$ClassSymbol): void;
              _checkOverride(env: Env<AttrContext>, tree: javac.tree.JCTree$JCMethodDecl, m: javac.code.Symbol$MethodSymbol): void;
              _checkOverride(tree: javac.tree.JCTree, site: javac.code.Type, origin: javac.code.Symbol$ClassSymbol, m: javac.code.Symbol$MethodSymbol): void;
              _checkOverrideClashes(pos: javac.util.JCDiagnostic$DiagnosticPosition, site: javac.code.Type, sym: javac.code.Symbol$MethodSymbol): void;
              _checkPackageExistsForOpens(pos: javac.util.JCDiagnostic$DiagnosticPosition, packge: javac.code.Symbol$PackageSymbol): void;
              _checkPotentiallyAmbiguousOverloads(tree: javac.tree.JCTree$JCClassDecl, site: javac.code.Type): void;
              _checkPreview(pos: javac.util.JCDiagnostic$DiagnosticPosition, other: javac.code.Symbol, s: javac.code.Symbol): void;
              checkProcessorType(processor: javac.tree.JCTree$JCExpression, resultType: javac.code.Type, env: Env<AttrContext>): javac.code.Type;
              _checkProfile(pos: javac.util.JCDiagnostic$DiagnosticPosition, s: javac.code.Symbol): void;
              _checkRaw(tree: javac.tree.JCTree, env: Env<AttrContext>): void;
              checkRedundantCast(env: Env<AttrContext>, tree: javac.tree.JCTree$JCTypeCast): void;
              _checkRefType(pos: javac.util.JCDiagnostic$DiagnosticPosition, t: javac.code.Type): javac.code.Type;
              _checkRefTypes(trees: javac.util.List<javac.tree.JCTree$JCExpression>, types: javac.util.List<javac.code.Type>): javac.util.List<javac.code.Type>;
              checkSerialStructure(tree: javac.tree.JCTree$JCClassDecl, c: javac.code.Symbol$ClassSymbol): void;
              _checkSunAPI(pos: javac.util.JCDiagnostic$DiagnosticPosition, s: javac.code.Symbol): void;
              _checkSwitchCaseLabelDominated(cases: javac.util.List<javac.tree.JCTree$JCCase>): void;
              _checkSwitchCaseStructure(cases: javac.util.List<javac.tree.JCTree$JCCase>): void;
              _checkTransparentClass(pos: javac.util.JCDiagnostic$DiagnosticPosition, c: javac.code.Symbol$ClassSymbol, s: javac.code.Scope): void;
              _checkTransparentVar(pos: javac.util.JCDiagnostic$DiagnosticPosition, v: javac.code.Symbol$VarSymbol, s: javac.code.Scope): void;
              checkType(pos: javac.util.JCDiagnostic$DiagnosticPosition, found: javac.code.Type, req: javac.code.Type): javac.code.Type;
              _checkType(pos: javac.util.JCDiagnostic$DiagnosticPosition, found: javac.code.Type, req: javac.code.Type, checkContext: Check$CheckContext): javac.code.Type;
              _checkTypeContainsImportableElement(tsym: javac.code.Symbol$TypeSymbol, origin: javac.code.Symbol$TypeSymbol, packge: javac.code.Symbol$PackageSymbol, name: javac.util.Name, processed: java.util.Set<javac.code.Symbol>): boolean;
              _checkUnique(pos: javac.util.JCDiagnostic$DiagnosticPosition, sym: javac.code.Symbol, s: javac.code.Scope): boolean;
              _checkUniqueClassName(pos: javac.util.JCDiagnostic$DiagnosticPosition, name: javac.util.Name, s: javac.code.Scope): boolean;
              _checkUniqueImport(pos: javac.util.JCDiagnostic$DiagnosticPosition, ordinallyImportedSoFar: javac.code.Scope, staticallyImportedSoFar: javac.code.Scope, topLevelScope: javac.code.Scope, sym: javac.code.Symbol, staticImport: boolean): boolean;
              checkValidGenericType(t: javac.code.Type): boolean;
              _checkVarargsMethodDecl(env: Env<AttrContext>, tree: javac.tree.JCTree$JCMethodDecl): void;
              _checkVisible(pos: javac.util.JCDiagnostic$DiagnosticPosition, what: javac.code.Symbol, inPackage: javac.code.Symbol$PackageSymbol, inSuperType: boolean): void;
              clear(): void;
              clearLocalClassNameIndexes(c: javac.code.Symbol$ClassSymbol): void;
              _closure(t: javac.code.Type, typeMap: java.util.Map<javac.code.Symbol$TypeSymbol,javac.code.Type>): void;
              _closure(t: javac.code.Type, typesSkip: java.util.Map<javac.code.Symbol$TypeSymbol,javac.code.Type>, typeMap: java.util.Map<javac.code.Symbol$TypeSymbol,javac.code.Type>): void;
              _compareAndRemove<T>(list: java.util.List<T>, comparer: java.util.function.ToIntBiFunction<T,T>): void;
              completionError(pos: javac.util.JCDiagnostic$DiagnosticPosition, ex: javac.code.Symbol$CompletionFailure): javac.code.Type;
              convertWarner(pos: javac.util.JCDiagnostic$DiagnosticPosition, found: javac.code.Type, expected: javac.code.Type): javac.util.Warner;
              _defaultTargetMetaInfo(): javac.util.Name[];
              _diff(ts1: javac.util.List<javac.code.Type>, ts2: javac.util.List<javac.code.Type>): javac.util.List<javac.code.Type>;
              _duplicateErasureError(pos: javac.util.JCDiagnostic$DiagnosticPosition, sym1: javac.code.Symbol, sym2: javac.code.Symbol): void;
              _duplicateError(pos: javac.util.JCDiagnostic$DiagnosticPosition, sym: javac.code.Symbol): void;
              _earlyRefError(pos: javac.util.JCDiagnostic$DiagnosticPosition, sym: javac.code.Symbol): void;
              _excl(t: javac.code.Type, ts: javac.util.List<javac.code.Type>): javac.util.List<javac.code.Type>;
              _findExport(pack: javac.code.Symbol$PackageSymbol): javac.code.Directive$ExportsDirective;
              _firstDirectIncompatibility(pos: javac.util.JCDiagnostic$DiagnosticPosition, t1: javac.code.Type, t2: javac.code.Type, site: javac.code.Type): javac.code.Symbol;
              _firstIncompatibility(pos: javac.util.JCDiagnostic$DiagnosticPosition, t1: javac.code.Type, t2: javac.code.Type, site: javac.code.Type): javac.code.Symbol;
              _firstIncompatibleTypeArg(type: javac.code.Type): javac.code.Type;
              _getApplicableTargets(a: javac.tree.JCTree$JCAnnotation, s: javac.code.Symbol): java.util.Optional<java.util.Set<javac.util.Name>>;
              _getAttributeTargetAttribute(s: javac.code.Symbol$TypeSymbol): javac.code.Attribute$Array;
              getCompiled(csym: javac.code.Symbol$ClassSymbol): javac.code.Symbol$ClassSymbol;
              getCompiled(msym: javac.code.Symbol$ModuleSymbol, flatname: javac.util.Name): javac.code.Symbol$ClassSymbol;
              _getDefaultTargetSet(): java.util.Set<javac.util.Name>;
              _getTargetNames(a: javac.tree.JCTree$JCAnnotation): javac.util.Name[];
              getTargetNames(annoSym: javac.code.Symbol$TypeSymbol): javac.util.Name[];
              _hasBindings(p: javac.tree.JCTree): boolean;
              _hasStatements(cases: javac.util.List<javac.tree.JCTree$JCCase>): boolean;
              _implicitEnumFinalFlag(tree: javac.tree.JCTree): long;
              importAccessible(sym: javac.code.Symbol, packge: javac.code.Symbol$PackageSymbol): boolean;
              _incl(t: javac.code.Type, ts: javac.util.List<javac.code.Type>): javac.util.List<javac.code.Type>;
              intersect(ts1: javac.util.List<javac.code.Type>, ts2: javac.util.List<javac.code.Type>): javac.util.List<javac.code.Type>;
              _intersects(t: javac.code.Type, ts: javac.util.List<javac.code.Type>): boolean;
              _is292targetTypeCast(tree: javac.tree.JCTree$JCTypeCast): boolean;
              _isAPISymbol(sym: javac.code.Symbol): boolean;
              _isCanonical(tree: javac.tree.JCTree): boolean;
              _isChecked(exc: javac.code.Type): boolean;
              _isDeprecatedOverrideIgnorable(m: javac.code.Symbol$MethodSymbol, origin: javac.code.Symbol$ClassSymbol): boolean;
              _isEffectivelyNonPublic(sym: javac.code.Symbol): boolean;
              _isExternalizable(t: javac.code.Type): boolean;
              _isHandled(exc: javac.code.Type, handled: javac.util.List<javac.code.Type>): boolean;
              _isOverrider(s: javac.code.Symbol): boolean;
              _isTargetSubsetOf(s: java.util.Set<javac.util.Name>, t: java.util.Set<javac.util.Name>): boolean;
              _isTrustMeAllowedOnMethod(s: javac.code.Symbol): boolean;
              _isTypeAnnotation(a: javac.tree.JCTree$JCAnnotation, isTypeParameter: boolean): boolean;
              _isTypeAnnotation(a: javac.code.Attribute, isTypeParameter: boolean): boolean;
              _isTypeArgErroneous(t: javac.code.Type): boolean;
              _isUnchecked(exc: javac.code.Symbol$ClassSymbol): boolean;
              _isUnchecked(exc: javac.code.Type): boolean;
              _isUnchecked(pos: javac.util.JCDiagnostic$DiagnosticPosition, exc: javac.code.Type): boolean;
              _labelType(label: javac.tree.JCTree$JCCaseLabel): javac.code.Type;
              localClassName(c: javac.code.Symbol$ClassSymbol): javac.util.Name;
              _methodsGroupedByName<C>(site: javac.code.Type, filter: java.util.function.Predicate<javac.code.Symbol>, groupMaker: java.util.function.Supplier<C>): javac.util.List<C>;
              newRound(): void;
              _noteCyclic(pos: javac.util.JCDiagnostic$DiagnosticPosition, c: javac.code.Symbol$ClassSymbol): void;
              _patternDominated(existingPattern: javac.tree.JCTree$JCPattern, currentPattern: javac.tree.JCTree$JCPattern): boolean;
              _potentiallyAmbiguousOverload(site: javac.code.Type, msym1: javac.code.Symbol$MethodSymbol, msym2: javac.code.Symbol$MethodSymbol): boolean;
              putCompiled(csym: javac.code.Symbol$ClassSymbol): void;
              removeCompiled(csym: javac.code.Symbol$ClassSymbol): void;
              _removePreempted<T>(list: java.util.List<T>, preempts: java.util.function.BiPredicate<T,T>): void;
              reportDeferredDiagnostics(): void;
              _setLint(newLint: javac.code.Lint): javac.code.Lint;
              _setMethod(newMethod: javac.code.Symbol$MethodSymbol): javac.code.Symbol$MethodSymbol;
              _shouldCheckPreview(m: javac.code.Symbol$MethodSymbol, other: javac.code.Symbol$MethodSymbol, origin: javac.code.Symbol$ClassSymbol): boolean;
              _subset(t: javac.code.Type, ts: javac.util.List<javac.code.Type>): boolean;
              _typeTagError(pos: javac.util.JCDiagnostic$DiagnosticPosition, required: javac.util.JCDiagnostic, found: any): javac.code.Type;
              _uncheckedOverrides(m: javac.code.Symbol$MethodSymbol, other: javac.code.Symbol$MethodSymbol): javac.util.JCDiagnostic$Fragment;
              _unhandled(thrown: javac.util.List<javac.code.Type>, handled: javac.util.List<javac.code.Type>): javac.util.List<javac.code.Type>;
              _union(ts1: javac.util.List<javac.code.Type>, ts2: javac.util.List<javac.code.Type>): javac.util.List<javac.code.Type>;
              _validate(tree: javac.tree.JCTree, env: Env<AttrContext>): void;
              _validate(tree: javac.tree.JCTree, env: Env<AttrContext>, checkRaw: boolean): void;
              _validate(trees: javac.util.List<javac.tree.JCTree>, env: Env<AttrContext>): void;
              _validateAnnotation(a: javac.tree.JCTree$JCAnnotation, declarationTree: javac.tree.JCTree, s: javac.code.Symbol): void;
              _validateAnnotation(a: javac.tree.JCTree$JCAnnotation): boolean;
              validateAnnotationDeferErrors(a: javac.tree.JCTree$JCAnnotation): boolean;
              _validateAnnotationMethod(pos: javac.util.JCDiagnostic$DiagnosticPosition, m: javac.code.Symbol$MethodSymbol): void;
              _validateAnnotationTree(tree: javac.tree.JCTree): void;
              _validateAnnotationType(restype: javac.tree.JCTree): void;
              _validateAnnotationType(pos: javac.util.JCDiagnostic$DiagnosticPosition, type: javac.code.Type): void;
              validateAnnotations(annotations: javac.util.List<javac.tree.JCTree$JCAnnotation>, declarationTree: javac.tree.JCTree, s: javac.code.Symbol): void;
              _validateDefault(container: javac.code.Symbol, pos: javac.util.JCDiagnostic$DiagnosticPosition): void;
              _validateDocumented(container: javac.code.Symbol, contained: javac.code.Symbol, pos: javac.util.JCDiagnostic$DiagnosticPosition): void;
              _validateInherited(container: javac.code.Symbol, contained: javac.code.Symbol, pos: javac.util.JCDiagnostic$DiagnosticPosition): void;
              validateRepeatable(s: javac.code.Symbol$TypeSymbol, repeatable: javac.code.Attribute$Compound, pos: javac.util.JCDiagnostic$DiagnosticPosition): void;
              _validateRetention(container: javac.code.Symbol$TypeSymbol, contained: javac.code.Symbol$TypeSymbol, pos: javac.util.JCDiagnostic$DiagnosticPosition): void;
              _validateTarget(container: javac.code.Symbol$TypeSymbol, contained: javac.code.Symbol$TypeSymbol, pos: javac.util.JCDiagnostic$DiagnosticPosition): void;
              _validateTargetAnnotationValue(a: javac.tree.JCTree$JCAnnotation): boolean;
              validateTypeAnnotation(a: javac.tree.JCTree$JCAnnotation, s: javac.code.Symbol, isTypeParameter: boolean): void;
              validateTypeAnnotations(annotations: javac.util.List<javac.tree.JCTree$JCAnnotation>, s: javac.code.Symbol, isTypeParameter: boolean): void;
              _validateValue(container: javac.code.Symbol$TypeSymbol, contained: javac.code.Symbol$TypeSymbol, pos: javac.util.JCDiagnostic$DiagnosticPosition): void;
              _varargsDuplicateError(pos: javac.util.JCDiagnostic$DiagnosticPosition, sym1: javac.code.Symbol, sym2: javac.code.Symbol): void;
              _varargsOverrides(m: javac.code.Symbol$MethodSymbol, other: javac.code.Symbol$MethodSymbol): javac.util.JCDiagnostic$Fragment;
              warnDeclaredUsingPreview(pos: javac.util.JCDiagnostic$DiagnosticPosition, sym: javac.code.Symbol): void;
              _warnDeprecated(pos: javac.util.JCDiagnostic$DiagnosticPosition, sym: javac.code.Symbol): void;
              _warnDivZero(pos: javac.util.JCDiagnostic$DiagnosticPosition): void;
              _warnOnExplicitStrictfp(pos: javac.util.JCDiagnostic$DiagnosticPosition): void;
              warnPreviewAPI(pos: javac.util.JCDiagnostic$DiagnosticPosition, warnKey: javac.util.JCDiagnostic$Warning): void;
              warnStatic(pos: javac.util.JCDiagnostic$DiagnosticPosition, warnKey: javac.util.JCDiagnostic$Warning): void;
              warnUnchecked(pos: javac.util.JCDiagnostic$DiagnosticPosition, warnKey: javac.util.JCDiagnostic$Warning): void;
              _warnUnsafeVararg(pos: javac.util.JCDiagnostic$DiagnosticPosition, warnKey: javac.util.JCDiagnostic$Warning): void;
              _withinAnonConstr(env: Env<AttrContext>): boolean;
              _allowModules: boolean;
              _allowRecords: boolean;
              _allowSealed: boolean;
              _basicHandler: Check$CheckContext;
              _compiled: java.util.Map<javac.util.Pair<javac.code.Symbol$ModuleSymbol,javac.util.Name>,javac.code.Symbol$ClassSymbol>;
              _defaultTargets: java.util.Set<javac.util.Name>;
              _deferredAttr: DeferredAttr;
              _deferredLintHandler: javac.code.DeferredLintHandler;
              _deprecationHandler: javac.util.MandatoryWarningHandler;
              _dfltTargetMeta: javac.util.Name[];
              _diags: javac.util.JCDiagnostic$Factory;
              disablePreviewCheck: boolean;
              _enter: Enter;
              _equalsHasCodeFilter: java.util.function.Predicate<javac.code.Symbol>;
              _fileManager: javax.tools.JavaFileManager;
              _infer: Infer;
              _isTypeArgErroneous: javac.code.Types$UnaryVisitor<boolean>;
              _lint: javac.code.Lint;
              _localClassNameIndexes: java.util.Map<javac.util.Pair<javac.util.Name,javac.util.Name>,int>;
              _log: javac.util.Log;
              _method: javac.code.Symbol$MethodSymbol;
              _names: javac.util.Names;
              _overrideWarner: javac.util.Warner;
              _preview: javac.code.Preview;
              _profile: javac.jvm.Profile;
              _removalHandler: javac.util.MandatoryWarningHandler;
              _rs: Resolve;
              _source: javac.code.Source;
              _sunApiHandler: javac.util.MandatoryWarningHandler;
              _syms: javac.code.Symtab;
              _syntheticNameChar: char;
              _target: javac.jvm.Target;
              _typeAnnotations: javac.code.TypeAnnotations;
              _types: javac.code.Types;
              _uncheckedHandler: javac.util.MandatoryWarningHandler;
              _warnOnAnyAccessToMembers: boolean;
            }
            interface Check extends CombineTypes<[_Check, java.lang.Object]> {}
            interface _Check$CheckContext$$static extends ClassLike {
            }
            let Check$CheckContext: _Check$CheckContext$$static;
            interface _Check$CheckContext {
              checkWarner(a0: javac.util.JCDiagnostic$DiagnosticPosition, a1: javac.code.Type, a2: javac.code.Type): javac.util.Warner;
              compatible(a0: javac.code.Type, a1: javac.code.Type, a2: javac.util.Warner): boolean;
              deferredAttrContext(): DeferredAttr$DeferredAttrContext;
              inferenceContext(): InferenceContext;
              report(a0: javac.util.JCDiagnostic$DiagnosticPosition, a1: javac.util.JCDiagnostic): void;
            }
            interface Check$CheckContext extends CombineTypes<[_Check$CheckContext, java.lang.Object]> {}
            interface _Check$ClashFilter$$static extends ClassLike {
              _new(a0: Check, site: javac.code.Type): Check$ClashFilter;
            }
            let Check$ClashFilter: _Check$ClashFilter$$static;
            interface _Check$ClashFilter {
              _shouldSkip(s: javac.code.Symbol): boolean;
              test(s: javac.code.Symbol): boolean;
              test(a0: any): boolean;
              _site: javac.code.Type;
              _this$0: Check;
            }
            interface Check$ClashFilter extends CombineTypes<[_Check$ClashFilter, java.lang.Object, java.util.function.Predicate<javac.code.Symbol>]> {}
            interface _Check$ConversionWarner$$static extends ClassLike {
              new(a0: Check, pos: javac.util.JCDiagnostic$DiagnosticPosition, uncheckedKey: string, found: javac.code.Type, expected: javac.code.Type): Check$ConversionWarner;
            }
            let Check$ConversionWarner: _Check$ConversionWarner$$static;
            interface _Check$ConversionWarner {
              warn(lint: javac.code.Lint$LintCategory): void;
              _expected: javac.code.Type;
              _found: javac.code.Type;
              _this$0: Check;
              _uncheckedKey: string;
            }
            interface Check$ConversionWarner extends CombineTypes<[_Check$ConversionWarner, com.sun.tools.javac.util.Warner]> {}
            interface _Check$CycleChecker$$static extends ClassLike {
              _new(this$0: Check): Check$CycleChecker;
            }
            let Check$CycleChecker: _Check$CycleChecker$$static;
            interface _Check$CycleChecker {
              _checkClass(pos: javac.util.JCDiagnostic$DiagnosticPosition, c: javac.code.Symbol, supertypes: javac.util.List<javac.tree.JCTree>): void;
              _checkSymbol(pos: javac.util.JCDiagnostic$DiagnosticPosition, sym: javac.code.Symbol): void;
              visitClassDef(tree: javac.tree.JCTree$JCClassDecl): void;
              visitIdent(tree: javac.tree.JCTree$JCIdent): void;
              visitSelect(tree: javac.tree.JCTree$JCFieldAccess): void;
              visitTypeApply(tree: javac.tree.JCTree$JCTypeApply): void;
              visitTypeArray(tree: javac.tree.JCTree$JCArrayTypeTree): void;
              _errorFound: boolean;
              _partialCheck: boolean;
              _seenClasses: java.util.Set<javac.code.Symbol>;
              _this$0: Check;
            }
            interface Check$CycleChecker extends CombineTypes<[_Check$CycleChecker, com.sun.tools.javac.tree.TreeScanner]> {}
            interface _Check$DefaultMethodClashFilter$$static extends ClassLike {
              _new(a0: Check, site: javac.code.Type): Check$DefaultMethodClashFilter;
            }
            let Check$DefaultMethodClashFilter: _Check$DefaultMethodClashFilter$$static;
            interface _Check$DefaultMethodClashFilter {
              test(s: javac.code.Symbol): boolean;
              test(a0: any): boolean;
              _site: javac.code.Type;
              _this$0: Check;
            }
            interface Check$DefaultMethodClashFilter extends CombineTypes<[_Check$DefaultMethodClashFilter, java.lang.Object, java.util.function.Predicate<javac.code.Symbol>]> {}
            interface _Check$NestedCheckContext$$static extends ClassLike {
              _new(enclosingContext: Check$CheckContext): Check$NestedCheckContext;
            }
            let Check$NestedCheckContext: _Check$NestedCheckContext$$static;
            interface _Check$NestedCheckContext {
              checkWarner(pos: javac.util.JCDiagnostic$DiagnosticPosition, found: javac.code.Type, req: javac.code.Type): javac.util.Warner;
              compatible(found: javac.code.Type, req: javac.code.Type, warn: javac.util.Warner): boolean;
              deferredAttrContext(): DeferredAttr$DeferredAttrContext;
              inferenceContext(): InferenceContext;
              report(pos: javac.util.JCDiagnostic$DiagnosticPosition, details: javac.util.JCDiagnostic): void;
              _enclosingContext: Check$CheckContext;
            }
            interface Check$NestedCheckContext extends CombineTypes<[_Check$NestedCheckContext, java.lang.Object, com.sun.tools.javac.comp.Check$CheckContext]> {}
            interface _Check$PotentiallyAmbiguousFilter$$static extends ClassLike {
              _new(this$0: Check, site: javac.code.Type): Check$PotentiallyAmbiguousFilter;
            }
            let Check$PotentiallyAmbiguousFilter: _Check$PotentiallyAmbiguousFilter$$static;
            interface _Check$PotentiallyAmbiguousFilter {
              _shouldSkip(s: javac.code.Symbol): boolean;
              _this$0: Check;
            }
            interface Check$PotentiallyAmbiguousFilter extends CombineTypes<[_Check$PotentiallyAmbiguousFilter, com.sun.tools.javac.comp.Check$ClashFilter]> {}
            interface _Check$SerialTypeVisitor$$static extends ClassLike {
              _serialFieldNames: java.util.Set<string>;
              _serialMethodNames: java.util.Set<string>;
              _new(a0: Check): Check$SerialTypeVisitor;
            }
            let Check$SerialTypeVisitor: _Check$SerialTypeVisitor$$static;
            interface _Check$SerialTypeVisitor {
              _canBeSerialized(type: javac.code.Type): boolean;
              _checkConcreteInstanceMethod(tree: javac.tree.JCTree$JCClassDecl, enclosing: javax.lang.model.element.Element, method: javac.code.Symbol$MethodSymbol): void;
              _checkCtorAccess(tree: javac.tree.JCTree$JCClassDecl, c: javac.code.Symbol$ClassSymbol): void;
              _checkDefaultIneffective(tree: javac.tree.JCTree$JCClassDecl, e: javax.lang.model.element.Element, method: javac.code.Symbol$MethodSymbol): void;
              _checkExceptions(tree: javac.tree.JCTree$JCClassDecl, enclosing: javax.lang.model.element.Element, method: javac.code.Symbol$MethodSymbol, declaredExceptions: javac.code.Type[]): void;
              _checkExceptions(tree: javac.tree.JCTree$JCClassDecl, enclosing: javax.lang.model.element.Element, method: javac.code.Symbol$MethodSymbol, ...declaredExceptions: javac.code.Type[]): void;
              _checkExternalizable(tree: javac.tree.JCTree$JCClassDecl, enclosing: javax.lang.model.element.Element, method: javac.code.Symbol$MethodSymbol): void;
              _checkNoArgs(tree: javac.tree.JCTree$JCClassDecl, enclosing: javax.lang.model.element.Element, method: javac.code.Symbol$MethodSymbol): void;
              _checkOneArg(tree: javac.tree.JCTree$JCClassDecl, enclosing: javax.lang.model.element.Element, method: javac.code.Symbol$MethodSymbol, expectedType: javac.code.Type): void;
              _checkPrivateMethod(tree: javac.tree.JCTree$JCClassDecl, e: javax.lang.model.element.Element, method: javac.code.Symbol$MethodSymbol): void;
              _checkPrivateNonStaticMethod(tree: javac.tree.JCTree$JCClassDecl, method: javac.code.Symbol$MethodSymbol): void;
              _checkReadObject(tree: javac.tree.JCTree$JCClassDecl, e: javax.lang.model.element.Element, method: javac.code.Symbol$MethodSymbol): void;
              _checkReadObjectNoData(tree: javac.tree.JCTree$JCClassDecl, e: javax.lang.model.element.Element, method: javac.code.Symbol$MethodSymbol): void;
              _checkReadResolve(tree: javac.tree.JCTree$JCClassDecl, e: javax.lang.model.element.Element, method: javac.code.Symbol$MethodSymbol): void;
              _checkReturnType(tree: javac.tree.JCTree$JCClassDecl, enclosing: javax.lang.model.element.Element, method: javac.code.Symbol$MethodSymbol, expectedReturnType: javac.code.Type): void;
              _checkSerialPersistentFields(tree: javac.tree.JCTree$JCClassDecl, e: javax.lang.model.element.Element, spf: javac.code.Symbol$VarSymbol): void;
              _checkSerialVersionUID(tree: javac.tree.JCTree$JCClassDecl, e: javax.lang.model.element.Element, svuid: javac.code.Symbol$VarSymbol): void;
              _checkWriteObject(tree: javac.tree.JCTree$JCClassDecl, e: javax.lang.model.element.Element, method: javac.code.Symbol$MethodSymbol): void;
              _checkWriteReplace(tree: javac.tree.JCTree$JCClassDecl, e: javax.lang.model.element.Element, method: javac.code.Symbol$MethodSymbol): void;
              defaultAction(e: javax.lang.model.element.Element, p: javac.tree.JCTree$JCClassDecl): java.lang.Void;
              defaultAction(a0: javax.lang.model.element.Element, a1: any): any;
              _runUnderLint<E>(symbol: E, p: javac.tree.JCTree$JCClassDecl, task: java.util.function.BiConsumer<E,javac.tree.JCTree$JCClassDecl>): java.lang.Void;
              visitType(e: javax.lang.model.element.TypeElement, p: javac.tree.JCTree$JCClassDecl): java.lang.Void;
              visitType(a0: javax.lang.model.element.TypeElement, a1: any): any;
              visitTypeAsAnnotationType(e: javax.lang.model.element.TypeElement, p: javac.tree.JCTree$JCClassDecl): java.lang.Void;
              visitTypeAsAnnotationType(a0: javax.lang.model.element.TypeElement, a1: any): any;
              visitTypeAsClass(e: javax.lang.model.element.TypeElement, p: javac.tree.JCTree$JCClassDecl): java.lang.Void;
              visitTypeAsClass(a0: javax.lang.model.element.TypeElement, a1: any): any;
              visitTypeAsEnum(e: javax.lang.model.element.TypeElement, p: javac.tree.JCTree$JCClassDecl): java.lang.Void;
              visitTypeAsEnum(a0: javax.lang.model.element.TypeElement, a1: any): any;
              visitTypeAsInterface(e: javax.lang.model.element.TypeElement, p: javac.tree.JCTree$JCClassDecl): java.lang.Void;
              visitTypeAsInterface(a0: javax.lang.model.element.TypeElement, a1: any): any;
              visitTypeAsRecord(e: javax.lang.model.element.TypeElement, p: javac.tree.JCTree$JCClassDecl): java.lang.Void;
              visitTypeAsRecord(a0: javax.lang.model.element.TypeElement, a1: any): any;
              _OSF_TYPE: javac.code.Type;
              _lint: javac.code.Lint;
              _this$0: Check;
            }
            interface Check$SerialTypeVisitor extends CombineTypes<[_Check$SerialTypeVisitor, javax.lang.model.util.ElementKindVisitor14<java.lang.Void,javac.tree.JCTree$JCClassDecl>]> {}
            interface _Check$Validator$$static extends ClassLike {
              _new(this$0: Env<AttrContext>): Check$Validator;
            }
            let Check$Validator: _Check$Validator$$static;
            interface _Check$Validator {
              validateTree(tree: javac.tree.JCTree, checkRaw: boolean, isOuter: boolean): void;
              validateTrees(trees: javac.util.List<javac.tree.JCTree>, checkRaw: boolean, isOuter: boolean): void;
              visitAnnotatedType(tree: javac.tree.JCTree$JCAnnotatedType): void;
              visitSelect(tree: javac.tree.JCTree$JCFieldAccess): void;
              visitSelectInternal(tree: javac.tree.JCTree$JCFieldAccess): void;
              visitTree(tree: javac.tree.JCTree): void;
              visitTypeApply(tree: javac.tree.JCTree$JCTypeApply): void;
              visitTypeArray(tree: javac.tree.JCTree$JCArrayTypeTree): void;
              visitTypeIdent(that: javac.tree.JCTree$JCPrimitiveTypeTree): void;
              visitTypeParameter(tree: javac.tree.JCTree$JCTypeParameter): void;
              visitWildcard(tree: javac.tree.JCTree$JCWildcard): void;
              _checkRaw: boolean;
              _env: Env<AttrContext>;
              _isOuter: boolean;
              _this$0: Check;
            }
            interface Check$Validator extends CombineTypes<[_Check$Validator, com.sun.tools.javac.tree.JCTree$Visitor]> {}
            interface _CompileStates$$static extends ClassLike {
              instance(context: javac.util.Context): CompileStates;
              _compileStatesKey: javac.util.Context$Key<CompileStates>;
              _serialVersionUID: long;
              new(context: javac.util.Context): CompileStates;
            }
            let CompileStates: _CompileStates$$static;
            interface _CompileStates {
              isDone(env: Env<AttrContext>, cs: CompileStates$CompileState): boolean;
              _context: javac.util.Context;
            }
            interface CompileStates extends CombineTypes<[_CompileStates, java.util.HashMap<Env<AttrContext>,CompileStates$CompileState>]> {}
            interface _CompileStates$CompileState$$static extends ClassLike {
              max(a: CompileStates$CompileState, b: CompileStates$CompileState): CompileStates$CompileState;
              valueOf(name: string): CompileStates$CompileState;
              values(): CompileStates$CompileState[];
              readonly ATTR: CompileStates$CompileState;
              readonly ENTER: CompileStates$CompileState;
              readonly FLOW: CompileStates$CompileState;
              readonly GENERATE: CompileStates$CompileState;
              readonly INIT: CompileStates$CompileState;
              readonly LOWER: CompileStates$CompileState;
              readonly PARSE: CompileStates$CompileState;
              readonly PROCESS: CompileStates$CompileState;
              readonly TRANSLITERALS: CompileStates$CompileState;
              readonly TRANSPATTERNS: CompileStates$CompileState;
              readonly TRANSTYPES: CompileStates$CompileState;
              readonly UNLAMBDA: CompileStates$CompileState;
            }
            let CompileStates$CompileState: _CompileStates$CompileState$$static;
            interface _CompileStates$CompileState {
              isAfter(other: CompileStates$CompileState): boolean;
              _value: int;
            }
            interface CompileStates$CompileState extends CombineTypes<[_CompileStates$CompileState]> {}
            interface _ConstFold$$static extends ClassLike {
              _b2i(b: boolean): int;
              _doubleValue(x: any): double;
              _floatValue(x: any): float;
              instance(context: javac.util.Context): ConstFold;
              _intValue(x: any): int;
              _longValue(x: any): long;
              _constFoldKey: javac.util.Context$Key<ConstFold>;
              _minusOne: int;
              _one: int;
              _zero: int;
            }
            let ConstFold: _ConstFold$$static;
            interface _ConstFold {
              _coerce(etype: javac.code.Type, ttype: javac.code.Type): javac.code.Type;
              _fold1(opcode: int, operand: javac.code.Type): javac.code.Type;
              _fold2(opcode: int, left: javac.code.Type, right: javac.code.Type): javac.code.Type;
              _syms: javac.code.Symtab;
            }
            interface ConstFold extends CombineTypes<[_ConstFold, java.lang.Object]> {}
            interface _DeferredAttr$$static extends ClassLike {
              instance(context: javac.util.Context): DeferredAttr;
              _deferredAttrKey: javac.util.Context$Key<DeferredAttr>;
              _new(context: javac.util.Context): DeferredAttr;
            }
            let DeferredAttr: _DeferredAttr$$static;
            interface _DeferredAttr {
              _attribSpeculative(tree: javac.tree.JCTree, env: Env<AttrContext>, resultInfo: Attr$ResultInfo): javac.tree.JCTree;
              _attribSpeculative(tree: javac.tree.JCTree, env: Env<AttrContext>, resultInfo: Attr$ResultInfo, localCache: ArgumentAttr$LocalCacheContext): javac.tree.JCTree;
              _attribSpeculative<Z>(tree: javac.tree.JCTree, env: Env<AttrContext>, resultInfo: Attr$ResultInfo, deferredCopier: javac.tree.TreeCopier<Z>, diagHandlerCreator: java.util.function.Supplier<javac.util.Log$DiagnosticHandler>, attributionMode: DeferredAttr$AttributionMode, localCache: ArgumentAttr$LocalCacheContext): javac.tree.JCTree;
              _attribSpeculative<Z>(tree: javac.tree.JCTree, env: Env<AttrContext>, resultInfo: Attr$ResultInfo, diagHandlerCreator: java.util.function.Supplier<javac.util.Log$DiagnosticHandler>, attributionMode: DeferredAttr$AttributionMode, localCache: ArgumentAttr$LocalCacheContext): javac.tree.JCTree;
              _attribSpeculativeLambda(that: javac.tree.JCTree$JCLambda, env: Env<AttrContext>, resultInfo: Attr$ResultInfo): javac.tree.JCTree$JCLambda;
              _hasTypeDeclaration(tree: javac.tree.JCTree): boolean;
              _annotate: Annotate;
              _argumentAttr: ArgumentAttr;
              _attr: Attr;
              _chk: Check;
              _dcfh: javac.code.DeferredCompletionFailureHandler;
              _deferredCopier: javac.code.Types$TypeMapping<java.lang.Void>;
              _diags: javac.util.JCDiagnostic$Factory;
              _dummyStuckPolicy: DeferredAttr$DeferredStuckPolicy;
              _emptyDeferredAttrContext: DeferredAttr$DeferredAttrContext;
              _enter: Enter;
              _flow: Flow;
              _infer: Infer;
              _log: javac.util.Log;
              _make: javac.tree.TreeMaker;
              _names: javac.util.Names;
              _rs: Resolve;
              _stuckTree: javac.tree.JCTree;
              _syms: javac.code.Symtab;
              _treeCopier: javac.tree.TreeCopier<java.lang.Void>;
              _typeEnvs: TypeEnvs;
              _types: javac.code.Types;
            }
            interface DeferredAttr extends CombineTypes<[_DeferredAttr, com.sun.tools.javac.tree.JCTree$Visitor]> {}
            interface _DeferredAttr$AttrMode$$static extends ClassLike {
              valueOf(name: string): DeferredAttr$AttrMode;
              values(): DeferredAttr$AttrMode[];
              readonly CHECK: DeferredAttr$AttrMode;
              readonly SPECULATIVE: DeferredAttr$AttrMode;
            }
            let DeferredAttr$AttrMode: _DeferredAttr$AttrMode$$static;
            interface _DeferredAttr$AttrMode {
            }
            interface DeferredAttr$AttrMode extends CombineTypes<[_DeferredAttr$AttrMode]> {}
            interface _DeferredAttr$AttributionMode$$static extends ClassLike {
              valueOf(name: string): DeferredAttr$AttributionMode;
              values(): DeferredAttr$AttributionMode[];
              readonly ANALYZER: DeferredAttr$AttributionMode;
              readonly ATTRIB_TO_TREE: DeferredAttr$AttributionMode;
              readonly FULL: DeferredAttr$AttributionMode;
              readonly SPECULATIVE: DeferredAttr$AttributionMode;
            }
            let DeferredAttr$AttributionMode: _DeferredAttr$AttributionMode$$static;
            interface _DeferredAttr$AttributionMode {
              _isSpeculative(): boolean;
              _recover(): boolean;
              _isSpeculative: boolean;
              _recover: boolean;
            }
            interface DeferredAttr$AttributionMode extends CombineTypes<[_DeferredAttr$AttributionMode]> {}
            interface _DeferredAttr$CheckStuckPolicy$$static extends ClassLike {
              new(this$0: DeferredAttr, resultInfo: Attr$ResultInfo, dt: DeferredAttr$DeferredType): DeferredAttr$CheckStuckPolicy;
            }
            let DeferredAttr$CheckStuckPolicy: _DeferredAttr$CheckStuckPolicy$$static;
            interface _DeferredAttr$CheckStuckPolicy {
              depVars(): java.util.Set<javac.code.Type>;
              isStuck(): boolean;
              _scanLambdaBody(lambda: javac.tree.JCTree$JCLambda, pt: javac.code.Type): void;
              stuckVars(): java.util.Set<javac.code.Type>;
              typesInferred(inferenceContext: InferenceContext): void;
              visitLambda(tree: javac.tree.JCTree$JCLambda): void;
              visitReference(tree: javac.tree.JCTree$JCMemberReference): void;
              visitSwitchExpression(expr: javac.tree.JCTree$JCSwitchExpression): void;
              _depVars: java.util.Set<javac.code.Type>;
              _inferenceContext: InferenceContext;
              _pt: javac.code.Type;
              _stuckVars: java.util.Set<javac.code.Type>;
              _this$0: DeferredAttr;
            }
            interface DeferredAttr$CheckStuckPolicy extends CombineTypes<[_DeferredAttr$CheckStuckPolicy, com.sun.tools.javac.comp.DeferredAttr$PolyScanner, com.sun.tools.javac.comp.Infer$FreeTypeListener, com.sun.tools.javac.comp.DeferredAttr$DeferredStuckPolicy]> {}
            interface _DeferredAttr$DeferredAttrContext$$static extends ClassLike {
              _new(this$0: DeferredAttr, mode: DeferredAttr$AttrMode, msym: javac.code.Symbol, phase: Resolve$MethodResolutionPhase, inferenceContext: InferenceContext, parent: DeferredAttr$DeferredAttrContext, warn: javac.util.Warner): DeferredAttr$DeferredAttrContext;
            }
            let DeferredAttr$DeferredAttrContext: _DeferredAttr$DeferredAttrContext$$static;
            interface _DeferredAttr$DeferredAttrContext {
              _addDeferredAttrNode(dt: DeferredAttr$DeferredType, resultInfo: Attr$ResultInfo, deferredStuckPolicy: DeferredAttr$DeferredStuckPolicy): void;
              _buildStuckGraph(): javac.util.List<DeferredAttr$DeferredAttrContext$StuckNode>;
              _canInfluence(graph: Infer$GraphSolver$InferenceGraph, sn1: DeferredAttr$DeferredAttrContext$StuckNode, sn2: DeferredAttr$DeferredAttrContext$StuckNode): boolean;
              _complete(): void;
              insideOverloadPhase(): boolean;
              _pickDeferredNode(): DeferredAttr$DeferredAttrNode;
              _deferredAttrNodes: java.util.ArrayList<DeferredAttr$DeferredAttrNode>;
              _inferenceContext: InferenceContext;
              _mode: DeferredAttr$AttrMode;
              _msym: javac.code.Symbol;
              _parent: DeferredAttr$DeferredAttrContext;
              _phase: Resolve$MethodResolutionPhase;
              _this$0: DeferredAttr;
              _warn: javac.util.Warner;
            }
            interface DeferredAttr$DeferredAttrContext extends CombineTypes<[_DeferredAttr$DeferredAttrContext, java.lang.Object]> {}
            interface _DeferredAttr$DeferredAttrContext$StuckNode$$static extends ClassLike {
              _new(this$1: DeferredAttr$DeferredAttrContext, data: DeferredAttr$DeferredAttrNode): DeferredAttr$DeferredAttrContext$StuckNode;
            }
            let DeferredAttr$DeferredAttrContext$StuckNode: _DeferredAttr$DeferredAttrContext$StuckNode$$static;
            interface _DeferredAttr$DeferredAttrContext$StuckNode {
              getAllDependencies(): java.lang.Iterable<DeferredAttr$DeferredAttrContext$StuckNode>;
              getDependenciesByKind(dk: javac.util.GraphUtils$DependencyKind): java.util.Collection<DeferredAttr$DeferredAttrContext$StuckNode>;
              getSupportedDependencyKinds(): javac.util.GraphUtils$DependencyKind[];
              _deps: java.util.Set<DeferredAttr$DeferredAttrContext$StuckNode>;
            }
            interface DeferredAttr$DeferredAttrContext$StuckNode extends CombineTypes<[_DeferredAttr$DeferredAttrContext$StuckNode, javac.util.GraphUtils$TarjanNode<DeferredAttr$DeferredAttrNode,DeferredAttr$DeferredAttrContext$StuckNode>]> {}
            interface _DeferredAttr$DeferredAttrDiagHandler$$static extends ClassLike {
              _new(log: javac.util.Log, newTree: javac.tree.JCTree): DeferredAttr$DeferredAttrDiagHandler;
            }
            let DeferredAttr$DeferredAttrDiagHandler: _DeferredAttr$DeferredAttrDiagHandler$$static;
            interface _DeferredAttr$DeferredAttrDiagHandler {
            }
            interface DeferredAttr$DeferredAttrDiagHandler extends CombineTypes<[_DeferredAttr$DeferredAttrDiagHandler, com.sun.tools.javac.util.Log$DeferredDiagnosticHandler]> {}
            interface _DeferredAttr$DeferredAttrDiagHandler$PosScanner$$static extends ClassLike {
              _new(pos: javac.util.JCDiagnostic$DiagnosticPosition): DeferredAttr$DeferredAttrDiagHandler$PosScanner;
            }
            let DeferredAttr$DeferredAttrDiagHandler$PosScanner: _DeferredAttr$DeferredAttrDiagHandler$PosScanner$$static;
            interface _DeferredAttr$DeferredAttrDiagHandler$PosScanner {
              scan(tree: javac.tree.JCTree): void;
              _found: boolean;
              _pos: javac.util.JCDiagnostic$DiagnosticPosition;
            }
            interface DeferredAttr$DeferredAttrDiagHandler$PosScanner extends CombineTypes<[_DeferredAttr$DeferredAttrDiagHandler$PosScanner, com.sun.tools.javac.tree.TreeScanner]> {}
            interface _DeferredAttr$DeferredAttrNode$$static extends ClassLike {
              _new(this$0: DeferredAttr, dt: DeferredAttr$DeferredType, resultInfo: Attr$ResultInfo, deferredStuckPolicy: DeferredAttr$DeferredStuckPolicy): DeferredAttr$DeferredAttrNode;
            }
            let DeferredAttr$DeferredAttrNode: _DeferredAttr$DeferredAttrNode$$static;
            interface _DeferredAttr$DeferredAttrNode {
              _process(deferredAttrContext: DeferredAttr$DeferredAttrContext): boolean;
              _deferredStuckPolicy: DeferredAttr$DeferredStuckPolicy;
              _dt: DeferredAttr$DeferredType;
              _resultInfo: Attr$ResultInfo;
              _this$0: DeferredAttr;
            }
            interface DeferredAttr$DeferredAttrNode extends CombineTypes<[_DeferredAttr$DeferredAttrNode, java.lang.Object]> {}
            interface _DeferredAttr$DeferredAttrNode$LambdaBodyStructChecker$$static extends ClassLike {
              _new(this$1: DeferredAttr$DeferredAttrNode): DeferredAttr$DeferredAttrNode$LambdaBodyStructChecker;
            }
            let DeferredAttr$DeferredAttrNode$LambdaBodyStructChecker: _DeferredAttr$DeferredAttrNode$LambdaBodyStructChecker$$static;
            interface _DeferredAttr$DeferredAttrNode$LambdaBodyStructChecker {
              visitClassDef(tree: javac.tree.JCTree$JCClassDecl): void;
              visitLambda(tree: javac.tree.JCTree$JCLambda): void;
              visitNewClass(tree: javac.tree.JCTree$JCNewClass): void;
              visitReturn(tree: javac.tree.JCTree$JCReturn): void;
              _isPotentiallyValueCompatible: boolean;
              _isVoidCompatible: boolean;
            }
            interface DeferredAttr$DeferredAttrNode$LambdaBodyStructChecker extends CombineTypes<[_DeferredAttr$DeferredAttrNode$LambdaBodyStructChecker, com.sun.tools.javac.tree.TreeScanner]> {}
            interface _DeferredAttr$DeferredAttrNode$StructuralStuckChecker$$static extends ClassLike {
              _new(this$1: DeferredAttr$DeferredAttrNode): DeferredAttr$DeferredAttrNode$StructuralStuckChecker;
            }
            let DeferredAttr$DeferredAttrNode$StructuralStuckChecker: _DeferredAttr$DeferredAttrNode$StructuralStuckChecker$$static;
            interface _DeferredAttr$DeferredAttrNode$StructuralStuckChecker {
              _canLambdaBodyCompleteNormally(tree: javac.tree.JCTree$JCLambda): boolean;
              check(dt: DeferredAttr$DeferredType, resultInfo: Attr$ResultInfo, deferredAttrContext: DeferredAttr$DeferredAttrContext): void;
              visitApply(tree: javac.tree.JCTree$JCMethodInvocation): void;
              visitConditional(tree: javac.tree.JCTree$JCConditional): void;
              visitLambda(tree: javac.tree.JCTree$JCLambda): void;
              visitNewClass(tree: javac.tree.JCTree$JCNewClass): void;
              visitReference(tree: javac.tree.JCTree$JCMemberReference): void;
              visitSwitchExpression(tree: javac.tree.JCTree$JCSwitchExpression): void;
              _env: Env<AttrContext>;
              _inferenceContext: InferenceContext;
              _resultInfo: Attr$ResultInfo;
              _this$1: DeferredAttr$DeferredAttrNode;
            }
            interface DeferredAttr$DeferredAttrNode$StructuralStuckChecker extends CombineTypes<[_DeferredAttr$DeferredAttrNode$StructuralStuckChecker, com.sun.tools.javac.tree.TreeScanner]> {}
            interface _DeferredAttr$DeferredStuckPolicy$$static extends ClassLike {
            }
            let DeferredAttr$DeferredStuckPolicy: _DeferredAttr$DeferredStuckPolicy$$static;
            interface _DeferredAttr$DeferredStuckPolicy {
              depVars(): java.util.Set<javac.code.Type>;
              isStuck(): boolean;
              stuckVars(): java.util.Set<javac.code.Type>;
            }
            interface DeferredAttr$DeferredStuckPolicy extends CombineTypes<[_DeferredAttr$DeferredStuckPolicy, java.lang.Object]> {}
            interface _DeferredAttr$DeferredType$$static extends ClassLike {
              _new(this$0: javac.tree.JCTree$JCExpression, tree: Env<AttrContext>): DeferredAttr$DeferredType;
            }
            let DeferredAttr$DeferredType: _DeferredAttr$DeferredType$$static;
            interface _DeferredAttr$DeferredType {
              _check(resultInfo: Attr$ResultInfo): javac.code.Type;
              _check(resultInfo: Attr$ResultInfo, deferredStuckPolicy: DeferredAttr$DeferredStuckPolicy): javac.code.Type;
              complete(resultInfo: Attr$ResultInfo, deferredAttrContext: DeferredAttr$DeferredAttrContext): javac.code.Type;
              getTag(): javac.code.TypeTag;
              _speculativeTree(deferredAttrContext: DeferredAttr$DeferredAttrContext): javac.tree.JCTree;
              _speculativeType(msym: javac.code.Symbol, phase: Resolve$MethodResolutionPhase): javac.code.Type;
              toString(): string;
              _env: Env<AttrContext>;
              _mode: DeferredAttr$AttrMode;
              _notPertinentToApplicability: java.util.Set<javac.code.Symbol>;
              _speculativeCache: DeferredAttr$DeferredType$SpeculativeCache;
              _this$0: DeferredAttr;
              tree: javac.tree.JCTree$JCExpression;
            }
            interface DeferredAttr$DeferredType extends CombineTypes<[_DeferredAttr$DeferredType, com.sun.tools.javac.code.Type]> {}
            interface _DeferredAttr$DeferredType$SpeculativeCache$$static extends ClassLike {
              _new(this$1: DeferredAttr$DeferredType): DeferredAttr$DeferredType$SpeculativeCache;
            }
            let DeferredAttr$DeferredType$SpeculativeCache: _DeferredAttr$DeferredType$SpeculativeCache$$static;
            interface _DeferredAttr$DeferredType$SpeculativeCache {
              _get(msym: javac.code.Symbol, phase: Resolve$MethodResolutionPhase): DeferredAttr$DeferredType$SpeculativeCache$Entry;
              _put(speculativeTree: javac.tree.JCTree, resultInfo: Attr$ResultInfo): void;
              _cache: java.util.Map<javac.code.Symbol,javac.util.List<DeferredAttr$DeferredType$SpeculativeCache$Entry>>;
            }
            interface DeferredAttr$DeferredType$SpeculativeCache extends CombineTypes<[_DeferredAttr$DeferredType$SpeculativeCache, java.lang.Object]> {}
            interface _DeferredAttr$DeferredType$SpeculativeCache$Entry$$static extends ClassLike {
              new(this$2: DeferredAttr$DeferredType$SpeculativeCache, speculativeTree: javac.tree.JCTree, resultInfo: Attr$ResultInfo): DeferredAttr$DeferredType$SpeculativeCache$Entry;
            }
            let DeferredAttr$DeferredType$SpeculativeCache$Entry: _DeferredAttr$DeferredType$SpeculativeCache$Entry$$static;
            interface _DeferredAttr$DeferredType$SpeculativeCache$Entry {
              _matches(phase: Resolve$MethodResolutionPhase): boolean;
              _resultInfo: Attr$ResultInfo;
              _speculativeTree: javac.tree.JCTree;
            }
            interface DeferredAttr$DeferredType$SpeculativeCache$Entry extends CombineTypes<[_DeferredAttr$DeferredType$SpeculativeCache$Entry, java.lang.Object]> {}
            interface _DeferredAttr$DeferredTypeMap$$static<T> extends ClassLike {
              _new(this$0: DeferredAttr, mode: DeferredAttr$AttrMode, msym: javac.code.Symbol, phase: Resolve$MethodResolutionPhase): DeferredAttr$DeferredTypeMap<T>;
            }
            let DeferredAttr$DeferredTypeMap: _DeferredAttr$DeferredTypeMap$$static<T>;
            interface _DeferredAttr$DeferredTypeMap<T> {
              _typeOf(dt: DeferredAttr$DeferredType, p: T): javac.code.Type;
              visitType(t: javac.code.Type, p: T): javac.code.Type;
              visitType(a0: javac.code.Type, a1: any): any;
              _deferredAttrContext: DeferredAttr$DeferredAttrContext;
            }
            interface DeferredAttr$DeferredTypeMap<T> extends CombineTypes<[_DeferredAttr$DeferredTypeMap<T>, javac.code.Type$StructuralTypeMapping<T>]> {}
            interface _DeferredAttr$FilterScanner$$static extends ClassLike {
              _new(validTags: java.util.Set<javac.tree.JCTree$Tag>): DeferredAttr$FilterScanner;
            }
            let DeferredAttr$FilterScanner: _DeferredAttr$FilterScanner$$static;
            interface _DeferredAttr$FilterScanner {
              scan(tree: javac.tree.JCTree): void;
              _skip(tree: javac.tree.JCTree): void;
              _treeFilter: java.util.function.Predicate<javac.tree.JCTree>;
            }
            interface DeferredAttr$FilterScanner extends CombineTypes<[_DeferredAttr$FilterScanner, com.sun.tools.javac.tree.TreeScanner]> {}
            interface _DeferredAttr$LambdaReturnScanner$$static extends ClassLike {
              _new(): DeferredAttr$LambdaReturnScanner;
            }
            let DeferredAttr$LambdaReturnScanner: _DeferredAttr$LambdaReturnScanner$$static;
            interface _DeferredAttr$LambdaReturnScanner {
            }
            interface DeferredAttr$LambdaReturnScanner extends CombineTypes<[_DeferredAttr$LambdaReturnScanner, com.sun.tools.javac.comp.DeferredAttr$FilterScanner]> {}
            interface _DeferredAttr$OverloadStuckPolicy$$static extends ClassLike {
              new(this$0: DeferredAttr, resultInfo: Attr$ResultInfo, dt: DeferredAttr$DeferredType): DeferredAttr$OverloadStuckPolicy;
            }
            let DeferredAttr$OverloadStuckPolicy: _DeferredAttr$OverloadStuckPolicy$$static;
            interface _DeferredAttr$OverloadStuckPolicy {
              isStuck(): boolean;
              visitLambda(tree: javac.tree.JCTree$JCLambda): void;
              visitReference(tree: javac.tree.JCTree$JCMemberReference): void;
              _stuck: boolean;
            }
            interface DeferredAttr$OverloadStuckPolicy extends CombineTypes<[_DeferredAttr$OverloadStuckPolicy, com.sun.tools.javac.comp.DeferredAttr$CheckStuckPolicy, com.sun.tools.javac.comp.DeferredAttr$DeferredStuckPolicy]> {}
            interface _DeferredAttr$PolyScanner$$static extends ClassLike {
              _new(): DeferredAttr$PolyScanner;
            }
            let DeferredAttr$PolyScanner: _DeferredAttr$PolyScanner$$static;
            interface _DeferredAttr$PolyScanner {
            }
            interface DeferredAttr$PolyScanner extends CombineTypes<[_DeferredAttr$PolyScanner, com.sun.tools.javac.comp.DeferredAttr$FilterScanner]> {}
            interface _DeferredAttr$RecoveryDeferredTypeMap$$static extends ClassLike {
              new(this$0: DeferredAttr, mode: DeferredAttr$AttrMode, msym: javac.code.Symbol, phase: Resolve$MethodResolutionPhase): DeferredAttr$RecoveryDeferredTypeMap;
            }
            let DeferredAttr$RecoveryDeferredTypeMap: _DeferredAttr$RecoveryDeferredTypeMap$$static;
            interface _DeferredAttr$RecoveryDeferredTypeMap {
              _map(ts: javac.util.List<javac.code.Type>, pts: javac.util.List<javac.code.Type>): javac.util.List<javac.code.Type>;
              _recover(dt: DeferredAttr$DeferredType, pt: javac.code.Type): javac.code.Type;
              _typeOf(dt: DeferredAttr$DeferredType, pt: javac.code.Type): javac.code.Type;
              _typeOf(a0: DeferredAttr$DeferredType, a1: any): javac.code.Type;
              visitMethodType(t: javac.code.Type$MethodType, pt: javac.code.Type): javac.code.Type;
              visitMethodType(a0: javac.code.Type$MethodType, a1: any): javac.code.Type;
              visitMethodType(a0: javac.code.Type$MethodType, a1: any): any;
              visitType(a0: javac.code.Type, a1: any): javac.code.Type;
              _this$0: DeferredAttr;
            }
            interface DeferredAttr$RecoveryDeferredTypeMap extends CombineTypes<[_DeferredAttr$RecoveryDeferredTypeMap, DeferredAttr$DeferredTypeMap<javac.code.Type>]> {}
            interface _DeferredAttr$SwitchExpressionScanner$$static extends ClassLike {
              _new(): DeferredAttr$SwitchExpressionScanner;
            }
            let DeferredAttr$SwitchExpressionScanner: _DeferredAttr$SwitchExpressionScanner$$static;
            interface _DeferredAttr$SwitchExpressionScanner {
            }
            interface DeferredAttr$SwitchExpressionScanner extends CombineTypes<[_DeferredAttr$SwitchExpressionScanner, com.sun.tools.javac.comp.DeferredAttr$FilterScanner]> {}
            interface _DeferredAttr$TypeDeclVisitor$$static extends ClassLike {
            }
            let DeferredAttr$TypeDeclVisitor: _DeferredAttr$TypeDeclVisitor$$static;
            interface _DeferredAttr$TypeDeclVisitor {
              visitClassDef(that: javac.tree.JCTree$JCClassDecl): void;
              _result: boolean;
            }
            interface DeferredAttr$TypeDeclVisitor extends CombineTypes<[_DeferredAttr$TypeDeclVisitor, com.sun.tools.javac.tree.TreeScanner]> {}
            interface _Enter$$static extends ClassLike {
              _classNameMatchesFileName(c: javac.code.Symbol$ClassSymbol, env: Env<AttrContext>): boolean;
              instance(context: javac.util.Context): Enter;
              _enterKey: javac.util.Context$Key<Enter>;
              _new(context: javac.util.Context): Enter;
            }
            let Enter: _Enter$$static;
            interface _Enter {
              _classEnter(tree: javac.tree.JCTree, env: Env<AttrContext>): javac.code.Type;
              _classEnter<T>(trees: javac.util.List<T>, env: Env<AttrContext>): javac.util.List<javac.code.Type>;
              classEnv(tree: javac.tree.JCTree$JCClassDecl, env: Env<AttrContext>): Env<AttrContext>;
              complete(trees: javac.util.List<javac.tree.JCTree$JCCompilationUnit>, c: javac.code.Symbol$ClassSymbol): void;
              _duplicateClass(pos: javac.util.JCDiagnostic$DiagnosticPosition, c: javac.code.Symbol$ClassSymbol): void;
              _enterScope(env: Env<AttrContext>): javac.code.Scope$WriteableScope;
              getClassEnv(sym: javac.code.Symbol$TypeSymbol): Env<AttrContext>;
              getEnv(sym: javac.code.Symbol$TypeSymbol): Env<AttrContext>;
              getEnvs(): java.lang.Iterable<Env<AttrContext>>;
              getTopLevelEnv(tree: javac.tree.JCTree$JCCompilationUnit): Env<AttrContext>;
              main(trees: javac.util.List<javac.tree.JCTree$JCCompilationUnit>): void;
              moduleEnv(tree: javac.tree.JCTree$JCModuleDecl, env: Env<AttrContext>): Env<AttrContext>;
              newRound(): void;
              _topLevelEnv(tree: javac.tree.JCTree$JCCompilationUnit): Env<AttrContext>;
              unenter(topLevel: javac.tree.JCTree$JCCompilationUnit, tree: javac.tree.JCTree): void;
              visitClassDef(tree: javac.tree.JCTree$JCClassDecl): void;
              visitModuleDef(tree: javac.tree.JCTree$JCModuleDecl): void;
              visitTopLevel(tree: javac.tree.JCTree$JCCompilationUnit): void;
              visitTree(tree: javac.tree.JCTree): void;
              visitTypeParameter(tree: javac.tree.JCTree$JCTypeParameter): void;
              _annotate: Annotate;
              _chk: Check;
              _diags: javac.util.JCDiagnostic$Factory;
              _env: Env<AttrContext>;
              _fileManager: javax.tools.JavaFileManager;
              _lint: javac.code.Lint;
              _log: javac.util.Log;
              _make: javac.tree.TreeMaker;
              _modules: Modules;
              _names: javac.util.Names;
              _pkginfoOpt: javac.main.Option$PkgInfo;
              _predefClassDef: javac.tree.JCTree$JCClassDecl;
              _result: javac.code.Type;
              _setPackageSymbols: javac.tree.TreeScanner;
              _syms: javac.code.Symtab;
              _todo: Todo;
              _typeEnter: TypeEnter;
              _typeEnvs: TypeEnvs;
              _types: javac.code.Types;
              _uncompleted: javac.util.ListBuffer<javac.code.Symbol$ClassSymbol>;
              _unfinishedModules: javac.util.ListBuffer<javac.tree.JCTree$JCCompilationUnit>;
            }
            interface Enter extends CombineTypes<[_Enter, com.sun.tools.javac.tree.JCTree$Visitor]> {}
            interface _Enter$UnenterScanner$$static extends ClassLike {
              new(this$0: Enter, msym: javac.code.Symbol$ModuleSymbol): Enter$UnenterScanner;
            }
            let Enter$UnenterScanner: _Enter$UnenterScanner$$static;
            interface _Enter$UnenterScanner {
              visitClassDef(tree: javac.tree.JCTree$JCClassDecl): void;
              _msym: javac.code.Symbol$ModuleSymbol;
              _this$0: Enter;
            }
            interface Enter$UnenterScanner extends CombineTypes<[_Enter$UnenterScanner, com.sun.tools.javac.tree.TreeScanner]> {}
            interface _Env$$static<A> extends ClassLike {
              new(tree: javac.tree.JCTree, info: A): Env<A>;
            }
            let Env: _Env$$static<A>;
            interface _Env<A> {
              dup(tree: javac.tree.JCTree, info: A): Env<A>;
              dup(tree: javac.tree.JCTree): Env<A>;
              dupto(that: Env<A>): Env<A>;
              enclosing(tag: javac.tree.JCTree$Tag): Env<A>;
              iterator(): java.util.Iterator<Env<A>>;
              toString(): string;
              baseClause: boolean;
              enclClass: javac.tree.JCTree$JCClassDecl;
              enclMethod: javac.tree.JCTree$JCMethodDecl;
              info: A;
              next: Env<A>;
              outer: Env<A>;
              toplevel: javac.tree.JCTree$JCCompilationUnit;
              tree: javac.tree.JCTree;
            }
            interface Env<A> extends CombineTypes<[_Env<A>, java.lang.Iterable<Env<A>>, java.lang.Object]> {}
            interface _Flow$$static extends ClassLike {
              instance(context: javac.util.Context): Flow;
              _flowKey: javac.util.Context$Key<Flow>;
              _new(context: javac.util.Context): Flow;
            }
            let Flow: _Flow$$static;
            interface _Flow {
              aliveAfter(env: Env<AttrContext>, that: javac.tree.JCTree, make: javac.tree.TreeMaker): boolean;
              analyzeLambda(env: Env<AttrContext>, that: javac.tree.JCTree$JCLambda, make: javac.tree.TreeMaker, speculative: boolean): void;
              analyzeLambdaThrownTypes(env: Env<AttrContext>, that: javac.tree.JCTree$JCLambda, make: javac.tree.TreeMaker): javac.util.List<javac.code.Type>;
              analyzeTree(env: Env<AttrContext>, make: javac.tree.TreeMaker): void;
              breaksToTree(env: Env<AttrContext>, breakTo: javac.tree.JCTree, body: javac.tree.JCTree, make: javac.tree.TreeMaker): boolean;
              makePatternDescription(selectorType: javac.code.Type, pattern: javac.tree.JCTree$JCPattern): Flow$PatternDescription;
              _attrEnv: Env<AttrContext>;
              _chk: Check;
              _diags: javac.util.JCDiagnostic$Factory;
              _infer: Infer;
              _lint: javac.code.Lint;
              _log: javac.util.Log;
              _make: javac.tree.TreeMaker;
              _names: javac.util.Names;
              _rs: Resolve;
              _syms: javac.code.Symtab;
              _types: javac.code.Types;
            }
            interface Flow extends CombineTypes<[_Flow, java.lang.Object]> {}
            interface _Flow$AliveAnalyzer$$static extends ClassLike {
              _new(this$0: Flow): Flow$AliveAnalyzer;
            }
            let Flow$AliveAnalyzer: _Flow$AliveAnalyzer$$static;
            interface _Flow$AliveAnalyzer {
              _allPermittedSubTypes(root: javac.code.Symbol$ClassSymbol, accept: java.util.function.Predicate<javac.code.Symbol$ClassSymbol>): java.util.Set<javac.code.Symbol>;
              analyzeTree(env: Env<AttrContext>, make: javac.tree.TreeMaker): void;
              analyzeTree(env: Env<AttrContext>, tree: javac.tree.JCTree, make: javac.tree.TreeMaker): void;
              _checkCovered(seltype: javac.code.Type, patterns: java.lang.Iterable<Flow$PatternDescription>): boolean;
              _clearPendingExits(inMethod: boolean): void;
              _components(seltype: javac.code.Type): javac.util.List<javac.code.Type>;
              _exhausts(selector: javac.tree.JCTree$JCExpression, cases: javac.util.List<javac.tree.JCTree$JCCase>): boolean;
              _markDead(): void;
              _reduceBindingPatterns(selectorType: javac.code.Type, patterns: java.util.Set<Flow$PatternDescription>): java.util.Set<Flow$PatternDescription>;
              _reduceNestedPatterns(patterns: java.util.Set<Flow$PatternDescription>): java.util.Set<Flow$PatternDescription>;
              _reduceRecordPattern(pattern: Flow$PatternDescription): Flow$PatternDescription;
              _reduceRecordPatterns(patterns: java.util.Set<Flow$PatternDescription>): java.util.Set<Flow$PatternDescription>;
              _removeCoveredRecordPatterns(patterns: java.util.Set<Flow$PatternDescription>): java.util.Set<Flow$PatternDescription>;
              _scanDef(tree: javac.tree.JCTree): void;
              _scanStat(tree: javac.tree.JCTree): void;
              _scanStats(trees: javac.util.List<javac.tree.JCTree$JCStatement>): void;
              visitApply(tree: javac.tree.JCTree$JCMethodInvocation): void;
              visitBlock(tree: javac.tree.JCTree$JCBlock): void;
              visitBreak(tree: javac.tree.JCTree$JCBreak): void;
              visitClassDef(tree: javac.tree.JCTree$JCClassDecl): void;
              visitContinue(tree: javac.tree.JCTree$JCContinue): void;
              visitDoLoop(tree: javac.tree.JCTree$JCDoWhileLoop): void;
              visitForLoop(tree: javac.tree.JCTree$JCForLoop): void;
              visitForeachLoop(tree: javac.tree.JCTree$JCEnhancedForLoop): void;
              visitIf(tree: javac.tree.JCTree$JCIf): void;
              visitLabelled(tree: javac.tree.JCTree$JCLabeledStatement): void;
              visitLambda(tree: javac.tree.JCTree$JCLambda): void;
              visitMethodDef(tree: javac.tree.JCTree$JCMethodDecl): void;
              visitModuleDef(tree: javac.tree.JCTree$JCModuleDecl): void;
              visitNewClass(tree: javac.tree.JCTree$JCNewClass): void;
              visitReturn(tree: javac.tree.JCTree$JCReturn): void;
              visitSwitch(tree: javac.tree.JCTree$JCSwitch): void;
              visitSwitchExpression(tree: javac.tree.JCTree$JCSwitchExpression): void;
              visitThrow(tree: javac.tree.JCTree$JCThrow): void;
              visitTry(tree: javac.tree.JCTree$JCTry): void;
              visitVarDef(tree: javac.tree.JCTree$JCVariableDecl): void;
              visitWhileLoop(tree: javac.tree.JCTree$JCWhileLoop): void;
              visitYield(tree: javac.tree.JCTree$JCYield): void;
              _alive: Flow$Liveness;
              _this$0: Flow;
            }
            interface Flow$AliveAnalyzer extends CombineTypes<[_Flow$AliveAnalyzer, com.sun.tools.javac.comp.Flow$BaseAnalyzer]> {}
            interface _Flow$AssignAnalyzer$$static extends ClassLike {
              new(this$0: Flow): Flow$AssignAnalyzer;
            }
            let Flow$AssignAnalyzer: _Flow$AssignAnalyzer$$static;
            interface _Flow$AssignAnalyzer {
              _addVars(stats: javac.util.List<javac.tree.JCTree$JCStatement>, inits: javac.util.Bits, uninits: javac.util.Bits): void;
              analyzeTree(env: Env<any>, make: javac.tree.TreeMaker): void;
              analyzeTree(env: Env<any>, tree: javac.tree.JCTree, make: javac.tree.TreeMaker): void;
              _checkInit(pos: javac.util.JCDiagnostic$DiagnosticPosition, sym: javac.code.Symbol$VarSymbol): void;
              _checkInit(pos: javac.util.JCDiagnostic$DiagnosticPosition, sym: javac.code.Symbol$VarSymbol, errkey: javac.util.JCDiagnostic$Error): void;
              _clearPendingExits(inMethod: boolean): void;
              _handleSwitch(tree: javac.tree.JCTree, selector: javac.tree.JCTree$JCExpression, cases: javac.util.List<javac.tree.JCTree$JCCase>, isExhaustive: boolean): void;
              _initParam(def: javac.tree.JCTree$JCVariableDecl): void;
              _isFinalUninitializedField(sym: javac.code.Symbol$VarSymbol): boolean;
              _isFinalUninitializedStaticField(sym: javac.code.Symbol$VarSymbol): boolean;
              _letInit(pos: javac.util.JCDiagnostic$DiagnosticPosition, sym: javac.code.Symbol$VarSymbol): void;
              _letInit(tree: javac.tree.JCTree): void;
              _markDead(): void;
              _merge(): void;
              _newVar(varDecl: javac.tree.JCTree$JCVariableDecl): void;
              _referenced(sym: javac.code.Symbol): void;
              _resetBits(bits: javac.util.Bits[]): void;
              _resetBits(...bits: javac.util.Bits[]): void;
              scan(a0: javac.tree.JCTree): void;
              _scanCond(tree: javac.tree.JCTree): void;
              _scanExpr(tree: javac.tree.JCTree): void;
              _scanExprs(trees: javac.util.List<javac.tree.JCTree$JCExpression>): void;
              _scanPattern(tree: javac.tree.JCTree): void;
              _split(setToNull: boolean): void;
              _trackable(sym: javac.code.Symbol$VarSymbol): boolean;
              _uninit(sym: javac.code.Symbol$VarSymbol): void;
              visitAnnotatedType(tree: javac.tree.JCTree$JCAnnotatedType): void;
              visitApply(tree: javac.tree.JCTree$JCMethodInvocation): void;
              visitAssert(tree: javac.tree.JCTree$JCAssert): void;
              visitAssign(tree: javac.tree.JCTree$JCAssign): void;
              visitAssignop(tree: javac.tree.JCTree$JCAssignOp): void;
              visitBinary(tree: javac.tree.JCTree$JCBinary): void;
              visitBindingPattern(tree: javac.tree.JCTree$JCBindingPattern): void;
              visitBlock(tree: javac.tree.JCTree$JCBlock): void;
              visitBreak(tree: javac.tree.JCTree$JCBreak): void;
              visitClassDef(tree: javac.tree.JCTree$JCClassDecl): void;
              visitConditional(tree: javac.tree.JCTree$JCConditional): void;
              visitContinue(tree: javac.tree.JCTree$JCContinue): void;
              visitDoLoop(tree: javac.tree.JCTree$JCDoWhileLoop): void;
              visitForLoop(tree: javac.tree.JCTree$JCForLoop): void;
              visitForeachLoop(tree: javac.tree.JCTree$JCEnhancedForLoop): void;
              visitIdent(tree: javac.tree.JCTree$JCIdent): void;
              visitIf(tree: javac.tree.JCTree$JCIf): void;
              visitLabelled(tree: javac.tree.JCTree$JCLabeledStatement): void;
              visitLambda(tree: javac.tree.JCTree$JCLambda): void;
              visitMethodDef(tree: javac.tree.JCTree$JCMethodDecl): void;
              visitModuleDef(tree: javac.tree.JCTree$JCModuleDecl): void;
              visitNewArray(tree: javac.tree.JCTree$JCNewArray): void;
              visitNewClass(tree: javac.tree.JCTree$JCNewClass): void;
              visitPackageDef(a0: javac.tree.JCTree$JCPackageDecl): void;
              visitReturn(tree: javac.tree.JCTree$JCReturn): void;
              visitSelect(tree: javac.tree.JCTree$JCFieldAccess): void;
              visitSwitch(tree: javac.tree.JCTree$JCSwitch): void;
              visitSwitchExpression(tree: javac.tree.JCTree$JCSwitchExpression): void;
              visitThrow(tree: javac.tree.JCTree$JCThrow): void;
              visitTry(tree: javac.tree.JCTree$JCTry): void;
              visitTypeTest(tree: javac.tree.JCTree$JCInstanceOf): void;
              visitUnary(tree: javac.tree.JCTree$JCUnary): void;
              visitVarDef(tree: javac.tree.JCTree$JCVariableDecl): void;
              visitWhileLoop(tree: javac.tree.JCTree$JCWhileLoop): void;
              visitYield(tree: javac.tree.JCTree$JCYield): void;
              _classDef: javac.tree.JCTree$JCClassDecl;
              _firstadr: int;
              _flowKind: Flow$FlowKind;
              _inits: javac.util.Bits;
              _initsWhenFalse: javac.util.Bits;
              _initsWhenTrue: javac.util.Bits;
              _isInitialConstructor: boolean;
              _nextadr: int;
              _returnadr: int;
              _startPos: int;
              _this$0: Flow;
              _uninits: javac.util.Bits;
              _uninitsTry: javac.util.Bits;
              _uninitsWhenFalse: javac.util.Bits;
              _uninitsWhenTrue: javac.util.Bits;
              _unrefdResources: javac.code.Scope$WriteableScope;
              _vardecls: javac.tree.JCTree$JCVariableDecl[];
            }
            interface Flow$AssignAnalyzer extends CombineTypes<[_Flow$AssignAnalyzer, com.sun.tools.javac.comp.Flow$BaseAnalyzer]> {}
            interface _Flow$AssignAnalyzer$AssignPendingExit$$static extends ClassLike {
              new(this$1: Flow$AssignAnalyzer, tree: javac.tree.JCTree, inits: javac.util.Bits, uninits: javac.util.Bits): Flow$AssignAnalyzer$AssignPendingExit;
            }
            let Flow$AssignAnalyzer$AssignPendingExit: _Flow$AssignAnalyzer$AssignPendingExit$$static;
            interface _Flow$AssignAnalyzer$AssignPendingExit {
              resolveJump(): void;
              _exit_inits: javac.util.Bits;
              _exit_uninits: javac.util.Bits;
              _inits: javac.util.Bits;
              _uninits: javac.util.Bits;
            }
            interface Flow$AssignAnalyzer$AssignPendingExit extends CombineTypes<[_Flow$AssignAnalyzer$AssignPendingExit, com.sun.tools.javac.comp.Flow$BaseAnalyzer$PendingExit]> {}
            interface _Flow$BaseAnalyzer$$static extends ClassLike {
              _new(): Flow$BaseAnalyzer;
            }
            let Flow$BaseAnalyzer: _Flow$BaseAnalyzer$$static;
            interface _Flow$BaseAnalyzer {
              _markDead(): void;
(): void;
              _recordExit(pe: Flow$BaseAnalyzer$PendingExit): void;
              _resolveBreaks(tree: javac.tree.JCTree, oldPendingExits: javac.util.ListBuffer<Flow$BaseAnalyzer$PendingExit>): Flow$Liveness;
              _resolveContinues(tree: javac.tree.JCTree): Flow$Liveness;
              _resolveJump(tree: javac.tree.JCTree, oldPendingExits: javac.util.ListBuffer<Flow$BaseAnalyzer$PendingExit>, jk: Flow$BaseAnalyzer$JumpKind): Flow$Liveness;
              _resolveYields(tree: javac.tree.JCTree, oldPendingExits: javac.util.ListBuffer<Flow$BaseAnalyzer$PendingExit>): Flow$Liveness;
              scan(tree: javac.tree.JCTree): void;
              _scanSyntheticBreak(make: javac.tree.TreeMaker, swtch: javac.tree.JCTree): void;
              visitPackageDef(tree: javac.tree.JCTree$JCPackageDecl): void;
              _pendingExits: javac.util.ListBuffer<Flow$BaseAnalyzer$PendingExit>;
            }
            interface Flow$BaseAnalyzer extends CombineTypes<[_Flow$BaseAnalyzer, com.sun.tools.javac.tree.TreeScanner]> {}
            interface _Flow$BaseAnalyzer$JumpKind$$static extends ClassLike {
              valueOf(name: string): Flow$BaseAnalyzer$JumpKind;
              values(): Flow$BaseAnalyzer$JumpKind[];
              readonly BREAK: Flow$BaseAnalyzer$JumpKind;
              readonly CONTINUE: Flow$BaseAnalyzer$JumpKind;
              readonly YIELD: Flow$BaseAnalyzer$JumpKind;
            }
            let Flow$BaseAnalyzer$JumpKind: _Flow$BaseAnalyzer$JumpKind$$static;
            interface _Flow$BaseAnalyzer$JumpKind {
              _getTarget(a0: javac.tree.JCTree): javac.tree.JCTree;
(a0: javac.tree.JCTree): javac.tree.JCTree;
              _treeTag: javac.tree.JCTree$Tag;
            }
            interface Flow$BaseAnalyzer$JumpKind extends CombineTypes<[_Flow$BaseAnalyzer$JumpKind]> {}
            interface _Flow$BaseAnalyzer$PendingExit$$static extends ClassLike {
              _new(tree: javac.tree.JCTree): Flow$BaseAnalyzer$PendingExit;
            }
            let Flow$BaseAnalyzer$PendingExit: _Flow$BaseAnalyzer$PendingExit$$static;
            interface _Flow$BaseAnalyzer$PendingExit {
              _resolveJump(): void;
              _tree: javac.tree.JCTree;
            }
            interface Flow$BaseAnalyzer$PendingExit extends CombineTypes<[_Flow$BaseAnalyzer$PendingExit, java.lang.Object]> {}
            interface _Flow$BindingPattern$$static extends ClassLike {
              _new(type: javac.code.Type): Flow$BindingPattern;
            }
            let Flow$BindingPattern: _Flow$BindingPattern$$static;
            interface _Flow$BindingPattern {
              equals(o: any): boolean;
              hashCode(): int;
              toString(): string;
              type(): javac.code.Type;
            }
            interface Flow$BindingPattern extends CombineTypes<[_Flow$BindingPattern, com.sun.tools.javac.comp.Flow$PatternDescription, java.lang.Record]> {}
            interface _Flow$CaptureAnalyzer$$static extends ClassLike {
              _new(this$0: Flow): Flow$CaptureAnalyzer;
            }
            let Flow$CaptureAnalyzer: _Flow$CaptureAnalyzer$$static;
            interface _Flow$CaptureAnalyzer {
              analyzeTree(env: Env<AttrContext>, make: javac.tree.TreeMaker): void;
              analyzeTree(env: Env<AttrContext>, tree: javac.tree.JCTree, make: javac.tree.TreeMaker): void;
              _checkEffectivelyFinal(pos: javac.util.JCDiagnostic$DiagnosticPosition, sym: javac.code.Symbol$VarSymbol): void;
              _getCurrentTreeStartPosition(): int;
              _letInit(tree: javac.tree.JCTree): void;
              _markDead(): void;
              _reportEffectivelyFinalError(pos: javac.util.JCDiagnostic$DiagnosticPosition, sym: javac.code.Symbol): void;
              visitAssign(tree: javac.tree.JCTree$JCAssign): void;
              visitAssignop(tree: javac.tree.JCTree$JCAssignOp): void;
              visitBindingPattern(tree: javac.tree.JCTree$JCBindingPattern): void;
              visitCase(tree: javac.tree.JCTree$JCCase): void;
              visitClassDef(tree: javac.tree.JCTree$JCClassDecl): void;
              visitIdent(tree: javac.tree.JCTree$JCIdent): void;
              visitLambda(tree: javac.tree.JCTree$JCLambda): void;
              visitModuleDef(tree: javac.tree.JCTree$JCModuleDecl): void;
              visitRecordPattern(tree: javac.tree.JCTree$JCRecordPattern): void;
              visitTry(tree: javac.tree.JCTree$JCTry): void;
              visitUnary(tree: javac.tree.JCTree$JCUnary): void;
              visitVarDef(tree: javac.tree.JCTree$JCVariableDecl): void;
              visitYield(tree: javac.tree.JCTree$JCYield): void;
              _currentTree: javac.tree.JCTree;
              _declaredInsideGuard: javac.code.Scope$WriteableScope;
              _this$0: Flow;
            }
            interface Flow$CaptureAnalyzer extends CombineTypes<[_Flow$CaptureAnalyzer, com.sun.tools.javac.comp.Flow$BaseAnalyzer]> {}
            interface _Flow$FlowAnalyzer$$static extends ClassLike {
              _new(this$0: Flow): Flow$FlowAnalyzer;
            }
            let Flow$FlowAnalyzer: _Flow$FlowAnalyzer$$static;
            interface _Flow$FlowAnalyzer {
              analyzeTree(env: Env<AttrContext>, make: javac.tree.TreeMaker): void;
              analyzeTree(env: Env<AttrContext>, tree: javac.tree.JCTree, make: javac.tree.TreeMaker): void;
              _checkCaughtType(pos: javac.util.JCDiagnostic$DiagnosticPosition, exc: javac.code.Type, thrownInTry: javac.util.List<javac.code.Type>, caughtInTry: javac.util.List<javac.code.Type>): void;
              _errorUncaught(): void;
              _handleSwitch(tree: javac.tree.JCTree, selector: javac.tree.JCTree$JCExpression, cases: javac.util.List<javac.tree.JCTree$JCCase>): void;
              _isExceptionOrThrowable(exc: javac.code.Type): boolean;
              _markDead(): void;
              _markThrown(tree: javac.tree.JCTree, exc: javac.code.Type): void;
              visitApply(tree: javac.tree.JCTree$JCMethodInvocation): void;
              visitBlock(tree: javac.tree.JCTree$JCBlock): void;
              visitBreak(tree: javac.tree.JCTree$JCBreak): void;
              visitClassDef(tree: javac.tree.JCTree$JCClassDecl): void;
              visitContinue(tree: javac.tree.JCTree$JCContinue): void;
              visitDoLoop(tree: javac.tree.JCTree$JCDoWhileLoop): void;
              visitForLoop(tree: javac.tree.JCTree$JCForLoop): void;
              visitForeachLoop(tree: javac.tree.JCTree$JCEnhancedForLoop): void;
              visitIf(tree: javac.tree.JCTree$JCIf): void;
              visitLabelled(tree: javac.tree.JCTree$JCLabeledStatement): void;
              visitLambda(tree: javac.tree.JCTree$JCLambda): void;
              visitMethodDef(tree: javac.tree.JCTree$JCMethodDecl): void;
              visitModuleDef(tree: javac.tree.JCTree$JCModuleDecl): void;
              visitNewClass(tree: javac.tree.JCTree$JCNewClass): void;
              visitReturn(tree: javac.tree.JCTree$JCReturn): void;
              visitStringTemplate(tree: javac.tree.JCTree$JCStringTemplate): void;
              visitSwitch(tree: javac.tree.JCTree$JCSwitch): void;
              visitSwitchExpression(tree: javac.tree.JCTree$JCSwitchExpression): void;
              visitThrow(tree: javac.tree.JCTree$JCThrow): void;
              visitTry(tree: javac.tree.JCTree$JCTry): void;
              visitVarDef(tree: javac.tree.JCTree$JCVariableDecl): void;
              visitWhileLoop(tree: javac.tree.JCTree$JCWhileLoop): void;
              visitYield(tree: javac.tree.JCTree$JCYield): void;
              _caught: javac.util.List<javac.code.Type>;
              _classDef: javac.tree.JCTree$JCClassDecl;
              _preciseRethrowTypes: java.util.HashMap<javac.code.Symbol,javac.util.List<javac.code.Type>>;
              _this$0: Flow;
              _thrown: javac.util.List<javac.code.Type>;
            }
            interface Flow$FlowAnalyzer extends CombineTypes<[_Flow$FlowAnalyzer, com.sun.tools.javac.comp.Flow$BaseAnalyzer]> {}
            interface _Flow$FlowAnalyzer$ThrownPendingExit$$static extends ClassLike {
              _new(this$1: Flow$FlowAnalyzer, tree: javac.tree.JCTree, thrown: javac.code.Type): Flow$FlowAnalyzer$ThrownPendingExit;
            }
            let Flow$FlowAnalyzer$ThrownPendingExit: _Flow$FlowAnalyzer$ThrownPendingExit$$static;
            interface _Flow$FlowAnalyzer$ThrownPendingExit {
              _thrown: javac.code.Type;
            }
            interface Flow$FlowAnalyzer$ThrownPendingExit extends CombineTypes<[_Flow$FlowAnalyzer$ThrownPendingExit, com.sun.tools.javac.comp.Flow$BaseAnalyzer$PendingExit]> {}
            interface _Flow$FlowKind$$static extends ClassLike {
              valueOf(name: string): Flow$FlowKind;
              values(): Flow$FlowKind[];
              readonly NORMAL: Flow$FlowKind;
              readonly SPECULATIVE_LOOP: Flow$FlowKind;
            }
            let Flow$FlowKind: _Flow$FlowKind$$static;
            interface _Flow$FlowKind {
              _isFinal(): boolean;
              _errKey: string;
              _isFinal: boolean;
            }
            interface Flow$FlowKind extends CombineTypes<[_Flow$FlowKind]> {}
            interface _Flow$LambdaAliveAnalyzer$$static extends ClassLike {
              _new(this$0: Flow): Flow$LambdaAliveAnalyzer;
            }
            let Flow$LambdaAliveAnalyzer: _Flow$LambdaAliveAnalyzer$$static;
            interface _Flow$LambdaAliveAnalyzer {
              visitClassDef(tree: javac.tree.JCTree$JCClassDecl): void;
              visitLambda(tree: javac.tree.JCTree$JCLambda): void;
              visitReturn(tree: javac.tree.JCTree$JCReturn): void;
              _inLambda: boolean;
            }
            interface Flow$LambdaAliveAnalyzer extends CombineTypes<[_Flow$LambdaAliveAnalyzer, com.sun.tools.javac.comp.Flow$AliveAnalyzer]> {}
            interface _Flow$LambdaAssignAnalyzer$$static extends ClassLike {
              _new(this$0: Env<AttrContext>): Flow$LambdaAssignAnalyzer;
            }
            let Flow$LambdaAssignAnalyzer: _Flow$LambdaAssignAnalyzer$$static;
            interface _Flow$LambdaAssignAnalyzer {
              _trackable(sym: javac.code.Symbol$VarSymbol): boolean;
              visitClassDef(tree: javac.tree.JCTree$JCClassDecl): void;
              visitLambda(tree: javac.tree.JCTree$JCLambda): void;
              visitVarDef(tree: javac.tree.JCTree$JCVariableDecl): void;
              _enclosedSymbols: javac.code.Scope$WriteableScope;
              _inLambda: boolean;
            }
            interface Flow$LambdaAssignAnalyzer extends CombineTypes<[_Flow$LambdaAssignAnalyzer, com.sun.tools.javac.comp.Flow$AssignAnalyzer]> {}
            interface _Flow$LambdaFlowAnalyzer$$static extends ClassLike {
              _new(this$0: Flow): Flow$LambdaFlowAnalyzer;
            }
            let Flow$LambdaFlowAnalyzer: _Flow$LambdaFlowAnalyzer$$static;
            interface _Flow$LambdaFlowAnalyzer {
              visitClassDef(tree: javac.tree.JCTree$JCClassDecl): void;
              visitLambda(tree: javac.tree.JCTree$JCLambda): void;
              _inLambda: boolean;
              _inferredThrownTypes: javac.util.List<javac.code.Type>;
              _this$0: Flow;
            }
            interface Flow$LambdaFlowAnalyzer extends CombineTypes<[_Flow$LambdaFlowAnalyzer, com.sun.tools.javac.comp.Flow$FlowAnalyzer]> {}
            interface _Flow$Liveness$$static extends ClassLike {
              from(value: boolean): Flow$Liveness;
              valueOf(name: string): Flow$Liveness;
              values(): Flow$Liveness[];
              readonly ALIVE: Flow$Liveness;
              readonly DEAD: Flow$Liveness;
              readonly RECOVERY: Flow$Liveness;
            }
            let Flow$Liveness: _Flow$Liveness$$static;
            interface _Flow$Liveness {
              and(a0: Flow$Liveness): Flow$Liveness;
              and(value: boolean): Flow$Liveness;
              or(a0: Flow$Liveness): Flow$Liveness;
              or(value: boolean): Flow$Liveness;
            }
            interface Flow$Liveness extends CombineTypes<[_Flow$Liveness]> {}
            interface _Flow$PatternDescription$$static extends ClassLike {
            }
            let Flow$PatternDescription: _Flow$PatternDescription$$static;
            interface _Flow$PatternDescription {
            }
            interface Flow$PatternDescription extends CombineTypes<[_Flow$PatternDescription, java.lang.Object]> {}
            interface _Flow$RecordPattern$$static extends ClassLike {
              hashCode(excludeComponent: int, recordType: javac.code.Type, nested: Flow$PatternDescription[]): int;
              hashCode(excludeComponent: int, recordType: javac.code.Type, ...nested: Flow$PatternDescription[]): int;
              new(recordType: javac.code.Type, fullComponentTypes: javac.code.Type[], nested: Flow$PatternDescription[]): Flow$RecordPattern;
              _new(recordType: javac.code.Type, _hashCode: int, fullComponentTypes: javac.code.Type[], nested: Flow$PatternDescription[]): Flow$RecordPattern;
              _new(recordType: javac.code.Type, _hashCode: int, fullComponentTypes: javac.code.Type[], ...nested: Flow$PatternDescription[]): Flow$RecordPattern;
            }
            let Flow$RecordPattern: _Flow$RecordPattern$$static;
            interface _Flow$RecordPattern {
              _hashCode(): int;
              equals(o: any): boolean;
              fullComponentTypes(): javac.code.Type[];
              hashCode(): int;
              hashCode(excludeComponent: int): int;
              nested(): Flow$PatternDescription[];
              recordType(): javac.code.Type;
              toString(): string;
            }
            interface Flow$RecordPattern extends CombineTypes<[_Flow$RecordPattern, com.sun.tools.javac.comp.Flow$PatternDescription, java.lang.Record]> {}
            interface _Flow$SnippetAliveAnalyzer$$static extends ClassLike {
              _new(this$0: Flow): Flow$SnippetAliveAnalyzer;
            }
            let Flow$SnippetAliveAnalyzer: _Flow$SnippetAliveAnalyzer$$static;
            interface _Flow$SnippetAliveAnalyzer {
              isAlive(): boolean;
              visitClassDef(tree: javac.tree.JCTree$JCClassDecl): void;
              visitLambda(tree: javac.tree.JCTree$JCLambda): void;
            }
            interface Flow$SnippetAliveAnalyzer extends CombineTypes<[_Flow$SnippetAliveAnalyzer, com.sun.tools.javac.comp.Flow$AliveAnalyzer]> {}
            interface _Flow$SnippetBreakToAnalyzer$$static extends ClassLike {
              new(this$0: Flow, breakTo: javac.tree.JCTree): Flow$SnippetBreakToAnalyzer;
            }
            let Flow$SnippetBreakToAnalyzer: _Flow$SnippetBreakToAnalyzer$$static;
            interface _Flow$SnippetBreakToAnalyzer {
              breaksTo(): boolean;
              visitBreak(tree: javac.tree.JCTree$JCBreak): void;
              _breakTo: javac.tree.JCTree;
              _breaksTo: boolean;
            }
            interface Flow$SnippetBreakToAnalyzer extends CombineTypes<[_Flow$SnippetBreakToAnalyzer, com.sun.tools.javac.comp.Flow$AliveAnalyzer]> {}
            interface _Infer$$static extends ClassLike {
              instance(context: javac.util.Context): Infer;
              _MAX_INCORPORATION_STEPS: int;
              readonly anyPoly: javac.code.Type;
              _inferKey: javac.util.Context$Key<Infer>;
              _new(context: javac.util.Context): Infer;
            }
            let Infer: _Infer$$static;
            interface _Infer {
              _asSuper(t: javac.code.Type, sup: javac.code.Type): javac.code.Type;
              _commonSuperWithDiffParameterization(t: javac.code.Type, s: javac.code.Type): boolean;
              _doIncorporation(inferenceContext: InferenceContext, warn: javac.util.Warner): void;
              _doIncorporationOp(opKind: Infer$IncorporationBinaryOpKind, op1: javac.code.Type, op2: javac.code.Type, warn: javac.util.Warner): boolean;
              _dumpGraphsIfNeeded(pos: javac.util.JCDiagnostic$DiagnosticPosition, msym: javac.code.Symbol, rsContext: Resolve$MethodResolutionContext): void;
              _error(diag: javac.util.JCDiagnostic): Infer$InferenceException;
              _generateReferenceToTargetConstraint(tree: javac.tree.JCTree, from: javac.code.Type$UndetVar, to: javac.code.Type, resultInfo: Attr$ResultInfo, inferenceContext: InferenceContext): javac.code.Type;
              _generateReturnConstraints(tree: javac.tree.JCTree, resultInfo: Attr$ResultInfo, mt: javac.code.Type$MethodType, inferenceContext: InferenceContext): javac.code.Type;
              _getBoundFragment(ib: javac.code.Type$UndetVar$InferenceBound, types: javac.util.List<javac.code.Type>): javac.util.JCDiagnostic$Fragment;
              _getParameterizedSupers(t: javac.code.Type, s: javac.code.Type): javac.util.List<javac.util.Pair<javac.code.Type,javac.code.Type>>;
              _instantiateAsUninferredVars(vars: javac.util.List<javac.code.Type>, inferenceContext: InferenceContext): void;
              instantiateFunctionalInterface(pos: javac.util.JCDiagnostic$DiagnosticPosition, funcInterface: javac.code.Type, paramTypes: javac.util.List<javac.code.Type>, checkContext: Check$CheckContext): javac.code.Type;
              _instantiateMethod(env: Env<AttrContext>, tvars: javac.util.List<javac.code.Type>, mt: javac.code.Type$MethodType, resultInfo: Attr$ResultInfo, msym: javac.code.Symbol$MethodSymbol, argtypes: javac.util.List<javac.code.Type>, allowBoxing: boolean, useVarargs: boolean, resolveContext: Resolve$MethodResolutionContext, warn: javac.util.Warner): javac.code.Type;
              instantiatePatternType(expressionType: javac.code.Type, patternTypeSymbol: javac.code.Symbol$TypeSymbol): javac.code.Type;
              _instantiatePatternVars(vars: javac.util.List<javac.code.Type>, c: InferenceContext): javac.util.List<javac.code.Type>;
              _instantiatePolymorphicSignatureInstance(env: Env<AttrContext>, spMethod: javac.code.Symbol$MethodSymbol, resolveContext: Resolve$MethodResolutionContext, argtypes: javac.util.List<javac.code.Type>): javac.code.Type;
              _needsEagerInstantiation(from: javac.code.Type$UndetVar, to: javac.code.Type, inferenceContext: InferenceContext): boolean;
              _replaceTypeVarsInBounds(vars: javac.util.List<javac.code.Type>, inferenceContext: InferenceContext): void;
              _reportBoundError(uv: javac.code.Type$UndetVar, ib: javac.code.Type$UndetVar$InferenceBound): void;
              _reportBoundError(uv: javac.code.Type$UndetVar, ib1: javac.code.Type$UndetVar$InferenceBound, ib2: javac.code.Type$UndetVar$InferenceBound): void;
              _reportInstError(uv: javac.code.Type$UndetVar, ib: javac.code.Type$UndetVar$InferenceBound): void;
              _roots(mt: javac.code.Type$MethodType, deferredAttrContext: DeferredAttr$DeferredAttrContext): javac.util.List<javac.code.Type>;
              _shouldPropagate(restype: javac.code.Type, target: Attr$ResultInfo, inferenceContext: InferenceContext): boolean;
              _chk: Check;
              _dependenciesFolder: string;
              _diags: javac.util.JCDiagnostic$Factory;
              _emptyContext: InferenceContext;
              _fromTypeVarFun: javac.code.Types$TypeMapping<java.lang.Void>;
              _incorporationCache: java.util.Map<Infer$IncorporationBinaryOp,boolean>;
              _incorporationEngine: Infer$IncorporationEngine;
              _log: javac.util.Log;
              _pendingGraphs: javac.util.List<string>;
              _rs: Resolve;
              _syms: javac.code.Symtab;
              _types: javac.code.Types;
            }
            interface Infer extends CombineTypes<[_Infer, java.lang.Object]> {}
            interface _Infer$BestLeafSolver$$static extends ClassLike {
              _new(this$0: javac.util.List<javac.code.Type>): Infer$BestLeafSolver;
            }
            let Infer$BestLeafSolver: _Infer$BestLeafSolver$$static;
            interface _Infer$BestLeafSolver {
              _computeTreeToLeafs(n: Infer$GraphSolver$InferenceGraph$Node): javac.util.Pair<javac.util.List<Infer$GraphSolver$InferenceGraph$Node>,int>;
              pickNode(g: Infer$GraphSolver$InferenceGraph): Infer$GraphSolver$InferenceGraph$Node;
              _noPath: javac.util.Pair<javac.util.List<Infer$GraphSolver$InferenceGraph$Node>,int>;
              _treeCache: java.util.Map<Infer$GraphSolver$InferenceGraph$Node,javac.util.Pair<javac.util.List<Infer$GraphSolver$InferenceGraph$Node>,int>>;
              _varsToSolve: javac.util.List<javac.code.Type>;
            }
            interface Infer$BestLeafSolver extends CombineTypes<[_Infer$BestLeafSolver, com.sun.tools.javac.comp.Infer$LeafSolver]> {}
            interface _Infer$BoundFilter$$static extends ClassLike {
              new(inferenceContext: InferenceContext): Infer$BoundFilter;
            }
            let Infer$BoundFilter: _Infer$BoundFilter$$static;
            interface _Infer$BoundFilter {
              test(t: javac.code.Type): boolean;
              test(a0: any): boolean;
              _inferenceContext: InferenceContext;
            }
            interface Infer$BoundFilter extends CombineTypes<[_Infer$BoundFilter, java.lang.Object, java.util.function.Predicate<javac.code.Type>]> {}
            interface _Infer$CheckBounds$$static extends ClassLike {
              _new(this$0: Infer, uv: javac.code.Type$UndetVar, t: javac.code.Type, from: javac.code.Type$UndetVar$InferenceBound): Infer$CheckBounds;
              _new(this$0: javac.code.Type$UndetVar, uv: javac.code.Type, t: java.util.function.BiFunction<InferenceContext,javac.code.Type,javac.code.Type>, typeFunc: java.util.function.BiPredicate<InferenceContext,javac.code.Type>, typeFilter: javac.code.Type$UndetVar$InferenceBound): Infer$CheckBounds;
            }
            let Infer$CheckBounds: _Infer$CheckBounds$$static;
            interface _Infer$CheckBounds {
              _apply(inferenceContext: InferenceContext, warn: javac.util.Warner): void;
              _boundsToCheck(): java.util.EnumSet<javac.code.Type$UndetVar$InferenceBound>;
              _checkBound(s: javac.code.Type, t: javac.code.Type, ib_s: javac.code.Type$UndetVar$InferenceBound, ib_t: javac.code.Type$UndetVar$InferenceBound, warn: javac.util.Warner): boolean;
              dup(that: javac.code.Type$UndetVar): Infer$IncorporationAction;
              _report(from: javac.code.Type$UndetVar$InferenceBound, to: javac.code.Type$UndetVar$InferenceBound): void;
              toString(): string;
              _from: javac.code.Type$UndetVar$InferenceBound;
              _optFilter: java.util.function.BiPredicate<InferenceContext,javac.code.Type>;
              _this$0: Infer;
              _typeFunc: java.util.function.BiFunction<InferenceContext,javac.code.Type,javac.code.Type>;
            }
            interface Infer$CheckBounds extends CombineTypes<[_Infer$CheckBounds, com.sun.tools.javac.comp.Infer$IncorporationAction]> {}
            interface _Infer$CheckInst$$static extends ClassLike {
              _new(this$0: Infer, uv: javac.code.Type$UndetVar, ib: javac.code.Type$UndetVar$InferenceBound, rest: javac.code.Type$UndetVar$InferenceBound[]): Infer$CheckInst;
              _new(this$0: Infer, uv: javac.code.Type$UndetVar, ib: javac.code.Type$UndetVar$InferenceBound, ...rest: javac.code.Type$UndetVar$InferenceBound[]): Infer$CheckInst;
              _new(this$0: javac.code.Type$UndetVar, uv: java.util.EnumSet<javac.code.Type$UndetVar$InferenceBound>): Infer$CheckInst;
            }
            let Infer$CheckInst: _Infer$CheckInst$$static;
            interface _Infer$CheckInst {
              _boundsToCheck(): java.util.EnumSet<javac.code.Type$UndetVar$InferenceBound>;
              dup(that: javac.code.Type$UndetVar): Infer$IncorporationAction;
              _report(from: javac.code.Type$UndetVar$InferenceBound, to: javac.code.Type$UndetVar$InferenceBound): void;
              _this$0: Infer;
              _to: java.util.EnumSet<javac.code.Type$UndetVar$InferenceBound>;
            }
            interface Infer$CheckInst extends CombineTypes<[_Infer$CheckInst, com.sun.tools.javac.comp.Infer$CheckBounds]> {}
            interface _Infer$CheckUpperBounds$$static extends ClassLike {
              new(this$0: Infer, uv: javac.code.Type$UndetVar, t: javac.code.Type): Infer$CheckUpperBounds;
            }
            let Infer$CheckUpperBounds: _Infer$CheckUpperBounds$$static;
            interface _Infer$CheckUpperBounds {
              _apply(inferenceContext: InferenceContext, warn: javac.util.Warner): void;
              dup(that: javac.code.Type$UndetVar): Infer$IncorporationAction;
              _this$0: Infer;
            }
            interface Infer$CheckUpperBounds extends CombineTypes<[_Infer$CheckUpperBounds, com.sun.tools.javac.comp.Infer$IncorporationAction]> {}
            interface _Infer$DependencyKind$$static extends ClassLike {
              valueOf(name: string): Infer$DependencyKind;
              values(): Infer$DependencyKind[];
              readonly BOUND: Infer$DependencyKind;
              readonly STUCK: Infer$DependencyKind;
            }
            let Infer$DependencyKind: _Infer$DependencyKind$$static;
            interface _Infer$DependencyKind {
              _dotStyle: string;
            }
            interface Infer$DependencyKind extends CombineTypes<[_Infer$DependencyKind, javac.util.GraphUtils$DependencyKind]> {}
            interface _Infer$FreeTypeListener$$static extends ClassLike {
            }
            let Infer$FreeTypeListener: _Infer$FreeTypeListener$$static;
            interface _Infer$FreeTypeListener {
              typesInferred(a0: InferenceContext): void;
(a0: InferenceContext): void;
            }
            interface Infer$FreeTypeListener extends CombineTypes<[_Infer$FreeTypeListener, java.lang.Object]> {}
            interface _Infer$GraphInferenceSteps$$static extends ClassLike {
              valueOf(name: string): Infer$GraphInferenceSteps;
              values(): Infer$GraphInferenceSteps[];
              readonly EQ: Infer$GraphInferenceSteps;
              readonly EQ_LOWER: Infer$GraphInferenceSteps;
              readonly EQ_LOWER_THROWS_UPPER_CAPTURED: Infer$GraphInferenceSteps;
            }
            let Infer$GraphInferenceSteps: _Infer$GraphInferenceSteps$$static;
            interface _Infer$GraphInferenceSteps {
              _steps: java.util.EnumSet<Infer$InferenceStep>;
            }
            interface Infer$GraphInferenceSteps extends CombineTypes<[_Infer$GraphInferenceSteps]> {}
            interface _Infer$GraphSolver$$static extends ClassLike {
              _new(this$0: Infer, inferenceContext: InferenceContext, warn: javac.util.Warner): Infer$GraphSolver;
            }
            let Infer$GraphSolver: _Infer$GraphSolver$$static;
            interface _Infer$GraphSolver {
              _solve(sstrategy: Infer$GraphStrategy): void;
              _inferenceContext: InferenceContext;
              _this$0: Infer;
              _warn: javac.util.Warner;
            }
            interface Infer$GraphSolver extends CombineTypes<[_Infer$GraphSolver, java.lang.Object]> {}
            interface _Infer$GraphSolver$InferenceGraph$$static extends ClassLike {
              _new(this$1: Infer$GraphSolver): Infer$GraphSolver$InferenceGraph;
            }
            let Infer$GraphSolver$InferenceGraph: _Infer$GraphSolver$InferenceGraph$$static;
            interface _Infer$GraphSolver$InferenceGraph {
              deleteNode(n: Infer$GraphSolver$InferenceGraph$Node): void;
              findNode(t: javac.code.Type): Infer$GraphSolver$InferenceGraph$Node;
              _initNodes(): void;
              _notifyUpdate(from: Infer$GraphSolver$InferenceGraph$Node, to: Infer$GraphSolver$InferenceGraph$Node): void;
              _toDot(): string;
              _nodes: java.util.ArrayList<Infer$GraphSolver$InferenceGraph$Node>;
              _this$1: Infer$GraphSolver;
            }
            interface Infer$GraphSolver$InferenceGraph extends CombineTypes<[_Infer$GraphSolver$InferenceGraph, java.lang.Object]> {}
            interface _Infer$GraphSolver$InferenceGraph$Node$$static extends ClassLike {
              _new(this$2: Infer$GraphSolver$InferenceGraph, ivar: javac.code.Type): Infer$GraphSolver$InferenceGraph$Node;
            }
            let Infer$GraphSolver$InferenceGraph$Node: _Infer$GraphSolver$InferenceGraph$Node$$static;
            interface _Infer$GraphSolver$InferenceGraph$Node {
              _addDependencies(depsToAdd: java.util.Set<Infer$GraphSolver$InferenceGraph$Node>): void;
              _addDependency(depToAdd: Infer$GraphSolver$InferenceGraph$Node): void;
              _closure(): java.util.Set<Infer$GraphSolver$InferenceGraph$Node>;
              _closureInternal(closure: java.util.Set<Infer$GraphSolver$InferenceGraph$Node>): void;
              dependencyAttributes(sink: Infer$GraphSolver$InferenceGraph$Node, dk: javac.util.GraphUtils$DependencyKind): java.util.Properties;
              dependencyAttributes(a0: javac.util.GraphUtils$DottableNode, a1: javac.util.GraphUtils$DependencyKind): java.util.Properties;
              getAllDependencies(): java.lang.Iterable<Infer$GraphSolver$InferenceGraph$Node>;
              getDependenciesByKind(dk: javac.util.GraphUtils$DependencyKind): java.util.Collection<Infer$GraphSolver$InferenceGraph$Node>;
              getSupportedDependencyKinds(): javac.util.GraphUtils$DependencyKind[];
              _graphChanged(from: Infer$GraphSolver$InferenceGraph$Node, to: Infer$GraphSolver$InferenceGraph$Node): void;
              _isLeaf(): boolean;
              _mergeWith(nodes: javac.util.List<Infer$GraphSolver$InferenceGraph$Node>): void;
              nodeAttributes(): java.util.Properties;
              _removeDependency(n: Infer$GraphSolver$InferenceGraph$Node): boolean;
              _deps: java.util.Set<Infer$GraphSolver$InferenceGraph$Node>;
              _this$2: Infer$GraphSolver$InferenceGraph;
            }
            interface Infer$GraphSolver$InferenceGraph$Node extends CombineTypes<[_Infer$GraphSolver$InferenceGraph$Node, javac.util.GraphUtils$DottableNode<javac.util.ListBuffer<javac.code.Type>,Infer$GraphSolver$InferenceGraph$Node>, javac.util.GraphUtils$TarjanNode<javac.util.ListBuffer<javac.code.Type>,Infer$GraphSolver$InferenceGraph$Node>]> {}
            interface _Infer$GraphStrategy$$static extends ClassLike {
            }
            let Infer$GraphStrategy: _Infer$GraphStrategy$$static;
            interface _Infer$GraphStrategy {
              done(): boolean;
              pickNode(a0: Infer$GraphSolver$InferenceGraph): Infer$GraphSolver$InferenceGraph$Node;
            }
            interface Infer$GraphStrategy extends CombineTypes<[_Infer$GraphStrategy, java.lang.Object]> {}
            interface _Infer$GraphStrategy$NodeNotFoundException$$static extends ClassLike {
              _serialVersionUID: long;
              new(graph: Infer$GraphSolver$InferenceGraph): Infer$GraphStrategy$NodeNotFoundException;
            }
            let Infer$GraphStrategy$NodeNotFoundException: _Infer$GraphStrategy$NodeNotFoundException$$static;
            interface _Infer$GraphStrategy$NodeNotFoundException {
              fillInStackTrace(): java.lang.Throwable;
              _graph: Infer$GraphSolver$InferenceGraph;
            }
            interface Infer$GraphStrategy$NodeNotFoundException extends CombineTypes<[_Infer$GraphStrategy$NodeNotFoundException, java.lang.RuntimeException]> {}
            interface _Infer$ImplicitArgType$$static extends ClassLike {
              new(this$0: Infer, msym: javac.code.Symbol, phase: Resolve$MethodResolutionPhase): Infer$ImplicitArgType;
            }
            let Infer$ImplicitArgType: _Infer$ImplicitArgType$$static;
            interface _Infer$ImplicitArgType {
              visitClassType(t: javac.code.Type$ClassType, aVoid: java.lang.Void): javac.code.Type;
              visitClassType(a0: javac.code.Type$ClassType, a1: any): javac.code.Type;
              visitClassType(a0: javac.code.Type$ClassType, a1: any): any;
              visitType(t: javac.code.Type, _unused: java.lang.Void): javac.code.Type;
              visitType(a0: javac.code.Type, a1: any): javac.code.Type;
              visitType(a0: javac.code.Type, a1: any): any;
              _this$0: Infer;
            }
            interface Infer$ImplicitArgType extends CombineTypes<[_Infer$ImplicitArgType, DeferredAttr$DeferredTypeMap<java.lang.Void>]> {}
            interface _Infer$IncorporationAction$$static extends ClassLike {
              _new(this$0: Infer, uv: javac.code.Type$UndetVar, t: javac.code.Type): Infer$IncorporationAction;
            }
            let Infer$IncorporationAction: _Infer$IncorporationAction$$static;
            interface _Infer$IncorporationAction {
              _apply(a0: InferenceContext, a1: javac.util.Warner): void;
              dup(a0: javac.code.Type$UndetVar): Infer$IncorporationAction;
              _isSameType(s: javac.code.Type, t: javac.code.Type): boolean;
              _isSubtype(s: javac.code.Type, t: javac.code.Type, warn: javac.util.Warner): boolean;
              toString(): string;
              _t: javac.code.Type;
              _this$0: Infer;
              _uv: javac.code.Type$UndetVar;
            }
            interface Infer$IncorporationAction extends CombineTypes<[_Infer$IncorporationAction, java.lang.Object]> {}
            interface _Infer$IncorporationBinaryOp$$static extends ClassLike {
              _new(this$0: Infer, opKind: Infer$IncorporationBinaryOpKind, op1: javac.code.Type, op2: javac.code.Type): Infer$IncorporationBinaryOp;
            }
            let Infer$IncorporationBinaryOp: _Infer$IncorporationBinaryOp$$static;
            interface _Infer$IncorporationBinaryOp {
              _apply(warn: javac.util.Warner): boolean;
              equals(o: any): boolean;
              hashCode(): int;
              _op1: javac.code.Type;
              _op2: javac.code.Type;
              _opKind: Infer$IncorporationBinaryOpKind;
              _this$0: Infer;
            }
            interface Infer$IncorporationBinaryOp extends CombineTypes<[_Infer$IncorporationBinaryOp, java.lang.Object]> {}
            interface _Infer$IncorporationBinaryOpKind$$static extends ClassLike {
              valueOf(name: string): Infer$IncorporationBinaryOpKind;
              values(): Infer$IncorporationBinaryOpKind[];
              readonly IS_SAME_TYPE: Infer$IncorporationBinaryOpKind;
              readonly IS_SUBTYPE: Infer$IncorporationBinaryOpKind;
            }
            let Infer$IncorporationBinaryOpKind: _Infer$IncorporationBinaryOpKind$$static;
            interface _Infer$IncorporationBinaryOpKind {
              _apply(a0: javac.code.Type, a1: javac.code.Type, a2: javac.util.Warner, a3: javac.code.Types): boolean;
(a0: javac.code.Type, a1: javac.code.Type, a2: javac.util.Warner, a3: javac.code.Types): boolean;
            }
            interface Infer$IncorporationBinaryOpKind extends CombineTypes<[_Infer$IncorporationBinaryOpKind]> {}
            interface _Infer$IncorporationEngine$$static extends ClassLike {
              _new(this$0: Infer): Infer$IncorporationEngine;
            }
            let Infer$IncorporationEngine: _Infer$IncorporationEngine$$static;
            interface _Infer$IncorporationEngine {
              _getIncorporationActions(uv: javac.code.Type$UndetVar, ib: javac.code.Type$UndetVar$InferenceBound, t: javac.code.Type, update: boolean): javac.util.List<Infer$IncorporationAction>;
              varBoundChanged(uv: javac.code.Type$UndetVar, ib: javac.code.Type$UndetVar$InferenceBound, bound: javac.code.Type, update: boolean): void;
              varInstantiated(uv: javac.code.Type$UndetVar): void;
              _this$0: Infer;
            }
            interface Infer$IncorporationEngine extends CombineTypes<[_Infer$IncorporationEngine, com.sun.tools.javac.code.Type$UndetVar$UndetVarListener, java.lang.Object]> {}
            interface _Infer$InferenceException$$static extends ClassLike {
              _serialVersionUID: long;
              _new(): Infer$InferenceException;
            }
            let Infer$InferenceException: _Infer$InferenceException$$static;
            interface _Infer$InferenceException {
              getDiagnostic(): javac.util.JCDiagnostic;
              _messages: javac.util.List<javac.util.JCDiagnostic>;
            }
            interface Infer$InferenceException extends CombineTypes<[_Infer$InferenceException, com.sun.tools.javac.comp.Resolve$InapplicableMethodException]> {}
            interface _Infer$InferenceStep$$static extends ClassLike {
              valueOf(name: string): Infer$InferenceStep;
              values(): Infer$InferenceStep[];
              readonly CAPTURED: Infer$InferenceStep;
              readonly EQ: Infer$InferenceStep;
              readonly LOWER: Infer$InferenceStep;
              readonly THROWS: Infer$InferenceStep;
              readonly UPPER: Infer$InferenceStep;
            }
            let Infer$InferenceStep: _Infer$InferenceStep$$static;
            interface _Infer$InferenceStep {
              accepts(t: javac.code.Type$UndetVar, inferenceContext: InferenceContext): boolean;
              _filterBounds(uv: javac.code.Type$UndetVar, inferenceContext: InferenceContext): javac.util.List<javac.code.Type>;
              _solve(a0: javac.code.Type$UndetVar, a1: InferenceContext): javac.code.Type;
(a0: javac.code.Type$UndetVar, a1: InferenceContext): javac.code.Type;
              _ib: javac.code.Type$UndetVar$InferenceBound;
            }
            interface Infer$InferenceStep extends CombineTypes<[_Infer$InferenceStep]> {}
            interface _Infer$LeafSolver$$static extends ClassLike {
              _new(this$0: Infer): Infer$LeafSolver;
            }
            let Infer$LeafSolver: _Infer$LeafSolver$$static;
            interface _Infer$LeafSolver {
              pickNode(g: Infer$GraphSolver$InferenceGraph): Infer$GraphSolver$InferenceGraph$Node;
            }
            interface Infer$LeafSolver extends CombineTypes<[_Infer$LeafSolver, java.lang.Object, com.sun.tools.javac.comp.Infer$GraphStrategy]> {}
            interface _Infer$PartiallyInferredMethodType$$static extends ClassLike {
              new(this$0: javac.code.Type$MethodType, mtype: InferenceContext, inferenceContext: Env<AttrContext>, env: javac.util.Warner): Infer$PartiallyInferredMethodType;
            }
            let Infer$PartiallyInferredMethodType: _Infer$PartiallyInferredMethodType$$static;
            interface _Infer$PartiallyInferredMethodType {
              _check(resultInfo: Attr$ResultInfo): javac.code.Type;
              isPartial(): boolean;
              _env: Env<AttrContext>;
              _inferenceContext: InferenceContext;
              _this$0: Infer;
              _warn: javac.util.Warner;
            }
            interface Infer$PartiallyInferredMethodType extends CombineTypes<[_Infer$PartiallyInferredMethodType, com.sun.tools.javac.code.Type$MethodType]> {}
            interface _Infer$PropagateBounds$$static extends ClassLike {
              new(this$0: Infer, uv: javac.code.Type$UndetVar, t: javac.code.Type, ib: javac.code.Type$UndetVar$InferenceBound): Infer$PropagateBounds;
            }
            let Infer$PropagateBounds: _Infer$PropagateBounds$$static;
            interface _Infer$PropagateBounds {
              _apply(inferenceContext: InferenceContext, warner: javac.util.Warner): void;
              _backwards(): java.util.EnumSet<javac.code.Type$UndetVar$InferenceBound>;
              dup(that: javac.code.Type$UndetVar): Infer$IncorporationAction;
              _forward(): java.util.EnumSet<javac.code.Type$UndetVar$InferenceBound>;
              toString(): string;
              _ib: javac.code.Type$UndetVar$InferenceBound;
              _this$0: Infer;
            }
            interface Infer$PropagateBounds extends CombineTypes<[_Infer$PropagateBounds, com.sun.tools.javac.comp.Infer$IncorporationAction]> {}
            interface _Infer$SubstBounds$$static extends ClassLike {
              _new(this$0: Infer, uv: javac.code.Type$UndetVar): Infer$SubstBounds;
            }
            let Infer$SubstBounds: _Infer$SubstBounds$$static;
            interface _Infer$SubstBounds {
              _apply(inferenceContext: InferenceContext, warn: javac.util.Warner): void;
              _checkCompatibleUpperBounds(uv: javac.code.Type$UndetVar, inferenceContext: InferenceContext): void;
              dup(that: javac.code.Type$UndetVar): Infer$IncorporationAction;
              _this$0: Infer;
            }
            interface Infer$SubstBounds extends CombineTypes<[_Infer$SubstBounds, com.sun.tools.javac.comp.Infer$CheckInst]> {}
            interface _InferenceContext$$static extends ClassLike {
              new(infer: Infer, inferencevars: javac.util.List<javac.code.Type>): InferenceContext;
              new(infer: Infer, inferencevars: javac.util.List<javac.code.Type>, undetvars: javac.util.List<javac.code.Type>): InferenceContext;
            }
            let InferenceContext: _InferenceContext$$static;
            interface _InferenceContext {
              _addFreeTypeListener(types: javac.util.List<javac.code.Type>, ftl: Infer$FreeTypeListener): void;
              _addVar(t: javac.code.Type$TypeVar): void;
              _asInstType(t: javac.code.Type): javac.code.Type;
              _asInstTypes(ts: javac.util.List<javac.code.Type>): javac.util.List<javac.code.Type>;
              asUndetVar(t: javac.code.Type): javac.code.Type;
              _asUndetVars(ts: javac.util.List<javac.code.Type>): javac.util.List<javac.code.Type>;
              _boundedVars(): javac.util.List<javac.code.Type>;
              _cachedCapture(tree: javac.tree.JCTree, t: javac.code.Type, readOnly: boolean): javac.code.Type;
              _dupTo(that: InferenceContext): void;
              _dupTo(that: InferenceContext, clone: boolean): void;
              _filterVars(fu: java.util.function.Predicate<javac.code.Type$UndetVar>): javac.util.List<javac.code.Type>;
              _free(t: javac.code.Type): boolean;
              _free(ts: javac.util.List<javac.code.Type>): boolean;
              _freeVarsIn(t: javac.code.Type): javac.util.List<javac.code.Type>;
              _freeVarsIn(ts: javac.util.List<javac.code.Type>): javac.util.List<javac.code.Type>;
              _inferenceVars(): javac.util.List<javac.code.Type>;
              _instTypes(): javac.util.List<javac.code.Type>;
              _instvars(): javac.util.List<javac.code.Type>;
              _min(roots: javac.util.List<javac.code.Type>, shouldSolve: boolean, warn: javac.util.Warner): InferenceContext;
              _notifyChange(): void;
              _notifyChange(inferredVars: javac.util.List<javac.code.Type>): void;
              _restvars(): javac.util.List<javac.code.Type>;
              rollback(saved_undet: javac.util.List<javac.code.Type>): void;
              save(): javac.util.List<javac.code.Type>;
              _solve(ss: Infer$GraphStrategy, warn: javac.util.Warner): void;
              solve(warn: javac.util.Warner): void;
              solve(vars: javac.util.List<javac.code.Type>, warn: javac.util.Warner): void;
              solveAny(varsToSolve: javac.util.List<javac.code.Type>, warn: javac.util.Warner): void;
              _solveBasic(varsToSolve: javac.util.List<javac.code.Type>, steps: java.util.EnumSet<Infer$InferenceStep>): javac.util.List<javac.code.Type>;
              toString(): string;
              undetVars(): javac.util.List<javac.code.Type>;
              _update(t: javac.code.Type): javac.code.Type;
              _captureTypeCache: java.util.Map<javac.tree.JCTree,javac.code.Type>;
              _freeTypeListeners: java.util.Map<Infer$FreeTypeListener,javac.util.List<javac.code.Type>>;
              _infer: Infer;
              _inferencevars: javac.util.List<javac.code.Type>;
              _types: javac.code.Types;
              _undetvars: javac.util.List<javac.code.Type>;
            }
            interface InferenceContext extends CombineTypes<[_InferenceContext, java.lang.Object]> {}
            interface _InferenceContext$ReachabilityVisitor$$static extends ClassLike {
              _new(this$0: InferenceContext): InferenceContext$ReachabilityVisitor;
            }
            let InferenceContext$ReachabilityVisitor: _InferenceContext$ReachabilityVisitor$$static;
            interface _InferenceContext$ReachabilityVisitor {
              _isEquiv(from: javac.code.Type$UndetVar, t: javac.code.Type, boundKind: javac.code.Type$UndetVar$InferenceBound): boolean;
              _scan(roots: javac.util.List<javac.code.Type>): void;
              visitArrayType(t: javac.code.Type$ArrayType, _unused: java.lang.Void): java.lang.Void;
              visitArrayType(a0: javac.code.Type$ArrayType, a1: any): any;
              visitClassType(t: javac.code.Type$ClassType, _unused: java.lang.Void): java.lang.Void;
              visitClassType(a0: javac.code.Type$ClassType, a1: any): any;
              visitType(t: javac.code.Type, _unused: java.lang.Void): java.lang.Void;
              visitType(a0: javac.code.Type, a1: any): any;
              visitTypeVar(t: javac.code.Type$TypeVar, aVoid: java.lang.Void): java.lang.Void;
              visitTypeVar(a0: javac.code.Type$TypeVar, a1: any): any;
              visitUndetVar(t: javac.code.Type$UndetVar, _unused: java.lang.Void): java.lang.Void;
              visitUndetVar(a0: javac.code.Type$UndetVar, a1: any): any;
              visitWildcardType(t: javac.code.Type$WildcardType, _unused: java.lang.Void): java.lang.Void;
              visitWildcardType(a0: javac.code.Type$WildcardType, a1: any): any;
              _equiv: java.util.Set<javac.code.Type>;
              _min: java.util.Set<javac.code.Type>;
              _minMap: java.util.Map<javac.code.Type,java.util.Set<javac.code.Type>>;
              _this$0: InferenceContext;
            }
            interface InferenceContext$ReachabilityVisitor extends CombineTypes<[_InferenceContext$ReachabilityVisitor, javac.code.Types$UnaryVisitor<java.lang.Void>]> {}
            interface _LambdaToMethod$$static extends ClassLike {
              instance(context: javac.util.Context): LambdaToMethod;
              readonly FLAG_BRIDGES: int;
              readonly FLAG_MARKERS: int;
              readonly FLAG_SERIALIZABLE: int;
              _unlambdaKey: javac.util.Context$Key<LambdaToMethod>;
            }
            let LambdaToMethod: _LambdaToMethod$$static;
            interface _LambdaToMethod {
              _addDeserializationCase(refSym: javac.code.Symbol$MethodHandleSymbol, targetType: javac.code.Type, samSym: javac.code.Symbol$MethodSymbol, pos: javac.util.JCDiagnostic$DiagnosticPosition, staticArgs: javac.util.List<javac.jvm.PoolConstant$LoadableConstant>, indyType: javac.code.Type$MethodType): void;
              _apportionTypeAnnotations(tree: javac.tree.JCTree$JCLambda, source: java.util.function.Supplier<javac.util.List<javac.code.Attribute$TypeCompound>>, owner: java.util.function.Consumer<javac.util.List<javac.code.Attribute$TypeCompound>>, lambda: java.util.function.Consumer<javac.util.List<javac.code.Attribute$TypeCompound>>): void;
              _classSig(type: javac.code.Type): string;
              _convertArgs(meth: javac.code.Symbol, args: javac.util.List<javac.tree.JCTree$JCExpression>, varargsElement: javac.code.Type): javac.util.List<javac.tree.JCTree$JCExpression>;
              _deserGetter(func: string, type: javac.code.Type): javac.tree.JCTree$JCExpression;
              _deserGetter(func: string, type: javac.code.Type, argTypes: javac.util.List<javac.code.Type>, args: javac.util.List<javac.tree.JCTree$JCExpression>): javac.tree.JCTree$JCExpression;
              _deserTest(prev: javac.tree.JCTree$JCExpression, func: string, lit: string): javac.tree.JCTree$JCExpression;
              _eqTest(argType: javac.code.Type, arg1: javac.tree.JCTree$JCExpression, arg2: javac.tree.JCTree$JCExpression): javac.tree.JCTree$JCExpression;
              _isProtectedInSuperClassOfEnclosingClassInOtherPackage(targetReference: javac.code.Symbol, currentClass: javac.code.Symbol): boolean;
              _makeDeserializeMethod(kSym: javac.code.Symbol): javac.tree.JCTree$JCMethodDecl;
              _makeIndyCall(pos: javac.util.JCDiagnostic$DiagnosticPosition, site: javac.code.Type, bsmName: javac.util.Name, staticArgs: javac.util.List<javac.jvm.PoolConstant$LoadableConstant>, indyType: javac.code.Type$MethodType, indyArgs: javac.util.List<javac.tree.JCTree$JCExpression>, methName: javac.util.Name): javac.tree.JCTree$JCExpression;
              _makeLambdaBody(tree: javac.tree.JCTree$JCLambda, lambdaMethodDecl: javac.tree.JCTree$JCMethodDecl): javac.tree.JCTree$JCBlock;
              _makeLambdaExpressionBody(expr: javac.tree.JCTree$JCExpression, lambdaMethodDecl: javac.tree.JCTree$JCMethodDecl): javac.tree.JCTree$JCBlock;
              _makeLambdaStatementBody(block: javac.tree.JCTree$JCBlock, lambdaMethodDecl: javac.tree.JCTree$JCMethodDecl, completeNormally: boolean): javac.tree.JCTree$JCBlock;
              _makeMetafactoryIndyCall(context: LambdaToMethod$LambdaAnalyzerPreprocessor$TranslationContext<any>, refSym: javac.code.Symbol$MethodHandleSymbol, indy_args: javac.util.List<javac.tree.JCTree$JCExpression>): javac.tree.JCTree$JCExpression;
              _makeNewClass(ctype: javac.code.Type, args: javac.util.List<javac.tree.JCTree$JCExpression>, cons: javac.code.Symbol): javac.tree.JCTree$JCNewClass;
              _makeNewClass(ctype: javac.code.Type, args: javac.util.List<javac.tree.JCTree$JCExpression>): javac.tree.JCTree$JCNewClass;
              _makePrivateSyntheticMethod(flags: long, a1: javac.util.Name, name: javac.code.Type, type: javac.code.Symbol): javac.code.Symbol$MethodSymbol;
              _makeSyntheticVar(flags: long, a1: javac.util.Name, name: javac.code.Type, type: javac.code.Symbol): javac.code.Symbol$VarSymbol;
              _makeThis(type: javac.code.Type, owner: javac.code.Symbol): javac.tree.JCTree$JCIdent;
              _setVarargsIfNeeded(tree: javac.tree.JCTree, varargsElement: javac.code.Type): void;
              translate<T>(tree: T): T;
              _translate<T>(tree: T, newContext: LambdaToMethod$LambdaAnalyzerPreprocessor$TranslationContext<any>): T;
              _translate<T>(trees: javac.util.List<T>, newContext: LambdaToMethod$LambdaAnalyzerPreprocessor$TranslationContext<any>): javac.util.List<T>;
              translateTopLevelClass(env: Env<AttrContext>, cdef: javac.tree.JCTree, make: javac.tree.TreeMaker): javac.tree.JCTree;
              _typeSig(type: javac.code.Type): string;
              _typeSig(type: javac.code.Type, allowIllegalSignature: boolean): string;
              _typeToMethodType(mt: javac.code.Type): javac.code.Type$MethodType;
              visitClassDef(tree: javac.tree.JCTree$JCClassDecl): void;
              visitIdent(tree: javac.tree.JCTree$JCIdent): void;
              visitLambda(tree: javac.tree.JCTree$JCLambda): void;
              visitNewClass(tree: javac.tree.JCTree$JCNewClass): void;
              visitReference(tree: javac.tree.JCTree$JCMemberReference): void;
              visitSelect(tree: javac.tree.JCTree$JCFieldAccess): void;
              visitVarDef(tree: javac.tree.JCTree$JCVariableDecl): void;
              _analyzer: LambdaToMethod$LambdaAnalyzerPreprocessor;
              _attr: Attr;
              _attrEnv: Env<AttrContext>;
              _context: LambdaToMethod$LambdaAnalyzerPreprocessor$TranslationContext<any>;
              _contextMap: java.util.Map<javac.tree.JCTree,LambdaToMethod$LambdaAnalyzerPreprocessor$TranslationContext<any>>;
              _debugLinesOrVars: boolean;
              _deduplicateLambdas: boolean;
              _diags: javac.util.JCDiagnostic$Factory;
              _dumpLambdaToMethodStats: boolean;
              _forceSerializable: boolean;
              _kInfo: LambdaToMethod$KlassInfo;
              _log: javac.util.Log;
              _lower: Lower;
              _make: javac.tree.TreeMaker;
              _names: javac.util.Names;
              _nestmateLambdas: boolean;
              _operators: Operators;
              _rs: Resolve;
              _syms: javac.code.Symtab;
              _transTypes: TransTypes;
              _types: javac.code.Types;
              _verboseDeduplication: boolean;
            }
            interface LambdaToMethod extends CombineTypes<[_LambdaToMethod, com.sun.tools.javac.tree.TreeTranslator]> {}
            interface _LambdaToMethod$DedupedLambda$$static extends ClassLike {
              _new(this$0: LambdaToMethod, symbol: javac.code.Symbol$MethodSymbol, tree: javac.tree.JCTree): LambdaToMethod$DedupedLambda;
            }
            let LambdaToMethod$DedupedLambda: _LambdaToMethod$DedupedLambda$$static;
            interface _LambdaToMethod$DedupedLambda {
              equals(o: any): boolean;
              hashCode(): int;
              _hashCode: int;
              _symbol: javac.code.Symbol$MethodSymbol;
              _this$0: LambdaToMethod;
              _tree: javac.tree.JCTree;
            }
            interface LambdaToMethod$DedupedLambda extends CombineTypes<[_LambdaToMethod$DedupedLambda, java.lang.Object]> {}
            interface _LambdaToMethod$KlassInfo$$static extends ClassLike {
            }
            let LambdaToMethod$KlassInfo: _LambdaToMethod$KlassInfo$$static;
            interface _LambdaToMethod$KlassInfo {
              _addMethod(decl: javac.tree.JCTree): void;
              _appendedMethodList: javac.util.ListBuffer<javac.tree.JCTree>;
              _clazz: javac.tree.JCTree$JCClassDecl;
              _dedupedLambdas: java.util.Map<LambdaToMethod$DedupedLambda,LambdaToMethod$DedupedLambda>;
              _deserMethodSym: javac.code.Symbol$MethodSymbol;
              _deserParamSym: javac.code.Symbol$VarSymbol;
              _deserializeCases: java.util.Map<string,javac.util.ListBuffer<javac.tree.JCTree$JCStatement>>;
              _dynMethSyms: java.util.Map<any,javac.code.Symbol$DynamicMethodSymbol>;
            }
            interface LambdaToMethod$KlassInfo extends CombineTypes<[_LambdaToMethod$KlassInfo, java.lang.Object]> {}
            interface _LambdaToMethod$L2MSignatureGenerator$$static extends ClassLike {
              _new(a0: LambdaToMethod, allowIllegalSignatures: boolean): LambdaToMethod$L2MSignatureGenerator;
            }
            let LambdaToMethod$L2MSignatureGenerator: _LambdaToMethod$L2MSignatureGenerator$$static;
            interface _LambdaToMethod$L2MSignatureGenerator {
              _append(ch: char): void;
              _append(ba: byte[]): void;
              _append(name: javac.util.Name): void;
              _reportIllegalSignature(t: javac.code.Type): void;
              toString(): string;
              _allowIllegalSignatures: boolean;
              _sb: comp$stringBuilder;
              _this$0: LambdaToMethod;
            }
            interface LambdaToMethod$L2MSignatureGenerator extends CombineTypes<[_LambdaToMethod$L2MSignatureGenerator, com.sun.tools.javac.code.Types$SignatureGenerator]> {}
            interface _LambdaToMethod$LambdaAnalyzerPreprocessor$$static extends ClassLike {
              _new(this$0: LambdaToMethod): LambdaToMethod$LambdaAnalyzerPreprocessor;
            }
            let LambdaToMethod$LambdaAnalyzerPreprocessor: _LambdaToMethod$LambdaAnalyzerPreprocessor$$static;
            interface _LambdaToMethod$LambdaAnalyzerPreprocessor {
              _analyzeAndPreprocessClass(tree: javac.tree.JCTree$JCClassDecl): javac.tree.JCTree$JCClassDecl;
              _analyzeLambda(tree: javac.tree.JCTree$JCLambda, methodReferenceReceiver: javac.tree.JCTree$JCExpression): void;
              _analyzeLambda(tree: javac.tree.JCTree$JCLambda, statKey: string): LambdaToMethod$LambdaAnalyzerPreprocessor$LambdaTranslationContext;
              _captureLocalClassDefs(csym: javac.code.Symbol, lambdaContext: LambdaToMethod$LambdaAnalyzerPreprocessor$LambdaTranslationContext): void;
              _capturedDecl(depth: int, sym: javac.code.Symbol): javac.tree.JCTree;
              _context(): LambdaToMethod$LambdaAnalyzerPreprocessor$TranslationContext<any>;
              _currentClass(): javac.code.Symbol$ClassSymbol;
              _currentlyInClass(csym: javac.code.Symbol): boolean;
              _directlyEnclosingLambda(): javac.tree.JCTree;
              _inClassWithinLambda(): boolean;
              _initSym(csym: javac.code.Symbol$ClassSymbol, flags: long): javac.code.Symbol;
              _lambdaFieldAccessFilter(fAccess: javac.tree.JCTree$JCFieldAccess): boolean;
              _lambdaIdentSymbolFilter(sym: javac.code.Symbol): boolean;
              _lambdaNewClassFilter(context: LambdaToMethod$LambdaAnalyzerPreprocessor$TranslationContext<any>, tree: javac.tree.JCTree$JCNewClass): boolean;
              _owner(): javac.code.Symbol;
              _owner(skipLambda: boolean): javac.code.Symbol;
              visitApply(tree: javac.tree.JCTree$JCMethodInvocation): void;
              visitBlock(tree: javac.tree.JCTree$JCBlock): void;
              visitClassDef(tree: javac.tree.JCTree$JCClassDecl): void;
              visitIdent(tree: javac.tree.JCTree$JCIdent): void;
              visitLambda(tree: javac.tree.JCTree$JCLambda): void;
              visitMethodDef(tree: javac.tree.JCTree$JCMethodDecl): void;
              visitNewClass(tree: javac.tree.JCTree$JCNewClass): void;
              visitReference(tree: javac.tree.JCTree$JCMemberReference): void;
              visitSelect(tree: javac.tree.JCTree$JCFieldAccess): void;
              visitVarDef(tree: javac.tree.JCTree$JCVariableDecl): void;
              _clinits: java.util.Map<javac.code.Symbol$ClassSymbol,javac.code.Symbol>;
              _frameStack: javac.util.List<LambdaToMethod$LambdaAnalyzerPreprocessor$Frame>;
              _lambdaCount: int;
              _localClassDefs: java.util.Map<javac.code.Symbol,javac.tree.JCTree$JCClassDecl>;
              _syntheticMethodNameCounts: LambdaToMethod$LambdaAnalyzerPreprocessor$SyntheticMethodNameCounter;
              _this$0: LambdaToMethod;
              _typesUnderConstruction: javac.util.List<javac.code.Symbol$ClassSymbol>;
            }
            interface LambdaToMethod$LambdaAnalyzerPreprocessor extends CombineTypes<[_LambdaToMethod$LambdaAnalyzerPreprocessor, com.sun.tools.javac.tree.TreeTranslator]> {}
            interface _LambdaToMethod$LambdaAnalyzerPreprocessor$Frame$$static extends ClassLike {
              new(a0: LambdaToMethod$LambdaAnalyzerPreprocessor, tree: javac.tree.JCTree): LambdaToMethod$LambdaAnalyzerPreprocessor$Frame;
            }
            let LambdaToMethod$LambdaAnalyzerPreprocessor$Frame: _LambdaToMethod$LambdaAnalyzerPreprocessor$Frame$$static;
            interface _LambdaToMethod$LambdaAnalyzerPreprocessor$Frame {
              _addLocal(sym: javac.code.Symbol): void;
              _locals: javac.util.List<javac.code.Symbol>;
              _tree: javac.tree.JCTree;
            }
            interface LambdaToMethod$LambdaAnalyzerPreprocessor$Frame extends CombineTypes<[_LambdaToMethod$LambdaAnalyzerPreprocessor$Frame, java.lang.Object]> {}
            interface _LambdaToMethod$LambdaAnalyzerPreprocessor$LambdaTranslationContext$$static extends ClassLike {
              _new(this$1: LambdaToMethod$LambdaAnalyzerPreprocessor, tree: javac.tree.JCTree$JCLambda): LambdaToMethod$LambdaAnalyzerPreprocessor$LambdaTranslationContext;
            }
            let LambdaToMethod$LambdaAnalyzerPreprocessor$LambdaTranslationContext: _LambdaToMethod$LambdaAnalyzerPreprocessor$LambdaTranslationContext$$static;
            interface _LambdaToMethod$LambdaAnalyzerPreprocessor$LambdaTranslationContext {
              _addSymbol(sym: javac.code.Symbol, skind: LambdaToMethod$LambdaSymbolKind): void;
              _complete(): void;
              _generatedLambdaSig(): javac.code.Type;
              _getSymbolMap(skind: LambdaToMethod$LambdaSymbolKind): java.util.Map<javac.code.Symbol,javac.code.Symbol>;
              _lambdaName(): javac.util.Name;
              _serializedLambdaDisambiguation(): string;
              _serializedLambdaName(): javac.util.Name;
              _translate(sym: javac.code.Symbol, skind: LambdaToMethod$LambdaSymbolKind): javac.code.Symbol;
              _translate(lambdaIdent: javac.tree.JCTree$JCIdent): javac.tree.JCTree;
              translate(fieldAccess: javac.tree.JCTree$JCFieldAccess): javac.tree.JCTree;
              translate(newClass: javac.tree.JCTree$JCNewClass): javac.tree.JCTree$JCNewClass;
              _assignedTo: javac.code.Symbol;
              _freeVarProcessedLocalClasses: java.util.Set<javac.code.Symbol>;
              _methodReferenceReceiver: javac.tree.JCTree$JCExpression;
              _self: javac.code.Symbol;
              _syntheticParams: javac.util.List<javac.tree.JCTree$JCVariableDecl>;
              _this$1: LambdaToMethod$LambdaAnalyzerPreprocessor;
              _translatedSym: javac.code.Symbol$MethodSymbol;
              _translatedSymbols: java.util.Map<LambdaToMethod$LambdaSymbolKind,java.util.Map<javac.code.Symbol,javac.code.Symbol>>;
            }
            interface LambdaToMethod$LambdaAnalyzerPreprocessor$LambdaTranslationContext extends CombineTypes<[_LambdaToMethod$LambdaAnalyzerPreprocessor$LambdaTranslationContext, LambdaToMethod$LambdaAnalyzerPreprocessor$TranslationContext<javac.tree.JCTree$JCLambda>]> {}
            interface _LambdaToMethod$LambdaAnalyzerPreprocessor$ReferenceTranslationContext$$static extends ClassLike {
              _new(this$1: LambdaToMethod$LambdaAnalyzerPreprocessor, tree: javac.tree.JCTree$JCMemberReference): LambdaToMethod$LambdaAnalyzerPreprocessor$ReferenceTranslationContext;
            }
            let LambdaToMethod$LambdaAnalyzerPreprocessor$ReferenceTranslationContext: _LambdaToMethod$LambdaAnalyzerPreprocessor$ReferenceTranslationContext$$static;
            interface _LambdaToMethod$LambdaAnalyzerPreprocessor$ReferenceTranslationContext {
              _bridgedRefSig(): javac.code.Type;
              _generatedRefSig(): javac.code.Type;
              _interfaceParameterIsIntersectionOrUnionType(): boolean;
              _isArrayOp(): boolean;
              _isIntersectionOrUnionType(t: javac.code.Type): boolean;
              _isPrivateInOtherClass(): boolean;
              _needsConversionToLambda(): boolean;
              _needsVarArgsConversion(): boolean;
              _receiverAccessible(): boolean;
              _isSuper: boolean;
              _this$1: LambdaToMethod$LambdaAnalyzerPreprocessor;
            }
            interface LambdaToMethod$LambdaAnalyzerPreprocessor$ReferenceTranslationContext extends CombineTypes<[_LambdaToMethod$LambdaAnalyzerPreprocessor$ReferenceTranslationContext, LambdaToMethod$LambdaAnalyzerPreprocessor$TranslationContext<javac.tree.JCTree$JCMemberReference>]> {}
            interface _LambdaToMethod$LambdaAnalyzerPreprocessor$SyntheticMethodNameCounter$$static extends ClassLike {
            }
            let LambdaToMethod$LambdaAnalyzerPreprocessor$SyntheticMethodNameCounter: _LambdaToMethod$LambdaAnalyzerPreprocessor$SyntheticMethodNameCounter$$static;
            interface _LambdaToMethod$LambdaAnalyzerPreprocessor$SyntheticMethodNameCounter {
              _getIndex(buf: LambdaToMethod$LambdaAnalyzerPreprocessor$SyntheticMethodNameCounter$stringBuilder): int;
              _map: java.util.Map<string,int>;
            }
            interface LambdaToMethod$LambdaAnalyzerPreprocessor$SyntheticMethodNameCounter extends CombineTypes<[_LambdaToMethod$LambdaAnalyzerPreprocessor$SyntheticMethodNameCounter, java.lang.Object]> {}
            interface _LambdaToMethod$LambdaAnalyzerPreprocessor$TranslationContext$$static<T> extends ClassLike {
              _new(this$1: T): LambdaToMethod$LambdaAnalyzerPreprocessor$TranslationContext<T>;
            }
            let LambdaToMethod$LambdaAnalyzerPreprocessor$TranslationContext: _LambdaToMethod$LambdaAnalyzerPreprocessor$TranslationContext$$static<T>;
            interface _LambdaToMethod$LambdaAnalyzerPreprocessor$TranslationContext<T> {
              _enclosingMethodName(): string;
              _isSerializable(): boolean;
              _needsAltMetafactory(): boolean;
              _syntheticMethodNameComponent(name: javac.util.Name): string;
              _bridges: javac.util.List<javac.code.Symbol>;
              _depth: int;
              _owner: javac.code.Symbol;
              _prev: LambdaToMethod$LambdaAnalyzerPreprocessor$TranslationContext<any>;
              _this$1: LambdaToMethod$LambdaAnalyzerPreprocessor;
              _tree: T;
            }
            interface LambdaToMethod$LambdaAnalyzerPreprocessor$TranslationContext<T> extends CombineTypes<[_LambdaToMethod$LambdaAnalyzerPreprocessor$TranslationContext<T>, java.lang.Object]> {}
            interface _LambdaToMethod$LambdaSymbolKind$$static extends ClassLike {
              valueOf(name: string): LambdaToMethod$LambdaSymbolKind;
              values(): LambdaToMethod$LambdaSymbolKind[];
              readonly CAPTURED_OUTER_THIS: LambdaToMethod$LambdaSymbolKind;
              readonly CAPTURED_THIS: LambdaToMethod$LambdaSymbolKind;
              readonly CAPTURED_VAR: LambdaToMethod$LambdaSymbolKind;
              readonly LOCAL_VAR: LambdaToMethod$LambdaSymbolKind;
              readonly PARAM: LambdaToMethod$LambdaSymbolKind;
            }
            let LambdaToMethod$LambdaSymbolKind: _LambdaToMethod$LambdaSymbolKind$$static;
            interface _LambdaToMethod$LambdaSymbolKind {
              _propagateAnnotations(): boolean;
            }
            interface LambdaToMethod$LambdaSymbolKind extends CombineTypes<[_LambdaToMethod$LambdaSymbolKind]> {}
            interface _LambdaToMethod$MemberReferenceToLambda$$static extends ClassLike {
              _new(a0: LambdaToMethod, tree: javac.tree.JCTree$JCMemberReference, localContext: LambdaToMethod$LambdaAnalyzerPreprocessor$ReferenceTranslationContext, owner: javac.code.Symbol): LambdaToMethod$MemberReferenceToLambda;
            }
            let LambdaToMethod$MemberReferenceToLambda: _LambdaToMethod$MemberReferenceToLambda$$static;
            interface _LambdaToMethod$MemberReferenceToLambda {
              _addParameter(name: string, p: javac.code.Type, genArg: boolean): javac.code.Symbol$VarSymbol;
              _addParametersReturnReceiver(): javac.code.Symbol$VarSymbol;
              _expressionInvoke(rcvr: javac.code.Symbol$VarSymbol): javac.tree.JCTree$JCExpression;
              _expressionNew(): javac.tree.JCTree$JCExpression;
              _getReceiverExpression(): javac.tree.JCTree$JCExpression;
              _lambda(): javac.tree.JCTree$JCLambda;
              _makeReceiver(rcvr: javac.code.Symbol$VarSymbol): javac.tree.JCTree$JCExpression;
              _args: javac.util.ListBuffer<javac.tree.JCTree$JCExpression>;
              _localContext: LambdaToMethod$LambdaAnalyzerPreprocessor$ReferenceTranslationContext;
              _owner: javac.code.Symbol;
              _params: javac.util.ListBuffer<javac.tree.JCTree$JCVariableDecl>;
              _receiverExpression: javac.tree.JCTree$JCExpression;
              _this$0: LambdaToMethod;
              _tree: javac.tree.JCTree$JCMemberReference;
            }
            interface LambdaToMethod$MemberReferenceToLambda extends CombineTypes<[_LambdaToMethod$MemberReferenceToLambda, java.lang.Object]> {}
            interface _Lower$$static extends ClassLike {
              _accessCode(tree: javac.tree.JCTree, enclOp: javac.tree.JCTree): int;
              instance(context: javac.util.Context): Lower;
              _treeTag(operator: javac.code.Symbol$OperatorSymbol): javac.tree.JCTree$Tag;
              _lowerKey: javac.util.Context$Key<Lower>;
              _new(context: javac.util.Context): Lower;
            }
            let Lower: _Lower$$static;
            interface _Lower {
              _abstractLval(lval: javac.tree.JCTree$JCExpression, builder: Lower$TreeBuilder): javac.tree.JCTree$JCExpression;
              _abstractRval(rval: javac.tree.JCTree$JCExpression, type: javac.code.Type, builder: Lower$TreeBuilder): javac.tree.JCTree$JCExpression;
              _abstractRval(rval: javac.tree.JCTree$JCExpression, builder: Lower$TreeBuilder): javac.tree.JCTree$JCExpression;
              _access(sym: javac.code.Symbol, tree: javac.tree.JCTree$JCExpression, enclOp: javac.tree.JCTree$JCExpression, refSuper: boolean): javac.tree.JCTree$JCExpression;
              _access(tree: javac.tree.JCTree$JCExpression): javac.tree.JCTree$JCExpression;
              _accessBase(pos: javac.util.JCDiagnostic$DiagnosticPosition, sym: javac.code.Symbol): javac.tree.JCTree$JCExpression;
              _accessClass(sym: javac.code.Symbol, protAccess: boolean, tree: javac.tree.JCTree): javac.code.Symbol$ClassSymbol;
              _accessConstructor(pos: javac.util.JCDiagnostic$DiagnosticPosition, constr: javac.code.Symbol): javac.code.Symbol;
              _accessConstructorDef(pos: int, constr: javac.code.Symbol, accessor: javac.code.Symbol$MethodSymbol): javac.tree.JCTree;
              _accessConstructorTag(): javac.code.Symbol$ClassSymbol;
              _accessDef(pos: int, vsym: javac.code.Symbol, accessor: javac.code.Symbol$MethodSymbol, acode: int): javac.tree.JCTree;
              _accessName(anum: int, acode: int): javac.util.Name;
              _accessSymbol(sym: javac.code.Symbol, tree: javac.tree.JCTree, enclOp: javac.tree.JCTree, protAccess: boolean, refSuper: boolean): javac.code.Symbol$MethodSymbol;
              _addDefaultIfNeeded(patternSwitch: boolean, wasEnumSelector: boolean, cases: javac.util.List<javac.tree.JCTree$JCCase>): javac.util.List<javac.tree.JCTree$JCCase>;
              _addPrunedInfo(tree: javac.tree.JCTree): void;
              _argsTypeSig(typeList: javac.util.List<javac.code.Type>): string;
              _assertFlagTest(pos: javac.util.JCDiagnostic$DiagnosticPosition): javac.tree.JCTree$JCExpression;
              _assertionsDisabledClass(): javac.code.Symbol$ClassSymbol;
              _binaryAccessOperator(acode: int, tag: javac.tree.JCTree$Tag): javac.code.Symbol$OperatorSymbol;
              _boxArgs(parameters: javac.util.List<javac.code.Type>, _args: javac.util.List<javac.tree.JCTree$JCExpression>, varargsElement: javac.code.Type): javac.util.List<javac.tree.JCTree$JCExpression>;
              _boxIfNeeded<T>(tree: T, type: javac.code.Type): T;
              _boxPrimitive(tree: javac.tree.JCTree$JCExpression): javac.tree.JCTree$JCExpression;
              _boxPrimitive(tree: javac.tree.JCTree$JCExpression, box: javac.code.Type): javac.tree.JCTree$JCExpression;
              _checkAccessConstructorTags(): void;
              _checkConflicts(translatedTrees: javac.util.List<javac.tree.JCTree>): void;
              _classDef(c: javac.code.Symbol$ClassSymbol): javac.tree.JCTree$JCClassDecl;
              _classOf(clazz: javac.tree.JCTree): javac.tree.JCTree$JCExpression;
              _classOfType(type: javac.code.Type, pos: javac.util.JCDiagnostic$DiagnosticPosition): javac.tree.JCTree$JCExpression;
              _convert(tree: javac.tree.JCTree$JCExpression, pt: javac.code.Type): javac.tree.JCTree$JCExpression;
              _createInfoClass(annots: javac.util.List<javac.tree.JCTree$JCAnnotation>, c: javac.code.Symbol$ClassSymbol): void;
              _enterSynthetic(pos: javac.util.JCDiagnostic$DiagnosticPosition, sym: javac.code.Symbol, s: javac.code.Scope$WriteableScope): void;
              _enumNamesFor(c: javac.code.Symbol$ClassSymbol): javac.util.List<javac.util.Name>;
              _expValue(exp: javac.tree.JCTree): boolean;
              _expValueIsNull(eq: boolean, t: javac.tree.JCTree): boolean;
              _freevarDefs(pos: int, freevars: javac.util.List<javac.code.Symbol$VarSymbol>, owner: javac.code.Symbol): javac.util.List<javac.tree.JCTree$JCVariableDecl>;
              _freevarDefs(pos: int, freevars: javac.util.List<javac.code.Symbol$VarSymbol>, owner: javac.code.Symbol, additionalFlags: long): javac.util.List<javac.tree.JCTree$JCVariableDecl>;
              _freevars(c: javac.code.Symbol$ClassSymbol): javac.util.List<javac.code.Symbol$VarSymbol>;
              _generateMandatedAccessors(tree: javac.tree.JCTree$JCClassDecl): javac.util.List<javac.tree.JCTree>;
              _generateRecordMethod(tree: javac.tree.JCTree$JCClassDecl, name: javac.util.Name, vars: javac.util.List<javac.code.Symbol$VarSymbol>, getterMethHandles: javac.code.Symbol$MethodHandleSymbol[]): javac.tree.JCTree;
              _handleSwitch(tree: javac.tree.JCTree, selector: javac.tree.JCTree$JCExpression, cases: javac.util.List<javac.tree.JCTree$JCCase>): void;
              _initField(pos: int, rhs: javac.code.Symbol, lhs: javac.code.Symbol): javac.tree.JCTree$JCStatement;
              _initOuterThis(pos: int, rhs: javac.code.Symbol$VarSymbol): javac.tree.JCTree$JCStatement;
              _isFalse(exp: javac.tree.JCTree): boolean;
              _isTranslatedClassAvailable(c: javac.code.Symbol$ClassSymbol): boolean;
              _isTrue(exp: javac.tree.JCTree): boolean;
              _loadFreevar(pos: javac.util.JCDiagnostic$DiagnosticPosition, v: javac.code.Symbol$VarSymbol): javac.tree.JCTree$JCExpression;
              _loadFreevars(pos: javac.util.JCDiagnostic$DiagnosticPosition, freevars: javac.util.List<javac.code.Symbol$VarSymbol>): javac.util.List<javac.tree.JCTree$JCExpression>;
              _lookupMethod(pos: javac.util.JCDiagnostic$DiagnosticPosition, name: javac.util.Name, qual: javac.code.Type, args: javac.util.List<javac.code.Type>): javac.code.Symbol$MethodSymbol;
              _lookupSynthetic(name: javac.util.Name, s: javac.code.Scope): javac.code.Symbol;
              _lowerBoxedPostop(tree: javac.tree.JCTree$JCUnary): javac.tree.JCTree$JCExpression;
              _makeAccessible(sym: javac.code.Symbol): void;
              _makeAssignop(optag: javac.tree.JCTree$Tag, lhs: javac.tree.JCTree, rhs: javac.tree.JCTree): javac.tree.JCTree$JCAssignOp;
              _makeBinary(optag: javac.tree.JCTree$Tag, lhs: javac.tree.JCTree$JCExpression, rhs: javac.tree.JCTree$JCExpression): javac.tree.JCTree$JCBinary;
              _makeCall(left: javac.tree.JCTree$JCExpression, name: javac.util.Name, args: javac.util.List<javac.tree.JCTree$JCExpression>): javac.tree.JCTree$JCMethodInvocation;
              _makeComma(expr1: javac.tree.JCTree$JCExpression, expr2: javac.tree.JCTree$JCExpression): javac.tree.JCTree$JCExpression;
              _makeEmptyClass(flags: long, a1: javac.code.Symbol$ClassSymbol): javac.tree.JCTree$JCClassDecl;
              _makeEmptyClass(flags: long, a1: javac.code.Symbol$ClassSymbol, owner: javac.util.Name, flatname: boolean): javac.tree.JCTree$JCClassDecl;
              _makeIndyQualifier(site: javac.code.Type, tree: javac.tree.JCTree$JCClassDecl, msym: javac.code.Symbol$MethodSymbol, staticArgTypes: javac.util.List<javac.code.Type>, staticArgValues: javac.jvm.PoolConstant$LoadableConstant[], bootstrapName: javac.util.Name, argName: javac.util.Name, isStatic: boolean): javac.tree.JCTree$JCFieldAccess;
              _makeLit(type: javac.code.Type, value: any): javac.tree.JCTree$JCExpression;
              _makeNewClass(ctype: javac.code.Type, args: javac.util.List<javac.tree.JCTree$JCExpression>): javac.tree.JCTree$JCNewClass;
              _makeNonNullCheck(expression: javac.tree.JCTree$JCExpression): javac.tree.JCTree$JCExpression;
              _makeNull(): javac.tree.JCTree$JCExpression;
              _makeOuterThis(pos: javac.util.JCDiagnostic$DiagnosticPosition, c: javac.code.Symbol$TypeSymbol): javac.tree.JCTree$JCExpression;
              _makeOuterThisVarDecl(pos: int, sym: javac.code.Symbol$VarSymbol): javac.tree.JCTree$JCVariableDecl;
              _makeOuterThisVarSymbol(owner: javac.code.Symbol, flags: long): javac.code.Symbol$VarSymbol;
              _makeOwnerThis(pos: javac.util.JCDiagnostic$DiagnosticPosition, sym: javac.code.Symbol, preciseMatch: boolean): javac.tree.JCTree$JCExpression;
              _makeOwnerThisN(pos: javac.util.JCDiagnostic$DiagnosticPosition, sym: javac.code.Symbol, preciseMatch: boolean): javac.tree.JCTree$JCExpression;
              _makeResourceCloseInvocation(resource: javac.tree.JCTree$JCExpression): javac.tree.JCTree$JCStatement;
              _makeString(tree: javac.tree.JCTree$JCExpression): javac.tree.JCTree$JCExpression;
              _makeSyntheticName(name: javac.util.Name, s: javac.code.Scope): javac.util.Name;
              _makeThis(pos: javac.util.JCDiagnostic$DiagnosticPosition, c: javac.code.Symbol$TypeSymbol): javac.tree.JCTree$JCExpression;
              _makeTranslationMap(tree: javac.tree.JCTree$JCMethodDecl): java.util.Map<javac.code.Symbol,javac.code.Symbol>;
              _makeTwrBlock(resources: javac.util.List<javac.tree.JCTree>, block: javac.tree.JCTree$JCBlock, depth: int): javac.tree.JCTree$JCBlock;
              _makeTwrTry(tree: javac.tree.JCTree$JCTry): javac.tree.JCTree;
              _makeUnary(optag: javac.tree.JCTree$Tag, arg: javac.tree.JCTree$JCExpression): javac.tree.JCTree$JCUnary;
              _make_at(pos: javac.util.JCDiagnostic$DiagnosticPosition): javac.tree.TreeMaker;
              _mapForEnum(pos: javac.util.JCDiagnostic$DiagnosticPosition, enumClass: javac.code.Symbol$TypeSymbol): Lower$EnumMapping;
              _needPackageInfoClass(pd: javac.tree.JCTree$JCPackageDecl): boolean;
              _needsPrivateAccess(sym: javac.code.Symbol): boolean;
              _needsProtectedAccess(sym: javac.code.Symbol, tree: javac.tree.JCTree): boolean;
              _outerCacheClass(): javac.code.Symbol$ClassSymbol;
              _outerThisDef(pos: int, owner: javac.code.Symbol$MethodSymbol): javac.tree.JCTree$JCVariableDecl;
              _outerThisDef(pos: int, owner: javac.code.Symbol$ClassSymbol): javac.tree.JCTree$JCVariableDecl;
              _outerThisName(type: javac.code.Type, owner: javac.code.Symbol): javac.util.Name;
              _ownerToCopyFreeVarsFrom(c: javac.code.Symbol$ClassSymbol): javac.code.Symbol$ClassSymbol;
              _patchTargets(body: javac.tree.JCTree, src: javac.tree.JCTree, dest: javac.tree.JCTree): void;
              _proxyName(name: javac.util.Name, index: int): javac.util.Name;
              _recordVars(t: javac.code.Type): javac.util.List<javac.code.Symbol$VarSymbol>;
              _shouldEmitOuterThis(sym: javac.code.Symbol$ClassSymbol): boolean;
              _swapAccessConstructorTag(oldCTag: javac.code.Symbol$ClassSymbol, newCTag: javac.code.Symbol$ClassSymbol): void;
              _syntheticName(tree: javac.tree.JCTree$JCClassDecl, baseName: string): javac.util.Name;
              translate<T>(tree: T): T;
              translate<T>(tree: T, type: javac.code.Type): T;
              translate<T>(tree: T, enclOp: javac.tree.JCTree$JCExpression): T;
              translate<T>(trees: javac.util.List<T>, type: javac.code.Type): javac.util.List<T>;
              translateTopLevelClass(env: Env<AttrContext>, cdef: javac.tree.JCTree, make: javac.tree.TreeMaker): javac.util.List<javac.tree.JCTree>;
              _unbox(tree: javac.tree.JCTree$JCExpression, primitive: javac.code.Type): javac.tree.JCTree$JCExpression;
              _useClone(): boolean;
              visitAnnotation(tree: javac.tree.JCTree$JCAnnotation): void;
              visitApply(tree: javac.tree.JCTree$JCMethodInvocation): void;
              _visitArrayForeachLoop(tree: javac.tree.JCTree$JCEnhancedForLoop): void;
              visitAssert(tree: javac.tree.JCTree$JCAssert): void;
              visitAssign(tree: javac.tree.JCTree$JCAssign): void;
              visitAssignop(tree: javac.tree.JCTree$JCAssignOp): void;
              visitBinary(tree: javac.tree.JCTree$JCBinary): void;
              visitBlock(tree: javac.tree.JCTree$JCBlock): void;
              _visitBoxedPrimitiveSwitch(tree: javac.tree.JCTree, selector: javac.tree.JCTree$JCExpression, cases: javac.util.List<javac.tree.JCTree$JCCase>): javac.tree.JCTree;
              visitBreak(tree: javac.tree.JCTree$JCBreak): void;
              visitClassDef(tree: javac.tree.JCTree$JCClassDecl): void;
              visitConditional(tree: javac.tree.JCTree$JCConditional): void;
              visitDoLoop(tree: javac.tree.JCTree$JCDoWhileLoop): void;
              _visitEnumConstantDef(_var: javac.tree.JCTree$JCVariableDecl, ordinal: int): void;
              _visitEnumDef(tree: javac.tree.JCTree$JCClassDecl): void;
              visitEnumSwitch(tree: javac.tree.JCTree, selector: javac.tree.JCTree$JCExpression, cases: javac.util.List<javac.tree.JCTree$JCCase>): javac.tree.JCTree;
              visitForLoop(tree: javac.tree.JCTree$JCForLoop): void;
              visitForeachLoop(tree: javac.tree.JCTree$JCEnhancedForLoop): void;
              visitIdent(tree: javac.tree.JCTree$JCIdent): void;
              visitIf(tree: javac.tree.JCTree$JCIf): void;
              visitIndexed(tree: javac.tree.JCTree$JCArrayAccess): void;
              _visitIterableForeachLoop(tree: javac.tree.JCTree$JCEnhancedForLoop): void;
              visitLetExpr(tree: javac.tree.JCTree$LetExpr): void;
              visitMethodDef(tree: javac.tree.JCTree$JCMethodDecl): void;
              _visitMethodDefInternal(tree: javac.tree.JCTree$JCMethodDecl): void;
              visitModuleDef(tree: javac.tree.JCTree$JCModuleDecl): void;
              visitNewArray(tree: javac.tree.JCTree$JCNewArray): void;
              visitNewClass(tree: javac.tree.JCTree$JCNewClass): void;
              visitPackageDef(tree: javac.tree.JCTree$JCPackageDecl): void;
              visitParens(tree: javac.tree.JCTree$JCParens): void;
              _visitRecordDef(tree: javac.tree.JCTree$JCClassDecl): void;
              visitReturn(tree: javac.tree.JCTree$JCReturn): void;
              visitSelect(tree: javac.tree.JCTree$JCFieldAccess): void;
              visitStringSwitch(tree: javac.tree.JCTree, selector: javac.tree.JCTree$JCExpression, caseList: javac.util.List<javac.tree.JCTree$JCCase>): javac.tree.JCTree;
              visitSwitch(tree: javac.tree.JCTree$JCSwitch): void;
              visitSwitchExpression(tree: javac.tree.JCTree$JCSwitchExpression): void;
              visitTry(tree: javac.tree.JCTree$JCTry): void;
              visitTypeCast(tree: javac.tree.JCTree$JCTypeCast): void;
              visitUnary(tree: javac.tree.JCTree$JCUnary): void;
              visitVarDef(tree: javac.tree.JCTree$JCVariableDecl): void;
              visitWhileLoop(tree: javac.tree.JCTree$JCWhileLoop): void;
              visitYield(tree: javac.tree.JCTree$JCYield): void;
              _accessConstrTags: javac.util.List<javac.code.Symbol$ClassSymbol>;
              _accessConstrs: java.util.Map<javac.code.Symbol,javac.code.Symbol$MethodSymbol>;
              _accessNums: java.util.Map<javac.code.Symbol,int>;
              _accessSyms: java.util.Map<javac.code.Symbol,javac.code.Symbol$MethodSymbol[]>;
              _accessed: javac.util.ListBuffer<javac.code.Symbol>;
              _actualSymbols: java.util.Map<javac.code.Symbol,javac.code.Symbol>;
              _assertionsDisabledClassCache: javac.code.Symbol$ClassSymbol;
              _attr: Attr;
              _attrEnv: Env<AttrContext>;
              _cfolder: ConstFold;
              _chk: Check;
              _classMap: Lower$ClassMap;
              _classdefs: java.util.Map<javac.code.Symbol$ClassSymbol,javac.tree.JCTree$JCClassDecl>;
              _conflictsChecker: javac.tree.JCTree$Visitor;
              _currentClass: javac.code.Symbol$ClassSymbol;
              _currentMethodDef: javac.tree.JCTree$JCMethodDecl;
              _currentMethodSym: javac.code.Symbol$MethodSymbol;
              _debugLower: boolean;
              _disableProtectedAccessors: boolean;
              _dollarAssertionsDisabled: javac.util.Name;
              _enclOp: javac.tree.JCTree$JCExpression;
              _endPosTable: javac.tree.EndPosTable;
              _enumSwitchMap: java.util.Map<javac.code.Symbol$TypeSymbol,Lower$EnumMapping>;
              _freevarCache: java.util.Map<javac.code.Symbol$ClassSymbol,javac.util.List<javac.code.Symbol$VarSymbol>>;
              _lambdaTranslationMap: java.util.Map<javac.code.Symbol,javac.code.Symbol>;
              _log: javac.util.Log;
              _make: javac.tree.TreeMaker;
              _make_pos: javac.util.JCDiagnostic$DiagnosticPosition;
              _names: javac.util.Names;
              _operators: Operators;
              _optimizeOuterThis: boolean;
              _outerThisStack: javac.util.List<javac.code.Symbol$VarSymbol>;
              _outermostClassDef: javac.tree.JCTree$JCClassDecl;
              _outermostMemberDef: javac.tree.JCTree;
              _pkginfoOpt: javac.main.Option$PkgInfo;
              _proxies: java.util.Map<javac.code.Symbol,javac.code.Symbol>;
              prunedTree: java.util.Map<javac.code.Symbol$ClassSymbol,javac.util.List<javac.tree.JCTree>>;
              _rs: Resolve;
              _syms: javac.code.Symtab;
              _systemArraycopyMethod: javac.code.Symbol$MethodSymbol;
              _target: javac.jvm.Target;
              _transTypes: TransTypes;
              _translated: javac.util.ListBuffer<javac.tree.JCTree>;
              _twrVars: javac.code.Scope$WriteableScope;
              _typeEnvs: TypeEnvs;
              _types: javac.code.Types;
              _useMatchException: boolean;
            }
            interface Lower extends CombineTypes<[_Lower, com.sun.tools.javac.tree.TreeTranslator]> {}
            interface _Lower$AssignopDependencyScanner$$static extends ClassLike {
              _new(this$0: Lower, tree: javac.tree.JCTree$JCAssignOp): Lower$AssignopDependencyScanner;
            }
            let Lower$AssignopDependencyScanner: _Lower$AssignopDependencyScanner$$static;
            interface _Lower$AssignopDependencyScanner {
              scan(tree: javac.tree.JCTree): void;
              visitAssignop(tree: javac.tree.JCTree$JCAssignOp): void;
              visitUnary(tree: javac.tree.JCTree$JCUnary): void;
              _dependencyFound: boolean;
              _sym: javac.code.Symbol;
            }
            interface Lower$AssignopDependencyScanner extends CombineTypes<[_Lower$AssignopDependencyScanner, com.sun.tools.javac.tree.TreeScanner]> {}
            interface _Lower$BasicFreeVarCollector$$static extends ClassLike {
              _new(this$0: Lower): Lower$BasicFreeVarCollector;
            }
            let Lower$BasicFreeVarCollector: _Lower$BasicFreeVarCollector$$static;
            interface _Lower$BasicFreeVarCollector {
              _addFreeVars(a0: javac.code.Symbol$ClassSymbol): void;
              visitApply(tree: javac.tree.JCTree$JCMethodInvocation): void;
              visitIdent(tree: javac.tree.JCTree$JCIdent): void;
              visitNewClass(tree: javac.tree.JCTree$JCNewClass): void;
              _visitSymbol(a0: javac.code.Symbol): void;
              visitYield(tree: javac.tree.JCTree$JCYield): void;
              _this$0: Lower;
            }
            interface Lower$BasicFreeVarCollector extends CombineTypes<[_Lower$BasicFreeVarCollector, com.sun.tools.javac.tree.TreeScanner]> {}
            interface _Lower$ClassMap$$static extends ClassLike {
              _new(this$0: Lower): Lower$ClassMap;
            }
            let Lower$ClassMap: _Lower$ClassMap$$static;
            interface _Lower$ClassMap {
              visitClassDef(tree: javac.tree.JCTree$JCClassDecl): void;
              _this$0: Lower;
            }
            interface Lower$ClassMap extends CombineTypes<[_Lower$ClassMap, com.sun.tools.javac.tree.TreeScanner]> {}
            interface _Lower$CompileTimeEnumMapping$$static extends ClassLike {
              _new(this$0: javac.util.List<javac.util.Name>): Lower$CompileTimeEnumMapping;
            }
            let Lower$CompileTimeEnumMapping: _Lower$CompileTimeEnumMapping$$static;
            interface _Lower$CompileTimeEnumMapping {
              caseValue(v: javac.code.Symbol$VarSymbol): javac.tree.JCTree$JCLiteral;
              switchValue(ordinalExpr: javac.tree.JCTree$JCExpression): javac.tree.JCTree$JCExpression;
              _enumNames: javac.util.List<javac.util.Name>;
              _this$0: Lower;
            }
            interface Lower$CompileTimeEnumMapping extends CombineTypes<[_Lower$CompileTimeEnumMapping, com.sun.tools.javac.comp.Lower$EnumMapping, java.lang.Object]> {}
            interface _Lower$EnumMapping$$static extends ClassLike {
            }
            let Lower$EnumMapping: _Lower$EnumMapping$$static;
            interface _Lower$EnumMapping {
              caseValue(a0: javac.code.Symbol$VarSymbol): javac.tree.JCTree$JCLiteral;
              switchValue(a0: javac.tree.JCTree$JCExpression): javac.tree.JCTree$JCExpression;
              translate(): void;
            }
            interface Lower$EnumMapping extends CombineTypes<[_Lower$EnumMapping, java.lang.Object]> {}
            interface _Lower$FreeVarCollector$$static extends ClassLike {
              _new(this$0: Lower, clazz: javac.code.Symbol$ClassSymbol): Lower$FreeVarCollector;
            }
            let Lower$FreeVarCollector: _Lower$FreeVarCollector$$static;
            interface _Lower$FreeVarCollector {
              _addFreeVar(v: javac.code.Symbol$VarSymbol): void;
              _addFreeVars(c: javac.code.Symbol$ClassSymbol): void;
              visitApply(tree: javac.tree.JCTree$JCMethodInvocation): void;
              visitNewClass(tree: javac.tree.JCTree$JCNewClass): void;
              visitSelect(tree: javac.tree.JCTree$JCFieldAccess): void;
              _visitSymbol(_sym: javac.code.Symbol): void;
              _clazz: javac.code.Symbol$ClassSymbol;
              _fvs: javac.util.List<javac.code.Symbol$VarSymbol>;
              _owner: javac.code.Symbol;
              _this$0: Lower;
            }
            interface Lower$FreeVarCollector extends CombineTypes<[_Lower$FreeVarCollector, com.sun.tools.javac.comp.Lower$BasicFreeVarCollector]> {}
            interface _Lower$LowerSignatureGenerator$$static extends ClassLike {
              _new(a0: Lower): Lower$LowerSignatureGenerator;
            }
            let Lower$LowerSignatureGenerator: _Lower$LowerSignatureGenerator$$static;
            interface _Lower$LowerSignatureGenerator {
              _append(ch: char): void;
              _append(ba: byte[]): void;
              _append(name: javac.util.Name): void;
              toString(): string;
              _sb: comp$stringBuilder;
            }
            interface Lower$LowerSignatureGenerator extends CombineTypes<[_Lower$LowerSignatureGenerator, com.sun.tools.javac.code.Types$SignatureGenerator]> {}
            interface _Lower$RuntimeEnumMapping$$static extends ClassLike {
              _new(this$0: Lower, pos: javac.util.JCDiagnostic$DiagnosticPosition, forEnum: javac.code.Symbol$TypeSymbol): Lower$RuntimeEnumMapping;
            }
            let Lower$RuntimeEnumMapping: _Lower$RuntimeEnumMapping$$static;
            interface _Lower$RuntimeEnumMapping {
              caseValue(v: javac.code.Symbol$VarSymbol): javac.tree.JCTree$JCLiteral;
              switchValue(ordinalExpr: javac.tree.JCTree$JCExpression): javac.tree.JCTree$JCExpression;
              translate(): void;
              _forEnum: javac.code.Symbol$TypeSymbol;
              _mapVar: javac.code.Symbol$VarSymbol;
              _next: int;
              _pos: javac.util.JCDiagnostic$DiagnosticPosition;
              _this$0: Lower;
              _values: java.util.Map<javac.code.Symbol$VarSymbol,int>;
            }
            interface Lower$RuntimeEnumMapping extends CombineTypes<[_Lower$RuntimeEnumMapping, com.sun.tools.javac.comp.Lower$EnumMapping, java.lang.Object]> {}
            interface _Lower$TreeBuilder$$static extends ClassLike {
            }
            let Lower$TreeBuilder: _Lower$TreeBuilder$$static;
            interface _Lower$TreeBuilder {
              build(a0: javac.tree.JCTree$JCExpression): javac.tree.JCTree$JCExpression;
(a0: javac.tree.JCTree$JCExpression): javac.tree.JCTree$JCExpression;
            }
            interface Lower$TreeBuilder extends CombineTypes<[_Lower$TreeBuilder, java.lang.Object]> {}
            interface _MatchBindingsComputer$$static extends ClassLike {
              instance(context: javac.util.Context): MatchBindingsComputer;
              readonly EMPTY: MatchBindingsComputer$MatchBindings;
              _matchBindingsComputerKey: javac.util.Context$Key<MatchBindingsComputer>;
              _new(context: javac.util.Context): MatchBindingsComputer;
            }
            let MatchBindingsComputer: _MatchBindingsComputer$$static;
            interface _MatchBindingsComputer {
              andOperation(pos: javac.util.JCDiagnostic$DiagnosticPosition, lhsBindings: MatchBindingsComputer$MatchBindings, rhsBindings: MatchBindingsComputer$MatchBindings): MatchBindingsComputer$MatchBindings;
              binary(tree: javac.tree.JCTree, lhsBindings: MatchBindingsComputer$MatchBindings, rhsBindings: MatchBindingsComputer$MatchBindings): MatchBindingsComputer$MatchBindings;
              caseGuard(tree: javac.tree.JCTree$JCCase, patternBindings: MatchBindingsComputer$MatchBindings, guardBindings: MatchBindingsComputer$MatchBindings): MatchBindingsComputer$MatchBindings;
              conditional(tree: javac.tree.JCTree, condBindings: MatchBindingsComputer$MatchBindings, trueBindings: MatchBindingsComputer$MatchBindings, falseBindings: MatchBindingsComputer$MatchBindings): MatchBindingsComputer$MatchBindings;
              finishBindings(tree: javac.tree.JCTree, matchBindings: MatchBindingsComputer$MatchBindings): MatchBindingsComputer$MatchBindings;
              _intersection(pos: javac.util.JCDiagnostic$DiagnosticPosition, lhsBindings: javac.util.List<javac.code.Symbol$BindingSymbol>, rhsBindings: javac.util.List<javac.code.Symbol$BindingSymbol>): javac.util.List<javac.code.Symbol$BindingSymbol>;
              switchCase(tree: javac.tree.JCTree, prevBindings: MatchBindingsComputer$MatchBindings, currentBindings: MatchBindingsComputer$MatchBindings): MatchBindingsComputer$MatchBindings;
              unary(tree: javac.tree.JCTree, bindings: MatchBindingsComputer$MatchBindings): MatchBindingsComputer$MatchBindings;
              _union(pos: javac.util.JCDiagnostic$DiagnosticPosition, lhsBindings: javac.util.List<javac.code.Symbol$BindingSymbol>, rhsBindings_s: javac.util.List<javac.code.Symbol$BindingSymbol>[]): javac.util.List<javac.code.Symbol$BindingSymbol>;
              _union(pos: javac.util.JCDiagnostic$DiagnosticPosition, lhsBindings: javac.util.List<javac.code.Symbol$BindingSymbol>, ...rhsBindings_s: javac.util.List<javac.code.Symbol$BindingSymbol>[]): javac.util.List<javac.code.Symbol$BindingSymbol>;
              _log: javac.util.Log;
            }
            interface MatchBindingsComputer extends CombineTypes<[_MatchBindingsComputer, com.sun.tools.javac.tree.TreeScanner]> {}
            interface _MatchBindingsComputer$MatchBindings$$static extends ClassLike {
              new(bindingsWhenTrue: javac.util.List<javac.code.Symbol$BindingSymbol>, bindingsWhenFalse: javac.util.List<javac.code.Symbol$BindingSymbol>): MatchBindingsComputer$MatchBindings;
              new(bindingsWhenTrue: javac.util.List<javac.code.Symbol$BindingSymbol>, bindingsWhenFalse: javac.util.List<javac.code.Symbol$BindingSymbol>, nullPattern: boolean): MatchBindingsComputer$MatchBindings;
            }
            let MatchBindingsComputer$MatchBindings: _MatchBindingsComputer$MatchBindings$$static;
            interface _MatchBindingsComputer$MatchBindings {
              readonly bindingsWhenFalse: javac.util.List<javac.code.Symbol$BindingSymbol>;
              readonly bindingsWhenTrue: javac.util.List<javac.code.Symbol$BindingSymbol>;
              readonly nullPattern: boolean;
            }
            interface MatchBindingsComputer$MatchBindings extends CombineTypes<[_MatchBindingsComputer$MatchBindings, java.lang.Object]> {}
            interface _MemberEnter$$static extends ClassLike {
              instance(context: javac.util.Context): MemberEnter;
              _memberEnterKey: javac.util.Context$Key<MemberEnter>;
              _new(context: javac.util.Context): MemberEnter;
            }
            let MemberEnter: _MemberEnter$$static;
            interface _MemberEnter {
              _checkReceiver(tree: javac.tree.JCTree$JCVariableDecl, localEnv: Env<AttrContext>): void;
              _checkType(tree: javac.tree.JCTree, type: javac.code.Type, errorKey: javac.util.JCDiagnostic$Error): void;
              getInitEnv(tree: javac.tree.JCTree$JCVariableDecl, env: Env<AttrContext>): Env<AttrContext>;
              getMethodEnv(tree: javac.tree.JCTree$JCMethodDecl, env: Env<AttrContext>): Env<AttrContext>;
              _initEnv(tree: javac.tree.JCTree$JCVariableDecl, env: Env<AttrContext>): Env<AttrContext>;
              _memberEnter(tree: javac.tree.JCTree, env: Env<AttrContext>): void;
              _memberEnter(trees: javac.util.List<javac.tree.JCTree>, env: Env<AttrContext>): void;
              _methodEnv(tree: javac.tree.JCTree$JCMethodDecl, env: Env<AttrContext>): Env<AttrContext>;
              needsLazyConstValue(tree: javac.tree.JCTree): boolean;
              _signature(msym: javac.code.Symbol$MethodSymbol, typarams: javac.util.List<javac.tree.JCTree$JCTypeParameter>, params: javac.util.List<javac.tree.JCTree$JCVariableDecl>, res: javac.tree.JCTree, recvparam: javac.tree.JCTree$JCVariableDecl, thrown: javac.util.List<javac.tree.JCTree$JCExpression>, env: Env<AttrContext>): javac.code.Type;
              visitErroneous(tree: javac.tree.JCTree$JCErroneous): void;
              visitMethodDef(tree: javac.tree.JCTree$JCMethodDecl): void;
              visitTree(tree: javac.tree.JCTree): void;
              visitVarDef(tree: javac.tree.JCTree$JCVariableDecl): void;
              _annotate: Annotate;
              _attr: Attr;
              _chk: Check;
              _deferredLintHandler: javac.code.DeferredLintHandler;
              _enter: Enter;
              _env: Env<AttrContext>;
              _log: javac.util.Log;
              _names: javac.util.Names;
              _source: javac.code.Source;
              _syms: javac.code.Symtab;
              _types: javac.code.Types;
            }
            interface MemberEnter extends CombineTypes<[_MemberEnter, com.sun.tools.javac.tree.JCTree$Visitor]> {}
            interface _MemberEnter$InitTreeVisitor$$static extends ClassLike {
              _ALLOWED_OPERATORS: java.util.Set<javac.tree.JCTree$Tag>;
              _new(): MemberEnter$InitTreeVisitor;
            }
            let MemberEnter$InitTreeVisitor: _MemberEnter$InitTreeVisitor$$static;
            interface _MemberEnter$InitTreeVisitor {
              visitBinary(that: javac.tree.JCTree$JCBinary): void;
              visitConditional(tree: javac.tree.JCTree$JCConditional): void;
              visitIdent(that: javac.tree.JCTree$JCIdent): void;
              visitLiteral(that: javac.tree.JCTree$JCLiteral): void;
              visitParens(tree: javac.tree.JCTree$JCParens): void;
              visitSelect(tree: javac.tree.JCTree$JCFieldAccess): void;
              visitTree(tree: javac.tree.JCTree): void;
              visitTypeCast(tree: javac.tree.JCTree$JCTypeCast): void;
              visitUnary(that: javac.tree.JCTree$JCUnary): void;
              _result: boolean;
            }
            interface MemberEnter$InitTreeVisitor extends CombineTypes<[_MemberEnter$InitTreeVisitor, com.sun.tools.javac.tree.JCTree$Visitor]> {}
            interface _Modules$$static extends ClassLike {
              instance(context: javac.util.Context): Modules;
              _ALL_MODULE_PATH: string;
              _ALL_SYSTEM: string;
              _IS_AUTOMATIC: java.util.function.Predicate<javac.code.Symbol$ModuleSymbol>;
              _new(context: javac.util.Context): Modules;
            }
            let Modules: _Modules$$static;
            interface _Modules {
              addExtraAddModules(extras: string[]): void;
              addExtraAddModules(...extras: string[]): void;
              _addVisiblePackages(msym: javac.code.Symbol$ModuleSymbol, seenPackages: java.util.Map<javac.util.Name,javac.code.Symbol$ModuleSymbol>, exportsFrom: javac.code.Symbol$ModuleSymbol, exports: java.util.Collection<javac.code.Directive$ExportsDirective>): void;
              allModules(): java.util.Set<javac.code.Symbol$ModuleSymbol>;
              _checkCyclicDependencies(mod: javac.tree.JCTree$JCModuleDecl): void;
              _checkNoAllModulePath(): void;
              _checkSourceLocation(tree: javac.tree.JCTree$JCCompilationUnit, msym: javac.code.Symbol$ModuleSymbol): void;
              _completeAutomaticModule(msym: javac.code.Symbol$ModuleSymbol): void;
              _completeModule(msym: javac.code.Symbol$ModuleSymbol): void;
              _computeTransitiveClosure(base: java.util.Set<javac.code.Symbol$ModuleSymbol>, rootModules: java.util.Set<javac.code.Symbol$ModuleSymbol>, observable: java.util.Set<javac.code.Symbol$ModuleSymbol>): java.util.Set<javac.code.Symbol$ModuleSymbol>;
              enter(trees: javac.util.List<javac.tree.JCTree$JCCompilationUnit>, c: javac.code.Symbol$ClassSymbol): boolean;
              _enter(trees: javac.util.List<javac.tree.JCTree$JCCompilationUnit>, init: java.util.function.Consumer<java.util.Set<javac.code.Symbol$ModuleSymbol>>, c: javac.code.Symbol$ClassSymbol): boolean;
              _enterModule(toplevel: javac.tree.JCTree$JCCompilationUnit, c: javac.code.Symbol$ClassSymbol, modules: java.util.Set<javac.code.Symbol$ModuleSymbol>): void;
              _enterModules(trees: javac.util.List<javac.tree.JCTree$JCCompilationUnit>, c: javac.code.Symbol$ClassSymbol): java.util.Set<javac.code.Symbol$ModuleSymbol>;
              _filterAlreadyWarnedIncubatorModules(incubatingModules: java.util.stream.Stream<string>): java.util.stream.Stream<string>;
              getCompleter(): javac.code.Symbol$Completer;
              getDefaultModule(): javac.code.Symbol$ModuleSymbol;
              _getModuleLocation(tree: javac.tree.JCTree$JCCompilationUnit): javax.tools.JavaFileManager$Location;
              getObservableModule(name: javac.util.Name): javac.code.Symbol$ModuleSymbol;
              getRootModules(): java.util.Set<javac.code.Symbol$ModuleSymbol>;
              _getSourceCompleter(tree: javac.tree.JCTree$JCCompilationUnit): javac.code.Symbol$Completer;
              _getUnnamedModuleCompleter(): javac.code.Symbol$Completer;
              getUsesProvidesCompleter(): javac.code.Symbol$Completer;
              _initAddExports(): void;
              _initAddReads(): void;
              initModules(trees: javac.util.List<javac.tree.JCTree$JCCompilationUnit>): void;
              _initVisiblePackages(msym: javac.code.Symbol$ModuleSymbol, readable: java.util.Collection<javac.code.Symbol$ModuleSymbol>): void;
              isInModuleGraph(msym: javac.code.Symbol$ModuleSymbol): boolean;
              _isKnownModule(msym: javac.code.Symbol$ModuleSymbol, unknownModules: java.util.Set<javac.code.Symbol$ModuleSymbol>): boolean;
              isRootModule(module: javac.code.Symbol$ModuleSymbol): boolean;
              _isValidName(name: Modules$charSequence): boolean;
              modulesInitialized(): boolean;
              newRound(): void;
              _retrieveRequiresTransitive(msym: javac.code.Symbol$ModuleSymbol): java.util.Set<javac.code.Symbol$ModuleSymbol>;
              _setCompilationUnitModules(trees: javac.util.List<javac.tree.JCTree$JCCompilationUnit>, rootModules: java.util.Set<javac.code.Symbol$ModuleSymbol>, c: javac.code.Symbol$ClassSymbol): void;
              _setupAllModules(): void;
              _setupAutomaticModule(msym: javac.code.Symbol$ModuleSymbol): void;
              _singleModuleOverride(trees: javac.util.List<javac.tree.JCTree$JCCompilationUnit>): string;
              _toString(msym: javac.code.Symbol$ModuleSymbol): string;
              _toString(locn: javax.tools.JavaFileManager$Location): string;
              _toString(fo: javax.tools.JavaFileObject): string;
              _addExports: java.util.Map<javac.code.Symbol$ModuleSymbol,java.util.Set<javac.code.Directive$ExportsDirective>>;
              _addExportsOpt: string;
              _addModsOpt: string;
              _addReads: java.util.Map<javac.code.Symbol$ModuleSymbol,java.util.Set<javac.code.Directive$RequiresDirective>>;
              _addReadsOpt: string;
              _allModules: java.util.Set<javac.code.Symbol$ModuleSymbol>;
              _allowAccessIntoSystem: boolean;
              _allowModules: boolean;
              _attr: Attr;
              _chk: Check;
              _defaultModule: javac.code.Symbol$ModuleSymbol;
              _deferredLintHandler: javac.code.DeferredLintHandler;
              _depth: int;
              _extraAddMods: java.util.Set<string>;
              _extraLimitMods: java.util.Set<string>;
              _fileManager: javax.tools.JavaFileManager;
              findPackageInFile: Modules$PackageNameFinder;
              _inInitModules: boolean;
              _java_: javac.util.Name;
              _java_se: javac.util.Name;
              _limitModsOpt: string;
              _lintOptions: boolean;
              _log: javac.util.Log;
              _mainCompleter: javac.code.Symbol$Completer;
              _moduleFinder: javac.code.ModuleFinder;
              _moduleVersionOpt: string;
              readonly multiModuleMode: boolean;
              _names: javac.util.Names;
              _requiresTransitiveCache: java.util.Map<javac.code.Symbol$ModuleSymbol,java.util.Set<javac.code.Symbol$ModuleSymbol>>;
              _rootModules: java.util.Set<javac.code.Symbol$ModuleSymbol>;
              _source: javac.code.Source;
              _sourceLauncher: boolean;
              _syms: javac.code.Symtab;
              _target: javac.jvm.Target;
              _typeEnvs: TypeEnvs;
              _types: javac.code.Types;
              _warnedMissing: java.util.Set<javac.code.Symbol$ModuleSymbol>;
            }
            interface Modules extends CombineTypes<[_Modules, com.sun.tools.javac.tree.JCTree$Visitor]> {}
            interface _Modules$ModuleVisitor$$static extends ClassLike {
              _new(this$0: Modules): Modules$ModuleVisitor;
            }
            let Modules$ModuleVisitor: _Modules$ModuleVisitor$$static;
            interface _Modules$ModuleVisitor {
              _checkDuplicateExportsToModule(name: javac.tree.JCTree$JCExpression, msym: javac.code.Symbol$ModuleSymbol, d: javac.code.Directive$ExportsDirective): void;
              _checkDuplicateOpensToModule(name: javac.tree.JCTree$JCExpression, msym: javac.code.Symbol$ModuleSymbol, d: javac.code.Directive$OpensDirective): void;
              _ensureJavaBase(): void;
              _lookupModule(moduleName: javac.tree.JCTree$JCExpression): javac.code.Symbol$ModuleSymbol;
              _reportExportsConflict(tree: javac.tree.JCTree$JCExports, packge: javac.code.Symbol$PackageSymbol): void;
              _reportExportsConflictToModule(name: javac.tree.JCTree$JCExpression, msym: javac.code.Symbol$ModuleSymbol): void;
              _reportOpensConflict(tree: javac.tree.JCTree$JCOpens, packge: javac.code.Symbol$PackageSymbol): void;
              _reportOpensConflictToModule(name: javac.tree.JCTree$JCExpression, msym: javac.code.Symbol$ModuleSymbol): void;
              visitExports(tree: javac.tree.JCTree$JCExports): void;
              visitModuleDef(tree: javac.tree.JCTree$JCModuleDecl): void;
              visitOpens(tree: javac.tree.JCTree$JCOpens): void;
              visitProvides(tree: javac.tree.JCTree$JCProvides): void;
              visitRequires(tree: javac.tree.JCTree$JCRequires): void;
              visitUses(tree: javac.tree.JCTree$JCUses): void;
              _allExports: java.util.Map<javac.code.Symbol$PackageSymbol,javac.util.List<javac.code.Directive$ExportsDirective>>;
              _allOpens: java.util.Map<javac.code.Symbol$PackageSymbol,javac.util.List<javac.code.Directive$OpensDirective>>;
              _allRequires: java.util.Set<javac.code.Symbol$ModuleSymbol>;
              _sym: javac.code.Symbol$ModuleSymbol;
              _this$0: Modules;
            }
            interface Modules$ModuleVisitor extends CombineTypes<[_Modules$ModuleVisitor, com.sun.tools.javac.tree.JCTree$Visitor]> {}
            interface _Modules$PackageNameFinder$$static extends ClassLike {
            }
            let Modules$PackageNameFinder: _Modules$PackageNameFinder$$static;
            interface _Modules$PackageNameFinder {
              findPackageNameOf(a0: javax.tools.JavaFileObject): javac.util.Name;
(a0: javax.tools.JavaFileObject): javac.util.Name;
            }
            interface Modules$PackageNameFinder extends CombineTypes<[_Modules$PackageNameFinder, java.lang.Object]> {}
            interface _Modules$UsesProvidesVisitor$$static extends ClassLike {
              new(this$0: javac.code.Symbol$ModuleSymbol, msym: Env<AttrContext>): Modules$UsesProvidesVisitor;
            }
            let Modules$UsesProvidesVisitor: _Modules$UsesProvidesVisitor$$static;
            interface _Modules$UsesProvidesVisitor {
              _checkForCorrectness(): void;
              _factoryMethod(tsym: javac.code.Symbol$ClassSymbol): javac.code.Symbol$MethodSymbol;
              _noArgsConstructor(tsym: javac.code.Symbol$ClassSymbol): javac.code.Symbol$MethodSymbol;
              visitExports(tree: javac.tree.JCTree$JCExports): void;
              visitModuleDef(tree: javac.tree.JCTree$JCModuleDecl): void;
              visitOpens(tree: javac.tree.JCTree$JCOpens): void;
              visitProvides(tree: javac.tree.JCTree$JCProvides): void;
              visitRequires(tree: javac.tree.JCTree$JCRequires): void;
              visitUses(tree: javac.tree.JCTree$JCUses): void;
              _allProvides: java.util.Map<javac.code.Symbol$ClassSymbol,java.util.Set<javac.code.Symbol$ClassSymbol>>;
              _allUses: java.util.Set<javac.code.Symbol$ClassSymbol>;
              _directiveToTreeMap: java.util.Map<javac.code.Directive$ProvidesDirective,javac.tree.JCTree$JCProvides>;
              _env: Env<AttrContext>;
              _msym: javac.code.Symbol$ModuleSymbol;
              _this$0: Modules;
            }
            interface Modules$UsesProvidesVisitor extends CombineTypes<[_Modules$UsesProvidesVisitor, com.sun.tools.javac.tree.JCTree$Visitor]> {}
            interface _Operators$$static extends ClassLike {
              instance(context: javac.util.Context): Operators;
              _operatorsKey: javac.util.Context$Key<Operators>;
              _new(context: javac.util.Context): Operators;
            }
            let Operators: _Operators$$static;
            interface _Operators {
              _binaryPromotion(t1: javac.code.Type, t2: javac.code.Type): javac.code.Type;
              _initBinaryOperators(): void;
              _initOperatorNames(): void;
              _initOperators<O>(opsMap: java.util.Map<javac.util.Name,javac.util.List<O>>, ops: O[]): void;
              _initOperators<O>(opsMap: java.util.Map<javac.util.Name,javac.util.List<O>>, ...ops: O[]): void;
              _initUnaryOperators(): void;
              _lookupBinaryOp(applicabilityTest: java.util.function.Predicate<javac.code.Symbol$OperatorSymbol>): javac.code.Symbol$OperatorSymbol;
              _makeOperator(name: javac.util.Name, formals: javac.util.List<Operators$OperatorType>, res: Operators$OperatorType, opcodes: int[]): javac.code.Symbol$OperatorSymbol;
              _makeOperator(name: javac.util.Name, formals: javac.util.List<Operators$OperatorType>, res: Operators$OperatorType, ...opcodes: int[]): javac.code.Symbol$OperatorSymbol;
              _mergeOpcodes(opcodes: int[]): int;
              _mergeOpcodes(...opcodes: int[]): int;
              operatorName(tag: javac.tree.JCTree$Tag): javac.util.Name;
              _reportErrorIfNeeded(pos: javac.util.JCDiagnostic$DiagnosticPosition, tag: javac.tree.JCTree$Tag, args: javac.code.Type[]): javac.code.Symbol$OperatorSymbol;
              _reportErrorIfNeeded(pos: javac.util.JCDiagnostic$DiagnosticPosition, tag: javac.tree.JCTree$Tag, ...args: javac.code.Type[]): javac.code.Symbol$OperatorSymbol;
              _resolve<O>(tag: javac.tree.JCTree$Tag, opMap: java.util.Map<javac.util.Name,javac.util.List<O>>, opTestFunc: java.util.function.Predicate<O>, resolveFunc: java.util.function.Function<O,javac.code.Symbol$OperatorSymbol>, noResultFunc: java.util.function.Supplier<javac.code.Symbol$OperatorSymbol>): javac.code.Symbol$OperatorSymbol;
              _resolveBinary(pos: javac.util.JCDiagnostic$DiagnosticPosition, tag: javac.tree.JCTree$Tag, op1: javac.code.Type, op2: javac.code.Type): javac.code.Symbol$OperatorSymbol;
              _resolveUnary(pos: javac.util.JCDiagnostic$DiagnosticPosition, tag: javac.tree.JCTree$Tag, op: javac.code.Type): javac.code.Symbol$OperatorSymbol;
              _setOperatorName(tag: javac.tree.JCTree$Tag, name: string): void;
              _setOperatorName(tag: javac.tree.JCTree$Tag, name: javac.util.Name): void;
              _unaryPromotion(t: javac.code.Type): javac.code.Type;
              _binaryOperators: java.util.Map<javac.util.Name,javac.util.List<Operators$BinaryOperatorHelper>>;
              _log: javac.util.Log;
              _names: javac.util.Names;
              readonly noOpSymbol: javac.code.Symbol$OperatorSymbol;
              _opname: javac.util.Name[];
              _syms: javac.code.Symtab;
              _types: javac.code.Types;
              _unaryOperators: java.util.Map<javac.util.Name,javac.util.List<Operators$UnaryOperatorHelper>>;
            }
            interface Operators extends CombineTypes<[_Operators, java.lang.Object]> {}
            interface _Operators$BinaryBooleanOperator$$static extends ClassLike {
              _new(this$0: Operators, tag: javac.tree.JCTree$Tag): Operators$BinaryBooleanOperator;
            }
            let Operators$BinaryBooleanOperator: _Operators$BinaryBooleanOperator$$static;
            interface _Operators$BinaryBooleanOperator {
              resolve(arg1: javac.code.Type, arg2: javac.code.Type): javac.code.Symbol$OperatorSymbol;
              test(arg1: javac.code.Type, arg2: javac.code.Type): boolean;
              test(a0: any, a1: any): boolean;
              _this$0: Operators;
            }
            interface Operators$BinaryBooleanOperator extends CombineTypes<[_Operators$BinaryBooleanOperator, com.sun.tools.javac.comp.Operators$BinaryOperatorHelper]> {}
            interface _Operators$BinaryEqualityOperator$$static extends ClassLike {
              _new(this$0: Operators, tag: javac.tree.JCTree$Tag): Operators$BinaryEqualityOperator;
            }
            let Operators$BinaryEqualityOperator: _Operators$BinaryEqualityOperator$$static;
            interface _Operators$BinaryEqualityOperator {
              _getKind(arg1: javac.code.Type, arg2: javac.code.Type): Operators$ComparisonKind;
              resolve(t1: javac.code.Type, t2: javac.code.Type): javac.code.Symbol$OperatorSymbol;
              test(arg1: javac.code.Type, arg2: javac.code.Type): boolean;
              test(a0: any, a1: any): boolean;
              _this$0: Operators;
            }
            interface Operators$BinaryEqualityOperator extends CombineTypes<[_Operators$BinaryEqualityOperator, com.sun.tools.javac.comp.Operators$BinaryOperatorHelper]> {}
            interface _Operators$BinaryNumericOperator$$static extends ClassLike {
              _new(this$0: Operators, tag: javac.tree.JCTree$Tag): Operators$BinaryNumericOperator;
              _new(this$0: javac.tree.JCTree$Tag, tag: java.util.function.Predicate<javac.code.Type>): Operators$BinaryNumericOperator;
            }
            let Operators$BinaryNumericOperator: _Operators$BinaryNumericOperator$$static;
            interface _Operators$BinaryNumericOperator {
              resolve(arg1: javac.code.Type, arg2: javac.code.Type): javac.code.Symbol$OperatorSymbol;
              test(arg1: javac.code.Type, arg2: javac.code.Type): boolean;
              test(a0: any, a1: any): boolean;
              _numericTest: java.util.function.Predicate<javac.code.Type>;
              _this$0: Operators;
            }
            interface Operators$BinaryNumericOperator extends CombineTypes<[_Operators$BinaryNumericOperator, com.sun.tools.javac.comp.Operators$BinaryOperatorHelper]> {}
            interface _Operators$BinaryOperatorHelper$$static extends ClassLike {
              _new(this$0: Operators, tag: javac.tree.JCTree$Tag): Operators$BinaryOperatorHelper;
            }
            let Operators$BinaryOperatorHelper: _Operators$BinaryOperatorHelper$$static;
            interface _Operators$BinaryOperatorHelper {
              _addBinaryOperator(arg1: Operators$OperatorType, arg2: Operators$OperatorType, res: Operators$OperatorType, opcode: int[]): Operators$BinaryOperatorHelper;
              _addBinaryOperator(arg1: Operators$OperatorType, arg2: Operators$OperatorType, res: Operators$OperatorType, ...opcode: int[]): Operators$BinaryOperatorHelper;
              _doLookup(t1: javac.code.Type, t2: javac.code.Type): javac.code.Symbol$OperatorSymbol;
              _isBinaryOperatorApplicable(op: javac.code.Symbol$OperatorSymbol, t1: javac.code.Type, t2: javac.code.Type): boolean;
              _resolve(a0: javac.code.Type, a1: javac.code.Type): javac.code.Symbol$OperatorSymbol;
(a0: javac.code.Type, a1: javac.code.Type): javac.code.Symbol$OperatorSymbol;
              _this$0: Operators;
            }
            interface Operators$BinaryOperatorHelper extends CombineTypes<[_Operators$BinaryOperatorHelper, java.util.function.BiPredicate<javac.code.Type,javac.code.Type>, Operators$OperatorHelper]> {}
            interface _Operators$BinaryShiftOperator$$static extends ClassLike {
              _new(this$0: Operators, tag: javac.tree.JCTree$Tag): Operators$BinaryShiftOperator;
            }
            let Operators$BinaryShiftOperator: _Operators$BinaryShiftOperator$$static;
            interface _Operators$BinaryShiftOperator {
              resolve(arg1: javac.code.Type, arg2: javac.code.Type): javac.code.Symbol$OperatorSymbol;
              test(arg1: javac.code.Type, arg2: javac.code.Type): boolean;
              test(a0: any, a1: any): boolean;
              _this$0: Operators;
            }
            interface Operators$BinaryShiftOperator extends CombineTypes<[_Operators$BinaryShiftOperator, com.sun.tools.javac.comp.Operators$BinaryOperatorHelper]> {}
            interface _Operators$BinaryStringOperator$$static extends ClassLike {
              _new(this$0: Operators, tag: javac.tree.JCTree$Tag): Operators$BinaryStringOperator;
            }
            let Operators$BinaryStringOperator: _Operators$BinaryStringOperator$$static;
            interface _Operators$BinaryStringOperator {
              resolve(arg1: javac.code.Type, arg2: javac.code.Type): javac.code.Symbol$OperatorSymbol;
              _stringPromotion(t: javac.code.Type): javac.code.Type;
              test(arg1: javac.code.Type, arg2: javac.code.Type): boolean;
              test(a0: any, a1: any): boolean;
              _this$0: Operators;
            }
            interface Operators$BinaryStringOperator extends CombineTypes<[_Operators$BinaryStringOperator, com.sun.tools.javac.comp.Operators$BinaryOperatorHelper]> {}
            interface _Operators$ComparisonKind$$static extends ClassLike {
              valueOf(name: string): Operators$ComparisonKind;
              values(): Operators$ComparisonKind[];
              readonly INVALID: Operators$ComparisonKind;
              readonly NUMERIC_OR_BOOLEAN: Operators$ComparisonKind;
              readonly REFERENCE: Operators$ComparisonKind;
            }
            let Operators$ComparisonKind: _Operators$ComparisonKind$$static;
            interface _Operators$ComparisonKind {
            }
            interface Operators$ComparisonKind extends CombineTypes<[_Operators$ComparisonKind]> {}
            interface _Operators$OperatorHelper$$static extends ClassLike {
              _new(this$0: Operators, tag: javac.tree.JCTree$Tag): Operators$OperatorHelper;
            }
            let Operators$OperatorHelper: _Operators$OperatorHelper$$static;
            interface _Operators$OperatorHelper {
              _doLookup(applicabilityTest: java.util.function.Predicate<javac.code.Symbol$OperatorSymbol>): javac.code.Symbol$OperatorSymbol;
              _initOperators(): javac.code.Symbol$OperatorSymbol[];
              _alternatives: java.util.Optional<javac.code.Symbol$OperatorSymbol[]>;
              _name: javac.util.Name;
              _operatorSuppliers: javac.util.List<java.util.function.Supplier<javac.code.Symbol$OperatorSymbol>>;
              _this$0: Operators;
            }
            interface Operators$OperatorHelper extends CombineTypes<[_Operators$OperatorHelper, java.lang.Object]> {}
            interface _Operators$OperatorType$$static extends ClassLike {
              valueOf(name: string): Operators$OperatorType;
              values(): Operators$OperatorType[];
              readonly BOOLEAN: Operators$OperatorType;
              readonly BOT: Operators$OperatorType;
              readonly BYTE: Operators$OperatorType;
              readonly CHAR: Operators$OperatorType;
              readonly DOUBLE: Operators$OperatorType;
              readonly FLOAT: Operators$OperatorType;
              readonly INT: Operators$OperatorType;
              readonly LONG: Operators$OperatorType;
              readonly OBJECT: Operators$OperatorType;
              readonly SHORT: Operators$OperatorType;
              readonly STRING: Operators$OperatorType;
            }
            let Operators$OperatorType: _Operators$OperatorType$$static;
            interface _Operators$OperatorType {
              _asType(syms: javac.code.Symtab): javac.code.Type;
              _asTypeFunc: java.util.function.Function<javac.code.Symtab,javac.code.Type>;
            }
            interface Operators$OperatorType extends CombineTypes<[_Operators$OperatorType]> {}
            interface _Operators$UnaryBooleanOperator$$static extends ClassLike {
              _new(this$0: Operators, tag: javac.tree.JCTree$Tag): Operators$UnaryBooleanOperator;
            }
            let Operators$UnaryBooleanOperator: _Operators$UnaryBooleanOperator$$static;
            interface _Operators$UnaryBooleanOperator {
              resolve(arg: javac.code.Type): javac.code.Symbol$OperatorSymbol;
              test(type: javac.code.Type): boolean;
              test(a0: any): boolean;
              _this$0: Operators;
            }
            interface Operators$UnaryBooleanOperator extends CombineTypes<[_Operators$UnaryBooleanOperator, com.sun.tools.javac.comp.Operators$UnaryOperatorHelper]> {}
            interface _Operators$UnaryNumericOperator$$static extends ClassLike {
              _new(this$0: Operators, tag: javac.tree.JCTree$Tag): Operators$UnaryNumericOperator;
              _new(this$0: javac.tree.JCTree$Tag, tag: java.util.function.Predicate<javac.code.Type>): Operators$UnaryNumericOperator;
            }
            let Operators$UnaryNumericOperator: _Operators$UnaryNumericOperator$$static;
            interface _Operators$UnaryNumericOperator {
              resolve(arg: javac.code.Type): javac.code.Symbol$OperatorSymbol;
              test(type: javac.code.Type): boolean;
              test(a0: any): boolean;
              _numericTest: java.util.function.Predicate<javac.code.Type>;
              _this$0: Operators;
            }
            interface Operators$UnaryNumericOperator extends CombineTypes<[_Operators$UnaryNumericOperator, com.sun.tools.javac.comp.Operators$UnaryOperatorHelper]> {}
            interface _Operators$UnaryOperatorHelper$$static extends ClassLike {
              _new(this$0: Operators, tag: javac.tree.JCTree$Tag): Operators$UnaryOperatorHelper;
            }
            let Operators$UnaryOperatorHelper: _Operators$UnaryOperatorHelper$$static;
            interface _Operators$UnaryOperatorHelper {
              _addUnaryOperator(arg: Operators$OperatorType, res: Operators$OperatorType, opcode: int[]): Operators$UnaryOperatorHelper;
              _addUnaryOperator(arg: Operators$OperatorType, res: Operators$OperatorType, ...opcode: int[]): Operators$UnaryOperatorHelper;
              _doLookup(t: javac.code.Type): javac.code.Symbol$OperatorSymbol;
              _isUnaryOperatorApplicable(op: javac.code.Symbol$OperatorSymbol, t: javac.code.Type): boolean;
              _resolve(a0: javac.code.Type): javac.code.Symbol$OperatorSymbol;
(a0: javac.code.Type): javac.code.Symbol$OperatorSymbol;
              _this$0: Operators;
            }
            interface Operators$UnaryOperatorHelper extends CombineTypes<[_Operators$UnaryOperatorHelper, java.util.function.Predicate<javac.code.Type>, Operators$OperatorHelper]> {}
            interface _Operators$UnaryPrefixPostfixOperator$$static extends ClassLike {
              _new(this$0: Operators, tag: javac.tree.JCTree$Tag): Operators$UnaryPrefixPostfixOperator;
            }
            let Operators$UnaryPrefixPostfixOperator: _Operators$UnaryPrefixPostfixOperator$$static;
            interface _Operators$UnaryPrefixPostfixOperator {
              resolve(arg: javac.code.Type): javac.code.Symbol$OperatorSymbol;
              _this$0: Operators;
            }
            interface Operators$UnaryPrefixPostfixOperator extends CombineTypes<[_Operators$UnaryPrefixPostfixOperator, com.sun.tools.javac.comp.Operators$UnaryNumericOperator]> {}
            interface _Operators$UnaryReferenceOperator$$static extends ClassLike {
              _new(this$0: Operators, tag: javac.tree.JCTree$Tag): Operators$UnaryReferenceOperator;
            }
            let Operators$UnaryReferenceOperator: _Operators$UnaryReferenceOperator$$static;
            interface _Operators$UnaryReferenceOperator {
              resolve(arg: javac.code.Type): javac.code.Symbol$OperatorSymbol;
              test(type: javac.code.Type): boolean;
              test(a0: any): boolean;
              _this$0: Operators;
            }
            interface Operators$UnaryReferenceOperator extends CombineTypes<[_Operators$UnaryReferenceOperator, com.sun.tools.javac.comp.Operators$UnaryOperatorHelper]> {}
            interface _Resolve$$static extends ClassLike {
              _bestOf(s1: javac.code.Symbol, s2: javac.code.Symbol): javac.code.Symbol;
              instance(context: javac.util.Context): Resolve;
              _isInitializer(env: Env<AttrContext>): boolean;
              _isStatic(env: Env<AttrContext>): boolean;
              _resolveKey: javac.util.Context$Key<Resolve>;
              _new(context: javac.util.Context): Resolve;
            }
            let Resolve: _Resolve$$static;
            interface _Resolve {
              _accessBase(sym: javac.code.Symbol, pos: javac.util.JCDiagnostic$DiagnosticPosition, location: javac.code.Symbol, site: javac.code.Type, name: javac.util.Name, qualified: boolean): javac.code.Symbol;
              _accessBase(sym: javac.code.Symbol, pos: javac.util.JCDiagnostic$DiagnosticPosition, site: javac.code.Type, name: javac.util.Name, qualified: boolean): javac.code.Symbol;
              _accessInternal(sym: javac.code.Symbol, pos: javac.util.JCDiagnostic$DiagnosticPosition, location: javac.code.Symbol, site: javac.code.Type, name: javac.util.Name, qualified: boolean, argtypes: javac.util.List<javac.code.Type>, typeargtypes: javac.util.List<javac.code.Type>, logResolveHelper: Resolve$LogResolveHelper): javac.code.Symbol;
              _accessMethod(sym: javac.code.Symbol, pos: javac.util.JCDiagnostic$DiagnosticPosition, location: javac.code.Symbol, site: javac.code.Type, name: javac.util.Name, qualified: boolean, argtypes: javac.util.List<javac.code.Type>, typeargtypes: javac.util.List<javac.code.Type>): javac.code.Symbol;
              _accessMethod(sym: javac.code.Symbol, pos: javac.util.JCDiagnostic$DiagnosticPosition, site: javac.code.Type, name: javac.util.Name, qualified: boolean, argtypes: javac.util.List<javac.code.Type>, typeargtypes: javac.util.List<javac.code.Type>): javac.code.Symbol;
              _adjustArgs(args: javac.util.List<javac.code.Type>, msym: javac.code.Symbol, length: int, allowVarargs: boolean): javac.util.List<javac.code.Type>;
              _ambiguityError(m1: javac.code.Symbol, m2: javac.code.Symbol): javac.code.Symbol;
              _checkAccessibleType(env: Env<AttrContext>, t: javac.code.Type): void;
              _checkMethod(env: Env<AttrContext>, site: javac.code.Type, m: javac.code.Symbol, resultInfo: Attr$ResultInfo, argtypes: javac.util.List<javac.code.Type>, typeargtypes: javac.util.List<javac.code.Type>, warn: javac.util.Warner): javac.code.Type;
              _checkNonAbstract(pos: javac.util.JCDiagnostic$DiagnosticPosition, sym: javac.code.Symbol): void;
              _checkNonExistentType(symbol: javac.code.Symbol): javac.code.Symbol;
              _checkRestrictedType(pos: javac.util.JCDiagnostic$DiagnosticPosition, bestSoFar: javac.code.Symbol, name: javac.util.Name): javac.code.Symbol;
              _createInvisibleSymbolError(env: Env<AttrContext>, sym: javac.code.Symbol): javac.code.Symbol;
              _dumpMethodReferenceSearchResults(referenceTree: javac.tree.JCTree$JCMemberReference, resolutionContext: Resolve$MethodResolutionContext, bestSoFar: javac.code.Symbol, bound: boolean): void;
              _enclosingInstanceMissing(env: Env<AttrContext>, type: javac.code.Type): boolean;
              _findConstructor(pos: javac.util.JCDiagnostic$DiagnosticPosition, env: Env<AttrContext>, site: javac.code.Type, argtypes: javac.util.List<javac.code.Type>, typeargtypes: javac.util.List<javac.code.Type>, allowBoxing: boolean, useVarargs: boolean): javac.code.Symbol;
              _findDiamond(pos: javac.util.JCDiagnostic$DiagnosticPosition, env: Env<AttrContext>, site: javac.code.Type, argtypes: javac.util.List<javac.code.Type>, typeargtypes: javac.util.List<javac.code.Type>, allowBoxing: boolean, useVarargs: boolean): javac.code.Symbol;
              _findDiamond(env: Env<AttrContext>, site: javac.code.Type, argtypes: javac.util.List<javac.code.Type>, typeargtypes: javac.util.List<javac.code.Type>, allowBoxing: boolean, useVarargs: boolean): javac.code.Symbol;
              _findField(env: Env<AttrContext>, site: javac.code.Type, name: javac.util.Name, c: javac.code.Symbol$TypeSymbol): javac.code.Symbol;
              _findFun(env: Env<AttrContext>, name: javac.util.Name, argtypes: javac.util.List<javac.code.Type>, typeargtypes: javac.util.List<javac.code.Type>, allowBoxing: boolean, useVarargs: boolean): javac.code.Symbol;
              _findGlobalType(env: Env<AttrContext>, scope: javac.code.Scope, name: javac.util.Name, recoveryLoadClass: Resolve$RecoveryLoadClass): javac.code.Symbol;
              _findIdent(pos: javac.util.JCDiagnostic$DiagnosticPosition, env: Env<AttrContext>, name: javac.util.Name, kind: javac.code.Kinds$KindSelector): javac.code.Symbol;
              _findIdentInPackage(pos: javac.util.JCDiagnostic$DiagnosticPosition, env: Env<AttrContext>, pck: javac.code.Symbol$TypeSymbol, name: javac.util.Name, kind: javac.code.Kinds$KindSelector): javac.code.Symbol;
              _findIdentInPackageInternal(env: Env<AttrContext>, pck: javac.code.Symbol$TypeSymbol, name: javac.util.Name, kind: javac.code.Kinds$KindSelector): javac.code.Symbol;
              _findIdentInType(pos: javac.util.JCDiagnostic$DiagnosticPosition, env: Env<AttrContext>, site: javac.code.Type, name: javac.util.Name, kind: javac.code.Kinds$KindSelector): javac.code.Symbol;
              _findIdentInTypeInternal(env: Env<AttrContext>, site: javac.code.Type, name: javac.util.Name, kind: javac.code.Kinds$KindSelector): javac.code.Symbol;
              _findIdentInternal(env: Env<AttrContext>, name: javac.util.Name, kind: javac.code.Kinds$KindSelector): javac.code.Symbol;
              _findImmediateMemberType(env: Env<AttrContext>, site: javac.code.Type, name: javac.util.Name, c: javac.code.Symbol$TypeSymbol): javac.code.Symbol;
              _findInheritedMemberType(env: Env<AttrContext>, site: javac.code.Type, name: javac.util.Name, c: javac.code.Symbol$TypeSymbol): javac.code.Symbol;
              _findMemberType(env: Env<AttrContext>, site: javac.code.Type, name: javac.util.Name, c: javac.code.Symbol$TypeSymbol): javac.code.Symbol;
              _findMethod(env: Env<AttrContext>, site: javac.code.Type, name: javac.util.Name, argtypes: javac.util.List<javac.code.Type>, typeargtypes: javac.util.List<javac.code.Type>, allowBoxing: boolean, useVarargs: boolean): javac.code.Symbol;
              _findMethod(env: Env<AttrContext>, site: javac.code.Type, name: javac.util.Name, argtypes: javac.util.List<javac.code.Type>, typeargtypes: javac.util.List<javac.code.Type>, intype: javac.code.Type, bestSoFar: javac.code.Symbol, allowBoxing: boolean, useVarargs: boolean): javac.code.Symbol;
              _findMethodInScope(env: Env<AttrContext>, site: javac.code.Type, name: javac.util.Name, argtypes: javac.util.List<javac.code.Type>, typeargtypes: javac.util.List<javac.code.Type>, sc: javac.code.Scope, bestSoFar: javac.code.Symbol, allowBoxing: boolean, useVarargs: boolean, abstractok: boolean): javac.code.Symbol;
              _findPolymorphicSignatureInstance(env: Env<AttrContext>, spMethod: javac.code.Symbol, argtypes: javac.util.List<javac.code.Type>): javac.code.Symbol;
              _findPolymorphicSignatureInstance(spMethod: javac.code.Symbol, mtype: javac.code.Type): javac.code.Symbol;
              _findType(env: Env<AttrContext>, name: javac.util.Name): javac.code.Symbol;
              _findTypeVar(env: Env<AttrContext>, name: javac.util.Name, staticOnly: boolean): javac.code.Symbol;
              _findVar(env: Env<AttrContext>, name: javac.util.Name): javac.code.Symbol;
              _getMemberReference(pos: javac.util.JCDiagnostic$DiagnosticPosition, env: Env<AttrContext>, referenceTree: javac.tree.JCTree$JCMemberReference, site: javac.code.Type, name: javac.util.Name): javac.code.Symbol;
              _getVerboseApplicableCandidateDiag(pos: int, sym: javac.code.Symbol, inst: javac.code.Type): javac.util.JCDiagnostic;
              _getVerboseInapplicableCandidateDiag(pos: int, sym: javac.code.Symbol, subDiag: javac.util.JCDiagnostic): javac.util.JCDiagnostic;
              _inaccessiblePackageReason(env: Env<AttrContext>, sym: javac.code.Symbol$PackageSymbol): javac.util.JCDiagnostic;
              _instantiate(env: Env<AttrContext>, site: javac.code.Type, m: javac.code.Symbol, resultInfo: Attr$ResultInfo, argtypes: javac.util.List<javac.code.Type>, typeargtypes: javac.util.List<javac.code.Type>, allowBoxing: boolean, useVarargs: boolean, warn: javac.util.Warner): javac.code.Type;
              isAccessible(env: Env<AttrContext>, c: javac.code.Symbol$TypeSymbol): boolean;
              isAccessible(env: Env<AttrContext>, c: javac.code.Symbol$TypeSymbol, checkInner: boolean): boolean;
              _isAccessible(env: Env<AttrContext>, t: javac.code.Type): boolean;
              _isAccessible(env: Env<AttrContext>, t: javac.code.Type, checkInner: boolean): boolean;
              isAccessible(env: Env<AttrContext>, site: javac.code.Type, sym: javac.code.Symbol): boolean;
              isAccessible(env: Env<AttrContext>, site: javac.code.Type, sym: javac.code.Symbol, checkInner: boolean): boolean;
              _isImportOnDemand(env: Env<AttrContext>, name: javac.util.Name): boolean;
              _isInnerSubClass(c: javac.code.Symbol$ClassSymbol, base: javac.code.Symbol): boolean;
              _isProtectedAccessible(sym: javac.code.Symbol, c: javac.code.Symbol$ClassSymbol, site: javac.code.Type): boolean;
              _isSerializable(t: javac.code.Type): boolean;
              _loadClass(env: Env<AttrContext>, name: javac.util.Name, recoveryLoadClass: Resolve$RecoveryLoadClass): javac.code.Symbol;
              logAccessErrorInternal(env: Env<AttrContext>, tree: javac.tree.JCTree, type: javac.code.Type): void;
              _logResolveError(error: Resolve$ResolveError, pos: javac.util.JCDiagnostic$DiagnosticPosition, location: javac.code.Symbol, site: javac.code.Type, name: javac.util.Name, argtypes: javac.util.List<javac.code.Type>, typeargtypes: javac.util.List<javac.code.Type>): void;
              _lookupInvisibleSymbol<S>(env: Env<AttrContext>, name: javac.util.Name, get: java.util.function.Function<javac.util.Name,java.lang.Iterable<S>>, load: java.util.function.BiFunction<javac.code.Symbol$ModuleSymbol,javac.util.Name,S>, validate: java.util.function.Predicate<S>, defaultResult: javac.code.Symbol): javac.code.Symbol;
              _lookupMethod(env: Env<AttrContext>, pos: javac.util.JCDiagnostic$DiagnosticPosition, location: javac.code.Symbol, methodCheck: Resolve$MethodCheck, lookupHelper: Resolve$LookupHelper): javac.code.Symbol;
              _lookupMethod(env: Env<AttrContext>, pos: javac.util.JCDiagnostic$DiagnosticPosition, location: javac.code.Symbol, resolveContext: Resolve$MethodResolutionContext, lookupHelper: Resolve$LookupHelper): javac.code.Symbol;
              _lookupPackage(env: Env<AttrContext>, name: javac.util.Name): javac.code.Symbol;
              _makeReferenceLookupHelper(referenceTree: javac.tree.JCTree$JCMemberReference, site: javac.code.Type, name: javac.util.Name, argtypes: javac.util.List<javac.code.Type>, typeargtypes: javac.util.List<javac.code.Type>, maxPhase: Resolve$MethodResolutionPhase): Resolve$ReferenceLookupHelper;
              methodArguments(argtypes: javac.util.List<javac.code.Type>): any;
              _mostSpecific(argtypes: javac.util.List<javac.code.Type>, m1: javac.code.Symbol, m2: javac.code.Symbol, env: Env<AttrContext>, site: javac.code.Type, useVarargs: boolean): javac.code.Symbol;
              _notOverriddenIn(site: javac.code.Type, sym: javac.code.Symbol): boolean;
              _pruneInterfaces(t: javac.code.Type): javac.util.List<javac.code.Type>;
              _rawInstantiate(env: Env<AttrContext>, site: javac.code.Type, m: javac.code.Symbol, resultInfo: Attr$ResultInfo, argtypes: javac.util.List<javac.code.Type>, typeargtypes: javac.util.List<javac.code.Type>, allowBoxing: boolean, useVarargs: boolean, warn: javac.util.Warner): javac.code.Type;
              _reportVerboseResolutionDiagnostic(dpos: javac.util.JCDiagnostic$DiagnosticPosition, name: javac.util.Name, site: javac.code.Type, argtypes: javac.util.List<javac.code.Type>, typeargtypes: javac.util.List<javac.code.Type>, bestSoFar: javac.code.Symbol): void;
              _resolveConstructor(pos: javac.util.JCDiagnostic$DiagnosticPosition, env: Env<AttrContext>, site: javac.code.Type, argtypes: javac.util.List<javac.code.Type>, typeargtypes: javac.util.List<javac.code.Type>): javac.code.Symbol;
              _resolveConstructor(resolveContext: Resolve$MethodResolutionContext, pos: javac.util.JCDiagnostic$DiagnosticPosition, env: Env<AttrContext>, site: javac.code.Type, argtypes: javac.util.List<javac.code.Type>, typeargtypes: javac.util.List<javac.code.Type>): javac.code.Symbol;
              _resolveDiamond(pos: javac.util.JCDiagnostic$DiagnosticPosition, env: Env<AttrContext>, site: javac.code.Type, argtypes: javac.util.List<javac.code.Type>, typeargtypes: javac.util.List<javac.code.Type>): javac.code.Symbol;
              _resolveIdent(pos: javac.util.JCDiagnostic$DiagnosticPosition, env: Env<AttrContext>, name: javac.util.Name, kind: javac.code.Kinds$KindSelector): javac.code.Symbol;
              _resolveImplicitThis(pos: javac.util.JCDiagnostic$DiagnosticPosition, env: Env<AttrContext>, t: javac.code.Type): javac.code.Type;
              _resolveImplicitThis(pos: javac.util.JCDiagnostic$DiagnosticPosition, env: Env<AttrContext>, t: javac.code.Type, isSuperCall: boolean): javac.code.Type;
              resolveInternalConstructor(pos: javac.util.JCDiagnostic$DiagnosticPosition, env: Env<AttrContext>, site: javac.code.Type, argtypes: javac.util.List<javac.code.Type>, typeargtypes: javac.util.List<javac.code.Type>): javac.code.Symbol$MethodSymbol;
              resolveInternalField(pos: javac.util.JCDiagnostic$DiagnosticPosition, env: Env<AttrContext>, site: javac.code.Type, name: javac.util.Name): javac.code.Symbol$VarSymbol;
              resolveInternalMethod(pos: javac.util.JCDiagnostic$DiagnosticPosition, env: Env<AttrContext>, site: javac.code.Type, name: javac.util.Name, argtypes: javac.util.List<javac.code.Type>, typeargtypes: javac.util.List<javac.code.Type>): javac.code.Symbol$MethodSymbol;
              _resolveMemberReference(env: Env<AttrContext>, referenceTree: javac.tree.JCTree$JCMemberReference, site: javac.code.Type, name: javac.util.Name, argtypes: javac.util.List<javac.code.Type>, typeargtypes: javac.util.List<javac.code.Type>, descriptor: javac.code.Type, methodCheck: Resolve$MethodCheck, inferenceContext: InferenceContext, referenceChooser: Resolve$ReferenceChooser): javac.util.Pair<javac.code.Symbol,Resolve$ReferenceLookupHelper>;
              _resolveMethod(pos: javac.util.JCDiagnostic$DiagnosticPosition, env: Env<AttrContext>, name: javac.util.Name, argtypes: javac.util.List<javac.code.Type>, typeargtypes: javac.util.List<javac.code.Type>): javac.code.Symbol;
              _resolveQualifiedMethod(pos: javac.util.JCDiagnostic$DiagnosticPosition, env: Env<AttrContext>, site: javac.code.Type, name: javac.util.Name, argtypes: javac.util.List<javac.code.Type>, typeargtypes: javac.util.List<javac.code.Type>): javac.code.Symbol;
              _resolveQualifiedMethod(pos: javac.util.JCDiagnostic$DiagnosticPosition, env: Env<AttrContext>, location: javac.code.Symbol, site: javac.code.Type, name: javac.util.Name, argtypes: javac.util.List<javac.code.Type>, typeargtypes: javac.util.List<javac.code.Type>): javac.code.Symbol;
              _resolveQualifiedMethod(resolveContext: Resolve$MethodResolutionContext, pos: javac.util.JCDiagnostic$DiagnosticPosition, env: Env<AttrContext>, location: javac.code.Symbol, site: javac.code.Type, name: javac.util.Name, argtypes: javac.util.List<javac.code.Type>, typeargtypes: javac.util.List<javac.code.Type>): javac.code.Symbol;
              _resolveSelf(pos: javac.util.JCDiagnostic$DiagnosticPosition, env: Env<AttrContext>, c: javac.code.Symbol$TypeSymbol, name: javac.util.Name): javac.code.Symbol;
              _resolveSelfContaining(pos: javac.util.JCDiagnostic$DiagnosticPosition, env: Env<AttrContext>, member: javac.code.Symbol, isSuperCall: boolean): javac.code.Symbol;
              _resolveSelfContainingInternal(env: Env<AttrContext>, member: javac.code.Symbol, isSuperCall: boolean): javac.code.Symbol;
              _selectBest(env: Env<AttrContext>, site: javac.code.Type, argtypes: javac.util.List<javac.code.Type>, typeargtypes: javac.util.List<javac.code.Type>, sym: javac.code.Symbol, bestSoFar: javac.code.Symbol, allowBoxing: boolean, useVarargs: boolean): javac.code.Symbol;
              _signatureMoreSpecific(actuals: javac.util.List<javac.code.Type>, env: Env<AttrContext>, site: javac.code.Type, m1: javac.code.Symbol, m2: javac.code.Symbol, useVarargs: boolean): boolean;
              _superclasses(intype: javac.code.Type): java.lang.Iterable<javac.code.Symbol$TypeSymbol>;
              _symbolPackageVisible(env: Env<AttrContext>, sym: javac.code.Symbol): boolean;
              _accessibilityChecker: javac.code.Types$SimpleVisitor<java.lang.Void,Env<AttrContext>>;
              _allowLocalVariableTypeInference: boolean;
              readonly allowModules: boolean;
              readonly allowRecords: boolean;
              _allowYieldStatement: boolean;
              _arityMethodCheck: Resolve$MethodCheck;
              _attr: Attr;
              _attrRecover: AttrRecover;
              _basicLogResolveHelper: Resolve$LogResolveHelper;
              _basicReferenceChooser: Resolve$ReferenceChooser;
              _chk: Check;
              _compactMethodDiags: boolean;
              _currentResolutionContext: Resolve$MethodResolutionContext;
              _deferredAttr: DeferredAttr;
              _diags: javac.util.JCDiagnostic$Factory;
              _doRecoveryLoadClass: Resolve$RecoveryLoadClass;
              _dumpMethodReferenceSearchResults: boolean;
              _finder: javac.code.ClassFinder;
              _infer: Infer;
              _log: javac.util.Log;
              _methodLogResolveHelper: Resolve$LogResolveHelper;
              _methodNotFound: Resolve$SymbolNotFoundError;
              _methodResolutionSteps: javac.util.List<Resolve$MethodResolutionPhase>;
              _moduleFinder: javac.code.ModuleFinder;
              _namedImportScopeRecovery: Resolve$RecoveryLoadClass;
              _names: javac.util.Names;
              _nilMethodCheck: Resolve$MethodCheck;
              _noArgs: javac.api.Formattable$LocalizedString;
              _noRecovery: Resolve$RecoveryLoadClass;
              _noteWarner: javac.util.Warner;
              _polymorphicSignatureScope: javac.code.Scope$WriteableScope;
              _referenceNotFound: Resolve$ReferenceLookupResult;
              _resolveMethodCheck: Resolve$MethodCheck;
              _silentLogResolveHelper: Resolve$LogResolveHelper;
              _starImportScopeRecovery: Resolve$RecoveryLoadClass;
              _structuralReferenceChooser: Resolve$ReferenceChooser;
              _syms: javac.code.Symtab;
              _typeNotFound: Resolve$SymbolNotFoundError;
              _types: javac.code.Types;
              _varNotFound: Resolve$SymbolNotFoundError;
              _verboseResolutionMode: java.util.EnumSet<Resolve$VerboseResolutionMode>;
            }
            interface Resolve extends CombineTypes<[_Resolve, java.lang.Object]> {}
            interface _Resolve$AbstractMethodCheck$$static extends ClassLike {
              _new(this$0: Resolve): Resolve$AbstractMethodCheck;
            }
            let Resolve$AbstractMethodCheck: _Resolve$AbstractMethodCheck$$static;
            interface _Resolve$AbstractMethodCheck {
              argumentsAcceptable(env: Env<AttrContext>, deferredAttrContext: DeferredAttr$DeferredAttrContext, argtypes: javac.util.List<javac.code.Type>, formals: javac.util.List<javac.code.Type>, warn: javac.util.Warner): void;
              _checkArg(a0: javac.util.JCDiagnostic$DiagnosticPosition, a1: boolean, a2: javac.code.Type, a3: javac.code.Type, a4: DeferredAttr$DeferredAttrContext, a5: javac.util.Warner): void;
(a0: javac.util.JCDiagnostic$DiagnosticPosition, a1: boolean, a2: javac.code.Type, a3: javac.code.Type, a4: DeferredAttr$DeferredAttrContext, a5: javac.util.Warner): void;
              mostSpecificCheck(actuals: javac.util.List<javac.code.Type>): Resolve$MethodCheck;
              _reportMC(pos: javac.util.JCDiagnostic$DiagnosticPosition, diag: Resolve$MethodCheckDiag, inferenceContext: InferenceContext, args: any[]): void;
              _reportMC(pos: javac.util.JCDiagnostic$DiagnosticPosition, diag: Resolve$MethodCheckDiag, inferenceContext: InferenceContext, ...args: any[]): void;
              _treeForDiagnostics(env: Env<AttrContext>): javac.tree.JCTree;
              _methodCheckFailure: Resolve$AbstractMethodCheck$SharedInapplicableMethodException;
              _this$0: Resolve;
            }
            interface Resolve$AbstractMethodCheck extends CombineTypes<[_Resolve$AbstractMethodCheck, com.sun.tools.javac.comp.Resolve$MethodCheck, java.lang.Object]> {}
            interface _Resolve$AbstractMethodCheck$SharedInapplicableMethodException$$static extends ClassLike {
              _serialVersionUID: long;
              _new(this$1: Resolve$AbstractMethodCheck): Resolve$AbstractMethodCheck$SharedInapplicableMethodException;
            }
            let Resolve$AbstractMethodCheck$SharedInapplicableMethodException: _Resolve$AbstractMethodCheck$SharedInapplicableMethodException$$static;
            interface _Resolve$AbstractMethodCheck$SharedInapplicableMethodException {
              _setMessage(details: javac.util.JCDiagnostic): Resolve$AbstractMethodCheck$SharedInapplicableMethodException;
              _this$1: Resolve$AbstractMethodCheck;
            }
            interface Resolve$AbstractMethodCheck$SharedInapplicableMethodException extends CombineTypes<[_Resolve$AbstractMethodCheck$SharedInapplicableMethodException, com.sun.tools.javac.comp.Resolve$InapplicableMethodException]> {}
            interface _Resolve$AccessError$$static extends ClassLike {
              _new(this$0: Env<AttrContext>, env: javac.code.Type, site: javac.code.Symbol): Resolve$AccessError;
            }
            let Resolve$AccessError: _Resolve$AccessError$$static;
            interface _Resolve$AccessError {
              exists(): boolean;
              _getDiagnostic(dkind: javac.util.JCDiagnostic$DiagnosticType, pos: javac.util.JCDiagnostic$DiagnosticPosition, location: javac.code.Symbol, site: javac.code.Type, name: javac.util.Name, argtypes: javac.util.List<javac.code.Type>, typeargtypes: javac.util.List<javac.code.Type>): javac.util.JCDiagnostic;
              _toString(type: javac.code.Type): string;
              _env: Env<AttrContext>;
              _site: javac.code.Type;
              _this$0: Resolve;
            }
            interface Resolve$AccessError extends CombineTypes<[_Resolve$AccessError, com.sun.tools.javac.comp.Resolve$InvalidSymbolError]> {}
            interface _Resolve$AmbiguityError$$static extends ClassLike {
              _new(this$0: Resolve, sym1: javac.code.Symbol, sym2: javac.code.Symbol): Resolve$AmbiguityError;
            }
            let Resolve$AmbiguityError: _Resolve$AmbiguityError$$static;
            interface _Resolve$AmbiguityError {
              _access(name: javac.util.Name, location: javac.code.Symbol$TypeSymbol): javac.code.Symbol;
              _addAmbiguousSymbol(s: javac.code.Symbol): Resolve$AmbiguityError;
              exists(): boolean;
              _flatten(sym: javac.code.Symbol): javac.util.List<javac.code.Symbol>;
              _getDiagnostic(dkind: javac.util.JCDiagnostic$DiagnosticType, pos: javac.util.JCDiagnostic$DiagnosticPosition, location: javac.code.Symbol, site: javac.code.Type, name: javac.util.Name, argtypes: javac.util.List<javac.code.Type>, typeargtypes: javac.util.List<javac.code.Type>): javac.util.JCDiagnostic;
              _mergeAbstracts(site: javac.code.Type): javac.code.Symbol;
              _ambiguousSyms: javac.util.List<javac.code.Symbol>;
              _this$0: Resolve;
            }
            interface Resolve$AmbiguityError extends CombineTypes<[_Resolve$AmbiguityError, com.sun.tools.javac.comp.Resolve$ResolveError]> {}
            interface _Resolve$ArrayConstructorReferenceLookupHelper$$static extends ClassLike {
              _new(this$0: javac.tree.JCTree$JCMemberReference, referenceTree: javac.code.Type, site: javac.util.List<javac.code.Type>, argtypes: javac.util.List<javac.code.Type>, typeargtypes: Resolve$MethodResolutionPhase): Resolve$ArrayConstructorReferenceLookupHelper;
            }
            let Resolve$ArrayConstructorReferenceLookupHelper: _Resolve$ArrayConstructorReferenceLookupHelper$$static;
            interface _Resolve$ArrayConstructorReferenceLookupHelper {
              _lookup(env: Env<AttrContext>, phase: Resolve$MethodResolutionPhase): javac.code.Symbol;
              _referenceKind(sym: javac.code.Symbol): javac.tree.JCTree$JCMemberReference$ReferenceKind;
              _this$0: Resolve;
            }
            interface Resolve$ArrayConstructorReferenceLookupHelper extends CombineTypes<[_Resolve$ArrayConstructorReferenceLookupHelper, com.sun.tools.javac.comp.Resolve$ReferenceLookupHelper]> {}
            interface _Resolve$BadClassFileError$$static extends ClassLike {
              new(this$0: Resolve, ex: javac.code.Symbol$CompletionFailure): Resolve$BadClassFileError;
            }
            let Resolve$BadClassFileError: _Resolve$BadClassFileError$$static;
            interface _Resolve$BadClassFileError {
              _getDiagnostic(dkind: javac.util.JCDiagnostic$DiagnosticType, pos: javac.util.JCDiagnostic$DiagnosticPosition, location: javac.code.Symbol, site: javac.code.Type, name: javac.util.Name, argtypes: javac.util.List<javac.code.Type>, typeargtypes: javac.util.List<javac.code.Type>): javac.util.JCDiagnostic;
              _ex: javac.code.Symbol$CompletionFailure;
              _this$0: Resolve;
            }
            interface Resolve$BadClassFileError extends CombineTypes<[_Resolve$BadClassFileError, com.sun.tools.javac.comp.Resolve$InvalidSymbolError]> {}
            interface _Resolve$BadConstructorReferenceError$$static extends ClassLike {
              new(this$0: Resolve, sym: javac.code.Symbol): Resolve$BadConstructorReferenceError;
            }
            let Resolve$BadConstructorReferenceError: _Resolve$BadConstructorReferenceError$$static;
            interface _Resolve$BadConstructorReferenceError {
              _getDiagnostic(dkind: javac.util.JCDiagnostic$DiagnosticType, pos: javac.util.JCDiagnostic$DiagnosticPosition, location: javac.code.Symbol, site: javac.code.Type, name: javac.util.Name, argtypes: javac.util.List<javac.code.Type>, typeargtypes: javac.util.List<javac.code.Type>): javac.util.JCDiagnostic;
              _this$0: Resolve;
            }
            interface Resolve$BadConstructorReferenceError extends CombineTypes<[_Resolve$BadConstructorReferenceError, com.sun.tools.javac.comp.Resolve$InvalidSymbolError]> {}
            interface _Resolve$BadMethodReferenceError$$static extends ClassLike {
              new(this$0: Resolve, sym: javac.code.Symbol, unboundLookup: boolean): Resolve$BadMethodReferenceError;
            }
            let Resolve$BadMethodReferenceError: _Resolve$BadMethodReferenceError$$static;
            interface _Resolve$BadMethodReferenceError {
              _getDiagnostic(dkind: javac.util.JCDiagnostic$DiagnosticType, pos: javac.util.JCDiagnostic$DiagnosticPosition, location: javac.code.Symbol, site: javac.code.Type, name: javac.util.Name, argtypes: javac.util.List<javac.code.Type>, typeargtypes: javac.util.List<javac.code.Type>): javac.util.JCDiagnostic;
              _this$0: Resolve;
              _unboundLookup: boolean;
            }
            interface Resolve$BadMethodReferenceError extends CombineTypes<[_Resolve$BadMethodReferenceError, com.sun.tools.javac.comp.Resolve$StaticError]> {}
            interface _Resolve$BadRestrictedTypeError$$static extends ClassLike {
              _new(this$0: Resolve, typeName: javac.util.Name): Resolve$BadRestrictedTypeError;
            }
            let Resolve$BadRestrictedTypeError: _Resolve$BadRestrictedTypeError$$static;
            interface _Resolve$BadRestrictedTypeError {
              _getDiagnostic(dkind: javac.util.JCDiagnostic$DiagnosticType, pos: javac.util.JCDiagnostic$DiagnosticPosition, location: javac.code.Symbol, site: javac.code.Type, name: javac.util.Name, argtypes: javac.util.List<javac.code.Type>, typeargtypes: javac.util.List<javac.code.Type>): javac.util.JCDiagnostic;
              _this$0: Resolve;
              _typeName: javac.util.Name;
            }
            interface Resolve$BadRestrictedTypeError extends CombineTypes<[_Resolve$BadRestrictedTypeError, com.sun.tools.javac.comp.Resolve$ResolveError]> {}
            interface _Resolve$BadVarargsMethod$$static extends ClassLike {
              _new(this$0: Resolve, delegatedError: Resolve$ResolveError): Resolve$BadVarargsMethod;
            }
            let Resolve$BadVarargsMethod: _Resolve$BadVarargsMethod$$static;
            interface _Resolve$BadVarargsMethod {
              _access(name: javac.util.Name, location: javac.code.Symbol$TypeSymbol): javac.code.Symbol;
              baseSymbol(): javac.code.Symbol;
              exists(): boolean;
              _getDiagnostic(dkind: javac.util.JCDiagnostic$DiagnosticType, pos: javac.util.JCDiagnostic$DiagnosticPosition, location: javac.code.Symbol, site: javac.code.Type, name: javac.util.Name, argtypes: javac.util.List<javac.code.Type>, typeargtypes: javac.util.List<javac.code.Type>): javac.util.JCDiagnostic;
              _delegatedError: Resolve$ResolveError;
            }
            interface Resolve$BadVarargsMethod extends CombineTypes<[_Resolve$BadVarargsMethod, com.sun.tools.javac.comp.Resolve$ResolveError]> {}
            interface _Resolve$BasicLookupHelper$$static extends ClassLike {
              _new(this$0: javac.util.Name, name: javac.code.Type, site: javac.util.List<javac.code.Type>, argtypes: javac.util.List<javac.code.Type>): Resolve$BasicLookupHelper;
              _new(this$0: javac.util.Name, name: javac.code.Type, site: javac.util.List<javac.code.Type>, argtypes: javac.util.List<javac.code.Type>, typeargtypes: Resolve$MethodResolutionPhase): Resolve$BasicLookupHelper;
            }
            let Resolve$BasicLookupHelper: _Resolve$BasicLookupHelper$$static;
            interface _Resolve$BasicLookupHelper {
              _access(env: Env<AttrContext>, pos: javac.util.JCDiagnostic$DiagnosticPosition, location: javac.code.Symbol, sym: javac.code.Symbol): javac.code.Symbol;
              _debug(pos: javac.util.JCDiagnostic$DiagnosticPosition, sym: javac.code.Symbol): void;
              _doLookup(a0: Env<AttrContext>, a1: Resolve$MethodResolutionPhase): javac.code.Symbol;
(a0: Env<AttrContext>, a1: Resolve$MethodResolutionPhase): javac.code.Symbol;
              _lookup(env: Env<AttrContext>, phase: Resolve$MethodResolutionPhase): javac.code.Symbol;
              _this$0: Resolve;
            }
            interface Resolve$BasicLookupHelper extends CombineTypes<[_Resolve$BasicLookupHelper, com.sun.tools.javac.comp.Resolve$LookupHelper]> {}
            interface _Resolve$ConstructorReferenceLookupHelper$$static extends ClassLike {
              _new(this$0: javac.tree.JCTree$JCMemberReference, referenceTree: javac.code.Type, site: javac.util.List<javac.code.Type>, argtypes: javac.util.List<javac.code.Type>, typeargtypes: Resolve$MethodResolutionPhase): Resolve$ConstructorReferenceLookupHelper;
            }
            let Resolve$ConstructorReferenceLookupHelper: _Resolve$ConstructorReferenceLookupHelper$$static;
            interface _Resolve$ConstructorReferenceLookupHelper {
              _lookup(env: Env<AttrContext>, phase: Resolve$MethodResolutionPhase): javac.code.Symbol;
              _referenceKind(sym: javac.code.Symbol): javac.tree.JCTree$JCMemberReference$ReferenceKind;
              _needsInference: boolean;
              _this$0: Resolve;
            }
            interface Resolve$ConstructorReferenceLookupHelper extends CombineTypes<[_Resolve$ConstructorReferenceLookupHelper, com.sun.tools.javac.comp.Resolve$ReferenceLookupHelper]> {}
            interface _Resolve$DiamondError$$static extends ClassLike {
              new(this$0: Resolve, sym: javac.code.Symbol, context: Resolve$MethodResolutionContext): Resolve$DiamondError;
            }
            let Resolve$DiamondError: _Resolve$DiamondError$$static;
            interface _Resolve$DiamondError {
              _getDetails(): javac.util.JCDiagnostic;
              _getDiagnostic(dkind: javac.util.JCDiagnostic$DiagnosticType, pos: javac.util.JCDiagnostic$DiagnosticPosition, location: javac.code.Symbol, site: javac.code.Type, name: javac.util.Name, argtypes: javac.util.List<javac.code.Type>, typeargtypes: javac.util.List<javac.code.Type>): javac.util.JCDiagnostic;
              _sym: javac.code.Symbol;
              _this$0: Resolve;
            }
            interface Resolve$DiamondError extends CombineTypes<[_Resolve$DiamondError, com.sun.tools.javac.comp.Resolve$InapplicableSymbolError]> {}
            interface _Resolve$InapplicableMethodException$$static extends ClassLike {
              _serialVersionUID: long;
              _new(diag: javac.util.JCDiagnostic): Resolve$InapplicableMethodException;
            }
            let Resolve$InapplicableMethodException: _Resolve$InapplicableMethodException$$static;
            interface _Resolve$InapplicableMethodException {
              fillInStackTrace(): java.lang.Throwable;
              getDiagnostic(): javac.util.JCDiagnostic;
              _diagnostic: javac.util.JCDiagnostic;
            }
            interface Resolve$InapplicableMethodException extends CombineTypes<[_Resolve$InapplicableMethodException, java.lang.RuntimeException]> {}
            interface _Resolve$InapplicableSymbolError$$static extends ClassLike {
              _new(this$0: Resolve, context: Resolve$MethodResolutionContext): Resolve$InapplicableSymbolError;
              _new(this$0: Resolve, kind: javac.code.Kinds$Kind, debugName: string, context: Resolve$MethodResolutionContext): Resolve$InapplicableSymbolError;
            }
            let Resolve$InapplicableSymbolError: _Resolve$InapplicableSymbolError$$static;
            interface _Resolve$InapplicableSymbolError {
              access(name: javac.util.Name, location: javac.code.Symbol$TypeSymbol): javac.code.Symbol;
              _errCandidate(): javac.util.Pair<javac.code.Symbol,javac.util.JCDiagnostic>;
              exists(): boolean;
              _getDiagnostic(dkind: javac.util.JCDiagnostic$DiagnosticType, pos: javac.util.JCDiagnostic$DiagnosticPosition, location: javac.code.Symbol, site: javac.code.Type, name: javac.util.Name, argtypes: javac.util.List<javac.code.Type>, typeargtypes: javac.util.List<javac.code.Type>): javac.util.JCDiagnostic;
              toString(): string;
              _resolveContext: Resolve$MethodResolutionContext;
              _this$0: Resolve;
            }
            interface Resolve$InapplicableSymbolError extends CombineTypes<[_Resolve$InapplicableSymbolError, com.sun.tools.javac.comp.Resolve$ResolveError]> {}
            interface _Resolve$InapplicableSymbolsError$$static extends ClassLike {
              _new(this$0: Resolve, context: Resolve$MethodResolutionContext): Resolve$InapplicableSymbolsError;
            }
            let Resolve$InapplicableSymbolsError: _Resolve$InapplicableSymbolsError$$static;
            interface _Resolve$InapplicableSymbolsError {
              _candidateDetails(candidatesMap: java.util.Map<javac.code.Symbol,javac.util.JCDiagnostic>, site: javac.code.Type): javac.util.List<javac.util.JCDiagnostic>;
              _errCandidate(): javac.util.Pair<javac.code.Symbol,javac.util.JCDiagnostic>;
              _filterCandidates(candidatesMap: java.util.Map<javac.code.Symbol,javac.util.JCDiagnostic>): java.util.Map<javac.code.Symbol,javac.util.JCDiagnostic>;
              _getDiagnostic(dkind: javac.util.JCDiagnostic$DiagnosticType, pos: javac.util.JCDiagnostic$DiagnosticPosition, location: javac.code.Symbol, site: javac.code.Type, name: javac.util.Name, argtypes: javac.util.List<javac.code.Type>, typeargtypes: javac.util.List<javac.code.Type>): javac.util.JCDiagnostic;
              _mapCandidates(): java.util.Map<javac.code.Symbol,javac.util.JCDiagnostic>;
              _this$0: Resolve;
            }
            interface Resolve$InapplicableSymbolsError extends CombineTypes<[_Resolve$InapplicableSymbolsError, com.sun.tools.javac.comp.Resolve$InapplicableSymbolError]> {}
            interface _Resolve$InapplicableSymbolsError$MostSpecificMap$$static extends ClassLike {
            }
            let Resolve$InapplicableSymbolsError$MostSpecificMap: _Resolve$InapplicableSymbolsError$MostSpecificMap$$static;
            interface _Resolve$InapplicableSymbolsError$MostSpecificMap {
              _put(c: Resolve$MethodResolutionContext$Candidate): void;
              _this$1: Resolve$InapplicableSymbolsError;
            }
            interface Resolve$InapplicableSymbolsError$MostSpecificMap extends CombineTypes<[_Resolve$InapplicableSymbolsError$MostSpecificMap, java.util.LinkedHashMap<javac.code.Symbol,javac.util.JCDiagnostic>]> {}
            interface _Resolve$InterfaceLookupPhase$$static extends ClassLike {
              valueOf(name: string): Resolve$InterfaceLookupPhase;
              values(): Resolve$InterfaceLookupPhase[];
              readonly ABSTRACT_OK: Resolve$InterfaceLookupPhase;
              readonly DEFAULT_OK: Resolve$InterfaceLookupPhase;
            }
            let Resolve$InterfaceLookupPhase: _Resolve$InterfaceLookupPhase$$static;
            interface _Resolve$InterfaceLookupPhase {
              _update(a0: javac.code.Symbol, a1: Resolve): Resolve$InterfaceLookupPhase;
(a0: javac.code.Symbol, a1: Resolve): Resolve$InterfaceLookupPhase;
            }
            interface Resolve$InterfaceLookupPhase extends CombineTypes<[_Resolve$InterfaceLookupPhase]> {}
            interface _Resolve$InvalidSymbolError$$static extends ClassLike {
              _new(this$0: Resolve, kind: javac.code.Kinds$Kind, sym: javac.code.Symbol, debugName: string): Resolve$InvalidSymbolError;
            }
            let Resolve$InvalidSymbolError: _Resolve$InvalidSymbolError$$static;
            interface _Resolve$InvalidSymbolError {
              access(name: javac.util.Name, location: javac.code.Symbol$TypeSymbol): javac.code.Symbol;
              exists(): boolean;
              toString(): string;
              _sym: javac.code.Symbol;
              _this$0: Resolve;
            }
            interface Resolve$InvalidSymbolError extends CombineTypes<[_Resolve$InvalidSymbolError, com.sun.tools.javac.comp.Resolve$ResolveError]> {}
            interface _Resolve$InvisibleSymbolError$$static extends ClassLike {
              _new(this$0: Env<AttrContext>, env: boolean, suppressError: javac.code.Symbol): Resolve$InvisibleSymbolError;
            }
            let Resolve$InvisibleSymbolError: _Resolve$InvisibleSymbolError$$static;
            interface _Resolve$InvisibleSymbolError {
              _getDiagnostic(dkind: javac.util.JCDiagnostic$DiagnosticType, pos: javac.util.JCDiagnostic$DiagnosticPosition, location: javac.code.Symbol, site: javac.code.Type, name: javac.util.Name, argtypes: javac.util.List<javac.code.Type>, typeargtypes: javac.util.List<javac.code.Type>): javac.util.JCDiagnostic;
              _env: Env<AttrContext>;
              _suppressError: boolean;
              _this$0: Resolve;
            }
            interface Resolve$InvisibleSymbolError extends CombineTypes<[_Resolve$InvisibleSymbolError, com.sun.tools.javac.comp.Resolve$InvalidSymbolError]> {}
            interface _Resolve$LogResolveHelper$$static extends ClassLike {
            }
            let Resolve$LogResolveHelper: _Resolve$LogResolveHelper$$static;
            interface _Resolve$LogResolveHelper {
              getArgumentTypes(a0: Resolve$ResolveError, a1: javac.code.Symbol, a2: javac.util.Name, a3: javac.util.List<javac.code.Type>): javac.util.List<javac.code.Type>;
              resolveDiagnosticNeeded(a0: javac.code.Type, a1: javac.util.List<javac.code.Type>, a2: javac.util.List<javac.code.Type>): boolean;
            }
            interface Resolve$LogResolveHelper extends CombineTypes<[_Resolve$LogResolveHelper, java.lang.Object]> {}
            interface _Resolve$LookupFilter$$static extends ClassLike {
              _new(this$0: Resolve, abstractOk: boolean): Resolve$LookupFilter;
            }
            let Resolve$LookupFilter: _Resolve$LookupFilter$$static;
            interface _Resolve$LookupFilter {
              test(s: javac.code.Symbol): boolean;
              test(a0: any): boolean;
              _abstractOk: boolean;
            }
            interface Resolve$LookupFilter extends CombineTypes<[_Resolve$LookupFilter, java.lang.Object, java.util.function.Predicate<javac.code.Symbol>]> {}
            interface _Resolve$LookupHelper$$static extends ClassLike {
              _new(this$0: javac.util.Name, name: javac.code.Type, site: javac.util.List<javac.code.Type>, argtypes: javac.util.List<javac.code.Type>, typeargtypes: Resolve$MethodResolutionPhase): Resolve$LookupHelper;
            }
            let Resolve$LookupHelper: _Resolve$LookupHelper$$static;
            interface _Resolve$LookupHelper {
              _access(a0: Env<AttrContext>, a1: javac.util.JCDiagnostic$DiagnosticPosition, a2: javac.code.Symbol, a3: javac.code.Symbol): javac.code.Symbol;
              _debug(pos: javac.util.JCDiagnostic$DiagnosticPosition, sym: javac.code.Symbol): void;
              _lookup(a0: Env<AttrContext>, a1: Resolve$MethodResolutionPhase): javac.code.Symbol;
              _shouldStop(sym: javac.code.Symbol, phase: Resolve$MethodResolutionPhase): boolean;
              _argtypes: javac.util.List<javac.code.Type>;
              _maxPhase: Resolve$MethodResolutionPhase;
              _name: javac.util.Name;
              _site: javac.code.Type;
              _typeargtypes: javac.util.List<javac.code.Type>;
            }
            interface Resolve$LookupHelper extends CombineTypes<[_Resolve$LookupHelper, java.lang.Object]> {}
            interface _Resolve$MethodCheck$$static extends ClassLike {
            }
            let Resolve$MethodCheck: _Resolve$MethodCheck$$static;
            interface _Resolve$MethodCheck {
              argumentsAcceptable(a0: Env<AttrContext>, a1: DeferredAttr$DeferredAttrContext, a2: javac.util.List<javac.code.Type>, a3: javac.util.List<javac.code.Type>, a4: javac.util.Warner): void;
              mostSpecificCheck(a0: javac.util.List<javac.code.Type>): Resolve$MethodCheck;
            }
            interface Resolve$MethodCheck extends CombineTypes<[_Resolve$MethodCheck, java.lang.Object]> {}
            interface _Resolve$MethodCheckContext$$static extends ClassLike {
              new(this$0: Resolve, strict: boolean, deferredAttrContext: DeferredAttr$DeferredAttrContext, rsWarner: javac.util.Warner): Resolve$MethodCheckContext;
            }
            let Resolve$MethodCheckContext: _Resolve$MethodCheckContext$$static;
            interface _Resolve$MethodCheckContext {
              checkWarner(pos: javac.util.JCDiagnostic$DiagnosticPosition, found: javac.code.Type, req: javac.code.Type): javac.util.Warner;
              compatible(found: javac.code.Type, req: javac.code.Type, warn: javac.util.Warner): boolean;
              deferredAttrContext(): DeferredAttr$DeferredAttrContext;
              inferenceContext(): InferenceContext;
              report(pos: javac.util.JCDiagnostic$DiagnosticPosition, details: javac.util.JCDiagnostic): void;
              toString(): string;
              _deferredAttrContext: DeferredAttr$DeferredAttrContext;
              _rsWarner: javac.util.Warner;
              _strict: boolean;
              _this$0: Resolve;
            }
            interface Resolve$MethodCheckContext extends CombineTypes<[_Resolve$MethodCheckContext, java.lang.Object, com.sun.tools.javac.comp.Check$CheckContext]> {}
            interface _Resolve$MethodCheckDiag$$static extends ClassLike {
              valueOf(name: string): Resolve$MethodCheckDiag;
              values(): Resolve$MethodCheckDiag[];
              readonly ARG_MISMATCH: Resolve$MethodCheckDiag;
              readonly ARITY_MISMATCH: Resolve$MethodCheckDiag;
              readonly INACCESSIBLE_VARARGS: Resolve$MethodCheckDiag;
              readonly VARARG_MISMATCH: Resolve$MethodCheckDiag;
            }
            let Resolve$MethodCheckDiag: _Resolve$MethodCheckDiag$$static;
            interface _Resolve$MethodCheckDiag {
              _regex(): string;
              _basicKey: string;
              _inferKey: string;
            }
            interface Resolve$MethodCheckDiag extends CombineTypes<[_Resolve$MethodCheckDiag]> {}
            interface _Resolve$MethodReferenceCheck$$static extends ClassLike {
              _new(this$0: Resolve, pendingInferenceContext: InferenceContext): Resolve$MethodReferenceCheck;
            }
            let Resolve$MethodReferenceCheck: _Resolve$MethodReferenceCheck$$static;
            interface _Resolve$MethodReferenceCheck {
              _checkArg(pos: javac.util.JCDiagnostic$DiagnosticPosition, varargs: boolean, actual: javac.code.Type, formal: javac.code.Type, deferredAttrContext: DeferredAttr$DeferredAttrContext, warn: javac.util.Warner): void;
              _methodCheckResult(varargsCheck: boolean, to: javac.code.Type, deferredAttrContext: DeferredAttr$DeferredAttrContext, rsWarner: javac.util.Warner): Attr$ResultInfo;
              mostSpecificCheck(actuals: javac.util.List<javac.code.Type>): Resolve$MethodCheck;
              toString(): string;
              _pendingInferenceContext: InferenceContext;
              _this$0: Resolve;
            }
            interface Resolve$MethodReferenceCheck extends CombineTypes<[_Resolve$MethodReferenceCheck, com.sun.tools.javac.comp.Resolve$AbstractMethodCheck]> {}
            interface _Resolve$MethodReferenceLookupHelper$$static extends ClassLike {
              _new(this$0: javac.tree.JCTree$JCMemberReference, referenceTree: javac.util.Name, name: javac.code.Type, site: javac.util.List<javac.code.Type>, argtypes: javac.util.List<javac.code.Type>, typeargtypes: Resolve$MethodResolutionPhase): Resolve$MethodReferenceLookupHelper;
            }
            let Resolve$MethodReferenceLookupHelper: _Resolve$MethodReferenceLookupHelper$$static;
            interface _Resolve$MethodReferenceLookupHelper {
              _lookup(env: Env<AttrContext>, phase: Resolve$MethodResolutionPhase): javac.code.Symbol;
              _referenceKind(sym: javac.code.Symbol): javac.tree.JCTree$JCMemberReference$ReferenceKind;
              _unboundLookup(inferenceContext: InferenceContext): Resolve$ReferenceLookupHelper;
              _originalSite: javac.code.Type;
              _this$0: Resolve;
            }
            interface Resolve$MethodReferenceLookupHelper extends CombineTypes<[_Resolve$MethodReferenceLookupHelper, com.sun.tools.javac.comp.Resolve$ReferenceLookupHelper]> {}
            interface _Resolve$MethodResolutionContext$$static extends ClassLike {
              _new(this$0: Resolve): Resolve$MethodResolutionContext;
            }
            let Resolve$MethodResolutionContext: _Resolve$MethodResolutionContext$$static;
            interface _Resolve$MethodResolutionContext {
              _addApplicableCandidate(sym: javac.code.Symbol, mtype: javac.code.Type): void;
              _addInapplicableCandidate(sym: javac.code.Symbol, details: javac.util.JCDiagnostic): void;
              _attrMode(): DeferredAttr$AttrMode;
              _deferredAttrContext(sym: javac.code.Symbol, inferenceContext: InferenceContext, pendingResult: Attr$ResultInfo, warn: javac.util.Warner): DeferredAttr$DeferredAttrContext;
              _internal(): boolean;
              _attrMode: DeferredAttr$AttrMode;
              _candidates: javac.util.List<Resolve$MethodResolutionContext$Candidate>;
              _internalResolution: boolean;
              _methodCheck: Resolve$MethodCheck;
              _step: Resolve$MethodResolutionPhase;
              _this$0: Resolve;
            }
            interface Resolve$MethodResolutionContext extends CombineTypes<[_Resolve$MethodResolutionContext, java.lang.Object]> {}
            interface _Resolve$MethodResolutionContext$Candidate$$static extends ClassLike {
            }
            let Resolve$MethodResolutionContext$Candidate: _Resolve$MethodResolutionContext$Candidate$$static;
            interface _Resolve$MethodResolutionContext$Candidate {
              _isApplicable(): boolean;
              _details: javac.util.JCDiagnostic;
              _mtype: javac.code.Type;
              _step: Resolve$MethodResolutionPhase;
              _sym: javac.code.Symbol;
            }
            interface Resolve$MethodResolutionContext$Candidate extends CombineTypes<[_Resolve$MethodResolutionContext$Candidate, java.lang.Object]> {}
            interface _Resolve$MethodResolutionDiagHelper$$static extends ClassLike {
              _rewrite(diags: javac.util.JCDiagnostic$Factory, pos: javac.util.JCDiagnostic$DiagnosticPosition, source: javac.util.DiagnosticSource, dkind: javac.util.JCDiagnostic$DiagnosticType, d: javac.util.JCDiagnostic): javac.util.JCDiagnostic;
              _argMismatchTemplate: Resolve$MethodResolutionDiagHelper$Template;
              _inferArgMismatchTemplate: Resolve$MethodResolutionDiagHelper$Template;
              _rewriters: java.util.Map<Resolve$MethodResolutionDiagHelper$Template,Resolve$MethodResolutionDiagHelper$DiagnosticRewriter>;
              _skip: Resolve$MethodResolutionDiagHelper$Template;
              _new(): Resolve$MethodResolutionDiagHelper;
            }
            let Resolve$MethodResolutionDiagHelper: _Resolve$MethodResolutionDiagHelper$$static;
            interface _Resolve$MethodResolutionDiagHelper {
            }
            interface Resolve$MethodResolutionDiagHelper extends CombineTypes<[_Resolve$MethodResolutionDiagHelper, java.lang.Object]> {}
            interface _Resolve$MethodResolutionDiagHelper$ArgMismatchRewriter$$static extends ClassLike {
              new(causeIndex: int): Resolve$MethodResolutionDiagHelper$ArgMismatchRewriter;
            }
            let Resolve$MethodResolutionDiagHelper$ArgMismatchRewriter: _Resolve$MethodResolutionDiagHelper$ArgMismatchRewriter$$static;
            interface _Resolve$MethodResolutionDiagHelper$ArgMismatchRewriter {
              rewriteDiagnostic(diags: javac.util.JCDiagnostic$Factory, preferredPos: javac.util.JCDiagnostic$DiagnosticPosition, preferredSource: javac.util.DiagnosticSource, preferredKind: javac.util.JCDiagnostic$DiagnosticType, d: javac.util.JCDiagnostic): javac.util.JCDiagnostic;
              _causeIndex: int;
            }
            interface Resolve$MethodResolutionDiagHelper$ArgMismatchRewriter extends CombineTypes<[_Resolve$MethodResolutionDiagHelper$ArgMismatchRewriter, java.lang.Object, com.sun.tools.javac.comp.Resolve$MethodResolutionDiagHelper$DiagnosticRewriter]> {}
            interface _Resolve$MethodResolutionDiagHelper$DiagnosticRewriter$$static extends ClassLike {
            }
            let Resolve$MethodResolutionDiagHelper$DiagnosticRewriter: _Resolve$MethodResolutionDiagHelper$DiagnosticRewriter$$static;
            interface _Resolve$MethodResolutionDiagHelper$DiagnosticRewriter {
              rewriteDiagnostic(a0: javac.util.JCDiagnostic$Factory, a1: javac.util.JCDiagnostic$DiagnosticPosition, a2: javac.util.DiagnosticSource, a3: javac.util.JCDiagnostic$DiagnosticType, a4: javac.util.JCDiagnostic): javac.util.JCDiagnostic;
(a0: javac.util.JCDiagnostic$Factory, a1: javac.util.JCDiagnostic$DiagnosticPosition, a2: javac.util.DiagnosticSource, a3: javac.util.JCDiagnostic$DiagnosticType, a4: javac.util.JCDiagnostic): javac.util.JCDiagnostic;
            }
            interface Resolve$MethodResolutionDiagHelper$DiagnosticRewriter extends CombineTypes<[_Resolve$MethodResolutionDiagHelper$DiagnosticRewriter, java.lang.Object]> {}
            interface _Resolve$MethodResolutionDiagHelper$Template$$static extends ClassLike {
              _new(key: string, subTemplates: Resolve$MethodResolutionDiagHelper$Template[]): Resolve$MethodResolutionDiagHelper$Template;
              _new(key: string, ...subTemplates: Resolve$MethodResolutionDiagHelper$Template[]): Resolve$MethodResolutionDiagHelper$Template;
            }
            let Resolve$MethodResolutionDiagHelper$Template: _Resolve$MethodResolutionDiagHelper$Template$$static;
            interface _Resolve$MethodResolutionDiagHelper$Template {
              _matches(o: any): boolean;
              _regex: string;
              _subTemplates: Resolve$MethodResolutionDiagHelper$Template[];
            }
            interface Resolve$MethodResolutionDiagHelper$Template extends CombineTypes<[_Resolve$MethodResolutionDiagHelper$Template, java.lang.Object]> {}
            interface _Resolve$MethodResolutionPhase$$static extends ClassLike {
              valueOf(name: string): Resolve$MethodResolutionPhase;
              values(): Resolve$MethodResolutionPhase[];
              readonly BASIC: Resolve$MethodResolutionPhase;
              readonly BOX: Resolve$MethodResolutionPhase;
              readonly VARARITY: Resolve$MethodResolutionPhase;
            }
            let Resolve$MethodResolutionPhase: _Resolve$MethodResolutionPhase$$static;
            interface _Resolve$MethodResolutionPhase {
              isBoxingRequired(): boolean;
              isVarargsRequired(): boolean;
              mergeResults(prev: javac.code.Symbol, sym: javac.code.Symbol): javac.code.Symbol;
              _isBoxingRequired: boolean;
              _isVarargsRequired: boolean;
            }
            interface Resolve$MethodResolutionPhase extends CombineTypes<[_Resolve$MethodResolutionPhase]> {}
            interface _Resolve$MethodResultInfo$$static extends ClassLike {
              new(this$0: Resolve, pt: javac.code.Type, checkContext: Check$CheckContext): Resolve$MethodResultInfo;
            }
            let Resolve$MethodResultInfo: _Resolve$MethodResultInfo$$static;
            interface _Resolve$MethodResultInfo {
              _U(found: javac.code.Type): javac.code.Type;
              _check(pos: javac.util.JCDiagnostic$DiagnosticPosition, found: javac.code.Type): javac.code.Type;
              _dup(newPt: javac.code.Type): Resolve$MethodResultInfo;
              _dup(newContext: Check$CheckContext): Attr$ResultInfo;
              _dup(newPt: javac.code.Type, newContext: Check$CheckContext): Attr$ResultInfo;
              _dup(a0: javac.code.Type): Attr$ResultInfo;
              _this$0: Resolve;
            }
            interface Resolve$MethodResultInfo extends CombineTypes<[_Resolve$MethodResultInfo, com.sun.tools.javac.comp.Attr$ResultInfo]> {}
            interface _Resolve$MostSpecificCheck$$static extends ClassLike {
              _new(this$0: javac.util.List<javac.code.Type>): Resolve$MostSpecificCheck;
            }
            let Resolve$MostSpecificCheck: _Resolve$MostSpecificCheck$$static;
            interface _Resolve$MostSpecificCheck {
              argumentsAcceptable(env: Env<AttrContext>, deferredAttrContext: DeferredAttr$DeferredAttrContext, formals1: javac.util.List<javac.code.Type>, formals2: javac.util.List<javac.code.Type>, warn: javac.util.Warner): void;
              _methodCheckResult(to: javac.code.Type, deferredAttrContext: DeferredAttr$DeferredAttrContext, rsWarner: javac.util.Warner, actual: javac.code.Type): Attr$ResultInfo;
              mostSpecificCheck(actuals: javac.util.List<javac.code.Type>): Resolve$MethodCheck;
              _actuals: javac.util.List<javac.code.Type>;
              _this$0: Resolve;
            }
            interface Resolve$MostSpecificCheck extends CombineTypes<[_Resolve$MostSpecificCheck, com.sun.tools.javac.comp.Resolve$MethodCheck, java.lang.Object]> {}
            interface _Resolve$MostSpecificCheck$MostSpecificCheckContext$$static extends ClassLike {
              new(this$1: Resolve$MostSpecificCheck, deferredAttrContext: DeferredAttr$DeferredAttrContext, rsWarner: javac.util.Warner, actual: javac.code.Type): Resolve$MostSpecificCheck$MostSpecificCheckContext;
            }
            let Resolve$MostSpecificCheck$MostSpecificCheckContext: _Resolve$MostSpecificCheck$MostSpecificCheckContext$$static;
            interface _Resolve$MostSpecificCheck$MostSpecificCheckContext {
              compatible(found: javac.code.Type, req: javac.code.Type, warn: javac.util.Warner): boolean;
              _compatibleBySubtyping(found: javac.code.Type, req: javac.code.Type): boolean;
              _functionalInterfaceMostSpecific(t: javac.code.Type, s: javac.code.Type, tree: javac.tree.JCTree): boolean;
              _unrelatedFunctionalInterfaces(t: javac.code.Type, s: javac.code.Type): boolean;
              _unrelatedInterfaces(t: javac.code.Type, s: javac.code.Type): boolean;
              _actual: javac.code.Type;
              _this$1: Resolve$MostSpecificCheck;
            }
            interface Resolve$MostSpecificCheck$MostSpecificCheckContext extends CombineTypes<[_Resolve$MostSpecificCheck$MostSpecificCheckContext, com.sun.tools.javac.comp.Resolve$MethodCheckContext]> {}
            interface _Resolve$MostSpecificCheck$MostSpecificCheckContext$MostSpecificFunctionReturnChecker$$static extends ClassLike {
              _new(this$2: Resolve$MostSpecificCheck$MostSpecificCheckContext, tRet: javac.code.Type, sRet: javac.code.Type): Resolve$MostSpecificCheck$MostSpecificCheckContext$MostSpecificFunctionReturnChecker;
            }
            let Resolve$MostSpecificCheck$MostSpecificCheckContext$MostSpecificFunctionReturnChecker: _Resolve$MostSpecificCheck$MostSpecificCheckContext$MostSpecificFunctionReturnChecker$$static;
            interface _Resolve$MostSpecificCheck$MostSpecificCheckContext$MostSpecificFunctionReturnChecker {
              _asExpr(expr: javac.tree.JCTree$JCExpression): javac.tree.JCTree$JCExpression;
              _lambdaResults(lambda: javac.tree.JCTree$JCLambda): javac.util.List<javac.tree.JCTree$JCExpression>;
              _skip(tree: javac.tree.JCTree): void;
              visitConditional(tree: javac.tree.JCTree$JCConditional): void;
              visitLambda(tree: javac.tree.JCTree$JCLambda): void;
              visitParens(tree: javac.tree.JCTree$JCParens): void;
              visitReference(tree: javac.tree.JCTree$JCMemberReference): void;
              _result: boolean;
              _sRet: javac.code.Type;
              _tRet: javac.code.Type;
              _this$2: Resolve$MostSpecificCheck$MostSpecificCheckContext;
            }
            interface Resolve$MostSpecificCheck$MostSpecificCheckContext$MostSpecificFunctionReturnChecker extends CombineTypes<[_Resolve$MostSpecificCheck$MostSpecificCheckContext$MostSpecificFunctionReturnChecker, com.sun.tools.javac.comp.DeferredAttr$PolyScanner]> {}
            interface _Resolve$RecoveryLoadClass$$static extends ClassLike {
            }
            let Resolve$RecoveryLoadClass: _Resolve$RecoveryLoadClass$$static;
            interface _Resolve$RecoveryLoadClass {
              loadClass(a0: Env<AttrContext>, a1: javac.util.Name): javac.code.Symbol;
(a0: Env<AttrContext>, a1: javac.util.Name): javac.code.Symbol;
            }
            interface Resolve$RecoveryLoadClass extends CombineTypes<[_Resolve$RecoveryLoadClass, java.lang.Object]> {}
            interface _Resolve$ReferenceChooser$$static extends ClassLike {
              _new(this$0: Resolve): Resolve$ReferenceChooser;
            }
            let Resolve$ReferenceChooser: _Resolve$ReferenceChooser$$static;
            interface _Resolve$ReferenceChooser {
              _boundResult(a0: Resolve$ReferenceLookupResult): Resolve$ReferenceLookupResult;
              _result(boundRes: Resolve$ReferenceLookupResult, unboundRes: Resolve$ReferenceLookupResult): Resolve$ReferenceLookupResult;
              _unboundResult(a0: Resolve$ReferenceLookupResult, a1: Resolve$ReferenceLookupResult): Resolve$ReferenceLookupResult;
              _this$0: Resolve;
            }
            interface Resolve$ReferenceChooser extends CombineTypes<[_Resolve$ReferenceChooser, java.lang.Object]> {}
            interface _Resolve$ReferenceLookupHelper$$static extends ClassLike {
              _new(this$0: javac.tree.JCTree$JCMemberReference, referenceTree: javac.util.Name, name: javac.code.Type, site: javac.util.List<javac.code.Type>, argtypes: javac.util.List<javac.code.Type>, typeargtypes: Resolve$MethodResolutionPhase): Resolve$ReferenceLookupHelper;
            }
            let Resolve$ReferenceLookupHelper: _Resolve$ReferenceLookupHelper$$static;
            interface _Resolve$ReferenceLookupHelper {
              _access(env: Env<AttrContext>, pos: javac.util.JCDiagnostic$DiagnosticPosition, location: javac.code.Symbol, sym: javac.code.Symbol): javac.code.Symbol;
              _referenceKind(a0: javac.code.Symbol): javac.tree.JCTree$JCMemberReference$ReferenceKind;
(a0: javac.code.Symbol): javac.tree.JCTree$JCMemberReference$ReferenceKind;
              _unboundLookup(inferenceContext: InferenceContext): Resolve$ReferenceLookupHelper;
              _referenceTree: javac.tree.JCTree$JCMemberReference;
            }
            interface Resolve$ReferenceLookupHelper extends CombineTypes<[_Resolve$ReferenceLookupHelper, com.sun.tools.javac.comp.Resolve$LookupHelper]> {}
            interface _Resolve$ReferenceLookupResult$$static extends ClassLike {
              _error(sym: javac.code.Symbol): Resolve$ReferenceLookupResult;
              _staticKind(sym: javac.code.Symbol, resolutionContext: Resolve$MethodResolutionContext, isStaticSelector: boolean): Resolve$ReferenceLookupResult$StaticKind;
              _new(sym: javac.code.Symbol, resolutionContext: Resolve$MethodResolutionContext, isStaticSelector: boolean): Resolve$ReferenceLookupResult;
            }
            let Resolve$ReferenceLookupResult: _Resolve$ReferenceLookupResult$$static;
            interface _Resolve$ReferenceLookupResult {
              _canIgnore(): boolean;
              _hasKind(sk: Resolve$ReferenceLookupResult$StaticKind): boolean;
              _isSuccess(): boolean;
              _staticKind: Resolve$ReferenceLookupResult$StaticKind;
              _sym: javac.code.Symbol;
            }
            interface Resolve$ReferenceLookupResult extends CombineTypes<[_Resolve$ReferenceLookupResult, java.lang.Object]> {}
            interface _Resolve$ReferenceLookupResult$StaticKind$$static extends ClassLike {
              _from(s: javac.code.Symbol): Resolve$ReferenceLookupResult$StaticKind;
              _reduce(sk1: Resolve$ReferenceLookupResult$StaticKind, sk2: Resolve$ReferenceLookupResult$StaticKind): Resolve$ReferenceLookupResult$StaticKind;
              valueOf(name: string): Resolve$ReferenceLookupResult$StaticKind;
              values(): Resolve$ReferenceLookupResult$StaticKind[];
              readonly BOTH: Resolve$ReferenceLookupResult$StaticKind;
              readonly NON_STATIC: Resolve$ReferenceLookupResult$StaticKind;
              readonly STATIC: Resolve$ReferenceLookupResult$StaticKind;
              readonly UNDEFINED: Resolve$ReferenceLookupResult$StaticKind;
            }
            let Resolve$ReferenceLookupResult$StaticKind: _Resolve$ReferenceLookupResult$StaticKind$$static;
            interface _Resolve$ReferenceLookupResult$StaticKind {
            }
            interface Resolve$ReferenceLookupResult$StaticKind extends CombineTypes<[_Resolve$ReferenceLookupResult$StaticKind]> {}
            interface _Resolve$ResolveDeferredRecoveryMap$$static extends ClassLike {
              new(this$0: Resolve, mode: DeferredAttr$AttrMode, msym: javac.code.Symbol, step: Resolve$MethodResolutionPhase): Resolve$ResolveDeferredRecoveryMap;
            }
            let Resolve$ResolveDeferredRecoveryMap: _Resolve$ResolveDeferredRecoveryMap$$static;
            interface _Resolve$ResolveDeferredRecoveryMap {
              _typeOf(dt: DeferredAttr$DeferredType, pt: javac.code.Type): javac.code.Type;
              _typeOf(a0: DeferredAttr$DeferredType, a1: any): javac.code.Type;
            }
            interface Resolve$ResolveDeferredRecoveryMap extends CombineTypes<[_Resolve$ResolveDeferredRecoveryMap, com.sun.tools.javac.comp.DeferredAttr$RecoveryDeferredTypeMap]> {}
            interface _Resolve$ResolveError$$static extends ClassLike {
              _new(this$0: Resolve, kind: javac.code.Kinds$Kind, debugName: string): Resolve$ResolveError;
            }
            let Resolve$ResolveError: _Resolve$ResolveError$$static;
            interface _Resolve$ResolveError {
              accept<R, P>(v: javax.lang.model.element.ElementVisitor<R,P>, p: P): R;
              _access(name: javac.util.Name, location: javac.code.Symbol$TypeSymbol): javac.code.Symbol;
              exists(): boolean;
              _getDiagnostic(a0: javac.util.JCDiagnostic$DiagnosticType, a1: javac.util.JCDiagnostic$DiagnosticPosition, a2: javac.code.Symbol, a3: javac.code.Type, a4: javac.util.Name, a5: javac.util.List<javac.code.Type>, a6: javac.util.List<javac.code.Type>): javac.util.JCDiagnostic;
(a0: javac.util.JCDiagnostic$DiagnosticType, a1: javac.util.JCDiagnostic$DiagnosticPosition, a2: javac.code.Symbol, a3: javac.code.Type, a4: javac.util.Name, a5: javac.util.List<javac.code.Type>, a6: javac.util.List<javac.code.Type>): javac.util.JCDiagnostic;
              isStatic(): boolean;
              toString(): string;
              _debugName: string;
              _this$0: Resolve;
            }
            interface Resolve$ResolveError extends CombineTypes<[_Resolve$ResolveError, com.sun.tools.javac.code.Symbol]> {}
            interface _Resolve$StaticError$$static extends ClassLike {
              _new(this$0: Resolve, sym: javac.code.Symbol): Resolve$StaticError;
            }
            let Resolve$StaticError: _Resolve$StaticError$$static;
            interface _Resolve$StaticError {
              _getDiagnostic(dkind: javac.util.JCDiagnostic$DiagnosticType, pos: javac.util.JCDiagnostic$DiagnosticPosition, location: javac.code.Symbol, site: javac.code.Type, name: javac.util.Name, argtypes: javac.util.List<javac.code.Type>, typeargtypes: javac.util.List<javac.code.Type>): javac.util.JCDiagnostic;
              _this$0: Resolve;
            }
            interface Resolve$StaticError extends CombineTypes<[_Resolve$StaticError, com.sun.tools.javac.comp.Resolve$InvalidSymbolError]> {}
            interface _Resolve$SymbolNotFoundError$$static extends ClassLike {
              _new(this$0: Resolve, kind: javac.code.Kinds$Kind): Resolve$SymbolNotFoundError;
              _new(this$0: Resolve, kind: javac.code.Kinds$Kind, debugName: string): Resolve$SymbolNotFoundError;
            }
            let Resolve$SymbolNotFoundError: _Resolve$SymbolNotFoundError$$static;
            interface _Resolve$SymbolNotFoundError {
              _args(args: javac.util.List<javac.code.Type>): any;
              _getDiagnostic(dkind: javac.util.JCDiagnostic$DiagnosticType, pos: javac.util.JCDiagnostic$DiagnosticPosition, location: javac.code.Symbol, site: javac.code.Type, name: javac.util.Name, argtypes: javac.util.List<javac.code.Type>, typeargtypes: javac.util.List<javac.code.Type>): javac.util.JCDiagnostic;
              _getErrorKey(kindname: javac.code.Kinds$KindName, hasTypeArgs: boolean, hasLocation: boolean): string;
              _getLocationDiag(location: javac.code.Symbol, site: javac.code.Type): javac.util.JCDiagnostic;
              _this$0: Resolve;
            }
            interface Resolve$SymbolNotFoundError extends CombineTypes<[_Resolve$SymbolNotFoundError, com.sun.tools.javac.comp.Resolve$ResolveError]> {}
            interface _Resolve$UnboundMethodReferenceLookupHelper$$static extends ClassLike {
              _new(this$0: javac.tree.JCTree$JCMemberReference, referenceTree: javac.util.Name, name: javac.code.Type, site: javac.util.List<javac.code.Type>, argtypes: javac.util.List<javac.code.Type>, typeargtypes: Resolve$MethodResolutionPhase): Resolve$UnboundMethodReferenceLookupHelper;
            }
            let Resolve$UnboundMethodReferenceLookupHelper: _Resolve$UnboundMethodReferenceLookupHelper$$static;
            interface _Resolve$UnboundMethodReferenceLookupHelper {
              _referenceKind(sym: javac.code.Symbol): javac.tree.JCTree$JCMemberReference$ReferenceKind;
              _unboundLookup(inferenceContext: InferenceContext): Resolve$ReferenceLookupHelper;
            }
            interface Resolve$UnboundMethodReferenceLookupHelper extends CombineTypes<[_Resolve$UnboundMethodReferenceLookupHelper, com.sun.tools.javac.comp.Resolve$MethodReferenceLookupHelper]> {}
            interface _Resolve$VerboseResolutionMode$$static extends ClassLike {
              _getVerboseResolutionMode(opts: javac.util.Options): java.util.EnumSet<Resolve$VerboseResolutionMode>;
              valueOf(name: string): Resolve$VerboseResolutionMode;
              values(): Resolve$VerboseResolutionMode[];
              readonly APPLICABLE: Resolve$VerboseResolutionMode;
              readonly DEFERRED_INST: Resolve$VerboseResolutionMode;
              readonly FAILURE: Resolve$VerboseResolutionMode;
              readonly INAPPLICABLE: Resolve$VerboseResolutionMode;
              readonly INTERNAL: Resolve$VerboseResolutionMode;
              readonly OBJECT_INIT: Resolve$VerboseResolutionMode;
              readonly PREDEF: Resolve$VerboseResolutionMode;
              readonly SUCCESS: Resolve$VerboseResolutionMode;
            }
            let Resolve$VerboseResolutionMode: _Resolve$VerboseResolutionMode$$static;
            interface _Resolve$VerboseResolutionMode {
              _opt: string;
            }
            interface Resolve$VerboseResolutionMode extends CombineTypes<[_Resolve$VerboseResolutionMode]> {}
            interface _ThisEscapeAnalyzer$$static extends ClassLike {
              _new(names: javac.util.Names, syms: javac.code.Symtab, types: javac.code.Types, log: javac.util.Log, lint: javac.code.Lint): ThisEscapeAnalyzer;
            }
            let ThisEscapeAnalyzer: _ThisEscapeAnalyzer$$static;
            interface _ThisEscapeAnalyzer {
              _analyzeStatements(stats: javac.util.List<javac.tree.JCTree$JCStatement>): void;
              analyzeTree(env: Env<AttrContext>): void;
              _checkInvariants(analyzing: boolean, allowExpr: boolean): boolean;
              _copyPendingWarning(): boolean;
              _invoke(site: javac.tree.JCTree, sym: javac.code.Symbol, args: javac.util.List<javac.tree.JCTree$JCExpression>, receiverRefs: ThisEscapeAnalyzer$RefSet<any>): void;
              _invokeInvokable(site: javac.tree.JCTree, args: javac.util.List<javac.tree.JCTree$JCExpression>, receiverRefs: ThisEscapeAnalyzer$RefSet<any>, methodInfo: ThisEscapeAnalyzer$MethodInfo): void;
              _invokeUnknown(invoke: javac.tree.JCTree, args: javac.util.List<javac.tree.JCTree$JCExpression>, receiverRefs: ThisEscapeAnalyzer$RefSet<any>): void;
              _isAnalyzing(): boolean;
              _isExplicitThisReference(types: javac.code.Types, currentClass: javac.code.Type$ClassType, tree: javac.tree.JCTree): boolean;
              _isParamOrVar(sym: javac.code.Symbol): boolean;
              _leakAt(tree: javac.tree.JCTree): void;
              _outerThisRefs(explicitOuterThis: javac.tree.JCTree$JCExpression, type: javac.code.Type): ThisEscapeAnalyzer$RefSet<ThisEscapeAnalyzer$OuterRef>;
              _popScope(): void;
              _pushScope(): void;
              scan(tree: javac.tree.JCTree): void;
              visitAnnotatedType(tree: javac.tree.JCTree$JCAnnotatedType): void;
              visitAnnotation(tree: javac.tree.JCTree$JCAnnotation): void;
              visitApply(invoke: javac.tree.JCTree$JCMethodInvocation): void;
              visitAssert(tree: javac.tree.JCTree$JCAssert): void;
              visitAssign(tree: javac.tree.JCTree$JCAssign): void;
              visitAssignop(tree: javac.tree.JCTree$JCAssignOp): void;
              visitBinary(tree: javac.tree.JCTree$JCBinary): void;
              visitBlock(tree: javac.tree.JCTree$JCBlock): void;
              visitCase(tree: javac.tree.JCTree$JCCase): void;
              visitClassDef(tree: javac.tree.JCTree$JCClassDecl): void;
              visitConditional(tree: javac.tree.JCTree$JCConditional): void;
              visitConstantCaseLabel(tree: javac.tree.JCTree$JCConstantCaseLabel): void;
              _visitDeferred<T>(recurse: java.lang.Runnable): void;
              visitDoLoop(tree: javac.tree.JCTree$JCDoWhileLoop): void;
              visitExec(tree: javac.tree.JCTree$JCExpressionStatement): void;
              visitForLoop(tree: javac.tree.JCTree$JCForLoop): void;
              visitForeachLoop(tree: javac.tree.JCTree$JCEnhancedForLoop): void;
              visitIdent(tree: javac.tree.JCTree$JCIdent): void;
              visitIf(tree: javac.tree.JCTree$JCIf): void;
              visitIndexed(tree: javac.tree.JCTree$JCArrayAccess): void;
              visitLambda(lambda: javac.tree.JCTree$JCLambda): void;
              visitLetExpr(tree: javac.tree.JCTree$LetExpr): void;
              _visitLooped<T>(tree: T, visitor: java.util.function.Consumer<T>): void;
              visitMethodDef(tree: javac.tree.JCTree$JCMethodDecl): void;
              visitModifiers(tree: javac.tree.JCTree$JCModifiers): void;
              visitNewArray(tree: javac.tree.JCTree$JCNewArray): void;
              visitNewClass(tree: javac.tree.JCTree$JCNewClass): void;
              visitPatternCaseLabel(tree: javac.tree.JCTree$JCPatternCaseLabel): void;
              visitRecordPattern(that: javac.tree.JCTree$JCRecordPattern): void;
              visitReference(tree: javac.tree.JCTree$JCMemberReference): void;
              visitReturn(tree: javac.tree.JCTree$JCReturn): void;
              _visitScoped(promote: boolean, action: java.lang.Runnable): void;
              visitSelect(tree: javac.tree.JCTree$JCFieldAccess): void;
              visitSwitch(tree: javac.tree.JCTree$JCSwitch): void;
              visitSwitchExpression(tree: javac.tree.JCTree$JCSwitchExpression): void;
              visitSynchronized(tree: javac.tree.JCTree$JCSynchronized): void;
              visitThrow(tree: javac.tree.JCTree$JCThrow): void;
              _visitTopLevel(klass: javac.tree.JCTree$JCClassDecl, action: java.lang.Runnable): void;
              visitTypeApply(tree: javac.tree.JCTree$JCTypeApply): void;
              visitTypeArray(tree: javac.tree.JCTree$JCArrayTypeTree): void;
              visitTypeBoundKind(that: javac.tree.JCTree$TypeBoundKind): void;
              visitTypeCast(tree: javac.tree.JCTree$JCTypeCast): void;
              visitTypeIntersection(tree: javac.tree.JCTree$JCTypeIntersection): void;
              visitTypeParameter(tree: javac.tree.JCTree$JCTypeParameter): void;
              visitTypeTest(tree: javac.tree.JCTree$JCInstanceOf): void;
              visitTypeUnion(tree: javac.tree.JCTree$JCTypeUnion): void;
              visitUnary(tree: javac.tree.JCTree$JCUnary): void;
              visitVarDef(tree: javac.tree.JCTree$JCVariableDecl): void;
              visitWhileLoop(tree: javac.tree.JCTree$JCWhileLoop): void;
              visitWildcard(tree: javac.tree.JCTree$JCWildcard): void;
              visitYield(tree: javac.tree.JCTree$JCYield): void;
              _callStack: java.util.ArrayDeque<javac.util.JCDiagnostic$DiagnosticPosition>;
              _depth: int;
              _invocations: java.util.Set<javac.util.Pair<javac.tree.JCTree$JCMethodDecl,ThisEscapeAnalyzer$RefSet<ThisEscapeAnalyzer$Ref>>>;
              _lint: javac.code.Lint;
              _log: javac.util.Log;
              _methodClass: javac.tree.JCTree$JCClassDecl;
              _methodMap: java.util.Map<javac.code.Symbol,ThisEscapeAnalyzer$MethodInfo>;
              _names: javac.util.Names;
              _pendingWarning: javac.util.JCDiagnostic$DiagnosticPosition[];
              _refs: ThisEscapeAnalyzer$RefSet<ThisEscapeAnalyzer$Ref>;
              _suppressed: java.util.Set<javac.code.Symbol>;
              _syms: javac.code.Symtab;
              _targetClass: javac.tree.JCTree$JCClassDecl;
              _types: javac.code.Types;
              _warningList: java.util.ArrayList<javac.util.JCDiagnostic$DiagnosticPosition[]>;
            }
            interface ThisEscapeAnalyzer extends CombineTypes<[_ThisEscapeAnalyzer, com.sun.tools.javac.tree.TreeScanner]> {}
            interface _ThisEscapeAnalyzer$ExprRef$$static extends ClassLike {
              direct(depth: int): ThisEscapeAnalyzer$ExprRef;
              indirect(depth: int): ThisEscapeAnalyzer$ExprRef;
              _new(depth: int, direct: boolean): ThisEscapeAnalyzer$ExprRef;
            }
            let ThisEscapeAnalyzer$ExprRef: _ThisEscapeAnalyzer$ExprRef$$static;
            interface _ThisEscapeAnalyzer$ExprRef {
            }
            interface ThisEscapeAnalyzer$ExprRef extends CombineTypes<[_ThisEscapeAnalyzer$ExprRef, com.sun.tools.javac.comp.ThisEscapeAnalyzer$Ref]> {}
            interface _ThisEscapeAnalyzer$MethodInfo$$static extends ClassLike {
            }
            let ThisEscapeAnalyzer$MethodInfo: _ThisEscapeAnalyzer$MethodInfo$$static;
            interface _ThisEscapeAnalyzer$MethodInfo {
              analyzable(): boolean;
              declaration(): javac.tree.JCTree$JCMethodDecl;
              declaringClass(): javac.tree.JCTree$JCClassDecl;
              equals(o: any): boolean;
              hashCode(): int;
              invokable(): boolean;
              toString(): string;
            }
            interface ThisEscapeAnalyzer$MethodInfo extends CombineTypes<[_ThisEscapeAnalyzer$MethodInfo, java.lang.Record]> {}
            interface _ThisEscapeAnalyzer$OuterRef$$static extends ClassLike {
              _new(direct: boolean): ThisEscapeAnalyzer$OuterRef;
            }
            let ThisEscapeAnalyzer$OuterRef: _ThisEscapeAnalyzer$OuterRef$$static;
            interface _ThisEscapeAnalyzer$OuterRef {
            }
            interface ThisEscapeAnalyzer$OuterRef extends CombineTypes<[_ThisEscapeAnalyzer$OuterRef, com.sun.tools.javac.comp.ThisEscapeAnalyzer$Ref]> {}
            interface _ThisEscapeAnalyzer$Ref$$static extends ClassLike {
              _new(depth: int, direct: boolean): ThisEscapeAnalyzer$Ref;
            }
            let ThisEscapeAnalyzer$Ref: _ThisEscapeAnalyzer$Ref$$static;
            interface _ThisEscapeAnalyzer$Ref {
              _addProperties(properties: java.util.ArrayList<string>): void;
              equals(obj: any): boolean;
              getDepth(): int;
              hashCode(): int;
              isDirect(): boolean;
              toString(): string;
              _depth: int;
              _direct: boolean;
            }
            interface ThisEscapeAnalyzer$Ref extends CombineTypes<[_ThisEscapeAnalyzer$Ref, java.lang.Object]> {}
            interface _ThisEscapeAnalyzer$RefSet$$static<T> extends ClassLike {
              newEmpty<T>(): ThisEscapeAnalyzer$RefSet<T>;
            }
            let ThisEscapeAnalyzer$RefSet: _ThisEscapeAnalyzer$RefSet$$static<T>;
            interface _ThisEscapeAnalyzer$RefSet<T> {
              clone(): ThisEscapeAnalyzer$RefSet<T>;
              clone(): any;
              discardExprs(depth: int): boolean;
              mapInto<S>(dest: ThisEscapeAnalyzer$RefSet<S>, type: java.lang.Class<ThisEscapeAnalyzer$Ref>, mapper: java.util.function.Function<boolean,S>): void;
              removeExprs(depth: int): ThisEscapeAnalyzer$RefSet<ThisEscapeAnalyzer$ExprRef>;
              removeExprs(depth: int, handler: java.util.function.Consumer<boolean>): void;
              replace(type: java.lang.Class<ThisEscapeAnalyzer$Ref>, mapper: java.util.function.Function<boolean,T>): void;
              replaceExprs(depth: int, mapper: java.util.function.Function<boolean,T>): void;
            }
            interface ThisEscapeAnalyzer$RefSet<T> extends CombineTypes<[_ThisEscapeAnalyzer$RefSet<T>, java.util.HashSet<T>]> {}
            interface _ThisEscapeAnalyzer$ReturnRef$$static extends ClassLike {
              _new(direct: boolean): ThisEscapeAnalyzer$ReturnRef;
            }
            let ThisEscapeAnalyzer$ReturnRef: _ThisEscapeAnalyzer$ReturnRef$$static;
            interface _ThisEscapeAnalyzer$ReturnRef {
            }
            interface ThisEscapeAnalyzer$ReturnRef extends CombineTypes<[_ThisEscapeAnalyzer$ReturnRef, com.sun.tools.javac.comp.ThisEscapeAnalyzer$Ref]> {}
            interface _ThisEscapeAnalyzer$ThisRef$$static extends ClassLike {
              direct(): ThisEscapeAnalyzer$ThisRef;
              indirect(): ThisEscapeAnalyzer$ThisRef;
              _new(direct: boolean): ThisEscapeAnalyzer$ThisRef;
            }
            let ThisEscapeAnalyzer$ThisRef: _ThisEscapeAnalyzer$ThisRef$$static;
            interface _ThisEscapeAnalyzer$ThisRef {
            }
            interface ThisEscapeAnalyzer$ThisRef extends CombineTypes<[_ThisEscapeAnalyzer$ThisRef, com.sun.tools.javac.comp.ThisEscapeAnalyzer$Ref]> {}
            interface _ThisEscapeAnalyzer$VarRef$$static extends ClassLike {
              direct(sym: javac.code.Symbol$VarSymbol): ThisEscapeAnalyzer$VarRef;
              indirect(sym: javac.code.Symbol$VarSymbol): ThisEscapeAnalyzer$VarRef;
              _new(sym: javac.code.Symbol$VarSymbol, direct: boolean): ThisEscapeAnalyzer$VarRef;
            }
            let ThisEscapeAnalyzer$VarRef: _ThisEscapeAnalyzer$VarRef$$static;
            interface _ThisEscapeAnalyzer$VarRef {
              _addProperties(properties: java.util.ArrayList<string>): void;
              equals(obj: any): boolean;
              getSymbol(): javac.code.Symbol$VarSymbol;
              hashCode(): int;
              _sym: javac.code.Symbol$VarSymbol;
            }
            interface ThisEscapeAnalyzer$VarRef extends CombineTypes<[_ThisEscapeAnalyzer$VarRef, com.sun.tools.javac.comp.ThisEscapeAnalyzer$Ref]> {}
            interface _ThisEscapeAnalyzer$YieldRef$$static extends ClassLike {
              _new(direct: boolean): ThisEscapeAnalyzer$YieldRef;
            }
            let ThisEscapeAnalyzer$YieldRef: _ThisEscapeAnalyzer$YieldRef$$static;
            interface _ThisEscapeAnalyzer$YieldRef {
            }
            interface ThisEscapeAnalyzer$YieldRef extends CombineTypes<[_ThisEscapeAnalyzer$YieldRef, com.sun.tools.javac.comp.ThisEscapeAnalyzer$Ref]> {}
            interface _Todo$$static extends ClassLike {
              instance(context: javac.util.Context): Todo;
              _todoKey: javac.util.Context$Key<Todo>;
              _new(context: javac.util.Context): Todo;
            }
            let Todo: _Todo$$static;
            interface _Todo {
              _addByFile(env: Env<AttrContext>): void;
              append(env: Env<AttrContext>): void;
              groupByFile(): java.util.Queue<java.util.Queue<Env<AttrContext>>>;
              iterator(): java.util.Iterator<Env<AttrContext>>;
              offer(e: Env<AttrContext>): boolean;
              offer(a0: any): boolean;
              peek(): Env<AttrContext>;
              peek(): any;
              poll(): Env<AttrContext>;
              poll(): any;
              _removeByFile(env: Env<AttrContext>): void;
              retainFiles(sourceFiles: java.util.Collection<javax.tools.JavaFileObject>): void;
              size(): int;
              _contents: java.util.LinkedList<Env<AttrContext>>;
              _contentsByFile: java.util.LinkedList<java.util.Queue<Env<AttrContext>>>;
              _fileMap: java.util.Map<javax.tools.JavaFileObject,Todo$FileQueue>;
            }
            interface Todo extends CombineTypes<[_Todo, java.util.AbstractQueue<Env<AttrContext>>]> {}
            interface _Todo$FileQueue$$static extends ClassLike {
              _new(this$0: Todo): Todo$FileQueue;
            }
            let Todo$FileQueue: _Todo$FileQueue$$static;
            interface _Todo$FileQueue {
              iterator(): java.util.Iterator<Env<AttrContext>>;
              offer(e: Env<AttrContext>): boolean;
              offer(a0: any): boolean;
              peek(): Env<AttrContext>;
              peek(): any;
              poll(): Env<AttrContext>;
              poll(): any;
              size(): int;
              _fileContents: java.util.LinkedList<Env<AttrContext>>;
              _this$0: Todo;
            }
            interface Todo$FileQueue extends CombineTypes<[_Todo$FileQueue, java.util.AbstractQueue<Env<AttrContext>>]> {}
            interface _TransLiterals$$static extends ClassLike {
              instance(context: javac.util.Context): TransLiterals;
              _transLiteralsKey: javac.util.Context$Key<TransLiterals>;
              _new(context: javac.util.Context): TransLiterals;
            }
            let TransLiterals: _TransLiterals$$static;
            interface _TransLiterals {
              _lookupMethod(pos: javac.util.JCDiagnostic$DiagnosticPosition, name: javac.util.Name, qual: javac.code.Type, args: javac.util.List<javac.code.Type>): javac.code.Symbol$MethodSymbol;
              _makeBinary(optag: javac.tree.JCTree$Tag, lhs: javac.tree.JCTree$JCExpression, rhs: javac.tree.JCTree$JCExpression): javac.tree.JCTree$JCBinary;
              _makeLit(type: javac.code.Type, value: any): javac.tree.JCTree$JCExpression;
              _makeString(string: string): javac.tree.JCTree$JCExpression;
              _makeStringList(strings: javac.util.List<string>): javac.util.List<javac.tree.JCTree$JCExpression>;
              translateTopLevelClass(env: Env<AttrContext>, cdef: javac.tree.JCTree, make: javac.tree.TreeMaker): javac.tree.JCTree;
              visitClassDef(tree: javac.tree.JCTree$JCClassDecl): void;
              visitMethodDef(tree: javac.tree.JCTree$JCMethodDecl): void;
              visitStringTemplate(tree: javac.tree.JCTree$JCStringTemplate): void;
              visitVarDef(tree: javac.tree.JCTree$JCVariableDecl): void;
              _currentClass: javac.code.Symbol$ClassSymbol;
              _currentMethodSym: javac.code.Symbol$MethodSymbol;
              _env: Env<AttrContext>;
              _make: javac.tree.TreeMaker;
              _names: javac.util.Names;
              _operators: Operators;
              _rs: Resolve;
              _syms: javac.code.Symtab;
              _types: javac.code.Types;
            }
            interface TransLiterals extends CombineTypes<[_TransLiterals, com.sun.tools.javac.tree.TreeTranslator]> {}
            interface _TransLiterals$TransStringTemplate$$static extends ClassLike {
              _new(this$0: TransLiterals, tree: javac.tree.JCTree$JCStringTemplate): TransLiterals$TransStringTemplate;
            }
            let TransLiterals$TransStringTemplate: _TransLiterals$TransStringTemplate$$static;
            interface _TransLiterals$TransStringTemplate {
              _bsmCall(name: javac.util.Name, bootstrapName: javac.util.Name, type: javac.code.Type, args: javac.util.List<javac.tree.JCTree$JCExpression>, argTypes: javac.util.List<javac.code.Type>, staticArgValues: javac.util.List<javac.jvm.PoolConstant$LoadableConstant>, staticArgsTypes: javac.util.List<javac.code.Type>): javac.tree.JCTree$JCExpression;
              _bsmProcessCall(): javac.tree.JCTree$JCExpression;
              _concatExpression(fragments: javac.util.List<string>, expressions: javac.util.List<javac.tree.JCTree$JCExpression>): javac.tree.JCTree$JCExpression;
              _isLinkageProcessor(): boolean;
              _isNamedProcessor(name: javac.util.Name): boolean;
              _newStringTemplate(): javac.tree.JCTree$JCExpression;
              _processCall(stringTemplate: javac.tree.JCTree$JCExpression): javac.tree.JCTree$JCExpression;
              _visit(): javac.tree.JCTree$JCExpression;
              _expressionTypes: javac.util.List<javac.code.Type>;
              _expressions: javac.util.List<javac.tree.JCTree$JCExpression>;
              _fragments: javac.util.List<string>;
              _processor: javac.tree.JCTree$JCExpression;
              _this$0: TransLiterals;
              _tree: javac.tree.JCTree$JCStringTemplate;
              _useValuesList: boolean;
            }
            interface TransLiterals$TransStringTemplate extends CombineTypes<[_TransLiterals$TransStringTemplate, java.lang.Object]> {}
            interface _TransPatterns$$static extends ClassLike {
              instance(context: javac.util.Context): TransPatterns;
              _patchCompletingNormallyCases(cases: javac.util.List<javac.tree.JCTree$JCCase>): void;
              _transPatternsKey: javac.util.Context$Key<TransPatterns>;
              _new(context: javac.util.Context): TransPatterns;
            }
            let TransPatterns: _TransPatterns$$static;
            interface _TransPatterns {
              _appendBreakIfNeeded(switchTree: javac.tree.JCTree, cases: javac.util.List<javac.tree.JCTree$JCCase>, c: javac.tree.JCTree$JCCase): void;
              _convert(expr: javac.tree.JCTree$JCExpression, target: javac.code.Type): javac.tree.JCTree$JCExpression;
              _createEnumDesc(pos: javac.util.JCDiagnostic$DiagnosticPosition, enumClass: javac.code.Symbol$ClassSymbol, constant: javac.util.Name): javac.jvm.PoolConstant$LoadableConstant;
              _fixupContinue(switchTree: javac.tree.JCTree, c: javac.tree.JCTree$JCCase, indexVariable: javac.code.Symbol$VarSymbol, currentCaseIndex: int): void;
              _handleSwitch(tree: javac.tree.JCTree, selector: javac.tree.JCTree$JCExpression, cases: javac.util.List<javac.tree.JCTree$JCCase>, hasUnconditionalPattern: boolean, patternSwitch: boolean): void;
              _invokeMethodWrapper(pos: javac.util.JCDiagnostic$DiagnosticPosition, toCall: javac.code.Symbol$MethodHandleSymbol, params: javac.jvm.PoolConstant$LoadableConstant[]): javac.jvm.PoolConstant$LoadableConstant;
              _invokeMethodWrapper(pos: javac.util.JCDiagnostic$DiagnosticPosition, toCall: javac.code.Symbol$MethodHandleSymbol, ...params: javac.jvm.PoolConstant$LoadableConstant[]): javac.jvm.PoolConstant$LoadableConstant;
              _makeApply(selector: javac.tree.JCTree$JCExpression, name: javac.util.Name, args: javac.util.List<javac.tree.JCTree$JCExpression>): javac.tree.JCTree$JCMethodInvocation;
              _makeBinary(optag: javac.tree.JCTree$Tag, lhs: javac.tree.JCTree$JCExpression, rhs: javac.tree.JCTree$JCExpression): javac.tree.JCTree$JCBinary;
              _makeLit(type: javac.code.Type, value: any): javac.tree.JCTree$JCExpression;
              _makeNewClass(ctype: javac.code.Type, args: javac.util.List<javac.tree.JCTree$JCExpression>): javac.tree.JCTree$JCNewClass;
              _makeNull(): javac.tree.JCTree$JCExpression;
              _makeTypeTest(lhs: javac.tree.JCTree$JCExpression, type: javac.tree.JCTree$JCExpression): javac.tree.JCTree$JCInstanceOf;
              _makeUnary(optag: javac.tree.JCTree$Tag, arg: javac.tree.JCTree$JCExpression): javac.tree.JCTree$JCUnary;
              _mergeConditions(left: javac.tree.JCTree$JCExpression, right: javac.tree.JCTree$JCExpression): javac.tree.JCTree$JCExpression;
              _preparePatternMatchingCatchIfNeeded(tree: javac.tree.JCTree$JCBlock): void;
              _principalType(p: javac.tree.JCTree): javac.code.Type;
              _processCases(currentSwitch: javac.tree.JCTree, inputCases: javac.util.List<javac.tree.JCTree$JCCase>): javac.util.List<javac.tree.JCTree$JCCase>;
              _toLoadableConstant(l: javac.tree.JCTree$JCCaseLabel, selector: javac.code.Type): javac.jvm.PoolConstant$LoadableConstant;
              translateTopLevelClass(env: Env<AttrContext>, cdef: javac.tree.JCTree, make: javac.tree.TreeMaker): javac.tree.JCTree;
              _unrollRecordPattern(recordPattern: javac.tree.JCTree$JCRecordPattern): TransPatterns$UnrolledRecordPattern;
              visitAnyPattern(that: javac.tree.JCTree$JCAnyPattern): void;
              visitBinary(tree: javac.tree.JCTree$JCBinary): void;
              visitBindingPattern(tree: javac.tree.JCTree$JCBindingPattern): void;
              visitBlock(tree: javac.tree.JCTree$JCBlock): void;
              visitClassDef(tree: javac.tree.JCTree$JCClassDecl): void;
              visitConditional(tree: javac.tree.JCTree$JCConditional): void;
              visitDoLoop(tree: javac.tree.JCTree$JCDoWhileLoop): void;
              visitForLoop(tree: javac.tree.JCTree$JCForLoop): void;
              visitIdent(tree: javac.tree.JCTree$JCIdent): void;
              visitIf(tree: javac.tree.JCTree$JCIf): void;
              visitLambda(tree: javac.tree.JCTree$JCLambda): void;
              visitMethodDef(tree: javac.tree.JCTree$JCMethodDecl): void;
              visitRecordPattern(tree: javac.tree.JCTree$JCRecordPattern): void;
              visitSwitch(tree: javac.tree.JCTree$JCSwitch): void;
              visitSwitchExpression(tree: javac.tree.JCTree$JCSwitchExpression): void;
              visitTry(tree: javac.tree.JCTree$JCTry): void;
              visitTypeTest(tree: javac.tree.JCTree$JCInstanceOf): void;
              visitVarDef(tree: javac.tree.JCTree$JCVariableDecl): void;
              visitWhileLoop(tree: javac.tree.JCTree$JCWhileLoop): void;
              _attr: Attr;
              _bindingContext: TransPatterns$BindingContext;
              _component2Proxy: java.util.Map<javac.code.Symbol$RecordComponent,javac.code.Symbol$MethodSymbol>;
              _currentClass: javac.code.Symbol$ClassSymbol;
              _currentClassTree: javac.tree.JCTree$JCClassDecl;
              _currentMethodSym: javac.code.Symbol$MethodSymbol;
              _currentValue: javac.code.Symbol$VarSymbol;
              _deconstructorCalls: java.util.Set<javac.tree.JCTree$JCMethodInvocation>;
              _env: Env<AttrContext>;
              _make: javac.tree.TreeMaker;
              _names: javac.util.Names;
              _operators: Operators;
              _pendingMethods: javac.util.ListBuffer<javac.tree.JCTree>;
              _preview: javac.code.Preview;
              _rs: Resolve;
              _syms: javac.code.Symtab;
              _target: javac.jvm.Target;
              _types: javac.code.Types;
              _variableIndex: int;
            }
            interface TransPatterns extends CombineTypes<[_TransPatterns, com.sun.tools.javac.tree.TreeTranslator]> {}
            interface _TransPatterns$BasicBindingContext$$static extends ClassLike {
              new(this$0: TransPatterns): TransPatterns$BasicBindingContext;
            }
            let TransPatterns$BasicBindingContext: _TransPatterns$BasicBindingContext$$static;
            interface _TransPatterns$BasicBindingContext {
              _bindingDeclared(varSymbol: javac.code.Symbol$BindingSymbol): javac.code.Symbol$VarSymbol;
              _bindingVars(diagPos: int): javac.util.List<javac.tree.JCTree$JCStatement>;
              _decorateExpression(expr: javac.tree.JCTree$JCExpression): javac.tree.JCTree$JCExpression;
              _decorateStatement(stat: javac.tree.JCTree$JCStatement): javac.tree.JCTree$JCStatement;
              _getBindingFor(varSymbol: javac.code.Symbol$BindingSymbol): javac.code.Symbol$VarSymbol;
              _makeHoistedVarDecl(pos: int, varSymbol: javac.code.Symbol$VarSymbol): javac.tree.JCTree$JCVariableDecl;
              _pop(): TransPatterns$BindingContext;
              _tryPrepend(binding: javac.code.Symbol$BindingSymbol, _var: javac.tree.JCTree$JCVariableDecl): boolean;
              _hoistedVarMap: java.util.Map<javac.code.Symbol$BindingSymbol,javac.code.Symbol$VarSymbol>;
              _parent: TransPatterns$BindingContext;
              _this$0: TransPatterns;
            }
            interface TransPatterns$BasicBindingContext extends CombineTypes<[_TransPatterns$BasicBindingContext, com.sun.tools.javac.comp.TransPatterns$BindingContext]> {}
            interface _TransPatterns$BindingContext$$static extends ClassLike {
              _new(this$0: TransPatterns): TransPatterns$BindingContext;
            }
            let TransPatterns$BindingContext: _TransPatterns$BindingContext$$static;
            interface _TransPatterns$BindingContext {
              _bindingDeclared(a0: javac.code.Symbol$BindingSymbol): javac.code.Symbol$VarSymbol;
              _bindingVars(a0: int): javac.util.List<javac.tree.JCTree$JCStatement>;
              _decorateExpression(a0: javac.tree.JCTree$JCExpression): javac.tree.JCTree$JCExpression;
              _decorateStatement(a0: javac.tree.JCTree$JCStatement): javac.tree.JCTree$JCStatement;
              _getBindingFor(a0: javac.code.Symbol$BindingSymbol): javac.code.Symbol$VarSymbol;
              _pop(): TransPatterns$BindingContext;
              _tryPrepend(a0: javac.code.Symbol$BindingSymbol, a1: javac.tree.JCTree$JCVariableDecl): boolean;
            }
            interface TransPatterns$BindingContext extends CombineTypes<[_TransPatterns$BindingContext, java.lang.Object]> {}
            interface _TransPatterns$BindingDeclarationFenceBindingContext$$static extends ClassLike {
            }
            let TransPatterns$BindingDeclarationFenceBindingContext: _TransPatterns$BindingDeclarationFenceBindingContext$$static;
            interface _TransPatterns$BindingDeclarationFenceBindingContext {
              _bindingDeclared(varSymbol: javac.code.Symbol$BindingSymbol): javac.code.Symbol$VarSymbol;
            }
            interface TransPatterns$BindingDeclarationFenceBindingContext extends CombineTypes<[_TransPatterns$BindingDeclarationFenceBindingContext, com.sun.tools.javac.comp.TransPatterns$BasicBindingContext]> {}
            interface _TransPatterns$ReplaceVar$$static extends ClassLike {
              new(a0: java.util.Map<javac.code.Symbol,javac.code.Symbol>): TransPatterns$ReplaceVar;
            }
            let TransPatterns$ReplaceVar: _TransPatterns$ReplaceVar$$static;
            interface _TransPatterns$ReplaceVar {
              visitIdent(tree: javac.tree.JCTree$JCIdent): void;
              visitPatternCaseLabel(tree: javac.tree.JCTree$JCPatternCaseLabel): void;
              _fromTo: java.util.Map<javac.code.Symbol,javac.code.Symbol>;
            }
            interface TransPatterns$ReplaceVar extends CombineTypes<[_TransPatterns$ReplaceVar, com.sun.tools.javac.tree.TreeScanner]> {}
            interface _TransPatterns$UnrolledRecordPattern$$static extends ClassLike {
              _new(primaryPattern: javac.tree.JCTree$JCBindingPattern, newGuard: javac.tree.JCTree$JCExpression): TransPatterns$UnrolledRecordPattern;
            }
            let TransPatterns$UnrolledRecordPattern: _TransPatterns$UnrolledRecordPattern$$static;
            interface _TransPatterns$UnrolledRecordPattern {
              equals(o: any): boolean;
              hashCode(): int;
              newGuard(): javac.tree.JCTree$JCExpression;
              primaryPattern(): javac.tree.JCTree$JCBindingPattern;
              toString(): string;
            }
            interface TransPatterns$UnrolledRecordPattern extends CombineTypes<[_TransPatterns$UnrolledRecordPattern, java.lang.Record]> {}
            interface _TransTypes$$static extends ClassLike {
              instance(context: javac.util.Context): TransTypes;
              _statePreviousToFlowAssertMsg: string;
              _transTypesKey: javac.util.Context$Key<TransTypes>;
              _new(context: javac.util.Context): TransTypes;
            }
            let TransTypes: _TransTypes$$static;
            interface _TransTypes {
              _addBridge(pos: javac.util.JCDiagnostic$DiagnosticPosition, meth: javac.code.Symbol$MethodSymbol, impl: javac.code.Symbol$MethodSymbol, origin: javac.code.Symbol$ClassSymbol, bridges: javac.util.ListBuffer<javac.tree.JCTree>): void;
              _addBridgeIfNeeded(pos: javac.util.JCDiagnostic$DiagnosticPosition, sym: javac.code.Symbol, origin: javac.code.Symbol$ClassSymbol, bridges: javac.util.ListBuffer<javac.tree.JCTree>): void;
              _addBridges(pos: javac.util.JCDiagnostic$DiagnosticPosition, i: javac.code.Symbol$TypeSymbol, origin: javac.code.Symbol$ClassSymbol, bridges: javac.util.ListBuffer<javac.tree.JCTree>): void;
              _addBridges(pos: javac.util.JCDiagnostic$DiagnosticPosition, origin: javac.code.Symbol$ClassSymbol, bridges: javac.util.ListBuffer<javac.tree.JCTree>): void;
              _cast(tree: javac.tree.JCTree$JCExpression, target: javac.code.Type): javac.tree.JCTree$JCExpression;
              coerce(env: Env<AttrContext>, tree: javac.tree.JCTree$JCExpression, target: javac.code.Type): javac.tree.JCTree$JCExpression;
              _coerce(tree: javac.tree.JCTree$JCExpression, target: javac.code.Type): javac.tree.JCTree$JCExpression;
              _createBridgeParams(impl: javac.code.Symbol$MethodSymbol, bridge: javac.code.Symbol$MethodSymbol, bridgeType: javac.code.Type): javac.util.List<javac.code.Symbol$VarSymbol>;
              _erasure(t: javac.code.Type): javac.code.Type;
              _isBridgeNeeded(method: javac.code.Symbol$MethodSymbol, impl: javac.code.Symbol$MethodSymbol, dest: javac.code.Type): boolean;
              _isSameMemberWhenErased(type: javac.code.Type, method: javac.code.Symbol$MethodSymbol, erasure: javac.code.Type): boolean;
              _retype(tree: javac.tree.JCTree$JCExpression, erasedType: javac.code.Type, target: javac.code.Type): javac.tree.JCTree$JCExpression;
              translate<T>(tree: T, pt: javac.code.Type): T;
              translate<T>(trees: javac.util.List<T>, pt: javac.code.Type): javac.util.List<T>;
              _translateArgs<T>(_args: javac.util.List<T>, parameters: javac.util.List<javac.code.Type>, varargsElement: javac.code.Type): javac.util.List<T>;
              translateArgs<T>(_args: javac.util.List<T>, parameters: javac.util.List<javac.code.Type>, varargsElement: javac.code.Type, localEnv: Env<AttrContext>): javac.util.List<T>;
              _translateClass(c: javac.code.Symbol$ClassSymbol): void;
              translateTopLevelClass(cdef: javac.tree.JCTree, make: javac.tree.TreeMaker): javac.tree.JCTree;
              visitAnnotatedType(tree: javac.tree.JCTree$JCAnnotatedType): void;
              visitAnnotation(tree: javac.tree.JCTree$JCAnnotation): void;
              visitAnyPattern(tree: javac.tree.JCTree$JCAnyPattern): void;
              visitApply(tree: javac.tree.JCTree$JCMethodInvocation): void;
              visitAssert(tree: javac.tree.JCTree$JCAssert): void;
              visitAssign(tree: javac.tree.JCTree$JCAssign): void;
              visitAssignop(tree: javac.tree.JCTree$JCAssignOp): void;
              visitBinary(tree: javac.tree.JCTree$JCBinary): void;
              visitBindingPattern(tree: javac.tree.JCTree$JCBindingPattern): void;
              visitBreak(tree: javac.tree.JCTree$JCBreak): void;
              visitCase(tree: javac.tree.JCTree$JCCase): void;
              visitClassDef(tree: javac.tree.JCTree$JCClassDecl): void;
              visitConditional(tree: javac.tree.JCTree$JCConditional): void;
              visitConstantCaseLabel(tree: javac.tree.JCTree$JCConstantCaseLabel): void;
              visitDoLoop(tree: javac.tree.JCTree$JCDoWhileLoop): void;
              visitExec(tree: javac.tree.JCTree$JCExpressionStatement): void;
              visitForLoop(tree: javac.tree.JCTree$JCForLoop): void;
              visitForeachLoop(tree: javac.tree.JCTree$JCEnhancedForLoop): void;
              visitIdent(tree: javac.tree.JCTree$JCIdent): void;
              visitIf(tree: javac.tree.JCTree$JCIf): void;
              visitIndexed(tree: javac.tree.JCTree$JCArrayAccess): void;
              visitLambda(tree: javac.tree.JCTree$JCLambda): void;
              visitMethodDef(tree: javac.tree.JCTree$JCMethodDecl): void;
              visitNewArray(tree: javac.tree.JCTree$JCNewArray): void;
              visitNewClass(tree: javac.tree.JCTree$JCNewClass): void;
              visitParens(tree: javac.tree.JCTree$JCParens): void;
              visitPatternCaseLabel(tree: javac.tree.JCTree$JCPatternCaseLabel): void;
              visitRecordPattern(tree: javac.tree.JCTree$JCRecordPattern): void;
              visitReference(tree: javac.tree.JCTree$JCMemberReference): void;
              visitReturn(tree: javac.tree.JCTree$JCReturn): void;
              visitSelect(tree: javac.tree.JCTree$JCFieldAccess): void;
              visitStringTemplate(tree: javac.tree.JCTree$JCStringTemplate): void;
              visitSwitch(tree: javac.tree.JCTree$JCSwitch): void;
              visitSwitchExpression(tree: javac.tree.JCTree$JCSwitchExpression): void;
              visitSynchronized(tree: javac.tree.JCTree$JCSynchronized): void;
              visitThrow(tree: javac.tree.JCTree$JCThrow): void;
              visitTry(tree: javac.tree.JCTree$JCTry): void;
              visitTypeApply(tree: javac.tree.JCTree$JCTypeApply): void;
              visitTypeArray(tree: javac.tree.JCTree$JCArrayTypeTree): void;
              visitTypeCast(tree: javac.tree.JCTree$JCTypeCast): void;
              visitTypeIntersection(tree: javac.tree.JCTree$JCTypeIntersection): void;
              visitTypeTest(tree: javac.tree.JCTree$JCInstanceOf): void;
              visitUnary(tree: javac.tree.JCTree$JCUnary): void;
              visitVarDef(tree: javac.tree.JCTree$JCVariableDecl): void;
              visitWhileLoop(tree: javac.tree.JCTree$JCWhileLoop): void;
              visitYield(tree: javac.tree.JCTree$JCYield): void;
              _annotate: Annotate;
              _attr: Attr;
              _compileStates: CompileStates;
              _enter: Enter;
              _env: Env<AttrContext>;
              _log: javac.util.Log;
              _make: javac.tree.TreeMaker;
              _names: javac.util.Names;
              _pt: javac.code.Type;
              _resolve: Resolve;
              _returnType: javac.code.Type;
              _syms: javac.code.Symtab;
              _types: javac.code.Types;
            }
            interface TransTypes extends CombineTypes<[_TransTypes, com.sun.tools.javac.tree.TreeTranslator]> {}
            interface _TreeDiffer$$static extends ClassLike {
              _equiv(symbols: java.util.Collection<javac.code.Symbol>, otherSymbols: java.util.Collection<javac.code.Symbol>): java.util.Map<javac.code.Symbol,javac.code.Symbol>;
              new(symbols: java.util.Collection<javac.code.Symbol>, otherSymbols: java.util.Collection<javac.code.Symbol>): TreeDiffer;
            }
            let TreeDiffer: _TreeDiffer$$static;
            interface _TreeDiffer {
              scan(tree: javac.tree.JCTree, parameter: javac.tree.JCTree): boolean;
              _scan(xs: java.lang.Iterable<javac.tree.JCTree>, ys: java.lang.Iterable<javac.tree.JCTree>): boolean;
              _scanDimAnnotations(xs: javac.util.List<javac.util.List<javac.tree.JCTree$JCAnnotation>>, ys: javac.util.List<javac.util.List<javac.tree.JCTree$JCAnnotation>>): boolean;
              visitAnnotatedType(tree: javac.tree.JCTree$JCAnnotatedType): void;
              visitAnnotation(tree: javac.tree.JCTree$JCAnnotation): void;
              visitApply(tree: javac.tree.JCTree$JCMethodInvocation): void;
              visitAssert(tree: javac.tree.JCTree$JCAssert): void;
              visitAssign(tree: javac.tree.JCTree$JCAssign): void;
              visitAssignop(tree: javac.tree.JCTree$JCAssignOp): void;
              visitBinary(tree: javac.tree.JCTree$JCBinary): void;
              visitBindingPattern(tree: javac.tree.JCTree$JCBindingPattern): void;
              visitBlock(tree: javac.tree.JCTree$JCBlock): void;
              visitBreak(tree: javac.tree.JCTree$JCBreak): void;
              visitCase(tree: javac.tree.JCTree$JCCase): void;
              visitCatch(tree: javac.tree.JCTree$JCCatch): void;
              visitClassDef(tree: javac.tree.JCTree$JCClassDecl): void;
              visitConditional(tree: javac.tree.JCTree$JCConditional): void;
              visitConstantCaseLabel(tree: javac.tree.JCTree$JCConstantCaseLabel): void;
              visitContinue(tree: javac.tree.JCTree$JCContinue): void;
              visitDefaultCaseLabel(tree: javac.tree.JCTree$JCDefaultCaseLabel): void;
              visitDoLoop(tree: javac.tree.JCTree$JCDoWhileLoop): void;
              visitErroneous(tree: javac.tree.JCTree$JCErroneous): void;
              visitExec(tree: javac.tree.JCTree$JCExpressionStatement): void;
              visitExports(tree: javac.tree.JCTree$JCExports): void;
              visitForLoop(tree: javac.tree.JCTree$JCForLoop): void;
              visitForeachLoop(tree: javac.tree.JCTree$JCEnhancedForLoop): void;
              visitIdent(tree: javac.tree.JCTree$JCIdent): void;
              visitIf(tree: javac.tree.JCTree$JCIf): void;
              visitImport(tree: javac.tree.JCTree$JCImport): void;
              visitIndexed(tree: javac.tree.JCTree$JCArrayAccess): void;
              visitLabelled(tree: javac.tree.JCTree$JCLabeledStatement): void;
              visitLambda(tree: javac.tree.JCTree$JCLambda): void;
              visitLetExpr(tree: javac.tree.JCTree$LetExpr): void;
              visitLiteral(tree: javac.tree.JCTree$JCLiteral): void;
              visitMethodDef(tree: javac.tree.JCTree$JCMethodDecl): void;
              visitModifiers(tree: javac.tree.JCTree$JCModifiers): void;
              visitModuleDef(tree: javac.tree.JCTree$JCModuleDecl): void;
              visitNewArray(tree: javac.tree.JCTree$JCNewArray): void;
              visitNewClass(tree: javac.tree.JCTree$JCNewClass): void;
              visitOpens(tree: javac.tree.JCTree$JCOpens): void;
              visitPackageDef(tree: javac.tree.JCTree$JCPackageDecl): void;
              visitPatternCaseLabel(tree: javac.tree.JCTree$JCPatternCaseLabel): void;
              visitProvides(tree: javac.tree.JCTree$JCProvides): void;
              visitRecordPattern(tree: javac.tree.JCTree$JCRecordPattern): void;
              visitReference(tree: javac.tree.JCTree$JCMemberReference): void;
              visitRequires(tree: javac.tree.JCTree$JCRequires): void;
              visitReturn(tree: javac.tree.JCTree$JCReturn): void;
              visitSelect(tree: javac.tree.JCTree$JCFieldAccess): void;
              visitSwitch(tree: javac.tree.JCTree$JCSwitch): void;
              visitSwitchExpression(tree: javac.tree.JCTree$JCSwitchExpression): void;
              visitSynchronized(tree: javac.tree.JCTree$JCSynchronized): void;
              visitThrow(tree: javac.tree.JCTree$JCThrow): void;
              visitTopLevel(tree: javac.tree.JCTree$JCCompilationUnit): void;
              visitTry(tree: javac.tree.JCTree$JCTry): void;
              visitTypeApply(tree: javac.tree.JCTree$JCTypeApply): void;
              visitTypeArray(tree: javac.tree.JCTree$JCArrayTypeTree): void;
              visitTypeBoundKind(tree: javac.tree.JCTree$TypeBoundKind): void;
              visitTypeCast(tree: javac.tree.JCTree$JCTypeCast): void;
              visitTypeIdent(tree: javac.tree.JCTree$JCPrimitiveTypeTree): void;
              visitTypeIntersection(tree: javac.tree.JCTree$JCTypeIntersection): void;
              visitTypeParameter(tree: javac.tree.JCTree$JCTypeParameter): void;
              visitTypeTest(tree: javac.tree.JCTree$JCInstanceOf): void;
              visitTypeUnion(tree: javac.tree.JCTree$JCTypeUnion): void;
              visitUnary(tree: javac.tree.JCTree$JCUnary): void;
              visitUses(tree: javac.tree.JCTree$JCUses): void;
              visitVarDef(tree: javac.tree.JCTree$JCVariableDecl): void;
              visitWhileLoop(tree: javac.tree.JCTree$JCWhileLoop): void;
              visitWildcard(tree: javac.tree.JCTree$JCWildcard): void;
              visitYield(tree: javac.tree.JCTree$JCYield): void;
              _equiv: java.util.Map<javac.code.Symbol,javac.code.Symbol>;
              _parameter: javac.tree.JCTree;
              _result: boolean;
            }
            interface TreeDiffer extends CombineTypes<[_TreeDiffer, com.sun.tools.javac.tree.TreeScanner]> {}
            interface _TreeHasher$$static extends ClassLike {
              hash(tree: javac.tree.JCTree, symbols: java.util.Collection<javac.code.Symbol>): int;
              new(symbolHashes: java.util.Map<javac.code.Symbol,int>): TreeHasher;
            }
            let TreeHasher: _TreeHasher$$static;
            interface _TreeHasher {
              _hash(object: any): void;
              scan(tree: javac.tree.JCTree): void;
              visitIdent(tree: javac.tree.JCTree$JCIdent): void;
              visitLiteral(tree: javac.tree.JCTree$JCLiteral): void;
              visitSelect(tree: javac.tree.JCTree$JCFieldAccess): void;
              visitVarDef(tree: javac.tree.JCTree$JCVariableDecl): void;
              _result: int;
              _symbolHashes: java.util.Map<javac.code.Symbol,int>;
            }
            interface TreeHasher extends CombineTypes<[_TreeHasher, com.sun.tools.javac.tree.TreeScanner]> {}
            interface _TypeEnter$$static extends ClassLike {
              instance(context: javac.util.Context): TypeEnter;
              _checkClash: boolean;
              _typeEnterKey: javac.util.Context$Key<TypeEnter>;
              _new(context: javac.util.Context): TypeEnter;
            }
            let TypeEnter: _TypeEnter$$static;
            interface _TypeEnter {
              complete(sym: javac.code.Symbol): void;
              _defaultConstructor(make: javac.tree.TreeMaker, helper: TypeEnter$DefaultConstructorHelper): javac.tree.JCTree;
              _ensureImportsChecked(trees: javac.util.List<javac.tree.JCTree$JCCompilationUnit>): void;
              _finishImports(toplevel: javac.tree.JCTree$JCCompilationUnit, resolve: java.lang.Runnable): void;
              _handleDeprecatedAnnotations(annotations: javac.util.List<javac.tree.JCTree$JCAnnotation>, sym: javac.code.Symbol): void;
              _lookupMethod(tsym: javac.code.Symbol$TypeSymbol, name: javac.util.Name, argtypes: javac.util.List<javac.code.Type>): javac.code.Symbol$MethodSymbol;
              markDeprecated(sym: javac.code.Symbol, annotations: javac.util.List<javac.tree.JCTree$JCAnnotation>, env: Env<AttrContext>): void;
              _setFlagIfAttributeTrue(a: javac.tree.JCTree$JCAnnotation, sym: javac.code.Symbol, attribute: javac.util.Name, flag: long): void;
              _allowDeprecationOnImport: boolean;
              _annotate: Annotate;
              _attr: Attr;
              _chk: Check;
              _completeClass: TypeEnter$ImportsPhase;
              _completionEnabled: boolean;
              _deferredLintHandler: javac.code.DeferredLintHandler;
              _dependencies: javac.util.Dependencies;
              _enter: Enter;
              _lint: javac.code.Lint;
              _log: javac.util.Log;
              _make: javac.tree.TreeMaker;
              _memberEnter: MemberEnter;
              _names: javac.util.Names;
              _parserFactory: javac.parser.ParserFactory;
              _preview: javac.code.Preview;
              _syms: javac.code.Symtab;
              _todo: Todo;
              _topLevelPhase: TypeEnter$Phase;
              _typeAnnotations: javac.code.TypeAnnotations;
              _typeEnvs: TypeEnvs;
              _types: javac.code.Types;
            }
            interface TypeEnter extends CombineTypes<[_TypeEnter, java.lang.Object, com.sun.tools.javac.code.Symbol$Completer]> {}
            interface _TypeEnter$AbstractHeaderPhase$$static extends ClassLike {
              new(a0: TypeEnter, phaseName: javac.util.Dependencies$CompletionCause, next: TypeEnter$Phase): TypeEnter$AbstractHeaderPhase;
            }
            let TypeEnter$AbstractHeaderPhase: _TypeEnter$AbstractHeaderPhase$$static;
            interface _TypeEnter$AbstractHeaderPhase {
              _attribSuperTypes(env: Env<AttrContext>, baseEnv: Env<AttrContext>): void;
              _baseEnv(tree: javac.tree.JCTree$JCClassDecl, env: Env<AttrContext>): Env<AttrContext>;
              _clearTypeParams(superType: javac.tree.JCTree$JCExpression): javac.tree.JCTree$JCExpression;
              _enumBase(pos: int, c: javac.code.Symbol$ClassSymbol): javac.tree.JCTree$JCExpression;
              _modelMissingTypes(env: Env<AttrContext>, t: javac.code.Type, tree: javac.tree.JCTree$JCExpression, interfaceExpected: boolean): javac.code.Type;
              _recordBase(pos: int, c: javac.code.Symbol$ClassSymbol): javac.tree.JCTree$JCExpression;
              _this$0: TypeEnter;
            }
            interface TypeEnter$AbstractHeaderPhase extends CombineTypes<[_TypeEnter$AbstractHeaderPhase, com.sun.tools.javac.comp.TypeEnter$Phase]> {}
            interface _TypeEnter$AbstractHeaderPhase$Synthesizer$$static extends ClassLike {
              _new(a0: TypeEnter$AbstractHeaderPhase, msym: javac.code.Symbol$ModuleSymbol, originalType: javac.code.Type, interfaceExpected: boolean): TypeEnter$AbstractHeaderPhase$Synthesizer;
            }
            let TypeEnter$AbstractHeaderPhase$Synthesizer: _TypeEnter$AbstractHeaderPhase$Synthesizer$$static;
            interface _TypeEnter$AbstractHeaderPhase$Synthesizer {
              _synthesizeClass(name: javac.util.Name, owner: javac.code.Symbol): javac.code.Symbol$ClassSymbol;
              _synthesizeTyparams(sym: javac.code.Symbol$ClassSymbol, n: int): void;
              _visit(tree: javac.tree.JCTree): javac.code.Type;
              _visit(trees: javac.util.List<javac.tree.JCTree>): javac.util.List<javac.code.Type>;
              visitIdent(tree: javac.tree.JCTree$JCIdent): void;
              visitSelect(tree: javac.tree.JCTree$JCFieldAccess): void;
              visitTree(tree: javac.tree.JCTree): void;
              visitTypeApply(tree: javac.tree.JCTree$JCTypeApply): void;
              _interfaceExpected: boolean;
              _msym: javac.code.Symbol$ModuleSymbol;
              _originalType: javac.code.Type;
              _result: javac.code.Type;
              _synthesizedSymbols: javac.util.List<javac.code.Symbol$ClassSymbol>;
              _this$1: TypeEnter$AbstractHeaderPhase;
            }
            interface TypeEnter$AbstractHeaderPhase$Synthesizer extends CombineTypes<[_TypeEnter$AbstractHeaderPhase$Synthesizer, com.sun.tools.javac.tree.JCTree$Visitor]> {}
            interface _TypeEnter$AbstractMembersPhase$$static extends ClassLike {
              new(a0: TypeEnter, completionCause: javac.util.Dependencies$CompletionCause, next: TypeEnter$Phase): TypeEnter$AbstractMembersPhase;
            }
            let TypeEnter$AbstractMembersPhase: _TypeEnter$AbstractMembersPhase$$static;
            interface _TypeEnter$AbstractMembersPhase {
              _doCompleteEnvs(envs: javac.util.List<Env<AttrContext>>): void;
              _enterThisAndSuper(sym: javac.code.Symbol$ClassSymbol, env: Env<AttrContext>): void;
              _completing: boolean;
              _this$0: TypeEnter;
              _todo: javac.util.List<Env<AttrContext>>;
            }
            interface TypeEnter$AbstractMembersPhase extends CombineTypes<[_TypeEnter$AbstractMembersPhase, com.sun.tools.javac.comp.TypeEnter$Phase]> {}
            interface _TypeEnter$AnonClassConstructorHelper$$static extends ClassLike {
              _new(this$0: TypeEnter, owner: javac.code.Symbol$TypeSymbol, constr: javac.code.Symbol$MethodSymbol, encl: javac.tree.JCTree$JCExpression): TypeEnter$AnonClassConstructorHelper;
            }
            let TypeEnter$AnonClassConstructorHelper: _TypeEnter$AnonClassConstructorHelper$$static;
            interface _TypeEnter$AnonClassConstructorHelper {
              constructorSymbol(): javac.code.Symbol$MethodSymbol;
              constructorType(): javac.code.Type;
              enclosingType(): javac.code.Type;
              superArgs(): javac.util.List<javac.util.Name>;
              _based: boolean;
              _constr: javac.code.Symbol$MethodSymbol;
              _encl: javac.code.Type;
              _this$0: TypeEnter;
            }
            interface TypeEnter$AnonClassConstructorHelper extends CombineTypes<[_TypeEnter$AnonClassConstructorHelper, com.sun.tools.javac.comp.TypeEnter$BasicConstructorHelper]> {}
            interface _TypeEnter$BasicConstructorHelper$$static extends ClassLike {
              _new(this$0: TypeEnter, owner: javac.code.Symbol$TypeSymbol): TypeEnter$BasicConstructorHelper;
            }
            let TypeEnter$BasicConstructorHelper: _TypeEnter$BasicConstructorHelper$$static;
            interface _TypeEnter$BasicConstructorHelper {
              constructorSymbol(): javac.code.Symbol$MethodSymbol;
              constructorType(): javac.code.Type;
              enclosingType(): javac.code.Type;
              owner(): javac.code.Symbol$TypeSymbol;
              superArgs(): javac.util.List<javac.util.Name>;
              _constructorSymbol: javac.code.Symbol$MethodSymbol;
              _constructorType: javac.code.Type;
              _owner: javac.code.Symbol$TypeSymbol;
              _this$0: TypeEnter;
            }
            interface TypeEnter$BasicConstructorHelper extends CombineTypes<[_TypeEnter$BasicConstructorHelper, com.sun.tools.javac.comp.TypeEnter$DefaultConstructorHelper, java.lang.Object]> {}
            interface _TypeEnter$DefaultConstructorHelper$$static extends ClassLike {
            }
            let TypeEnter$DefaultConstructorHelper: _TypeEnter$DefaultConstructorHelper$$static;
            interface _TypeEnter$DefaultConstructorHelper {
              constructorSymbol(): javac.code.Symbol$MethodSymbol;
              constructorType(): javac.code.Type;
              enclosingType(): javac.code.Type;
              finalAdjustment(md: javac.tree.JCTree$JCMethodDecl): javac.tree.JCTree$JCMethodDecl;
              owner(): javac.code.Symbol$TypeSymbol;
              superArgs(): javac.util.List<javac.util.Name>;
            }
            interface TypeEnter$DefaultConstructorHelper extends CombineTypes<[_TypeEnter$DefaultConstructorHelper, java.lang.Object]> {}
            interface _TypeEnter$HeaderPhase$$static extends ClassLike {
              new(a0: TypeEnter): TypeEnter$HeaderPhase;
            }
            let TypeEnter$HeaderPhase: _TypeEnter$HeaderPhase$$static;
            interface _TypeEnter$HeaderPhase {
              _fillPermits(tree: javac.tree.JCTree$JCClassDecl, baseEnv: Env<AttrContext>): void;
              _runPhase(env: Env<AttrContext>): void;
              _this$0: TypeEnter;
            }
            interface TypeEnter$HeaderPhase extends CombineTypes<[_TypeEnter$HeaderPhase, com.sun.tools.javac.comp.TypeEnter$AbstractHeaderPhase]> {}
            interface _TypeEnter$HierarchyPhase$$static extends ClassLike {
              new(a0: TypeEnter): TypeEnter$HierarchyPhase;
            }
            let TypeEnter$HierarchyPhase: _TypeEnter$HierarchyPhase$$static;
            interface _TypeEnter$HierarchyPhase {
              _clearTypeParams(superType: javac.tree.JCTree$JCExpression): javac.tree.JCTree$JCExpression;
              complete(sym: javac.code.Symbol): void;
              _doCompleteEnvs(envs: javac.util.List<Env<AttrContext>>): void;
              _runPhase(env: Env<AttrContext>): void;
              _this$0: TypeEnter;
            }
            interface TypeEnter$HierarchyPhase extends CombineTypes<[_TypeEnter$HierarchyPhase, com.sun.tools.javac.comp.TypeEnter$AbstractHeaderPhase, com.sun.tools.javac.code.Symbol$Completer]> {}
            interface _TypeEnter$ImportsPhase$$static extends ClassLike {
              new(a0: TypeEnter): TypeEnter$ImportsPhase;
            }
            let TypeEnter$ImportsPhase: _TypeEnter$ImportsPhase$$static;
            interface _TypeEnter$ImportsPhase {
              _attribImportType(tree: javac.tree.JCTree, env: Env<AttrContext>): javac.code.Type;
              _checkClassPackageClash(tree: javac.tree.JCTree$JCPackageDecl): void;
              _doImport(tree: javac.tree.JCTree$JCImport): void;
              _importAll(imp: javac.tree.JCTree$JCImport, tsym: javac.code.Symbol$TypeSymbol, env: Env<AttrContext>): void;
              _importJavaLang(tree: javac.tree.JCTree$JCCompilationUnit, env: Env<AttrContext>, typeImportFilter: javac.code.Scope$ImportFilter): void;
              _importNamed(pos: javac.util.JCDiagnostic$DiagnosticPosition, tsym: javac.code.Symbol, env: Env<AttrContext>, imp: javac.tree.JCTree$JCImport): void;
              _importNamedStatic(imp: javac.tree.JCTree$JCImport, tsym: javac.code.Symbol$TypeSymbol, name: javac.util.Name, env: Env<AttrContext>): void;
              _importStaticAll(imp: javac.tree.JCTree$JCImport, tsym: javac.code.Symbol$TypeSymbol, env: Env<AttrContext>): void;
              _resolveImports(tree: javac.tree.JCTree$JCCompilationUnit, env: Env<AttrContext>): void;
              _runPhase(env: Env<AttrContext>): void;
              _staticImports(tree: javac.tree.JCTree$JCCompilationUnit, env: Env<AttrContext>, staticImportFilter: javac.code.Scope$ImportFilter): void;
              _cfHandler: java.util.function.BiConsumer<javac.tree.JCTree$JCImport,javac.code.Symbol$CompletionFailure>;
              _env: Env<AttrContext>;
              _staticImportFilter: javac.code.Scope$ImportFilter;
              _this$0: TypeEnter;
              _typeImportFilter: javac.code.Scope$ImportFilter;
            }
            interface TypeEnter$ImportsPhase extends CombineTypes<[_TypeEnter$ImportsPhase, com.sun.tools.javac.comp.TypeEnter$Phase]> {}
            interface _TypeEnter$MembersPhase$$static extends ClassLike {
              new(a0: TypeEnter): TypeEnter$MembersPhase;
            }
            let TypeEnter$MembersPhase: _TypeEnter$MembersPhase$$static;
            interface _TypeEnter$MembersPhase {
              _addAccessor(tree: javac.tree.JCTree$JCVariableDecl, env: Env<AttrContext>): void;
              _addEnumMembers(tree: javac.tree.JCTree$JCClassDecl, env: Env<AttrContext>): void;
              _addRecordMembersIfNeeded(tree: javac.tree.JCTree$JCClassDecl, env: Env<AttrContext>): void;
              _finishClass(tree: javac.tree.JCTree$JCClassDecl, defaultConstructor: javac.tree.JCTree, env: Env<AttrContext>): void;
              _getCanonicalConstructorDecl(tree: javac.tree.JCTree$JCClassDecl): javac.tree.JCTree$JCMethodDecl;
              _getDefaultConstructorHelper(env: Env<AttrContext>): TypeEnter$DefaultConstructorHelper;
              _runPhase(env: Env<AttrContext>): void;
              _this$0: TypeEnter;
            }
            interface TypeEnter$MembersPhase extends CombineTypes<[_TypeEnter$MembersPhase, com.sun.tools.javac.comp.TypeEnter$AbstractMembersPhase]> {}
            interface _TypeEnter$Phase$$static extends ClassLike {
              _new(this$0: TypeEnter, phaseName: javac.util.Dependencies$CompletionCause, next: TypeEnter$Phase): TypeEnter$Phase;
            }
            let TypeEnter$Phase: _TypeEnter$Phase$$static;
            interface _TypeEnter$Phase {
              completeEnvs(envs: javac.util.List<Env<AttrContext>>): javac.util.List<Env<AttrContext>>;
              _doCompleteEnvs(envs: javac.util.List<Env<AttrContext>>): void;
              _runPhase(a0: Env<AttrContext>): void;
(a0: Env<AttrContext>): void;
              _next: TypeEnter$Phase;
              _phaseName: javac.util.Dependencies$CompletionCause;
              _queue: javac.util.ListBuffer<Env<AttrContext>>;
              _this$0: TypeEnter;
            }
            interface TypeEnter$Phase extends CombineTypes<[_TypeEnter$Phase, java.lang.Object]> {}
            interface _TypeEnter$RecordConstructorHelper$$static extends ClassLike {
              _new(this$0: javac.code.Symbol$ClassSymbol, owner: javac.util.List<javac.tree.JCTree$JCVariableDecl>): TypeEnter$RecordConstructorHelper;
            }
            let TypeEnter$RecordConstructorHelper: _TypeEnter$RecordConstructorHelper$$static;
            interface _TypeEnter$RecordConstructorHelper {
              constructorSymbol(): javac.code.Symbol$MethodSymbol;
              constructorType(): javac.code.Type;
              finalAdjustment(md: javac.tree.JCTree$JCMethodDecl): javac.tree.JCTree$JCMethodDecl;
              _lastIsVarargs: boolean;
              _recordFieldDecls: javac.util.List<javac.tree.JCTree$JCVariableDecl>;
              _this$0: TypeEnter;
            }
            interface TypeEnter$RecordConstructorHelper extends CombineTypes<[_TypeEnter$RecordConstructorHelper, com.sun.tools.javac.comp.TypeEnter$BasicConstructorHelper]> {}
            interface _TypeEnter$RecordPhase$$static extends ClassLike {
              new(a0: TypeEnter): TypeEnter$RecordPhase;
            }
            let TypeEnter$RecordPhase: _TypeEnter$RecordPhase$$static;
            interface _TypeEnter$RecordPhase {
              _runPhase(env: Env<AttrContext>): void;
              _this$0: TypeEnter;
            }
            interface TypeEnter$RecordPhase extends CombineTypes<[_TypeEnter$RecordPhase, com.sun.tools.javac.comp.TypeEnter$AbstractMembersPhase]> {}
            interface _TypeEnvs$$static extends ClassLike {
              instance(context: javac.util.Context): TypeEnvs;
              _serialVersionUID: long;
              _typeEnvsKey: javac.util.Context$Key<TypeEnvs>;
              _new(context: javac.util.Context): TypeEnvs;
            }
            let TypeEnvs: _TypeEnvs$$static;
            interface _TypeEnvs {
              _clear(): void;
              _get(sym: javac.code.Symbol$TypeSymbol): Env<AttrContext>;
              _put(sym: javac.code.Symbol$TypeSymbol, env: Env<AttrContext>): Env<AttrContext>;
              _remove(sym: javac.code.Symbol$TypeSymbol): Env<AttrContext>;
              _values(): java.util.Collection<Env<AttrContext>>;
              _map: java.util.HashMap<javac.code.Symbol$TypeSymbol,Env<AttrContext>>;
            }
            interface TypeEnvs extends CombineTypes<[_TypeEnvs, java.lang.Object]> {}
          }
          module file {
            interface _BaseFileManager$$static extends ClassLike {
              getKind(path: java.nio.file.Path): javax.tools.JavaFileObject$Kind;
              getKind(name: string): javax.tools.JavaFileObject$Kind;
              _nullCheck<T>(o: T): T;
              _nullCheck<T>(it: java.util.Collection<T>): java.util.Collection<T>;
              _EMPTY_ARRAY: byte[];
              _javacFileManagerOptions: java.util.Set<javac.main.Option>;
              _new(charset: java.nio.charset.Charset): BaseFileManager;
            }
            let BaseFileManager: _BaseFileManager$$static;
            interface _BaseFileManager {
              cache(file: javax.tools.JavaFileObject, cb: java.nio.CharBuffer): void;
              clear(): void;
              _createLocations(): Locations;
              decode(inbuf: java.nio.ByteBuffer, ignoreEncodingErrors: boolean): java.nio.CharBuffer;
              _deferredClose(): void;
              flushCache(file: javax.tools.JavaFileObject): void;
              getCachedContent(file: javax.tools.JavaFileObject): java.nio.CharBuffer;
              _getClassLoader(urls: java.net.URL[]): java.lang.ClassLoader;
              getDecoder(encodingName: string, ignoreEncodingErrors: boolean): java.nio.charset.CharsetDecoder;
              _getDefaultEncodingName(): string;
              getEncodingName(): string;
              handleOption(current: string, remaining: java.util.Iterator<string>): boolean;
              handleOption(option: javac.main.Option, value: string): boolean;
              handleOptions(map: java.util.Map<javac.main.Option,string>): boolean;
              isDefaultBootClassPath(): boolean;
              isDefaultSystemModulesPath(): boolean;
              isSupportedOption(option: string): int;
              makeByteBuffer(_in: java.io.InputStream): java.nio.ByteBuffer;
              _newOutputToPath(path: java.nio.file.Path): void;
              recycleByteBuffer(buf: java.nio.ByteBuffer): void;
              resetOutputFilesWritten(): void;
              setContext(context: javac.util.Context): void;
              _updateLastUsedTime(): void;
              autoClose: boolean;
              _byteArrayCache: byte[];
              _charset: java.nio.charset.Charset;
              _classLoaderClass: string;
              _contentCache: java.util.Map<javax.tools.JavaFileObject,BaseFileManager$ContentCacheEntry>;
              _defaultEncodingName: string;
              _deferredCloseTimeout: long;
              _encodingName: string;
              _lastUsedTime: long;
              _locations: Locations;
              log: javac.util.Log;
              _multiReleaseValue: string;
              _options: javac.util.Options;
              _outputFilesWritten: java.util.HashSet<java.nio.file.Path>;
            }
            interface BaseFileManager extends CombineTypes<[_BaseFileManager, javax.tools.JavaFileManager, java.lang.Object]> {}
            interface _BaseFileManager$ContentCacheEntry$$static extends ClassLike {
              _new(file: javax.tools.JavaFileObject, cb: java.nio.CharBuffer): BaseFileManager$ContentCacheEntry;
            }
            let BaseFileManager$ContentCacheEntry: _BaseFileManager$ContentCacheEntry$$static;
            interface _BaseFileManager$ContentCacheEntry {
              _getValue(): java.nio.CharBuffer;
              _isValid(file: javax.tools.JavaFileObject): boolean;
              _ref: java.lang.ref.SoftReference<java.nio.CharBuffer>;
              _timestamp: long;
            }
            interface BaseFileManager$ContentCacheEntry extends CombineTypes<[_BaseFileManager$ContentCacheEntry, java.lang.Object]> {}
            interface _CacheFSInfo$$static extends ClassLike {
              preRegister(context: javac.util.Context): void;
              new(): CacheFSInfo;
            }
            let CacheFSInfo: _CacheFSInfo$$static;
            interface _CacheFSInfo {
              clearCache(): void;
              exists(file: java.nio.file.Path): boolean;
              _getAttributes(file: java.nio.file.Path): java.util.Optional<java.nio.file.attribute.BasicFileAttributes>;
              getCanonicalFile(file: java.nio.file.Path): java.nio.file.Path;
              getJarClassPath(file: java.nio.file.Path): java.util.List<java.nio.file.Path>;
              isDirectory(file: java.nio.file.Path): boolean;
              isFile(file: java.nio.file.Path): boolean;
              _maybeReadAttributes(file: java.nio.file.Path): java.util.Optional<java.nio.file.attribute.BasicFileAttributes>;
              _attributeCache: java.util.concurrent.ConcurrentHashMap<java.nio.file.Path,java.util.Optional<java.nio.file.attribute.BasicFileAttributes>>;
              _canonicalPathCache: java.util.concurrent.ConcurrentHashMap<java.nio.file.Path,java.nio.file.Path>;
              _jarClassPathCache: java.util.concurrent.ConcurrentHashMap<java.nio.file.Path,java.util.List<java.nio.file.Path>>;
            }
            interface CacheFSInfo extends CombineTypes<[_CacheFSInfo, com.sun.tools.javac.file.FSInfo]> {}
            interface _FSInfo$$static extends ClassLike {
              instance(context: javac.util.Context): FSInfo;
              _tryResolveFile(base: java.net.URL, input: string): java.net.URL;
              _new(): FSInfo;
              _new(context: javac.util.Context): FSInfo;
            }
            let FSInfo: _FSInfo$$static;
            interface _FSInfo {
              exists(file: java.nio.file.Path): boolean;
              getCanonicalFile(file: java.nio.file.Path): java.nio.file.Path;
              getJarClassPath(file: java.nio.file.Path): java.util.List<java.nio.file.Path>;
              getJarFSProvider(): java.nio.file.spi.FileSystemProvider;
              isDirectory(file: java.nio.file.Path): boolean;
              isFile(file: java.nio.file.Path): boolean;
              _jarFSProvider: java.nio.file.spi.FileSystemProvider;
            }
            interface FSInfo extends CombineTypes<[_FSInfo, java.lang.Object]> {}
            interface _JRTIndex$$static extends ClassLike {
              getSharedInstance(): JRTIndex;
              instance(context: javac.util.Context): JRTIndex;
              isAvailable(): boolean;
              _sharedInstance: JRTIndex;
            }
            let JRTIndex: _JRTIndex$$static;
            interface _JRTIndex {
              _getCtInfo(dir: RelativePath$RelativeDirectory): JRTIndex$CtSym;
              getCtSym(packageName: JRTIndex$charSequence): JRTIndex$CtSym;
              _getEntry(rd: RelativePath$RelativeDirectory): JRTIndex$Entry;
              isInJRT(fo: javax.tools.FileObject): boolean;
              _ctBundle: java.util.ResourceBundle;
              _entries: java.util.Map<RelativePath$RelativeDirectory,java.lang.ref.SoftReference<JRTIndex$Entry>>;
              _jrtfs: java.nio.file.FileSystem;
            }
            interface JRTIndex extends CombineTypes<[_JRTIndex, java.lang.Object]> {}
            interface _JRTIndex$CtSym$$static extends ClassLike {
              _EMPTY: JRTIndex$CtSym;
              _new(hidden: boolean, proprietary: boolean, minProfile: string): JRTIndex$CtSym;
            }
            let JRTIndex$CtSym: _JRTIndex$CtSym$$static;
            interface _JRTIndex$CtSym {
              toString(): string;
              readonly hidden: boolean;
              readonly minProfile: string;
              readonly proprietary: boolean;
            }
            interface JRTIndex$CtSym extends CombineTypes<[_JRTIndex$CtSym, java.lang.Object]> {}
            interface _JRTIndex$Entry$$static extends ClassLike {
            }
            let JRTIndex$Entry: _JRTIndex$Entry$$static;
            interface _JRTIndex$Entry {
              _ctSym: JRTIndex$CtSym;
              _files: java.util.Map<string,java.nio.file.Path>;
              _subdirs: java.util.Set<RelativePath$RelativeDirectory>;
            }
            interface JRTIndex$Entry extends CombineTypes<[_JRTIndex$Entry, java.lang.Object]> {}
            interface _JavacFileManager$$static extends ClassLike {
              _asFiles(paths: java.lang.Iterable<java.nio.file.Path>): java.lang.Iterable<java.io.File>;
              _asPaths(files: java.lang.Iterable<java.io.File>): java.lang.Iterable<java.nio.file.Path>;
              getMessage(e: java.io.IOException): string;
              getRelativeName(file: java.io.File): string;
              _isRelativeUri(uri: java.net.URI): boolean;
              _isRelativeUri(u: string): boolean;
              _isValidName(name: string): boolean;
              preRegister(context: javac.util.Context): void;
              _printAscii(format: string, args: any[]): void;
              _printAscii(format: string, ...args: any[]): void;
              testName(name: string, isValidPackageName: boolean, isValidClassName: boolean): void;
              toArray(buffer: java.nio.CharBuffer): char[];
              _validateClassName(className: string): void;
              _validatePackageName(packageName: string): void;
              _FOLLOW_LINKS_OPTIONS: java.util.Set<java.nio.file.FileVisitOption>;
              _MISSING_CONTAINER: JavacFileManager$Container;
              _NO_FILE_VISIT_OPTIONS: java.util.Set<java.nio.file.FileVisitOption>;
              _SOURCE_OR_CLASS: java.util.Set<javax.tools.JavaFileObject$Kind>;
              _fileSystemIsCaseSensitive: boolean;
              new(context: javac.util.Context, register: boolean, charset: java.nio.charset.Charset): JavacFileManager;
            }
            let JavacFileManager: _JavacFileManager$$static;
            interface _JavacFileManager {
              asPath(file: javax.tools.FileObject): java.nio.file.Path;
              _caseMapCheck(f: java.nio.file.Path, name: RelativePath): boolean;
              _checkModuleOrientedOrOutputLocation(location: javax.tools.JavaFileManager$Location): void;
              _checkNotModuleOrientedLocation(location: javax.tools.JavaFileManager$Location): void;
              _checkOutputLocation(location: javax.tools.JavaFileManager$Location): void;
              _clearCachesForLocation(location: javax.tools.JavaFileManager$Location): void;
              close(): void;
              contains(location: javax.tools.JavaFileManager$Location, fo: javax.tools.FileObject): boolean;
              flush(): void;
              getClassLoader(location: javax.tools.JavaFileManager$Location): java.lang.ClassLoader;
              _getClassOutDir(): java.nio.file.Path;
              _getContainer(path: java.nio.file.Path): JavacFileManager$Container;
              getFileForInput(location: javax.tools.JavaFileManager$Location, packageName: string, relativeName: string): javax.tools.FileObject;
              _getFileForInput(location: javax.tools.JavaFileManager$Location, name: RelativePath$RelativeFile): javax.tools.JavaFileObject;
              getFileForOutput(classname: string, kind: javax.tools.JavaFileObject$Kind, sibling: javax.tools.JavaFileObject): javax.tools.JavaFileObject;
              getFileForOutput(location: javax.tools.JavaFileManager$Location, packageName: string, relativeName: string, sibling: javax.tools.FileObject): javax.tools.FileObject;
              _getFileForOutput(location: javax.tools.JavaFileManager$Location, fileName: RelativePath$RelativeFile, sibling: javax.tools.FileObject): javax.tools.JavaFileObject;
              _getJRTIndex(): JRTIndex;
              getJavaFileForInput(location: javax.tools.JavaFileManager$Location, className: string, kind: javax.tools.JavaFileObject$Kind): javax.tools.JavaFileObject;
              getJavaFileForOutput(location: javax.tools.JavaFileManager$Location, className: string, kind: javax.tools.JavaFileObject$Kind, sibling: javax.tools.FileObject): javax.tools.JavaFileObject;
              getJavaFileObject(name: string): javax.tools.JavaFileObject;
              getJavaFileObject(file: java.nio.file.Path): javax.tools.JavaFileObject;
              getJavaFileObjects(names: string[]): java.lang.Iterable<javax.tools.JavaFileObject>;
              getJavaFileObjects(...names: string[]): java.lang.Iterable<javax.tools.JavaFileObject>;
              getJavaFileObjects(files: java.io.File[]): java.lang.Iterable<javax.tools.JavaFileObject>;
              getJavaFileObjects(...files: java.io.File[]): java.lang.Iterable<javax.tools.JavaFileObject>;
              getJavaFileObjects(paths: java.nio.file.Path[]): java.lang.Iterable<javax.tools.JavaFileObject>;
              getJavaFileObjects(...paths: java.nio.file.Path[]): java.lang.Iterable<javax.tools.JavaFileObject>;
              getJavaFileObjectsFromFiles(files: java.lang.Iterable<java.io.File>): java.lang.Iterable<javax.tools.JavaFileObject>;
              getJavaFileObjectsFromPaths(paths: java.util.Collection<java.nio.file.Path>): java.lang.Iterable<javax.tools.JavaFileObject>;
              getJavaFileObjectsFromStrings(names: java.lang.Iterable<string>): java.lang.Iterable<javax.tools.JavaFileObject>;
              getLocation(location: javax.tools.JavaFileManager$Location): java.lang.Iterable<java.io.File>;
              getLocationAsPaths(location: javax.tools.JavaFileManager$Location): java.util.Collection<java.nio.file.Path>;
              getLocationAsPaths(a0: javax.tools.JavaFileManager$Location): java.lang.Iterable;
              getLocationForModule(location: javax.tools.JavaFileManager$Location, moduleName: string): javax.tools.JavaFileManager$Location;
              getLocationForModule(location: javax.tools.JavaFileManager$Location, fo: javax.tools.JavaFileObject): javax.tools.JavaFileManager$Location;
              _getPath(first: string, more: string[]): java.nio.file.Path;
              _getPath(first: string, ...more: string[]): java.nio.file.Path;
              getServiceLoader<S>(location: javax.tools.JavaFileManager$Location, service: java.lang.Class<S>): java.util.ServiceLoader<S>;
              _getSourceOutDir(): java.nio.file.Path;
              handleOption(option: javac.main.Option, value: string): boolean;
              _hasExplicitLocation(location: javax.tools.JavaFileManager$Location): boolean;
              hasLocation(location: javax.tools.JavaFileManager$Location): boolean;
              _indexPathsAndContainersByRelativeDirectory(location: javax.tools.JavaFileManager$Location): java.util.Map<RelativePath$RelativeDirectory,java.util.List<JavacFileManager$PathAndContainer>>;
              inferBinaryName(location: javax.tools.JavaFileManager$Location, file: javax.tools.JavaFileObject): string;
              inferModuleName(location: javax.tools.JavaFileManager$Location): string;
              isSameFile(a: javax.tools.FileObject, b: javax.tools.FileObject): boolean;
              isSymbolFileEnabled(): boolean;
              _isValidFile(s: string, fileKinds: java.util.Set<javax.tools.JavaFileObject$Kind>): boolean;
              list(location: javax.tools.JavaFileManager$Location, packageName: string, kinds: java.util.Set<javax.tools.JavaFileObject$Kind>, recurse: boolean): java.lang.Iterable<javax.tools.JavaFileObject>;
              listLocationsForModules(location: javax.tools.JavaFileManager$Location): java.lang.Iterable<java.util.Set<javax.tools.JavaFileManager$Location>>;
              _pathsAndContainers(location: javax.tools.JavaFileManager$Location, relativeDirectory: RelativePath$RelativeDirectory): java.util.List<JavacFileManager$PathAndContainer>;
              _pathsAndContainers(location: javax.tools.JavaFileManager$Location): java.util.List<JavacFileManager$PathAndContainer>;
              setContext(context: javac.util.Context): void;
              setLocation(location: javax.tools.JavaFileManager$Location, searchpath: java.lang.Iterable<java.io.File>): void;
              setLocationForModule(location: javax.tools.JavaFileManager$Location, moduleName: string, paths: java.util.Collection<java.nio.file.Path>): void;
              setLocationFromPaths(location: javax.tools.JavaFileManager$Location, searchpath: java.util.Collection<java.nio.file.Path>): void;
              setPathFactory(f: javax.tools.StandardJavaFileManager$PathFactory): void;
              setSymbolFileEnabled(b: boolean): void;
              _containers: java.util.Map<java.nio.file.Path,JavacFileManager$Container>;
              _fsInfo: FSInfo;
              _jrtIndex: JRTIndex;
              _nonIndexingContainersByLocation: java.util.Map<javax.tools.JavaFileManager$Location,java.util.List<JavacFileManager$PathAndContainer>>;
              _pathFactory: javax.tools.StandardJavaFileManager$PathFactory;
              _pathsAndContainersByLocationAndRelativeDirectory: java.util.Map<javax.tools.JavaFileManager$Location,java.util.Map<RelativePath$RelativeDirectory,java.util.List<JavacFileManager$PathAndContainer>>>;
              _sortFiles: JavacFileManager$SortFiles;
              _symbolFileEnabled: boolean;
            }
            interface JavacFileManager extends CombineTypes<[_JavacFileManager, javax.tools.StandardJavaFileManager, com.sun.tools.javac.file.BaseFileManager]> {}
            interface _JavacFileManager$ArchiveContainer$$static extends ClassLike {
              new(a0: JavacFileManager, archivePath: java.nio.file.Path): JavacFileManager$ArchiveContainer;
            }
            let JavacFileManager$ArchiveContainer: _JavacFileManager$ArchiveContainer$$static;
            interface _JavacFileManager$ArchiveContainer {
              close(): void;
              getFileObject(userPath: java.nio.file.Path, name: RelativePath$RelativeFile): javax.tools.JavaFileObject;
              indexedDirectories(): java.lang.Iterable<RelativePath$RelativeDirectory>;
              _isValid(fileName: java.nio.file.Path): boolean;
              list(userPath: java.nio.file.Path, subdirectory: RelativePath$RelativeDirectory, fileKinds: java.util.Set<javax.tools.JavaFileObject$Kind>, recurse: boolean, resultList: javac.util.ListBuffer<javax.tools.JavaFileObject>): void;
              maintainsDirectoryIndex(): boolean;
              _archivePath: java.nio.file.Path;
              _fileSystem: java.nio.file.FileSystem;
              _packages: java.util.Map<RelativePath$RelativeDirectory,java.nio.file.Path>;
              _this$0: JavacFileManager;
            }
            interface JavacFileManager$ArchiveContainer extends CombineTypes<[_JavacFileManager$ArchiveContainer, com.sun.tools.javac.file.JavacFileManager$Container, java.lang.Object]> {}
            interface _JavacFileManager$Container$$static extends ClassLike {
            }
            let JavacFileManager$Container: _JavacFileManager$Container$$static;
            interface _JavacFileManager$Container {
              close(): void;
              getFileObject(a0: java.nio.file.Path, a1: RelativePath$RelativeFile): javax.tools.JavaFileObject;
              indexedDirectories(): java.lang.Iterable<RelativePath$RelativeDirectory>;
              list(a0: java.nio.file.Path, a1: RelativePath$RelativeDirectory, a2: java.util.Set<javax.tools.JavaFileObject$Kind>, a3: boolean, a4: javac.util.ListBuffer<javax.tools.JavaFileObject>): void;
              maintainsDirectoryIndex(): boolean;
            }
            interface JavacFileManager$Container extends CombineTypes<[_JavacFileManager$Container, java.lang.Object]> {}
            interface _JavacFileManager$DirectoryContainer$$static extends ClassLike {
              new(a0: JavacFileManager, directory: java.nio.file.Path): JavacFileManager$DirectoryContainer;
            }
            let JavacFileManager$DirectoryContainer: _JavacFileManager$DirectoryContainer$$static;
            interface _JavacFileManager$DirectoryContainer {
              close(): void;
              getFileObject(userPath: java.nio.file.Path, name: RelativePath$RelativeFile): javax.tools.JavaFileObject;
              indexedDirectories(): java.lang.Iterable<RelativePath$RelativeDirectory>;
              list(userPath: java.nio.file.Path, subdirectory: RelativePath$RelativeDirectory, fileKinds: java.util.Set<javax.tools.JavaFileObject$Kind>, recurse: boolean, resultList: javac.util.ListBuffer<javax.tools.JavaFileObject>): void;
              maintainsDirectoryIndex(): boolean;
              _directory: java.nio.file.Path;
              _this$0: JavacFileManager;
            }
            interface JavacFileManager$DirectoryContainer extends CombineTypes<[_JavacFileManager$DirectoryContainer, com.sun.tools.javac.file.JavacFileManager$Container, java.lang.Object]> {}
            interface _JavacFileManager$JRTImageContainer$$static extends ClassLike {
            }
            let JavacFileManager$JRTImageContainer: _JavacFileManager$JRTImageContainer$$static;
            interface _JavacFileManager$JRTImageContainer {
              close(): void;
              getFileObject(userPath: java.nio.file.Path, name: RelativePath$RelativeFile): javax.tools.JavaFileObject;
              indexedDirectories(): java.lang.Iterable<RelativePath$RelativeDirectory>;
              list(userPath: java.nio.file.Path, subdirectory: RelativePath$RelativeDirectory, fileKinds: java.util.Set<javax.tools.JavaFileObject$Kind>, recurse: boolean, resultList: javac.util.ListBuffer<javax.tools.JavaFileObject>): void;
              maintainsDirectoryIndex(): boolean;
              _this$0: JavacFileManager;
            }
            interface JavacFileManager$JRTImageContainer extends CombineTypes<[_JavacFileManager$JRTImageContainer, com.sun.tools.javac.file.JavacFileManager$Container, java.lang.Object]> {}
            interface _JavacFileManager$PathAndContainer$$static extends ClassLike {
              _new(path: java.nio.file.Path, container: JavacFileManager$Container, index: int): JavacFileManager$PathAndContainer;
            }
            let JavacFileManager$PathAndContainer: _JavacFileManager$PathAndContainer$$static;
            interface _JavacFileManager$PathAndContainer {
              compareTo(other: JavacFileManager$PathAndContainer): int;
              compareTo(a0: any): int;
              equals(o: any): boolean;
              hashCode(): int;
              _container: JavacFileManager$Container;
              _index: int;
              _path: java.nio.file.Path;
            }
            interface JavacFileManager$PathAndContainer extends CombineTypes<[_JavacFileManager$PathAndContainer, java.lang.Comparable<JavacFileManager$PathAndContainer>, java.lang.Object]> {}
            interface _JavacFileManager$SortFiles$$static extends ClassLike {
              valueOf(name: string): JavacFileManager$SortFiles;
              values(): JavacFileManager$SortFiles[];
              readonly FORWARD: JavacFileManager$SortFiles;
              readonly REVERSE: JavacFileManager$SortFiles;
            }
            let JavacFileManager$SortFiles: _JavacFileManager$SortFiles$$static;
            interface _JavacFileManager$SortFiles {
            }
            interface JavacFileManager$SortFiles extends CombineTypes<[_JavacFileManager$SortFiles, java.util.Comparator<java.nio.file.Path>]> {}
            interface _Locations$$static extends ClassLike {
              _normalize(p: java.nio.file.Path): java.nio.file.Path;
              _javaHome: java.nio.file.Path;
              _thisSystemModules: java.nio.file.Path;
              _new(): Locations;
            }
            let Locations: _Locations$$static;
            interface _Locations {
              close(): void;
              _contains(searchPath: java.util.Collection<java.nio.file.Path>, file: java.nio.file.Path): boolean;
              _contains(location: javax.tools.JavaFileManager$Location, file: java.nio.file.Path): boolean;
              _getHandler(location: javax.tools.JavaFileManager$Location): Locations$LocationHandler;
              _getLocation(location: javax.tools.JavaFileManager$Location): java.util.Collection<java.nio.file.Path>;
              _getLocationForModule(location: javax.tools.JavaFileManager$Location, name: string): javax.tools.JavaFileManager$Location;
              _getLocationForModule(location: javax.tools.JavaFileManager$Location, file: java.nio.file.Path): javax.tools.JavaFileManager$Location;
              _getOutputLocation(location: javax.tools.JavaFileManager$Location): java.nio.file.Path;
              _getPath(first: string, more: string[]): java.nio.file.Path;
              _getPath(first: string, ...more: string[]): java.nio.file.Path;
              _getPathEntries(searchPath: string): java.lang.Iterable<java.nio.file.Path>;
              _getPathEntries(searchPath: string, emptyPathDefault: java.nio.file.Path): java.lang.Iterable<java.nio.file.Path>;
              _handleOption(option: javac.main.Option, value: string): boolean;
              _hasExplicitLocation(location: javax.tools.JavaFileManager$Location): boolean;
              _hasLocation(location: javax.tools.JavaFileManager$Location): boolean;
              _inferModuleName(location: javax.tools.JavaFileManager$Location): string;
              _initHandlers(): void;
              _isArchive(file: java.nio.file.Path): boolean;
              _isDefaultBootClassPath(): boolean;
              _isDefaultSystemModulesPath(): boolean;
              _listLocationsForModules(location: javax.tools.JavaFileManager$Location): java.lang.Iterable<java.util.Set<javax.tools.JavaFileManager$Location>>;
              _setLocation(location: javax.tools.JavaFileManager$Location, files: java.lang.Iterable<java.nio.file.Path>): void;
              _setLocationForModule(location: javax.tools.JavaFileManager$Location, moduleName: string, files: java.lang.Iterable<java.nio.file.Path>): void;
              setMultiReleaseValue(multiReleaseValue: string): void;
              _setPathFactory(f: javax.tools.StandardJavaFileManager$PathFactory): void;
              _update(log: javac.util.Log, warn: boolean, fsInfo: FSInfo): void;
              _closeables: java.util.List<java.io.Closeable>;
              _fileSystems: java.util.Map<java.nio.file.Path,java.nio.file.FileSystem>;
              _fsEnv: java.util.Map<string,string>;
              _fsInfo: FSInfo;
              _handlersForLocation: java.util.Map<javax.tools.JavaFileManager$Location,Locations$LocationHandler>;
              _handlersForOption: java.util.Map<javac.main.Option,Locations$LocationHandler>;
              _log: javac.util.Log;
              _moduleNameReader: javac.jvm.ModuleNameReader;
              _pathFactory: javax.tools.StandardJavaFileManager$PathFactory;
              _warn: boolean;
            }
            interface Locations extends CombineTypes<[_Locations, java.lang.Object]> {}
            interface _Locations$BasicLocationHandler$$static extends ClassLike {
              _new(location: javax.tools.JavaFileManager$Location, options: javac.main.Option[]): Locations$BasicLocationHandler;
              _new(location: javax.tools.JavaFileManager$Location, ...options: javac.main.Option[]): Locations$BasicLocationHandler;
            }
            let Locations$BasicLocationHandler: _Locations$BasicLocationHandler$$static;
            interface _Locations$BasicLocationHandler {
              _checkDirectory(path: java.nio.file.Path): java.nio.file.Path;
              _checkSingletonDirectory(paths: java.lang.Iterable<java.nio.file.Path>): java.nio.file.Path;
              _isExplicit(): boolean;
              _setPathsForModule(moduleName: string, files: java.lang.Iterable<java.nio.file.Path>): void;
              _explicit: boolean;
              _location: javax.tools.JavaFileManager$Location;
              _options: java.util.Set<javac.main.Option>;
            }
            interface Locations$BasicLocationHandler extends CombineTypes<[_Locations$BasicLocationHandler, com.sun.tools.javac.file.Locations$LocationHandler]> {}
            interface _Locations$BootClassPathLocationHandler$$static extends ClassLike {
              _new(a0: Locations): Locations$BootClassPathLocationHandler;
            }
            let Locations$BootClassPathLocationHandler: _Locations$BootClassPathLocationHandler$$static;
            interface _Locations$BootClassPathLocationHandler {
              _canonicalize(option: javac.main.Option): javac.main.Option;
              _computePath(): Locations$SearchPath;
              _contains(file: java.nio.file.Path): boolean;
              _getPaths(): java.util.Collection<java.nio.file.Path>;
              _handleOption(option: javac.main.Option, value: string): boolean;
              _isDefault(): boolean;
              _lazy(): void;
              _setPaths(files: java.lang.Iterable<java.nio.file.Path>): void;
              _systemClasses(): java.util.Collection<java.nio.file.Path>;
              _isDefault: boolean;
              _optionValues: java.util.Map<javac.main.Option,string>;
              _searchPath: java.util.Collection<java.nio.file.Path>;
              _this$0: Locations;
            }
            interface Locations$BootClassPathLocationHandler extends CombineTypes<[_Locations$BootClassPathLocationHandler, com.sun.tools.javac.file.Locations$BasicLocationHandler]> {}
            interface _Locations$ClassPathLocationHandler$$static extends ClassLike {
              _new(a0: Locations): Locations$ClassPathLocationHandler;
            }
            let Locations$ClassPathLocationHandler: _Locations$ClassPathLocationHandler$$static;
            interface _Locations$ClassPathLocationHandler {
              _computePath(value: string): Locations$SearchPath;
              _createPath(): Locations$SearchPath;
              _getPaths(): java.util.Collection<java.nio.file.Path>;
              _lazy(): void;
              _this$0: Locations;
            }
            interface Locations$ClassPathLocationHandler extends CombineTypes<[_Locations$ClassPathLocationHandler, com.sun.tools.javac.file.Locations$SimpleLocationHandler]> {}
            interface _Locations$LocationHandler$$static extends ClassLike {
              _new(): Locations$LocationHandler;
            }
            let Locations$LocationHandler: _Locations$LocationHandler$$static;
            interface _Locations$LocationHandler {
              _contains(a0: java.nio.file.Path): boolean;
              _getLocationForModule(moduleName: string): javax.tools.JavaFileManager$Location;
              _getLocationForModule(file: java.nio.file.Path): javax.tools.JavaFileManager$Location;
              _getPaths(): java.util.Collection<java.nio.file.Path>;
              _handleOption(a0: javac.main.Option, a1: string): boolean;
              _inferModuleName(): string;
              _isExplicit(): boolean;
              _isSet(): boolean;
              _listLocationsForModules(): java.lang.Iterable<java.util.Set<javax.tools.JavaFileManager$Location>>;
              _setPaths(a0: java.lang.Iterable<java.nio.file.Path>): void;
              _setPathsForModule(a0: string, a1: java.lang.Iterable<java.nio.file.Path>): void;
            }
            interface Locations$LocationHandler extends CombineTypes<[_Locations$LocationHandler, java.lang.Object]> {}
            interface _Locations$ModuleLocationHandler$$static extends ClassLike {
              _new(a0: Locations$LocationHandler, parent: string, name: string, moduleName: java.util.Collection<java.nio.file.Path>, searchPath: boolean): Locations$ModuleLocationHandler;
            }
            let Locations$ModuleLocationHandler: _Locations$ModuleLocationHandler$$static;
            interface _Locations$ModuleLocationHandler {
              _contains(file: java.nio.file.Path): boolean;
              getName(): string;
              _getPaths(): java.util.Collection<java.nio.file.Path>;
              _handleOption(option: javac.main.Option, value: string): boolean;
              _inferModuleName(): string;
              _isExplicit(): boolean;
              isOutputLocation(): boolean;
              _setPaths(paths: java.lang.Iterable<java.nio.file.Path>): void;
              _setPathsForModule(moduleName: string, paths: java.lang.Iterable<java.nio.file.Path>): void;
              toString(): string;
              _explicit: boolean;
              _moduleName: string;
              _name: string;
              _output: boolean;
              _parent: Locations$LocationHandler;
              _searchPath: java.util.Collection<java.nio.file.Path>;
              _this$0: Locations;
            }
            interface Locations$ModuleLocationHandler extends CombineTypes<[_Locations$ModuleLocationHandler, com.sun.tools.javac.file.Locations$LocationHandler, javax.tools.JavaFileManager$Location]> {}
            interface _Locations$ModulePathLocationHandler$$static extends ClassLike {
              _new(a0: Locations, location: javax.tools.JavaFileManager$Location, options: javac.main.Option[]): Locations$ModulePathLocationHandler;
              _new(a0: Locations, location: javax.tools.JavaFileManager$Location, ...options: javac.main.Option[]): Locations$ModulePathLocationHandler;
            }
            let Locations$ModulePathLocationHandler: _Locations$ModulePathLocationHandler$$static;
            interface _Locations$ModulePathLocationHandler {
              _checkPaths(paths: java.lang.Iterable<java.nio.file.Path>): java.util.List<java.nio.file.Path>;
              _checkValidModulePathEntry(p: java.nio.file.Path): void;
              _contains(file: java.nio.file.Path): boolean;
              getLocationForModule(moduleName: string): javax.tools.JavaFileManager$Location;
              getLocationForModule(file: java.nio.file.Path): javax.tools.JavaFileManager$Location;
              handleOption(option: javac.main.Option, value: string): boolean;
              _initModuleLocations(): void;
              _isModuleName(name: string): boolean;
              _listLocationsForModules(): java.lang.Iterable<java.util.Set<javax.tools.JavaFileManager$Location>>;
              _setPaths(paths: java.lang.Iterable<java.nio.file.Path>): void;
              _setPathsForModule(name: string, paths: java.lang.Iterable<java.nio.file.Path>): void;
              _moduleTable: Locations$ModuleTable;
              _this$0: Locations;
            }
            interface Locations$ModulePathLocationHandler extends CombineTypes<[_Locations$ModulePathLocationHandler, com.sun.tools.javac.file.Locations$SimpleLocationHandler]> {}
            interface _Locations$ModulePathLocationHandler$ModulePathIterator$$static extends ClassLike {
              _new(this$1: Locations$ModulePathLocationHandler): Locations$ModulePathLocationHandler$ModulePathIterator;
            }
            let Locations$ModulePathLocationHandler$ModulePathIterator: _Locations$ModulePathLocationHandler$ModulePathIterator$$static;
            interface _Locations$ModulePathLocationHandler$ModulePathIterator {
              hasNext(): boolean;
              _inferModuleName(p: java.nio.file.Path): javac.util.Pair<string,java.nio.file.Path>;
              next(): java.util.Set<javax.tools.JavaFileManager$Location>;
              next(): any;
              _readModuleName(path: java.nio.file.Path): string;
              _scanDirectory(path: java.nio.file.Path): java.util.Set<javax.tools.JavaFileManager$Location>;
              _scanFile(path: java.nio.file.Path): java.util.Set<javax.tools.JavaFileManager$Location>;
              _next: java.util.Set<javax.tools.JavaFileManager$Location>;
              _pathIndex: int;
              _pathIter: java.util.Iterator<java.nio.file.Path>;
              _this$1: Locations$ModulePathLocationHandler;
            }
            interface Locations$ModulePathLocationHandler$ModulePathIterator extends CombineTypes<[_Locations$ModulePathLocationHandler$ModulePathIterator, java.util.Iterator<java.util.Set<javax.tools.JavaFileManager$Location>>, java.lang.Object]> {}
            interface _Locations$ModuleSourcePathLocationHandler$$static extends ClassLike {
              _new(a0: Locations): Locations$ModuleSourcePathLocationHandler;
            }
            let Locations$ModuleSourcePathLocationHandler: _Locations$ModuleSourcePathLocationHandler$$static;
            interface _Locations$ModuleSourcePathLocationHandler {
              _add(map: java.util.Map<string,java.util.List<java.nio.file.Path>>, prefix: java.nio.file.Path, suffix: java.nio.file.Path): void;
              _checkPaths(paths: java.lang.Iterable<java.nio.file.Path>): java.util.List<java.nio.file.Path>;
              _contains(file: java.nio.file.Path): boolean;
              _expandBraces(value: string, results: java.util.Collection<string>): void;
              _getLocationForModule(name: string): javax.tools.JavaFileManager$Location;
              _getLocationForModule(file: java.nio.file.Path): javax.tools.JavaFileManager$Location;
              _getMatchingBrace(value: string, offset: int): int;
              _getPaths(): java.util.Collection<java.nio.file.Path>;
              _handleOption(option: javac.main.Option, value: string): boolean;
              _init(value: string): void;
              _initForModule(value: string): void;
              _initFromPattern(value: string): void;
              _initModuleTable(map: java.util.Map<string,java.util.List<java.nio.file.Path>>): void;
              _isSeparator(ch: char): boolean;
              _isSet(): boolean;
              _listLocationsForModules(): java.lang.Iterable<java.util.Set<javax.tools.JavaFileManager$Location>>;
              _setPaths(files: java.lang.Iterable<java.nio.file.Path>): void;
              _setPathsForModule(name: string, paths: java.lang.Iterable<java.nio.file.Path>): void;
              _checkModuleInfo: java.util.function.Predicate<java.nio.file.Path>;
              _moduleTable: Locations$ModuleTable;
              _paths: java.util.List<java.nio.file.Path>;
              _this$0: Locations;
            }
            interface Locations$ModuleSourcePathLocationHandler extends CombineTypes<[_Locations$ModuleSourcePathLocationHandler, com.sun.tools.javac.file.Locations$BasicLocationHandler]> {}
            interface _Locations$ModuleTable$$static extends ClassLike {
            }
            let Locations$ModuleTable: _Locations$ModuleTable$$static;
            interface _Locations$ModuleTable {
              _add(h: Locations$ModuleLocationHandler): void;
              _clear(): void;
              _contains(file: java.nio.file.Path): boolean;
              _explicitLocations(): java.util.Set<javax.tools.JavaFileManager$Location>;
              _get(name: string): Locations$ModuleLocationHandler;
              _get(path: java.nio.file.Path): Locations$ModuleLocationHandler;
              _isEmpty(): boolean;
              _locations(): java.util.Set<javax.tools.JavaFileManager$Location>;
              _updatePaths(h: Locations$ModuleLocationHandler): void;
              _nameMap: java.util.Map<string,Locations$ModuleLocationHandler>;
              _pathMap: java.util.Map<java.nio.file.Path,Locations$ModuleLocationHandler>;
              _this$0: Locations;
            }
            interface Locations$ModuleTable extends CombineTypes<[_Locations$ModuleTable, java.lang.Object]> {}
            interface _Locations$OutputLocationHandler$$static extends ClassLike {
              _new(a0: Locations, location: javax.tools.JavaFileManager$Location, options: javac.main.Option[]): Locations$OutputLocationHandler;
              _new(a0: Locations, location: javax.tools.JavaFileManager$Location, ...options: javac.main.Option[]): Locations$OutputLocationHandler;
            }
            let Locations$OutputLocationHandler: _Locations$OutputLocationHandler$$static;
            interface _Locations$OutputLocationHandler {
              _contains(file: java.nio.file.Path): boolean;
              _getLocationForModule(name: string): javax.tools.JavaFileManager$Location;
              _getLocationForModule(file: java.nio.file.Path): javax.tools.JavaFileManager$Location;
              _getPaths(): java.util.Collection<java.nio.file.Path>;
              _handleOption(option: javac.main.Option, value: string): boolean;
              _listLocationsForModules(): java.lang.Iterable<java.util.Set<javax.tools.JavaFileManager$Location>>;
              _setPaths(paths: java.lang.Iterable<java.nio.file.Path>): void;
              _setPathsForModule(name: string, paths: java.lang.Iterable<java.nio.file.Path>): void;
              _listed: boolean;
              _moduleTable: Locations$ModuleTable;
              _outputDir: java.nio.file.Path;
              _this$0: Locations;
            }
            interface Locations$OutputLocationHandler extends CombineTypes<[_Locations$OutputLocationHandler, com.sun.tools.javac.file.Locations$BasicLocationHandler]> {}
            interface _Locations$PatchModulesLocationHandler$$static extends ClassLike {
              _new(a0: Locations): Locations$PatchModulesLocationHandler;
            }
            let Locations$PatchModulesLocationHandler: _Locations$PatchModulesLocationHandler$$static;
            interface _Locations$PatchModulesLocationHandler {
              _contains(file: java.nio.file.Path): boolean;
              _getLocationForModule(name: string): javax.tools.JavaFileManager$Location;
              _getLocationForModule(file: java.nio.file.Path): javax.tools.JavaFileManager$Location;
              _getPaths(): java.util.Collection<java.nio.file.Path>;
              _handleOption(option: javac.main.Option, value: string): boolean;
              _isSet(): boolean;
              _listLocationsForModules(): java.lang.Iterable<java.util.Set<javax.tools.JavaFileManager$Location>>;
              _setPaths(files: java.lang.Iterable<java.nio.file.Path>): void;
              _setPathsForModule(moduleName: string, files: java.lang.Iterable<java.nio.file.Path>): void;
              _moduleTable: Locations$ModuleTable;
              _this$0: Locations;
            }
            interface Locations$PatchModulesLocationHandler extends CombineTypes<[_Locations$PatchModulesLocationHandler, com.sun.tools.javac.file.Locations$BasicLocationHandler]> {}
            interface _Locations$SearchPath$$static extends ClassLike {
              _serialVersionUID: long;
            }
            let Locations$SearchPath: _Locations$SearchPath$$static;
            interface _Locations$SearchPath {
              addDirectories(dirs: string, warn: boolean): Locations$SearchPath;
              addDirectories(dirs: string): Locations$SearchPath;
              _addDirectory(dir: java.nio.file.Path, warn: boolean): void;
              addFile(file: java.nio.file.Path, warn: boolean): void;
              addFiles(files: string, warn: boolean): Locations$SearchPath;
              addFiles(files: string): Locations$SearchPath;
              addFiles(files: java.lang.Iterable<java.nio.file.Path>, warn: boolean): Locations$SearchPath;
              addFiles(files: java.lang.Iterable<java.nio.file.Path>): Locations$SearchPath;
              _addJarClassPath(jarFile: java.nio.file.Path, warn: boolean): void;
              emptyPathDefault(x: java.nio.file.Path): Locations$SearchPath;
              expandJarClassPaths(x: boolean): Locations$SearchPath;
              _canonicalValues: java.util.Set<java.nio.file.Path>;
              _emptyPathDefault: java.nio.file.Path;
              _expandJarClassPaths: boolean;
              _this$0: Locations;
            }
            interface Locations$SearchPath extends CombineTypes<[_Locations$SearchPath, java.util.LinkedHashSet<java.nio.file.Path>]> {}
            interface _Locations$SimpleLocationHandler$$static extends ClassLike {
              _new(a0: Locations, location: javax.tools.JavaFileManager$Location, options: javac.main.Option[]): Locations$SimpleLocationHandler;
              _new(a0: Locations, location: javax.tools.JavaFileManager$Location, ...options: javac.main.Option[]): Locations$SimpleLocationHandler;
            }
            let Locations$SimpleLocationHandler: _Locations$SimpleLocationHandler$$static;
            interface _Locations$SimpleLocationHandler {
              _computePath(value: string): Locations$SearchPath;
              _contains(file: java.nio.file.Path): boolean;
              _createPath(): Locations$SearchPath;
              _getPaths(): java.util.Collection<java.nio.file.Path>;
              _handleOption(option: javac.main.Option, value: string): boolean;
              _setPaths(files: java.lang.Iterable<java.nio.file.Path>): void;
              _searchPath: java.util.Collection<java.nio.file.Path>;
              _this$0: Locations;
            }
            interface Locations$SimpleLocationHandler extends CombineTypes<[_Locations$SimpleLocationHandler, com.sun.tools.javac.file.Locations$BasicLocationHandler]> {}
            interface _Locations$SystemModulesLocationHandler$$static extends ClassLike {
              _new(a0: Locations): Locations$SystemModulesLocationHandler;
            }
            let Locations$SystemModulesLocationHandler: _Locations$SystemModulesLocationHandler$$static;
            interface _Locations$SystemModulesLocationHandler {
              _checkPaths(paths: java.lang.Iterable<java.nio.file.Path>): java.util.List<java.nio.file.Path>;
              _contains(file: java.nio.file.Path): boolean;
              _getLocationForModule(name: string): javax.tools.JavaFileManager$Location;
              _getLocationForModule(file: java.nio.file.Path): javax.tools.JavaFileManager$Location;
              _getPaths(): java.util.Collection<java.nio.file.Path>;
              _handleOption(option: javac.main.Option, value: string): boolean;
              _initSystemModules(): void;
              _isCurrentPlatform(p: java.nio.file.Path): boolean;
              _listLocationsForModules(): java.lang.Iterable<java.util.Set<javax.tools.JavaFileManager$Location>>;
              _setPaths(files: java.lang.Iterable<java.nio.file.Path>): void;
              _setPathsForModule(name: string, paths: java.lang.Iterable<java.nio.file.Path>): void;
              _update(p: java.nio.file.Path): void;
              _moduleTable: Locations$ModuleTable;
              _modules: java.nio.file.Path;
              _systemJavaHome: java.nio.file.Path;
              _this$0: Locations;
            }
            interface Locations$SystemModulesLocationHandler extends CombineTypes<[_Locations$SystemModulesLocationHandler, com.sun.tools.javac.file.Locations$BasicLocationHandler]> {}
            interface _PathFileObject$$static extends ClassLike {
              _forDirectoryPath(fileManager: BaseFileManager, path: java.nio.file.Path, userPackageRootDir: java.nio.file.Path, relativePath: RelativePath): PathFileObject;
              forJRTPath(fileManager: BaseFileManager, path: java.nio.file.Path): PathFileObject;
              forJarPath(fileManager: BaseFileManager, path: java.nio.file.Path, userJarPath: java.nio.file.Path): PathFileObject;
              _forSimplePath(fileManager: BaseFileManager, path: java.nio.file.Path, userPath: java.nio.file.Path): PathFileObject;
              getSimpleName(fo: javax.tools.FileObject): string;
              _removeExtension(fileName: string): string;
              _toBinaryName(relativePath: RelativePath): string;
              _toBinaryName(relativePath: java.nio.file.Path): string;
              _toBinaryName(relativePath: string, sep: string): string;
              _defaultFileSystem: java.nio.file.FileSystem;
              _isMacOS: boolean;
              _new(fileManager: BaseFileManager, path: java.nio.file.Path): PathFileObject;
            }
            let PathFileObject: _PathFileObject$$static;
            interface _PathFileObject {
              delete(): boolean;
              _ensureParentDirectoriesExist(): void;
              equals(other: any): boolean;
              getAccessLevel(): javax.lang.model.element.Modifier;
              getCharContent(ignoreEncodingErrors: boolean): PathFileObject$charSequence;
              getKind(): javax.tools.JavaFileObject$Kind;
              getLastModified(): long;
              getNestingKind(): javax.lang.model.element.NestingKind;
              getPath(): java.nio.file.Path;
              getShortName(): string;
              _getSibling(a0: string): PathFileObject;
              hashCode(): int;
              _inferBinaryName(a0: java.lang.Iterable<java.nio.file.Path>): string;
              isNameCompatible(simpleName: string, kind: javax.tools.JavaFileObject$Kind): boolean;
              _isPathNameCompatible(p: java.nio.file.Path, simpleName: string, kind: javax.tools.JavaFileObject$Kind): boolean;
              _isSameFile(other: PathFileObject): boolean;
              openInputStream(): java.io.InputStream;
              openOutputStream(): java.io.OutputStream;
              openReader(ignoreEncodingErrors: boolean): java.io.Reader;
              openWriter(): java.io.Writer;
              toString(): string;
              toUri(): java.net.URI;
              _fileManager: BaseFileManager;
              _hasParents: boolean;
              _path: java.nio.file.Path;
            }
            interface PathFileObject extends CombineTypes<[_PathFileObject, javax.tools.JavaFileObject, java.lang.Object]> {}
            interface _PathFileObject$CannotCreateUriError$$static extends ClassLike {
              _serialVersionUID: long;
              new(value: string, cause: java.lang.Throwable): PathFileObject$CannotCreateUriError;
            }
            let PathFileObject$CannotCreateUriError: _PathFileObject$CannotCreateUriError$$static;
            interface _PathFileObject$CannotCreateUriError {
            }
            interface PathFileObject$CannotCreateUriError extends CombineTypes<[_PathFileObject$CannotCreateUriError, java.lang.Error]> {}
            interface _PathFileObject$DirectoryFileObject$$static extends ClassLike {
            }
            let PathFileObject$DirectoryFileObject: _PathFileObject$DirectoryFileObject$$static;
            interface _PathFileObject$DirectoryFileObject {
              getName(): string;
              _getSibling(baseName: string): PathFileObject;
              inferBinaryName(paths: java.lang.Iterable<java.nio.file.Path>): string;
              toString(): string;
              _relativePath: RelativePath;
              _userPackageRootDir: java.nio.file.Path;
            }
            interface PathFileObject$DirectoryFileObject extends CombineTypes<[_PathFileObject$DirectoryFileObject, com.sun.tools.javac.file.PathFileObject]> {}
            interface _PathFileObject$JRTFileObject$$static extends ClassLike {
            }
            let PathFileObject$JRTFileObject: _PathFileObject$JRTFileObject$$static;
            interface _PathFileObject$JRTFileObject {
              getName(): string;
              _getSibling(baseName: string): PathFileObject;
              inferBinaryName(paths: java.lang.Iterable<java.nio.file.Path>): string;
              toString(): string;
            }
            interface PathFileObject$JRTFileObject extends CombineTypes<[_PathFileObject$JRTFileObject, com.sun.tools.javac.file.PathFileObject]> {}
            interface _PathFileObject$JarFileObject$$static extends ClassLike {
            }
            let PathFileObject$JarFileObject: _PathFileObject$JarFileObject$$static;
            interface _PathFileObject$JarFileObject {
              getName(): string;
              _getSibling(baseName: string): PathFileObject;
              inferBinaryName(paths: java.lang.Iterable<java.nio.file.Path>): string;
              toString(): string;
              _userJarPath: java.nio.file.Path;
            }
            interface PathFileObject$JarFileObject extends CombineTypes<[_PathFileObject$JarFileObject, com.sun.tools.javac.file.PathFileObject]> {}
            interface _PathFileObject$SimpleFileObject$$static extends ClassLike {
            }
            let PathFileObject$SimpleFileObject: _PathFileObject$SimpleFileObject$$static;
            interface _PathFileObject$SimpleFileObject {
              getKind(): javax.tools.JavaFileObject$Kind;
              getName(): string;
              getShortName(): string;
              _getSibling(baseName: string): PathFileObject;
              inferBinaryName(paths: java.lang.Iterable<java.nio.file.Path>): string;
              isNameCompatible(simpleName: string, kind: javax.tools.JavaFileObject$Kind): boolean;
              toUri(): java.net.URI;
              _userPath: java.nio.file.Path;
            }
            interface PathFileObject$SimpleFileObject extends CombineTypes<[_PathFileObject$SimpleFileObject, com.sun.tools.javac.file.PathFileObject]> {}
            interface _RelativePath$$static extends ClassLike {
              _new(p: string): RelativePath;
            }
            let RelativePath: _RelativePath$$static;
            interface _RelativePath {
              basename(): string;
              compareTo(other: RelativePath): int;
              compareTo(a0: any): int;
              dirname(): RelativePath$RelativeDirectory;
              equals(other: any): boolean;
              getPath(): string;
              hashCode(): int;
              resolveAgainst(directory: java.nio.file.Path): java.nio.file.Path;
              resolveAgainst(fs: java.nio.file.FileSystem): java.nio.file.Path;
              toString(): string;
              _path: string;
            }
            interface RelativePath extends CombineTypes<[_RelativePath, java.lang.Comparable<RelativePath>, java.lang.Object]> {}
            interface _RelativePath$RelativeDirectory$$static extends ClassLike {
              _forPackage(packageName: RelativePath$RelativeDirectory$charSequence): RelativePath$RelativeDirectory;
              new(p: string): RelativePath$RelativeDirectory;
              new(d: RelativePath$RelativeDirectory, p: string): RelativePath$RelativeDirectory;
            }
            let RelativePath$RelativeDirectory: _RelativePath$RelativeDirectory$$static;
            interface _RelativePath$RelativeDirectory {
              basename(): string;
              compareTo(a0: any): int;
              _contains(other: RelativePath): boolean;
              dirname(): RelativePath$RelativeDirectory;
              toString(): string;
            }
            interface RelativePath$RelativeDirectory extends CombineTypes<[_RelativePath$RelativeDirectory, com.sun.tools.javac.file.RelativePath]> {}
            interface _RelativePath$RelativeFile$$static extends ClassLike {
              _forClass(className: RelativePath$RelativeFile$charSequence, kind: javax.tools.JavaFileObject$Kind): RelativePath$RelativeFile;
              new(p: string): RelativePath$RelativeFile;
              new(d: RelativePath$RelativeDirectory, p: string): RelativePath$RelativeFile;
              _new(d: RelativePath$RelativeDirectory, p: RelativePath): RelativePath$RelativeFile;
            }
            let RelativePath$RelativeFile: _RelativePath$RelativeFile$$static;
            interface _RelativePath$RelativeFile {
              basename(): string;
              compareTo(a0: any): int;
              dirname(): RelativePath$RelativeDirectory;
              _getZipEntry(zip: java.util.zip.ZipFile): java.util.zip.ZipEntry;
              toString(): string;
            }
            interface RelativePath$RelativeFile extends CombineTypes<[_RelativePath$RelativeFile, com.sun.tools.javac.file.RelativePath]> {}
          }
          module jvm {
            interface _ByteCodes$$static extends ClassLike {
              readonly BYTEcode: int;
              readonly ByteCodeCount: int;
              readonly CHARcode: int;
              readonly DOUBLEcode: int;
              readonly FLOATcode: int;
              readonly INTcode: int;
              readonly LONGcode: int;
              readonly OBJECTcode: int;
              readonly SHORTcode: int;
              readonly TypeCodeCount: int;
              readonly VOIDcode: int;
              readonly aaload: int;
              readonly aastore: int;
              readonly aconst_null: int;
              readonly aload: int;
              readonly aload_0: int;
              readonly aload_1: int;
              readonly aload_2: int;
              readonly aload_3: int;
              readonly anewarray: int;
              readonly areturn: int;
              readonly arraylength: int;
              readonly astore: int;
              readonly astore_0: int;
              readonly astore_1: int;
              readonly astore_2: int;
              readonly astore_3: int;
              readonly athrow: int;
              readonly baload: int;
              readonly bastore: int;
              readonly bipush: int;
              readonly bool_and: int;
              readonly bool_not: int;
              readonly bool_or: int;
              readonly breakpoint: int;
              readonly caload: int;
              readonly castore: int;
              readonly checkcast: int;
              readonly d2f: int;
              readonly d2i: int;
              readonly d2l: int;
              readonly dadd: int;
              readonly daload: int;
              readonly dastore: int;
              readonly dcmpg: int;
              readonly dcmpl: int;
              readonly dconst_0: int;
              readonly dconst_1: int;
              readonly ddiv: int;
              readonly dload: int;
              readonly dload_0: int;
              readonly dload_1: int;
              readonly dload_2: int;
              readonly dload_3: int;
              readonly dmod: int;
              readonly dmul: int;
              readonly dneg: int;
              readonly dontgoto: int;
              readonly dreturn: int;
              readonly dstore: int;
              readonly dstore_0: int;
              readonly dstore_1: int;
              readonly dstore_2: int;
              readonly dstore_3: int;
              readonly dsub: int;
              readonly dup: int;
              readonly dup2: int;
              readonly dup2_x1: int;
              readonly dup2_x2: int;
              readonly dup_x1: int;
              readonly dup_x2: int;
              readonly error: int;
              readonly f2d: int;
              readonly f2i: int;
              readonly f2l: int;
              readonly fadd: int;
              readonly faload: int;
              readonly fastore: int;
              readonly fcmpg: int;
              readonly fcmpl: int;
              readonly fconst_0: int;
              readonly fconst_1: int;
              readonly fconst_2: int;
              readonly fdiv: int;
              readonly fload: int;
              readonly fload_0: int;
              readonly fload_1: int;
              readonly fload_2: int;
              readonly fload_3: int;
              readonly fmod: int;
              readonly fmul: int;
              readonly fneg: int;
              readonly freturn: int;
              readonly fstore: int;
              readonly fstore_0: int;
              readonly fstore_1: int;
              readonly fstore_2: int;
              readonly fstore_3: int;
              readonly fsub: int;
              readonly getfield: int;
              readonly getstatic: int;
              readonly goto_: int;
              readonly goto_w: int;
              readonly i2d: int;
              readonly i2f: int;
              readonly i2l: int;
              readonly iadd: int;
              readonly iaload: int;
              readonly iand: int;
              readonly iastore: int;
              readonly iconst_0: int;
              readonly iconst_1: int;
              readonly iconst_2: int;
              readonly iconst_3: int;
              readonly iconst_4: int;
              readonly iconst_5: int;
              readonly iconst_m1: int;
              readonly idiv: int;
              readonly if_acmp_nonnull: int;
              readonly if_acmp_null: int;
              readonly if_acmpeq: int;
              readonly if_acmpne: int;
              readonly if_icmpeq: int;
              readonly if_icmpge: int;
              readonly if_icmpgt: int;
              readonly if_icmple: int;
              readonly if_icmplt: int;
              readonly if_icmpne: int;
              readonly ifeq: int;
              readonly ifge: int;
              readonly ifgt: int;
              readonly ifle: int;
              readonly iflt: int;
              readonly ifne: int;
              readonly iinc: int;
              readonly illegal: int;
              readonly iload: int;
              readonly iload_0: int;
              readonly iload_1: int;
              readonly iload_2: int;
              readonly iload_3: int;
              readonly imod: int;
              readonly imul: int;
              readonly ineg: int;
              readonly instanceof_: int;
              readonly int2byte: int;
              readonly int2char: int;
              readonly int2short: int;
              readonly invokedynamic: int;
              readonly invokeinterface: int;
              readonly invokespecial: int;
              readonly invokestatic: int;
              readonly invokevirtual: int;
              readonly ior: int;
              readonly ireturn: int;
              readonly ishl: int;
              readonly ishll: int;
              readonly ishr: int;
              readonly ishrl: int;
              readonly istore: int;
              readonly istore_0: int;
              readonly istore_1: int;
              readonly istore_2: int;
              readonly istore_3: int;
              readonly isub: int;
              readonly iushr: int;
              readonly iushrl: int;
              readonly ixor: int;
              readonly jsr: int;
              readonly jsr_w: int;
              readonly l2d: int;
              readonly l2f: int;
              readonly l2i: int;
              readonly ladd: int;
              readonly laload: int;
              readonly land: int;
              readonly lastore: int;
              readonly lcmp: int;
              readonly lconst_0: int;
              readonly lconst_1: int;
              readonly ldc1: int;
              readonly ldc2: int;
              readonly ldc2w: int;
              readonly ldiv: int;
              readonly lload: int;
              readonly lload_0: int;
              readonly lload_1: int;
              readonly lload_2: int;
              readonly lload_3: int;
              readonly lmod: int;
              readonly lmul: int;
              readonly lneg: int;
              readonly lookupswitch: int;
              readonly lor: int;
              readonly lreturn: int;
              readonly lshl: int;
              readonly lshll: int;
              readonly lshr: int;
              readonly lshrl: int;
              readonly lstore: int;
              readonly lstore_0: int;
              readonly lstore_1: int;
              readonly lstore_2: int;
              readonly lstore_3: int;
              readonly lsub: int;
              readonly lushr: int;
              readonly lushrl: int;
              readonly lxor: int;
              readonly monitorenter: int;
              readonly monitorexit: int;
              readonly multianewarray: int;
              readonly new_: int;
              readonly newarray: int;
              readonly nop: int;
              readonly nullchk: int;
              readonly pop: int;
              readonly pop2: int;
              readonly preMask: int;
              readonly preShift: int;
              readonly putfield: int;
              readonly putstatic: int;
              readonly ret: int;
              readonly return_: int;
              readonly saload: int;
              readonly sastore: int;
              readonly sipush: int;
              readonly string_add: int;
              readonly swap: int;
              readonly tableswitch: int;
              readonly typecodeNames: string[];
              readonly wide: int;
            }
            let ByteCodes: _ByteCodes$$static;
            interface _ByteCodes {
            }
            interface ByteCodes extends CombineTypes<[_ByteCodes, java.lang.Object]> {}
            interface _CRTFlags$$static extends ClassLike {
              readonly CRT_ASSIGNMENT: int;
              readonly CRT_BLOCK: int;
              readonly CRT_BRANCH_FALSE: int;
              readonly CRT_BRANCH_TRUE: int;
              readonly CRT_CREATE: int;
              readonly CRT_FLOW_CONTROLLER: int;
              readonly CRT_FLOW_TARGET: int;
              readonly CRT_INVOKE: int;
              readonly CRT_STATEMENT: int;
              readonly CRT_VALID_FLAGS: int;
            }
            let CRTFlags: _CRTFlags$$static;
            interface _CRTFlags {
            }
            interface CRTFlags extends CombineTypes<[_CRTFlags, java.lang.Object]> {}
            interface _CRTable$$static extends ClassLike {
              new(tree: javac.tree.JCTree$JCMethodDecl, endPosTable: javac.tree.EndPosTable): CRTable;
            }
            let CRTable: _CRTable$$static;
            interface _CRTable {
              _encodePosition(pos: int, lineMap: javac.util.Position$LineMap, log: javac.util.Log): int;
              _getTypes(flags: int): string;
              length(): int;
              put(tree: any, flags: int, startPc: int, endPc: int): void;
              writeCRT(databuf: javac.util.ByteBuffer, lineMap: javac.util.Position$LineMap, log: javac.util.Log): int;
              _crtDebug: boolean;
              _endPosTable: javac.tree.EndPosTable;
              _entries: javac.util.ListBuffer<CRTable$CRTEntry>;
              _methodTree: javac.tree.JCTree$JCMethodDecl;
              _positions: java.util.Map<any,CRTable$SourceRange>;
            }
            interface CRTable extends CombineTypes<[_CRTable, java.lang.Object, com.sun.tools.javac.jvm.CRTFlags]> {}
            interface _CRTable$CRTEntry$$static extends ClassLike {
              _new(tree: any, flags: int, startPc: int, endPc: int): CRTable$CRTEntry;
            }
            let CRTable$CRTEntry: _CRTable$CRTEntry$$static;
            interface _CRTable$CRTEntry {
              _endPc: int;
              _flags: int;
              _startPc: int;
              _tree: any;
            }
            interface CRTable$CRTEntry extends CombineTypes<[_CRTable$CRTEntry, java.lang.Object]> {}
            interface _CRTable$SourceComputer$$static extends ClassLike {
              _new(this$0: CRTable): CRTable$SourceComputer;
            }
            let CRTable$SourceComputer: _CRTable$SourceComputer$$static;
            interface _CRTable$SourceComputer {
              csp(tree: javac.tree.JCTree): CRTable$SourceRange;
              csp(trees: javac.util.List<javac.tree.JCTree>): CRTable$SourceRange;
              cspCases(trees: javac.util.List<javac.tree.JCTree$JCCase>): CRTable$SourceRange;
              cspCatchers(trees: javac.util.List<javac.tree.JCTree$JCCatch>): CRTable$SourceRange;
              endPos(tree: javac.tree.JCTree): int;
              startPos(tree: javac.tree.JCTree): int;
              visitApply(tree: javac.tree.JCTree$JCMethodInvocation): void;
              visitAssert(tree: javac.tree.JCTree$JCAssert): void;
              visitAssign(tree: javac.tree.JCTree$JCAssign): void;
              visitAssignop(tree: javac.tree.JCTree$JCAssignOp): void;
              visitBinary(tree: javac.tree.JCTree$JCBinary): void;
              visitBlock(tree: javac.tree.JCTree$JCBlock): void;
              visitBreak(tree: javac.tree.JCTree$JCBreak): void;
              visitCase(tree: javac.tree.JCTree$JCCase): void;
              visitCatch(tree: javac.tree.JCTree$JCCatch): void;
              visitConditional(tree: javac.tree.JCTree$JCConditional): void;
              visitConstantCaseLabel(tree: javac.tree.JCTree$JCConstantCaseLabel): void;
              visitContinue(tree: javac.tree.JCTree$JCContinue): void;
              visitDefaultCaseLabel(that: javac.tree.JCTree$JCDefaultCaseLabel): void;
              visitDoLoop(tree: javac.tree.JCTree$JCDoWhileLoop): void;
              visitErroneous(tree: javac.tree.JCTree$JCErroneous): void;
              visitExec(tree: javac.tree.JCTree$JCExpressionStatement): void;
              visitForLoop(tree: javac.tree.JCTree$JCForLoop): void;
              visitForeachLoop(tree: javac.tree.JCTree$JCEnhancedForLoop): void;
              visitIdent(tree: javac.tree.JCTree$JCIdent): void;
              visitIf(tree: javac.tree.JCTree$JCIf): void;
              visitIndexed(tree: javac.tree.JCTree$JCArrayAccess): void;
              visitLabelled(tree: javac.tree.JCTree$JCLabeledStatement): void;
              visitLetExpr(tree: javac.tree.JCTree$LetExpr): void;
              visitLiteral(tree: javac.tree.JCTree$JCLiteral): void;
              visitMethodDef(tree: javac.tree.JCTree$JCMethodDecl): void;
              visitNewArray(tree: javac.tree.JCTree$JCNewArray): void;
              visitNewClass(tree: javac.tree.JCTree$JCNewClass): void;
              visitParens(tree: javac.tree.JCTree$JCParens): void;
              visitPatternCaseLabel(tree: javac.tree.JCTree$JCPatternCaseLabel): void;
              visitReturn(tree: javac.tree.JCTree$JCReturn): void;
              visitSelect(tree: javac.tree.JCTree$JCFieldAccess): void;
              visitSkip(tree: javac.tree.JCTree$JCSkip): void;
              visitSwitch(tree: javac.tree.JCTree$JCSwitch): void;
              visitSwitchExpression(tree: javac.tree.JCTree$JCSwitchExpression): void;
              visitSynchronized(tree: javac.tree.JCTree$JCSynchronized): void;
              visitThrow(tree: javac.tree.JCTree$JCThrow): void;
              visitTree(tree: javac.tree.JCTree): void;
              visitTry(tree: javac.tree.JCTree$JCTry): void;
              visitTypeApply(tree: javac.tree.JCTree$JCTypeApply): void;
              visitTypeArray(tree: javac.tree.JCTree$JCArrayTypeTree): void;
              visitTypeCast(tree: javac.tree.JCTree$JCTypeCast): void;
              visitTypeIdent(tree: javac.tree.JCTree$JCPrimitiveTypeTree): void;
              visitTypeParameter(tree: javac.tree.JCTree$JCTypeParameter): void;
              visitTypeTest(tree: javac.tree.JCTree$JCInstanceOf): void;
              visitTypeUnion(tree: javac.tree.JCTree$JCTypeUnion): void;
              visitUnary(tree: javac.tree.JCTree$JCUnary): void;
              visitVarDef(tree: javac.tree.JCTree$JCVariableDecl): void;
              visitWhileLoop(tree: javac.tree.JCTree$JCWhileLoop): void;
              visitWildcard(tree: javac.tree.JCTree$JCWildcard): void;
              visitYield(tree: javac.tree.JCTree$JCYield): void;
              _result: CRTable$SourceRange;
              _this$0: CRTable;
            }
            interface CRTable$SourceComputer extends CombineTypes<[_CRTable$SourceComputer, com.sun.tools.javac.tree.JCTree$Visitor]> {}
            interface _CRTable$SourceRange$$static extends ClassLike {
              _new(): CRTable$SourceRange;
              _new(startPos: int, endPos: int): CRTable$SourceRange;
            }
            let CRTable$SourceRange: _CRTable$SourceRange$$static;
            interface _CRTable$SourceRange {
              _mergeWith(sr: CRTable$SourceRange): CRTable$SourceRange;
              _endPos: int;
              _startPos: int;
            }
            interface CRTable$SourceRange extends CombineTypes<[_CRTable$SourceRange, java.lang.Object]> {}
            interface _ClassFile$$static extends ClassLike {
              externalize(name: javac.util.Name): javac.util.Name;
              externalize(name: string): string;
              internalize(buf: byte[], offset: int, len: int): byte[];
              internalize(name: javac.util.Name): javac.util.Name;
              readonly CONSTANT_Class: int;
              readonly CONSTANT_Double: int;
              readonly CONSTANT_Dynamic: int;
              readonly CONSTANT_Fieldref: int;
              readonly CONSTANT_Float: int;
              readonly CONSTANT_Integer: int;
              readonly CONSTANT_InterfaceMethodref: int;
              readonly CONSTANT_InvokeDynamic: int;
              readonly CONSTANT_Long: int;
              readonly CONSTANT_MethodHandle: int;
              readonly CONSTANT_MethodType: int;
              readonly CONSTANT_Methodref: int;
              readonly CONSTANT_Module: int;
              readonly CONSTANT_NameandType: int;
              readonly CONSTANT_Package: int;
              readonly CONSTANT_String: int;
              readonly CONSTANT_Unicode: int;
              readonly CONSTANT_Utf8: int;
              readonly JAVA_MAGIC: int;
              readonly MAX_CODE: int;
              readonly MAX_DIMENSIONS: int;
              readonly MAX_LOCALS: int;
              readonly MAX_PARAMETERS: int;
              readonly MAX_STACK: int;
              readonly PREVIEW_MINOR_VERSION: int;
              readonly REF_getField: int;
              readonly REF_getStatic: int;
              readonly REF_invokeInterface: int;
              readonly REF_invokeSpecial: int;
              readonly REF_invokeStatic: int;
              readonly REF_invokeVirtual: int;
              readonly REF_newInvokeSpecial: int;
              readonly REF_putField: int;
              readonly REF_putStatic: int;
              new(): ClassFile;
            }
            let ClassFile: _ClassFile$$static;
            interface _ClassFile {
            }
            interface ClassFile extends CombineTypes<[_ClassFile, java.lang.Object]> {}
            interface _ClassFile$Version$$static extends ClassLike {
              MAX(): ClassFile$Version;
              MIN(): ClassFile$Version;
              valueOf(name: string): ClassFile$Version;
              values(): ClassFile$Version[];
              _MAX: ClassFile$Version;
              _MIN: ClassFile$Version;
              readonly V45_3: ClassFile$Version;
              readonly V48: ClassFile$Version;
              readonly V49: ClassFile$Version;
              readonly V50: ClassFile$Version;
              readonly V51: ClassFile$Version;
              readonly V52: ClassFile$Version;
              readonly V53: ClassFile$Version;
              readonly V54: ClassFile$Version;
              readonly V55: ClassFile$Version;
              readonly V56: ClassFile$Version;
              readonly V57: ClassFile$Version;
              readonly V58: ClassFile$Version;
              readonly V59: ClassFile$Version;
              readonly V60: ClassFile$Version;
              readonly V61: ClassFile$Version;
              readonly V62: ClassFile$Version;
              readonly V63: ClassFile$Version;
              readonly V64: ClassFile$Version;
              readonly V65: ClassFile$Version;
            }
            let ClassFile$Version: _ClassFile$Version$$static;
            interface _ClassFile$Version {
              readonly major: int;
              readonly minor: int;
            }
            interface ClassFile$Version extends CombineTypes<[_ClassFile$Version]> {}
            interface _ClassReader$$static extends ClassLike {
              instance(context: javac.util.Context): ClassReader;
              _isAsciiDigit(c: char): boolean;
              readonly INITIAL_BUFFER_SIZE: int;
              _classReaderKey: javac.util.Context$Key<ClassReader>;
              _new(context: javac.util.Context): ClassReader;
            }
            let ClassReader: _ClassReader$$static;
            interface _ClassReader {
              _addTypeAnnotationsToSymbol(s: javac.code.Symbol, attributes: javac.util.List<javac.code.Attribute$TypeCompound>): void;
              _adjustClassFlags(flags: long): long;
              _adjustFieldFlags(flags: long): long;
              _adjustMethodFlags(flags: long): long;
              _adjustMethodParams(flags: long, a1: javac.util.List<javac.code.Type>): javac.util.List<javac.code.Type>;
              _attachAnnotationDefault(sym: javac.code.Symbol): void;
              _attachAnnotations(sym: javac.code.Symbol): void;
              _attachAnnotations(sym: javac.code.Symbol, annotations: javac.util.List<ClassReader$CompoundAnnotationProxy>): void;
              _attachTypeAnnotations(sym: javac.code.Symbol): void;
              badClassFile(key: string, args: any[]): javac.code.ClassFinder$BadClassFile;
              badClassFile(key: string, ...args: any[]): javac.code.ClassFinder$BadClassFile;
              badClassFile(fragment: javac.util.JCDiagnostic$Fragment): javac.code.ClassFinder$BadClassFile;
              badClassFile(diagnostic: javac.util.JCDiagnostic): javac.code.ClassFinder$BadClassFile;
              badEnclosingMethod(sym: javac.code.Symbol): javac.code.ClassFinder$BadEnclosingMethodAttr;
              _classSigToType(): javac.code.Type;
              _enterClass(name: javac.util.Name): javac.code.Symbol$ClassSymbol;
              _enterClass(name: javac.util.Name, owner: javac.code.Symbol$TypeSymbol): javac.code.Symbol$ClassSymbol;
              _enterMember(c: javac.code.Symbol$ClassSymbol, sym: javac.code.Symbol): void;
              _enterTypevars(sym: javac.code.Symbol, t: javac.code.Type): void;
              _findMethod(nt: PoolConstant$NameAndType, scope: javac.code.Scope, flags: long): javac.code.Symbol$MethodSymbol;
              _findTypeVar(name: javac.util.Name): javac.code.Type;
              _initAttributeReaders(): void;
              _initParameterNames(sym: javac.code.Symbol$MethodSymbol): void;
              _isSameBinaryType(mt1: javac.code.Type$MethodType, mt2: javac.code.Type$MethodType): boolean;
              _lookupMethod(tsym: javac.code.Symbol$TypeSymbol, name: javac.util.Name, argtypes: javac.util.List<javac.code.Type>): javac.code.Symbol$MethodSymbol;
              _nextByte(): int;
              _nextChar(): char;
              _nextInt(): int;
              _optPoolEntry<Z>(index: int, poolFunc: java.util.function.IntFunction<Z>, defaultValue: Z): Z;
              _parameter(mpIndex: int, lvtIndex: int, t: javac.code.Type, owner: javac.code.Symbol$MethodSymbol, exclude: java.util.Set<javac.util.Name>): javac.code.Symbol$VarSymbol;
              _quoteBadSignature(): string;
              _readAnnotations(): javac.util.List<ClassReader$CompoundAnnotationProxy>;
              _readAttributeValue(): javac.code.Attribute;
              _readAttrs(sym: javac.code.Symbol, kind: ClassReader$AttributeKind): void;
              _readClass(c: javac.code.Symbol$ClassSymbol): void;
              _readClassAttrs(c: javac.code.Symbol$ClassSymbol): void;
              _readClassBuffer(c: javac.code.Symbol$ClassSymbol): void;
              readClassFile(c: javac.code.Symbol$ClassSymbol): void;
              _readCode(owner: javac.code.Symbol): Code;
              _readCompoundAnnotation(): ClassReader$CompoundAnnotationProxy;
              _readEnclosingMethodAttr(sym: javac.code.Symbol): void;
              _readExportsFlags(flags: int): java.util.Set<javac.code.Directive$ExportsFlag>;
              _readField(): javac.code.Symbol$VarSymbol;
              _readInnerClasses(c: javac.code.Symbol$ClassSymbol): void;
              _readMemberAttrs(sym: javac.code.Symbol): void;
              _readMethod(): javac.code.Symbol$MethodSymbol;
              _readModuleFlags(flags: int): java.util.Set<javac.code.Symbol$ModuleFlags>;
              _readModuleResolutionFlags(flags: int): java.util.Set<javac.code.Symbol$ModuleResolutionFlags>;
              _readName(buf: byte[], off: int, len: int): javac.util.Name;
              _readOpensFlags(flags: int): java.util.Set<javac.code.Directive$OpensFlag>;
              _readParameterAnnotations(meth: javac.code.Symbol): void;
              _readPosition(): javac.code.TypeAnnotationPosition;
              _readRequiresFlags(flags: int): java.util.Set<javac.code.Directive$RequiresFlag>;
              _readTypeAnnotation(): ClassReader$TypeAnnotationProxy;
              _readTypeOrClassSymbol(i: int): javac.code.Type;
              _readTypePath(): javac.util.List<javac.code.TypeAnnotationPosition$TypePathEntry>;
              _readTypeToProxy(i: int): javac.code.Type;
              _setFlagIfAttributeTrue(proxy: ClassReader$CompoundAnnotationProxy, sym: javac.code.Symbol, attribute: javac.util.Name, flag: long): void;
              _setParameters(sym: javac.code.Symbol$MethodSymbol, jvmType: javac.code.Type): void;
              _sigToType(sig: byte[], offset: int, len: int): javac.code.Type;
              _sigToType(): javac.code.Type;
              _sigToTypeParam(): javac.code.Type;
              _sigToTypeParams(sig: byte[], offset: int, len: int): javac.util.List<javac.code.Type>;
              _sigToTypeParams(): javac.util.List<javac.code.Type>;
              _sigToTypes(terminator: char): javac.util.List<javac.code.Type>;
              _simpleBinaryName(self: javac.util.Name, enclosing: javac.util.Name): javac.util.Name;
              _skipBytes(n: int): void;
              _skipInnerClasses(): void;
              _skipMember(): void;
              _validateMethodType(name: javac.util.Name, t: javac.code.Type): void;
              _CLASS_ATTRIBUTE: java.util.Set<ClassReader$AttributeKind>;
              _CLASS_OR_MEMBER_ATTRIBUTE: java.util.Set<ClassReader$AttributeKind>;
              _MEMBER_ATTRIBUTE: java.util.Set<ClassReader$AttributeKind>;
              _addTypeAnnotationsToSymbol: boolean;
              _allowModules: boolean;
              _allowRecords: boolean;
              _allowSealedTypes: boolean;
              _annotate: javac.comp.Annotate;
              _attributeReaders: java.util.Map<javac.util.Name,ClassReader$AttributeReader>;
              _bp: int;
              _buf: javac.util.ByteBuffer;
              _currentClassFile: javax.tools.JavaFileObject;
              _currentModule: javac.code.Symbol$ModuleSymbol;
              _currentOwner: javac.code.Symbol;
              _dcfh: javac.code.DeferredCompletionFailureHandler;
              _diagFactory: javac.util.JCDiagnostic$Factory;
              _fileManager: javax.tools.JavaFileManager;
              filling: boolean;
              _foundTypeVariables: javac.util.List<javac.code.Type>;
              _interimProvides: javac.util.List<ClassReader$InterimProvidesDirective>;
              _interimUses: javac.util.List<ClassReader$InterimUsesDirective>;
              _lintClassfile: boolean;
              _log: javac.util.Log;
              _majorVersion: int;
              _minorVersion: int;
              _missingTypeVariables: javac.util.List<javac.code.Type>;
              _names: javac.util.Names;
              _parameterAccessFlags: int[];
              _parameterAnnotations: ClassReader$ParameterAnnotations[];
              _parameterNameIndicesLvt: int[];
              _parameterNameIndicesMp: int[];
              _poolReader: PoolReader;
              _preview: javac.code.Preview;
              readonly profile: Profile;
              _readingClassAttr: boolean;
              _repeatable: ClassReader$CompoundAnnotationProxy;
              saveParameterNames: boolean;
              _sbp: int;
              _sigEnterPhase: boolean;
              _siglimit: int;
              _signature: byte[];
              _signatureBuffer: byte[];
              _sigp: int;
              _syms: javac.code.Symtab;
              _target: ClassReader$CompoundAnnotationProxy;
              _types: javac.code.Types;
              _typevars: javac.code.Scope$WriteableScope;
              _utf8validation: javac.util.Convert$Validation;
              _verbose: boolean;
              _warnOnIllegalUtf8: boolean;
              _warnedAttrs: java.util.Set<javac.util.Name>;
            }
            interface ClassReader extends CombineTypes<[_ClassReader, java.lang.Object]> {}
            interface _ClassReader$AnnotationCompleter$$static extends ClassLike {
              _new(this$0: javac.code.Symbol, sym: javac.util.List<ClassReader$CompoundAnnotationProxy>): ClassReader$AnnotationCompleter;
            }
            let ClassReader$AnnotationCompleter: _ClassReader$AnnotationCompleter$$static;
            interface _ClassReader$AnnotationCompleter {
              run(): void;
              toString(): string;
              _classFile: javax.tools.JavaFileObject;
              _l: javac.util.List<ClassReader$CompoundAnnotationProxy>;
              _sym: javac.code.Symbol;
              _this$0: ClassReader;
            }
            interface ClassReader$AnnotationCompleter extends CombineTypes<[_ClassReader$AnnotationCompleter, com.sun.tools.javac.jvm.ClassReader$AnnotationDeproxy, java.lang.Runnable]> {}
            interface _ClassReader$AnnotationDefaultCompleter$$static extends ClassLike {
              _new(this$0: ClassReader, sym: javac.code.Symbol$MethodSymbol, value: javac.code.Attribute): ClassReader$AnnotationDefaultCompleter;
            }
            let ClassReader$AnnotationDefaultCompleter: _ClassReader$AnnotationDefaultCompleter$$static;
            interface _ClassReader$AnnotationDefaultCompleter {
              run(): void;
              toString(): string;
              _classFile: javax.tools.JavaFileObject;
              _sym: javac.code.Symbol$MethodSymbol;
              _this$0: ClassReader;
              _value: javac.code.Attribute;
            }
            interface ClassReader$AnnotationDefaultCompleter extends CombineTypes<[_ClassReader$AnnotationDefaultCompleter, com.sun.tools.javac.jvm.ClassReader$AnnotationDeproxy, java.lang.Runnable]> {}
            interface _ClassReader$AnnotationDeproxy$$static extends ClassLike {
              _new(this$0: ClassReader, owner: javac.code.Symbol$ClassSymbol): ClassReader$AnnotationDeproxy;
            }
            let ClassReader$AnnotationDeproxy: _ClassReader$AnnotationDeproxy$$static;
            interface _ClassReader$AnnotationDeproxy {
              _deproxy(t: javac.code.Type, a: javac.code.Attribute): javac.code.Attribute;
              _deproxyCompound(a: ClassReader$CompoundAnnotationProxy): javac.code.Attribute$Compound;
              _deproxyCompoundList(pl: javac.util.List<ClassReader$CompoundAnnotationProxy>): javac.util.List<javac.code.Attribute$Compound>;
              _findAccessMethod(container: javac.code.Type, name: javac.util.Name): javac.code.Symbol$MethodSymbol;
              _resolvePossibleProxyType(t: javac.code.Type): javac.code.Type;
              visitArray(array: javac.code.Attribute$Array): void;
              visitArrayAttributeProxy(proxy: ClassReader$ArrayAttributeProxy): void;
              visitClass(clazz: javac.code.Attribute$Class): void;
              visitClassAttributeProxy(proxy: ClassReader$ClassAttributeProxy): void;
              visitCompound(compound: javac.code.Attribute$Compound): void;
              visitCompoundAnnotationProxy(proxy: ClassReader$CompoundAnnotationProxy): void;
              visitConstant(value: javac.code.Attribute$Constant): void;
              visitEnum(e: javac.code.Attribute$Enum): void;
              visitEnumAttributeProxy(proxy: ClassReader$EnumAttributeProxy): void;
              visitError(e: javac.code.Attribute$Error): void;
              _requestingOwner: javac.code.Symbol$ClassSymbol;
              _result: javac.code.Attribute;
              _this$0: ClassReader;
              _type: javac.code.Type;
            }
            interface ClassReader$AnnotationDeproxy extends CombineTypes<[_ClassReader$AnnotationDeproxy, com.sun.tools.javac.jvm.ClassReader$ProxyVisitor, java.lang.Object]> {}
            interface _ClassReader$ArrayAttributeProxy$$static extends ClassLike {
              _new(values: javac.util.List<javac.code.Attribute>): ClassReader$ArrayAttributeProxy;
            }
            let ClassReader$ArrayAttributeProxy: _ClassReader$ArrayAttributeProxy$$static;
            interface _ClassReader$ArrayAttributeProxy {
              accept(v: javac.code.Attribute$Visitor): void;
              toString(): string;
              _values: javac.util.List<javac.code.Attribute>;
            }
            interface ClassReader$ArrayAttributeProxy extends CombineTypes<[_ClassReader$ArrayAttributeProxy, com.sun.tools.javac.code.Attribute]> {}
            interface _ClassReader$AttributeKind$$static extends ClassLike {
              valueOf(name: string): ClassReader$AttributeKind;
              values(): ClassReader$AttributeKind[];
              readonly CLASS: ClassReader$AttributeKind;
              readonly MEMBER: ClassReader$AttributeKind;
            }
            let ClassReader$AttributeKind: _ClassReader$AttributeKind$$static;
            interface _ClassReader$AttributeKind {
            }
            interface ClassReader$AttributeKind extends CombineTypes<[_ClassReader$AttributeKind]> {}
            interface _ClassReader$AttributeReader$$static extends ClassLike {
              _new(this$0: javac.util.Name, name: ClassFile$Version, version: java.util.Set<ClassReader$AttributeKind>): ClassReader$AttributeReader;
            }
            let ClassReader$AttributeReader: _ClassReader$AttributeReader$$static;
            interface _ClassReader$AttributeReader {
              _accepts(kind: ClassReader$AttributeKind): boolean;
              _read(a0: javac.code.Symbol, a1: int): void;
(a0: javac.code.Symbol, a1: int): void;
              _kinds: java.util.Set<ClassReader$AttributeKind>;
              _name: javac.util.Name;
              _this$0: ClassReader;
              _version: ClassFile$Version;
            }
            interface ClassReader$AttributeReader extends CombineTypes<[_ClassReader$AttributeReader, java.lang.Object]> {}
            interface _ClassReader$ClassAttributeProxy$$static extends ClassLike {
              new(classType: javac.code.Type): ClassReader$ClassAttributeProxy;
            }
            let ClassReader$ClassAttributeProxy: _ClassReader$ClassAttributeProxy$$static;
            interface _ClassReader$ClassAttributeProxy {
              accept(v: javac.code.Attribute$Visitor): void;
              toString(): string;
              _classType: javac.code.Type;
            }
            interface ClassReader$ClassAttributeProxy extends CombineTypes<[_ClassReader$ClassAttributeProxy, com.sun.tools.javac.code.Attribute]> {}
            interface _ClassReader$CompleterDeproxy$$static extends ClassLike {
              new(a0: ClassReader, c: javac.code.Symbol$ClassSymbol, target: ClassReader$CompoundAnnotationProxy, repeatable: ClassReader$CompoundAnnotationProxy): ClassReader$CompleterDeproxy;
            }
            let ClassReader$CompleterDeproxy: _ClassReader$CompleterDeproxy$$static;
            interface _ClassReader$CompleterDeproxy {
              complete(sym: javac.code.Symbol$ClassSymbol): void;
              _proxyOn: javac.code.Symbol$ClassSymbol;
              _repeatable: ClassReader$CompoundAnnotationProxy;
              _target: ClassReader$CompoundAnnotationProxy;
              _this$0: ClassReader;
            }
            interface ClassReader$CompleterDeproxy extends CombineTypes<[_ClassReader$CompleterDeproxy, java.lang.Object, com.sun.tools.javac.comp.Annotate$AnnotationTypeCompleter]> {}
            interface _ClassReader$CompoundAnnotationProxy$$static extends ClassLike {
              new(type: javac.code.Type, values: javac.util.List<javac.util.Pair<javac.util.Name,javac.code.Attribute>>): ClassReader$CompoundAnnotationProxy;
            }
            let ClassReader$CompoundAnnotationProxy: _ClassReader$CompoundAnnotationProxy$$static;
            interface _ClassReader$CompoundAnnotationProxy {
              accept(v: javac.code.Attribute$Visitor): void;
              toString(): string;
              _values: javac.util.List<javac.util.Pair<javac.util.Name,javac.code.Attribute>>;
            }
            interface ClassReader$CompoundAnnotationProxy extends CombineTypes<[_ClassReader$CompoundAnnotationProxy, com.sun.tools.javac.code.Attribute]> {}
            interface _ClassReader$EnumAttributeProxy$$static extends ClassLike {
              new(enumType: javac.code.Type, enumerator: javac.util.Name): ClassReader$EnumAttributeProxy;
            }
            let ClassReader$EnumAttributeProxy: _ClassReader$EnumAttributeProxy$$static;
            interface _ClassReader$EnumAttributeProxy {
              accept(v: javac.code.Attribute$Visitor): void;
              toString(): string;
              _enumType: javac.code.Type;
              _enumerator: javac.util.Name;
            }
            interface ClassReader$EnumAttributeProxy extends CombineTypes<[_ClassReader$EnumAttributeProxy, com.sun.tools.javac.code.Attribute]> {}
            interface _ClassReader$InterimProvidesDirective$$static extends ClassLike {
              new(service: javac.util.Name, impls: javac.util.List<javac.util.Name>): ClassReader$InterimProvidesDirective;
            }
            let ClassReader$InterimProvidesDirective: _ClassReader$InterimProvidesDirective$$static;
            interface _ClassReader$InterimProvidesDirective {
              readonly impls: javac.util.List<javac.util.Name>;
              readonly service: javac.util.Name;
            }
            interface ClassReader$InterimProvidesDirective extends CombineTypes<[_ClassReader$InterimProvidesDirective, java.lang.Object]> {}
            interface _ClassReader$InterimUsesDirective$$static extends ClassLike {
              new(service: javac.util.Name): ClassReader$InterimUsesDirective;
            }
            let ClassReader$InterimUsesDirective: _ClassReader$InterimUsesDirective$$static;
            interface _ClassReader$InterimUsesDirective {
              readonly service: javac.util.Name;
            }
            interface ClassReader$InterimUsesDirective extends CombineTypes<[_ClassReader$InterimUsesDirective, java.lang.Object]> {}
            interface _ClassReader$ParameterAnnotations$$static extends ClassLike {
              _new(): ClassReader$ParameterAnnotations;
            }
            let ClassReader$ParameterAnnotations: _ClassReader$ParameterAnnotations$$static;
            interface _ClassReader$ParameterAnnotations {
              _add(newAnnotations: javac.util.List<ClassReader$CompoundAnnotationProxy>): void;
              _proxies: javac.util.List<ClassReader$CompoundAnnotationProxy>;
            }
            interface ClassReader$ParameterAnnotations extends CombineTypes<[_ClassReader$ParameterAnnotations, java.lang.Object]> {}
            interface _ClassReader$ProxyType$$static extends ClassLike {
              new(a0: ClassReader, index: int): ClassReader$ProxyType;
            }
            let ClassReader$ProxyType: _ClassReader$ProxyType$$static;
            interface _ClassReader$ProxyType {
              getTag(): javac.code.TypeTag;
              resolve(): javac.code.Type;
              toString(): string;
              _name: javac.util.Name;
              _this$0: ClassReader;
            }
            interface ClassReader$ProxyType extends CombineTypes<[_ClassReader$ProxyType, com.sun.tools.javac.code.Type]> {}
            interface _ClassReader$ProxyVisitor$$static extends ClassLike {
            }
            let ClassReader$ProxyVisitor: _ClassReader$ProxyVisitor$$static;
            interface _ClassReader$ProxyVisitor {
              visitArrayAttributeProxy(a0: ClassReader$ArrayAttributeProxy): void;
              visitClassAttributeProxy(a0: ClassReader$ClassAttributeProxy): void;
              visitCompoundAnnotationProxy(a0: ClassReader$CompoundAnnotationProxy): void;
              visitEnumAttributeProxy(a0: ClassReader$EnumAttributeProxy): void;
            }
            interface ClassReader$ProxyVisitor extends CombineTypes<[_ClassReader$ProxyVisitor, com.sun.tools.javac.code.Attribute$Visitor, java.lang.Object]> {}
            interface _ClassReader$SourceFileObject$$static extends ClassLike {
              new(name: javac.util.Name): ClassReader$SourceFileObject;
            }
            let ClassReader$SourceFileObject: _ClassReader$SourceFileObject$$static;
            interface _ClassReader$SourceFileObject {
              delete(): boolean;
              equals(other: any): boolean;
              getAccessLevel(): javax.lang.model.element.Modifier;
              getCharContent(ignoreEncodingErrors: boolean): java.nio.CharBuffer;
              getCharContent(a0: boolean): ClassReader$SourceFileObject$charSequence;
              getKind(): javax.tools.JavaFileObject$Kind;
              getLastModified(): long;
              getName(): string;
              getNestingKind(): javax.lang.model.element.NestingKind;
              hashCode(): int;
              isNameCompatible(simpleName: string, kind: javax.tools.JavaFileObject$Kind): boolean;
              openInputStream(): java.io.InputStream;
              openOutputStream(): java.io.OutputStream;
              openReader(ignoreEncodingErrors: boolean): java.io.Reader;
              openWriter(): java.io.Writer;
              toUri(): java.net.URI;
              _name: javac.util.Name;
            }
            interface ClassReader$SourceFileObject extends CombineTypes<[_ClassReader$SourceFileObject, javax.tools.JavaFileObject, java.lang.Object]> {}
            interface _ClassReader$TypeAnnotationCompleter$$static extends ClassLike {
              _new(this$0: javac.code.Symbol, sym: javac.util.List<ClassReader$TypeAnnotationProxy>): ClassReader$TypeAnnotationCompleter;
            }
            let ClassReader$TypeAnnotationCompleter: _ClassReader$TypeAnnotationCompleter$$static;
            interface _ClassReader$TypeAnnotationCompleter {
              _deproxyTypeCompoundList(proxies: javac.util.List<ClassReader$TypeAnnotationProxy>): javac.util.List<javac.code.Attribute$TypeCompound>;
              run(): void;
              _proxies: javac.util.List<ClassReader$TypeAnnotationProxy>;
              _this$0: ClassReader;
            }
            interface ClassReader$TypeAnnotationCompleter extends CombineTypes<[_ClassReader$TypeAnnotationCompleter, com.sun.tools.javac.jvm.ClassReader$AnnotationCompleter]> {}
            interface _ClassReader$TypeAnnotationProxy$$static extends ClassLike {
              new(compound: ClassReader$CompoundAnnotationProxy, position: javac.code.TypeAnnotationPosition): ClassReader$TypeAnnotationProxy;
            }
            let ClassReader$TypeAnnotationProxy: _ClassReader$TypeAnnotationProxy$$static;
            interface _ClassReader$TypeAnnotationProxy {
              _compound: ClassReader$CompoundAnnotationProxy;
              _position: javac.code.TypeAnnotationPosition;
            }
            interface ClassReader$TypeAnnotationProxy extends CombineTypes<[_ClassReader$TypeAnnotationProxy, java.lang.Object]> {}
            interface _ClassReader$TypeAnnotationStructuralTypeMapping$$static extends ClassLike {
            }
            let ClassReader$TypeAnnotationStructuralTypeMapping: _ClassReader$TypeAnnotationStructuralTypeMapping$$static;
            interface _ClassReader$TypeAnnotationStructuralTypeMapping {
              _attributesForPath(path: javac.util.List<javac.code.TypeAnnotationPosition$TypePathEntry>): javac.util.List<javac.code.Attribute$TypeCompound>;
              _reannotate(type: javac.code.Type, path: javac.util.List<javac.code.TypeAnnotationPosition$TypePathEntry>): javac.code.Type;
              _rewriteTypeParams(path: javac.util.List<javac.code.TypeAnnotationPosition$TypePathEntry>, typarams: javac.util.List<javac.code.Type>): javac.util.List<javac.code.Type>;
              visitArrayType(t: javac.code.Type$ArrayType, path: javac.util.List<javac.code.TypeAnnotationPosition$TypePathEntry>): javac.code.Type;
              visitArrayType(a0: javac.code.Type$ArrayType, a1: any): any;
              visitClassType(t: javac.code.Type$ClassType, path: javac.util.List<javac.code.TypeAnnotationPosition$TypePathEntry>): javac.code.Type;
              visitClassType(a0: javac.code.Type$ClassType, a1: any): any;
              visitType(t: javac.code.Type, path: javac.util.List<javac.code.TypeAnnotationPosition$TypePathEntry>): javac.code.Type;
              visitType(a0: javac.code.Type, a1: any): javac.code.Type;
              visitType(a0: javac.code.Type, a1: any): any;
              visitWildcardType(wt: javac.code.Type$WildcardType, path: javac.util.List<javac.code.TypeAnnotationPosition$TypePathEntry>): javac.code.Type;
              visitWildcardType(a0: javac.code.Type$WildcardType, a1: any): any;
              _attributesByPath: java.util.Map<javac.util.List<javac.code.TypeAnnotationPosition$TypePathEntry>,javac.util.ListBuffer<javac.code.Attribute$TypeCompound>>;
            }
            interface ClassReader$TypeAnnotationStructuralTypeMapping extends CombineTypes<[_ClassReader$TypeAnnotationStructuralTypeMapping, javac.code.Types$TypeMapping<javac.util.List<javac.code.TypeAnnotationPosition$TypePathEntry>>]> {}
            interface _ClassReader$TypeAnnotationSymbolVisitor$$static extends ClassLike {
              _classExtends(index: int): java.util.function.Predicate<javac.code.TypeAnnotationPosition>;
              _methodFormalParameter(index: int): java.util.function.Predicate<javac.code.TypeAnnotationPosition>;
              _thrownType(index: int): java.util.function.Predicate<javac.code.TypeAnnotationPosition>;
              _typeParameterBound(targetType: javac.code.TargetType, parameterIndex: int, boundIndex: int): java.util.function.Predicate<javac.code.TypeAnnotationPosition>;
              readonly SUPERCLASS_INDEX: int;
            }
            let ClassReader$TypeAnnotationSymbolVisitor: _ClassReader$TypeAnnotationSymbolVisitor$$static;
            interface _ClassReader$TypeAnnotationSymbolVisitor {
              _addTypeAnnotations(type: javac.code.Type, targetType: javac.code.TargetType): javac.code.Type;
              _addTypeAnnotations(type: javac.code.Type, filter: java.util.function.Predicate<javac.code.TypeAnnotationPosition>): javac.code.Type;
              _rewriteTypeParameters(tvars: javac.util.List<javac.code.Type>, boundType: javac.code.TargetType): javac.util.List<javac.code.Type>;
              visitClassSymbol(s: javac.code.Symbol$ClassSymbol, unused: java.lang.Void): java.lang.Void;
              visitClassSymbol(a0: javac.code.Symbol$ClassSymbol, a1: any): any;
              visitMethodSymbol(s: javac.code.Symbol$MethodSymbol, unused: java.lang.Void): java.lang.Void;
              visitMethodSymbol(a0: javac.code.Symbol$MethodSymbol, a1: any): any;
              visitSymbol(s: javac.code.Symbol, unused: java.lang.Void): java.lang.Void;
              visitSymbol(a0: javac.code.Symbol, a1: any): any;
              visitVarSymbol(s: javac.code.Symbol$VarSymbol, unused: java.lang.Void): java.lang.Void;
              visitVarSymbol(a0: javac.code.Symbol$VarSymbol, a1: any): any;
              _attributes: javac.util.List<javac.code.Attribute$TypeCompound>;
            }
            interface ClassReader$TypeAnnotationSymbolVisitor extends CombineTypes<[_ClassReader$TypeAnnotationSymbolVisitor, javac.code.Types$DefaultSymbolVisitor<java.lang.Void,java.lang.Void>]> {}
            interface _ClassReader$UsesProvidesCompleter$$static extends ClassLike {
              new(a0: javac.code.Symbol$ModuleSymbol, currentModule: javac.util.List<ClassReader$InterimUsesDirective>, interimUsesCopy: javac.util.List<ClassReader$InterimProvidesDirective>): ClassReader$UsesProvidesCompleter;
            }
            let ClassReader$UsesProvidesCompleter: _ClassReader$UsesProvidesCompleter$$static;
            interface _ClassReader$UsesProvidesCompleter {
              complete(sym: javac.code.Symbol): void;
              _currentModule: javac.code.Symbol$ModuleSymbol;
              _interimProvidesCopy: javac.util.List<ClassReader$InterimProvidesDirective>;
              _interimUsesCopy: javac.util.List<ClassReader$InterimUsesDirective>;
              _this$0: ClassReader;
            }
            interface ClassReader$UsesProvidesCompleter extends CombineTypes<[_ClassReader$UsesProvidesCompleter, java.lang.Object, com.sun.tools.javac.code.Symbol$Completer]> {}
            interface _ClassWriter$$static extends ClassLike {
              flagNames(flags: long): string;
              instance(context: javac.util.Context): ClassWriter;
              _CLASS_BUF_SIZE: int;
              _DATA_BUF_SIZE: int;
              _FULL_FRAME: int;
              _MAX_LOCAL_LENGTH_DIFF: int;
              _SAME_FRAME_EXTENDED: int;
              _SAME_FRAME_SIZE: int;
              _SAME_LOCALS_1_STACK_ITEM_EXTENDED: int;
              _classWriterKey: javac.util.Context$Key<ClassWriter>;
              _flagName: string[];
              _new(context: javac.util.Context): ClassWriter;
            }
            let ClassWriter: _ClassWriter$$static;
            interface _ClassWriter {
              addExtraAttributes(addExtraAttributes: java.util.function.ToIntFunction<javac.code.Symbol>): void;
              _adjustFlags(flags: long): int;
              _beginAttrs(): int;
              endAttr(index: int): void;
              _endAttrs(index: int, count: int): void;
              _getLastModified(filename: javax.tools.FileObject): long;
              _listNested(sym: javac.code.Symbol, seen: javac.util.ListBuffer<javac.code.Symbol$ClassSymbol>): void;
              _needsLocalVariableTypeEntry(t: javac.code.Type): boolean;
              _putChar(buf: javac.util.ByteBuffer, op: int, x: int): void;
              _putInt(buf: javac.util.ByteBuffer, adr: int, x: int): void;
              _requiresParamFlags(m: javac.code.Symbol$MethodSymbol): boolean;
              _requiresParamNames(m: javac.code.Symbol$MethodSymbol): boolean;
              writeAttr(attrName: javac.util.Name): int;
              _writeBootstrapMethods(): void;
              writeClass(c: javac.code.Symbol$ClassSymbol): javax.tools.JavaFileObject;
              writeClassFile(out: java.io.OutputStream, c: javac.code.Symbol$ClassSymbol): void;
              _writeCode(code: Code): void;
              _writeCompoundAttribute(c: javac.code.Attribute$Compound): void;
              _writeEnclosingMethodAttribute(c: javac.code.Symbol$ClassSymbol): int;
              _writeEnclosingMethodAttribute(attributeName: javac.util.Name, c: javac.code.Symbol$ClassSymbol): int;
              _writeExtraAttributes(sym: javac.code.Symbol): int;
              _writeExtraClassAttributes(c: javac.code.Symbol$ClassSymbol): int;
              _writeField(v: javac.code.Symbol$VarSymbol): void;
              _writeFields(s: javac.code.Scope): void;
              _writeFlagAttrs(flags: long): int;
              _writeInnerClasses(): void;
              _writeJavaAnnotations(attrs: javac.util.List<javac.code.Attribute$Compound>): int;
              _writeMemberAttrs(sym: javac.code.Symbol, isRecordComponent: boolean): int;
              _writeMethod(m: javac.code.Symbol$MethodSymbol): void;
              _writeMethodParametersAttr(m: javac.code.Symbol$MethodSymbol, writeParamNames: boolean): int;
              _writeMethods(s: javac.code.Scope): void;
              _writeModuleAttribute(c: javac.code.Symbol$ClassSymbol): int;
              _writeNestHostIfNeeded(csym: javac.code.Symbol$ClassSymbol): int;
              _writeNestMembersIfNeeded(csym: javac.code.Symbol$ClassSymbol): int;
              _writeParamAnnotations(params: javac.util.List<javac.code.Symbol$VarSymbol>, retention: javac.code.Attribute$RetentionPolicy): void;
              _writeParamAnnotations(m: javac.code.Symbol$MethodSymbol, retention: javac.code.Attribute$RetentionPolicy): void;
              _writeParameterAttrs(vars: javac.util.List<javac.code.Symbol$VarSymbol>): int;
              _writePermittedSubclassesIfNeeded(csym: javac.code.Symbol$ClassSymbol): int;
              _writePosition(p: javac.code.TypeAnnotationPosition): void;
              _writeRecordAttribute(csym: javac.code.Symbol$ClassSymbol): int;
              _writeStackMap(code: Code): void;
              _writeStackMapType(t: javac.code.Type): void;
              _writeTypeAnnotation(c: javac.code.Attribute$TypeCompound): void;
              _writeTypeAnnotations(typeAnnos: javac.util.List<javac.code.Attribute$TypeCompound>, inCode: boolean): int;
              _awriter: ClassWriter$AttributeWriter;
              _check: javac.comp.Check;
              databuf: javac.util.ByteBuffer;
              _debugstackmap: boolean;
              _dumpClassModifiers: boolean;
              _dumpFieldModifiers: boolean;
              _dumpInnerClassModifiers: boolean;
              _dumpMethodModifiers: boolean;
              _emitSourceFile: boolean;
              _extraAttributeHooks: javac.util.List<java.util.function.ToIntFunction<javac.code.Symbol>>;
              _fileManager: javax.tools.JavaFileManager;
              _genCrt: boolean;
              _log: javac.util.Log;
              multiModuleMode: boolean;
              _names: javac.util.Names;
              _options: javac.util.Options;
              _poolWriter: PoolWriter;
              _poolbuf: javac.util.ByteBuffer;
              _preview: javac.code.Preview;
              _source: javac.code.Source;
              _target: Target;
              _types: javac.code.Types;
              _verbose: boolean;
            }
            interface ClassWriter extends CombineTypes<[_ClassWriter, com.sun.tools.javac.jvm.ClassFile]> {}
            interface _ClassWriter$AttributeWriter$$static extends ClassLike {
              _new(this$0: ClassWriter): ClassWriter$AttributeWriter;
            }
            let ClassWriter$AttributeWriter: _ClassWriter$AttributeWriter$$static;
            interface _ClassWriter$AttributeWriter {
              visitArray(array: javac.code.Attribute$Array): void;
              visitClass(clazz: javac.code.Attribute$Class): void;
              visitCompound(compound: javac.code.Attribute$Compound): void;
              visitConstant(_value: javac.code.Attribute$Constant): void;
              visitEnum(e: javac.code.Attribute$Enum): void;
              visitError(x: javac.code.Attribute$Error): void;
              _this$0: ClassWriter;
            }
            interface ClassWriter$AttributeWriter extends CombineTypes<[_ClassWriter$AttributeWriter, com.sun.tools.javac.code.Attribute$Visitor, java.lang.Object]> {}
            interface _ClassWriter$PoolOverflow$$static extends ClassLike {
              _serialVersionUID: long;
              new(): ClassWriter$PoolOverflow;
            }
            let ClassWriter$PoolOverflow: _ClassWriter$PoolOverflow$$static;
            interface _ClassWriter$PoolOverflow {
            }
            interface ClassWriter$PoolOverflow extends CombineTypes<[_ClassWriter$PoolOverflow, java.lang.RuntimeException]> {}
            interface _ClassWriter$StackMapTableFrame$$static extends ClassLike {
              _compare(arr1: javac.code.Type[], arr2: javac.code.Type[], types: javac.code.Types): int;
              _getInstance(this_frame: Code$StackMapFrame, prev_pc: int, prev_locals: javac.code.Type[], types: javac.code.Types): ClassWriter$StackMapTableFrame;
              _isInt(t: javac.code.Type): boolean;
              _isSameType(t1: javac.code.Type, t2: javac.code.Type, types: javac.code.Types): boolean;
              _new(): ClassWriter$StackMapTableFrame;
            }
            let ClassWriter$StackMapTableFrame: _ClassWriter$StackMapTableFrame$$static;
            interface _ClassWriter$StackMapTableFrame {
              _getFrameType(): int;
(): int;
              _write(writer: ClassWriter): void;
            }
            interface ClassWriter$StackMapTableFrame extends CombineTypes<[_ClassWriter$StackMapTableFrame, java.lang.Object]> {}
            interface _ClassWriter$StackMapTableFrame$AppendFrame$$static extends ClassLike {
              _new(frameType: int, offsetDelta: int, locals: javac.code.Type[]): ClassWriter$StackMapTableFrame$AppendFrame;
            }
            let ClassWriter$StackMapTableFrame$AppendFrame: _ClassWriter$StackMapTableFrame$AppendFrame$$static;
            interface _ClassWriter$StackMapTableFrame$AppendFrame {
              _getFrameType(): int;
              _write(writer: ClassWriter): void;
              _frameType: int;
              _locals: javac.code.Type[];
              _offsetDelta: int;
            }
            interface ClassWriter$StackMapTableFrame$AppendFrame extends CombineTypes<[_ClassWriter$StackMapTableFrame$AppendFrame, com.sun.tools.javac.jvm.ClassWriter$StackMapTableFrame]> {}
            interface _ClassWriter$StackMapTableFrame$ChopFrame$$static extends ClassLike {
              _new(frameType: int, offsetDelta: int): ClassWriter$StackMapTableFrame$ChopFrame;
            }
            let ClassWriter$StackMapTableFrame$ChopFrame: _ClassWriter$StackMapTableFrame$ChopFrame$$static;
            interface _ClassWriter$StackMapTableFrame$ChopFrame {
              _getFrameType(): int;
              _write(writer: ClassWriter): void;
              _frameType: int;
              _offsetDelta: int;
            }
            interface ClassWriter$StackMapTableFrame$ChopFrame extends CombineTypes<[_ClassWriter$StackMapTableFrame$ChopFrame, com.sun.tools.javac.jvm.ClassWriter$StackMapTableFrame]> {}
            interface _ClassWriter$StackMapTableFrame$FullFrame$$static extends ClassLike {
              _new(offsetDelta: int, locals: javac.code.Type[], stack: javac.code.Type[]): ClassWriter$StackMapTableFrame$FullFrame;
            }
            let ClassWriter$StackMapTableFrame$FullFrame: _ClassWriter$StackMapTableFrame$FullFrame$$static;
            interface _ClassWriter$StackMapTableFrame$FullFrame {
              _getFrameType(): int;
              _write(writer: ClassWriter): void;
              _locals: javac.code.Type[];
              _offsetDelta: int;
              _stack: javac.code.Type[];
            }
            interface ClassWriter$StackMapTableFrame$FullFrame extends CombineTypes<[_ClassWriter$StackMapTableFrame$FullFrame, com.sun.tools.javac.jvm.ClassWriter$StackMapTableFrame]> {}
            interface _ClassWriter$StackMapTableFrame$SameFrame$$static extends ClassLike {
              _new(offsetDelta: int): ClassWriter$StackMapTableFrame$SameFrame;
            }
            let ClassWriter$StackMapTableFrame$SameFrame: _ClassWriter$StackMapTableFrame$SameFrame$$static;
            interface _ClassWriter$StackMapTableFrame$SameFrame {
              _getFrameType(): int;
              _write(writer: ClassWriter): void;
              _offsetDelta: int;
            }
            interface ClassWriter$StackMapTableFrame$SameFrame extends CombineTypes<[_ClassWriter$StackMapTableFrame$SameFrame, com.sun.tools.javac.jvm.ClassWriter$StackMapTableFrame]> {}
            interface _ClassWriter$StackMapTableFrame$SameLocals1StackItemFrame$$static extends ClassLike {
              _new(offsetDelta: int, stack: javac.code.Type): ClassWriter$StackMapTableFrame$SameLocals1StackItemFrame;
            }
            let ClassWriter$StackMapTableFrame$SameLocals1StackItemFrame: _ClassWriter$StackMapTableFrame$SameLocals1StackItemFrame$$static;
            interface _ClassWriter$StackMapTableFrame$SameLocals1StackItemFrame {
              _getFrameType(): int;
              _write(writer: ClassWriter): void;
              _offsetDelta: int;
              _stack: javac.code.Type;
            }
            interface ClassWriter$StackMapTableFrame$SameLocals1StackItemFrame extends CombineTypes<[_ClassWriter$StackMapTableFrame$SameLocals1StackItemFrame, com.sun.tools.javac.jvm.ClassWriter$StackMapTableFrame]> {}
            interface _ClassWriter$StringOverflow$$static extends ClassLike {
              _serialVersionUID: long;
              new(s: string): ClassWriter$StringOverflow;
            }
            let ClassWriter$StringOverflow: _ClassWriter$StringOverflow$$static;
            interface _ClassWriter$StringOverflow {
              readonly value: string;
            }
            interface ClassWriter$StringOverflow extends CombineTypes<[_ClassWriter$StringOverflow, java.lang.RuntimeException]> {}
            interface _Code$$static extends ClassLike {
              arraycode(type: javac.code.Type): int;
              mergeChains(chain1: Code$Chain, chain2: Code$Chain): Code$Chain;
              mnem(opcode: int): string;
              negate(opcode: int): int;
              truncate(tc: int): int;
              typecode(type: javac.code.Type): int;
              width(typecode: int): int;
              width(type: javac.code.Type): int;
              width(types: javac.util.List<javac.code.Type>): int;
              _jsrReturnValue: javac.code.Type;
              new(meth: javac.code.Symbol$MethodSymbol, fatcode: boolean, lineMap: javac.util.Position$LineMap, varDebugInfo: boolean, stackMap: Code$StackMapFormat, debugCode: boolean, crt: CRTable, syms: javac.code.Symtab, types: javac.code.Types, poolWriter: PoolWriter): Code;
            }
            let Code: _Code$$static;
            interface _Code {
              addCatch(startPc: char, endPc: char, handlerPc: char, catchType: char): void;
              addLineNumber(startPc: char, lineNumber: char): void;
              _addLocalVar(v: javac.code.Symbol$VarSymbol): void;
              _adjustAliveRanges(oldCP: int, delta: int): void;
              align(incr: int): void;
              _appendArray(source: int[], append: int[]): int[];
              branch(opcode: int): Code$Chain;
              checkLimits(pos: javac.util.JCDiagnostic$DiagnosticPosition, log: javac.util.Log): boolean;
              compressCatchTable(): void;
              curCP(): int;
              _emit1(od: int): void;
              _emit2(od: int): void;
              emit4(od: int): void;
              emitAnewarray(od: int, arrayType: javac.code.Type): void;
              _emitCLDCStackMap(pc: int, localsSize: int): void;
              emitInvokedynamic(dynMember: javac.code.Symbol$DynamicMethodSymbol, mtype: javac.code.Type): void;
              emitInvokeinterface(member: javac.code.Symbol, mtype: javac.code.Type): void;
              emitInvokespecial(member: javac.code.Symbol, mtype: javac.code.Type): void;
              emitInvokestatic(member: javac.code.Symbol, mtype: javac.code.Type): void;
              emitInvokevirtual(member: javac.code.Symbol, mtype: javac.code.Type): void;
              emitJump(opcode: int): int;
              emitLdc(constant: PoolConstant$LoadableConstant): void;
              emitMultianewarray(ndims: int, type: int, arrayType: javac.code.Type): void;
              emitNewarray(elemcode: int, arrayType: javac.code.Type): void;
              emitStackMap(): void;
              _emitStackMapFrame(pc: int, localsSize: int): void;
              _emitop(op: int): void;
              emitop0(op: int): void;
              emitop1(op: int, od: int): void;
              emitop1(op: int, od: int, data: PoolConstant): void;
              emitop1w(op: int, od: int): void;
              emitop1w(op: int, od1: int, od2: int): void;
              emitop2<P>(op: int, constant: P, poolFunc: java.util.function.ToIntBiFunction<PoolWriter,P>): void;
              emitop2(op: int, od: int): void;
              emitop2(op: int, od: int, data: PoolConstant): void;
              emitop4(op: int, od: int): void;
              _endScope(adr: int): void;
              endScopes(first: int): void;
              entryPoint(): int;
              entryPoint(state: Code$State): int;
              entryPoint(state: Code$State, pushed: javac.code.Type): int;
              fillExceptionParameterPositions(): void;
              _fillLocalVarPosition(lv: Code$LocalVar): void;
              _findExceptionIndex(p: javac.code.TypeAnnotationPosition): int;
              _get1(pc: int): int;
              _get2(pc: int): int;
              get4(pc: int): int;
              _getInitialFrame(): Code$StackMapFrame;
              getLVTSize(): int;
              _getLocalsSize(): int;
              isAlive(): boolean;
              isStatementStart(): boolean;
              markDead(): void;
              markStatBegin(): void;
              _newLocal(typecode: int): int;
              _newLocal(type: javac.code.Type): int;
              newLocal(v: javac.code.Symbol$VarSymbol): int;
              newRegSegment(): void;
              _postop(): void;
              _put1(pc: int, op: int): void;
              _put2(pc: int, od: int): void;
              put4(pc: int, od: int): void;
              _putVar(_var: Code$LocalVar): void;
              resolve(chain: Code$Chain, target: int): void;
              resolve(chain: Code$Chain): void;
              resolvePending(): void;
              setDefined(newDefined: javac.util.Bits): void;
              setDefined(adr: int): void;
              setLetExprStackPos(pos: int): int;
              setUndefined(adr: int): void;
              statBegin(pos: int): void;
              _alive: boolean;
              _catchInfo: javac.util.ListBuffer<char[]>;
              code: byte[];
              cp: int;
              crt: CRTable;
              readonly debugCode: boolean;
              fatcode: boolean;
              _fixedPc: boolean;
              _frameBeforeLast: Code$StackMapFrame;
              _lastFrame: Code$StackMapFrame;
              _lastStackMapPC: int;
              _letExprStackPos: int;
              _lineDebugInfo: boolean;
              _lineInfo: javac.util.List<char[]>;
              _lineMap: javac.util.Position$LineMap;
              _lvar: Code$LocalVar[];
              max_locals: int;
              max_stack: int;
              _meth: javac.code.Symbol$MethodSymbol;
              readonly needStackMap: boolean;
              nextreg: int;
              _pendingJumps: Code$Chain;
              _pendingStackMap: boolean;
              _pendingStatPos: int;
              _poolWriter: PoolWriter;
              _stackMap: Code$StackMapFormat;
              _stackMapBuffer: Code$StackMapFrame[];
              _stackMapBufferSize: int;
              _stackMapTableBuffer: ClassWriter$StackMapTableFrame[];
              _state: Code$State;
              _syms: javac.code.Symtab;
              _types: javac.code.Types;
              _varBuffer: Code$LocalVar[];
              _varBufferSize: int;
              _varDebugInfo: boolean;
            }
            interface Code extends CombineTypes<[_Code, java.lang.Object]> {}
            interface _Code$Chain$$static extends ClassLike {
              new(pc: int, next: Code$Chain, state: Code$State): Code$Chain;
            }
            let Code$Chain: _Code$Chain$$static;
            interface _Code$Chain {
              readonly next: Code$Chain;
              readonly pc: int;
              _state: Code$State;
            }
            interface Code$Chain extends CombineTypes<[_Code$Chain, java.lang.Object]> {}
            interface _Code$LocalVar$$static extends ClassLike {
              _new(v: javac.code.Symbol$VarSymbol): Code$LocalVar;
            }
            let Code$LocalVar: _Code$LocalVar$$static;
            interface _Code$LocalVar {
              closeRange(length: char): void;
              dup(): Code$LocalVar;
              _firstRange(): Code$LocalVar$Range;
              getWidestRange(): Code$LocalVar$Range;
              hasOpenRange(): boolean;
              isLastRangeInitialized(): boolean;
              _lastRange(): Code$LocalVar$Range;
              openRange(start: char): void;
              _removeLastRange(): void;
              toString(): string;
              _aliveRanges: java.util.List<Code$LocalVar$Range>;
              _reg: char;
              _sym: javac.code.Symbol$VarSymbol;
            }
            interface Code$LocalVar extends CombineTypes<[_Code$LocalVar, java.lang.Object]> {}
            interface _Code$LocalVar$Range$$static extends ClassLike {
              _new(this$0: Code$LocalVar): Code$LocalVar$Range;
              _new(this$0: Code$LocalVar, start: char): Code$LocalVar$Range;
              _new(this$0: Code$LocalVar, start: char, length: char): Code$LocalVar$Range;
            }
            let Code$LocalVar$Range: _Code$LocalVar$Range$$static;
            interface _Code$LocalVar$Range {
              _closed(): boolean;
              toString(): string;
              _length: char;
              _start_pc: char;
            }
            interface Code$LocalVar$Range extends CombineTypes<[_Code$LocalVar$Range, java.lang.Object]> {}
            interface _Code$Mneumonics$$static extends ClassLike {
              _mnem: string[];
            }
            let Code$Mneumonics: _Code$Mneumonics$$static;
            interface _Code$Mneumonics {
            }
            interface Code$Mneumonics extends CombineTypes<[_Code$Mneumonics, java.lang.Object]> {}
            interface _Code$StackMapFormat$$static extends ClassLike {
              valueOf(name: string): Code$StackMapFormat;
              values(): Code$StackMapFormat[];
              readonly CLDC: Code$StackMapFormat;
              readonly JSR202: Code$StackMapFormat;
              readonly NONE: Code$StackMapFormat;
            }
            let Code$StackMapFormat: _Code$StackMapFormat$$static;
            interface _Code$StackMapFormat {
              _getAttributeName(names: javac.util.Names): javac.util.Name;
            }
            interface Code$StackMapFormat extends CombineTypes<[_Code$StackMapFormat]> {}
            interface _Code$StackMapFrame$$static extends ClassLike {
              _new(): Code$StackMapFrame;
            }
            let Code$StackMapFrame: _Code$StackMapFrame$$static;
            interface _Code$StackMapFrame {
              _locals: javac.code.Type[];
              _pc: int;
              _stack: javac.code.Type[];
            }
            interface Code$StackMapFrame extends CombineTypes<[_Code$StackMapFrame, java.lang.Object]> {}
            interface _Code$State$$static extends ClassLike {
              _new(this$0: Code): Code$State;
            }
            let Code$State: _Code$State$$static;
            interface _Code$State {
              _dump(): void;
              _dump(pc: int): void;
              _dup(): Code$State;
              _error(): javac.code.Type;
              _forceStackTop(t: javac.code.Type): void;
              _join(other: Code$State): Code$State;
              _lock(register: int): void;
              _markInitialized(old: UninitializedType): void;
              _peek(): javac.code.Type;
              _pop(n: int): void;
              _pop(t: javac.code.Type): void;
              _pop1(): javac.code.Type;
              _pop2(): javac.code.Type;
              _push(t: javac.code.Type): void;
              _unlock(register: int): void;
              _defined: javac.util.Bits;
              _locks: int[];
              _nlocks: int;
              _stack: javac.code.Type[];
              _stacksize: int;
              _this$0: Code;
            }
            interface Code$State extends CombineTypes<[_Code$State, java.lang.Cloneable, java.lang.Object]> {}
            interface _Gen$$static extends ClassLike {
              instance(context: javac.util.Context): Gen;
              one(tc: int): int;
              _qsort2(keys: int[], values: int[], lo: int, hi: int): void;
              zero(tc: int): int;
              _genKey: javac.util.Context$Key<Gen>;
              _new(context: javac.util.Context): Gen;
            }
            let Gen: _Gen$$static;
            interface _Gen {
              _binaryQualifier(sym: javac.code.Symbol, site: javac.code.Type): javac.code.Symbol;
              _callMethod(pos: javac.util.JCDiagnostic$DiagnosticPosition, site: javac.code.Type, name: javac.util.Name, argtypes: javac.util.List<javac.code.Type>, isStatic: boolean): void;
              _catchTypesWithAnnotations(tree: javac.tree.JCTree$JCCatch): javac.util.List<javac.util.Pair<javac.util.List<javac.code.Attribute$TypeCompound>,javac.tree.JCTree$JCExpression>>;
              _catchTypesWithAnnotationsFromMulticatch(tree: javac.tree.JCTree$JCTypeUnion, first: javac.util.List<javac.code.Attribute$TypeCompound>): javac.util.List<javac.util.Pair<javac.util.List<javac.code.Attribute$TypeCompound>,javac.tree.JCTree$JCExpression>>;
              _checkDimension(pos: javac.util.JCDiagnostic$DiagnosticPosition, t: javac.code.Type): javac.code.Type;
              _checkDimensionInternal(pos: javac.util.JCDiagnostic$DiagnosticPosition, t: javac.code.Type): void;
              _checkStringConstant(pos: javac.util.JCDiagnostic$DiagnosticPosition, constValue: any): void;
              _completeBinop(lhs: javac.tree.JCTree, rhs: javac.tree.JCTree, operator: javac.code.Symbol$OperatorSymbol): Items$Item;
              _doHandleSwitchExpression(tree: javac.tree.JCTree$JCSwitchExpression): void;
              _doVisitBlock(tree: javac.tree.JCTree$JCBlock): void;
              _emitMinusOne(tc: int): void;
              _endFinalizerGap(env: javac.comp.Env<Gen$GenContext>): void;
              _endFinalizerGaps(from: javac.comp.Env<Gen$GenContext>, to: javac.comp.Env<Gen$GenContext>): void;
              genArgs(trees: javac.util.List<javac.tree.JCTree$JCExpression>, pts: javac.util.List<javac.code.Type>): void;
              _genCatch(tree: javac.tree.JCTree$JCCatch, env: javac.comp.Env<Gen$GenContext>, startpc: int, endpc: int, gaps: javac.util.List<int>): void;
              _genCatchBlock(tree: javac.tree.JCTree$JCCatch, env: javac.comp.Env<Gen$GenContext>): void;
              genClass(env: javac.comp.Env<javac.comp.AttrContext>, cdef: javac.tree.JCTree$JCClassDecl): boolean;
              genCond(tree: javac.tree.JCTree, crtFlags: int): Items$CondItem;
              genCond(_tree: javac.tree.JCTree, markBranches: boolean): Items$CondItem;
              genDef(tree: javac.tree.JCTree, env: javac.comp.Env<Gen$GenContext>): void;
              genExpr(tree: javac.tree.JCTree, pt: javac.code.Type): Items$Item;
              _genFinalizer(env: javac.comp.Env<Gen$GenContext>): void;
              _genLoop(loop: javac.tree.JCTree$JCStatement, body: javac.tree.JCTree$JCStatement, cond: javac.tree.JCTree$JCExpression, step: javac.util.List<javac.tree.JCTree$JCExpressionStatement>, testFirst: boolean): void;
              _genMethod(tree: javac.tree.JCTree$JCMethodDecl, env: javac.comp.Env<Gen$GenContext>, fatcode: boolean): void;
              _genNullCheck(tree: javac.tree.JCTree): void;
              _genPatternMatchingCatch(tree: javac.tree.JCTree$JCCatch, env: javac.comp.Env<Gen$GenContext>, ranges: javac.util.List<int[]>): void;
              genStat(tree: javac.tree.JCTree, env: javac.comp.Env<Gen$GenContext>, crtFlags: int): void;
              genStat(tree: javac.tree.JCTree, env: javac.comp.Env<Gen$GenContext>): void;
              genStats(trees: javac.util.List<javac.tree.JCTree$JCStatement>, env: javac.comp.Env<Gen$GenContext>, crtFlags: int): void;
              genStats(trees: javac.util.List<javac.tree.JCTree>, env: javac.comp.Env<Gen$GenContext>): void;
              _genTry(body: javac.tree.JCTree, catchers: javac.util.List<javac.tree.JCTree$JCCatch>, env: javac.comp.Env<Gen$GenContext>): void;
              _generateReferencesToPrunedTree(classSymbol: javac.code.Symbol$ClassSymbol): void;
              _getAndRemoveNonFieldTAs(sym: javac.code.Symbol$VarSymbol): javac.util.List<javac.code.Attribute$TypeCompound>;
              getAttrEnv(): javac.comp.Env<javac.comp.AttrContext>;
              getCode(): Code;
              getItems(): Items;
              _handleSwitch(swtch: javac.tree.JCTree, selector: javac.tree.JCTree$JCExpression, cases: javac.util.List<javac.tree.JCTree$JCCase>, patternSwitch: boolean): void;
              _hasFinally(target: javac.tree.JCTree, env: javac.comp.Env<Gen$GenContext>): boolean;
              _hasTry(tree: javac.tree.JCTree$JCSwitchExpression): boolean;
              _initCode(tree: javac.tree.JCTree$JCMethodDecl, env: javac.comp.Env<Gen$GenContext>, fatcode: boolean): int;
              _isAccessSuper(enclMethod: javac.tree.JCTree$JCMethodDecl): boolean;
              isConstantDynamic(sym: javac.code.Symbol): boolean;
              isInvokeDynamic(sym: javac.code.Symbol): boolean;
              _isOddAccessName(name: javac.util.Name): boolean;
              _loadIntConst(n: int): void;
              _makeNewArray(pos: javac.util.JCDiagnostic$DiagnosticPosition, type: javac.code.Type, ndims: int): Items$Item;
              _makeRef(pos: javac.util.JCDiagnostic$DiagnosticPosition, type: javac.code.Type): int;
              _makeTemp(type: javac.code.Type): Items$LocalItem;
              _nonVirtualForPrivateAccess(sym: javac.code.Symbol): boolean;
              _normalizeDefs(defs: javac.util.List<javac.tree.JCTree>, c: javac.code.Symbol$ClassSymbol): javac.util.List<javac.tree.JCTree>;
              _normalizeMethod(md: javac.tree.JCTree$JCMethodDecl, initCode: javac.util.List<javac.tree.JCTree$JCStatement>, initTAs: javac.util.List<javac.code.Attribute$TypeCompound>): void;
              _registerCatch(pos: javac.util.JCDiagnostic$DiagnosticPosition, startpc: int, endpc: int, handler_pc: int, catch_type: int): void;
              _reloadStackBeforeSwitchExpr(): void;
              _setTypeAnnotationPositions(treePos: int): void;
              _unwind(target: javac.tree.JCTree, env: javac.comp.Env<Gen$GenContext>): javac.comp.Env<Gen$GenContext>;
              _unwindBreak(target: javac.tree.JCTree): javac.comp.Env<Gen$GenContext>;
              visitApply(tree: javac.tree.JCTree$JCMethodInvocation): void;
              visitAssign(tree: javac.tree.JCTree$JCAssign): void;
              visitAssignop(tree: javac.tree.JCTree$JCAssignOp): void;
              visitBinary(tree: javac.tree.JCTree$JCBinary): void;
              visitBlock(tree: javac.tree.JCTree$JCBlock): void;
              visitBreak(tree: javac.tree.JCTree$JCBreak): void;
              visitConditional(tree: javac.tree.JCTree$JCConditional): void;
              visitContinue(tree: javac.tree.JCTree$JCContinue): void;
              visitDoLoop(tree: javac.tree.JCTree$JCDoWhileLoop): void;
              visitExec(tree: javac.tree.JCTree$JCExpressionStatement): void;
              visitForLoop(tree: javac.tree.JCTree$JCForLoop): void;
              visitForeachLoop(tree: javac.tree.JCTree$JCEnhancedForLoop): void;
              visitIdent(tree: javac.tree.JCTree$JCIdent): void;
              visitIf(tree: javac.tree.JCTree$JCIf): void;
              visitIndexed(tree: javac.tree.JCTree$JCArrayAccess): void;
              visitLabelled(tree: javac.tree.JCTree$JCLabeledStatement): void;
              visitLetExpr(tree: javac.tree.JCTree$LetExpr): void;
              visitLiteral(tree: javac.tree.JCTree$JCLiteral): void;
              visitMethodDef(tree: javac.tree.JCTree$JCMethodDecl): void;
              visitNewArray(tree: javac.tree.JCTree$JCNewArray): void;
              visitNewClass(tree: javac.tree.JCTree$JCNewClass): void;
              visitParens(tree: javac.tree.JCTree$JCParens): void;
              visitReturn(tree: javac.tree.JCTree$JCReturn): void;
              visitSelect(tree: javac.tree.JCTree$JCFieldAccess): void;
              visitSkip(tree: javac.tree.JCTree$JCSkip): void;
              visitSwitch(tree: javac.tree.JCTree$JCSwitch): void;
              visitSwitchExpression(tree: javac.tree.JCTree$JCSwitchExpression): void;
              visitSynchronized(tree: javac.tree.JCTree$JCSynchronized): void;
              visitThrow(tree: javac.tree.JCTree$JCThrow): void;
              visitTry(tree: javac.tree.JCTree$JCTry): void;
              visitTypeCast(tree: javac.tree.JCTree$JCTypeCast): void;
              visitTypeTest(tree: javac.tree.JCTree$JCInstanceOf): void;
              visitUnary(tree: javac.tree.JCTree$JCUnary): void;
              visitVarDef(tree: javac.tree.JCTree$JCVariableDecl): void;
              visitWhileLoop(tree: javac.tree.JCTree$JCWhileLoop): void;
              visitWildcard(tree: javac.tree.JCTree$JCWildcard): void;
              visitYield(tree: javac.tree.JCTree$JCYield): void;
              _accessDollar: javac.util.Name;
              _annotate: javac.comp.Annotate;
              _attrEnv: javac.comp.Env<javac.comp.AttrContext>;
              _chk: javac.comp.Check;
              _classReferenceVisitor: Gen$ClassReferenceVisitor;
              _code: Code;
              _concat: StringConcat;
              _debugCode: boolean;
              _disableVirtualizedPrivateInvoke: boolean;
              _endPosTable: javac.tree.EndPosTable;
              _env: javac.comp.Env<Gen$GenContext>;
              _genCrt: boolean;
              _inCondSwitchExpression: boolean;
              _invocationsWithPatternMatchingCatch: java.util.Set<javac.tree.JCTree$JCMethodInvocation>;
              _items: Items;
              _lineDebugInfo: boolean;
              _log: javac.util.Log;
              _lower: javac.comp.Lower;
              _make: javac.tree.TreeMaker;
              _methodType: javac.code.Type;
              _names: javac.util.Names;
              _nerrs: int;
              _patternMatchingInvocationRanges: javac.util.ListBuffer<int[]>;
              _poolWriter: PoolWriter;
              _pt: javac.code.Type;
              _qualifiedSymbolCache: java.util.Map<javac.code.Type,javac.code.Symbol>;
              _result: Items$Item;
              _rs: javac.comp.Resolve;
              _stackBeforeSwitchExpression: javac.util.List<Items$LocalItem>;
              _stackMap: Code$StackMapFormat;
              _switchExpressionFalseChain: Code$Chain;
              _switchExpressionTrueChain: Code$Chain;
              _switchResult: Items$LocalItem;
              _syms: javac.code.Symtab;
              _target: Target;
              _toplevel: javac.tree.JCTree$JCCompilationUnit;
              _types: javac.code.Types;
              _varDebugInfo: boolean;
            }
            interface Gen extends CombineTypes<[_Gen, com.sun.tools.javac.tree.JCTree$Visitor]> {}
            interface _Gen$ClassReferenceVisitor$$static extends ClassLike {
              _new(this$0: Gen): Gen$ClassReferenceVisitor;
            }
            let Gen$ClassReferenceVisitor: _Gen$ClassReferenceVisitor$$static;
            interface _Gen$ClassReferenceVisitor {
              visitBinary(tree: javac.tree.JCTree$JCBinary): void;
              visitConditional(tree: javac.tree.JCTree$JCConditional): void;
              visitIdent(tree: javac.tree.JCTree$JCIdent): void;
              visitParens(tree: javac.tree.JCTree$JCParens): void;
              visitSelect(tree: javac.tree.JCTree$JCFieldAccess): void;
              visitTree(tree: javac.tree.JCTree): void;
              visitTypeCast(tree: javac.tree.JCTree$JCTypeCast): void;
              visitUnary(tree: javac.tree.JCTree$JCUnary): void;
              _this$0: Gen;
            }
            interface Gen$ClassReferenceVisitor extends CombineTypes<[_Gen$ClassReferenceVisitor, com.sun.tools.javac.tree.JCTree$Visitor]> {}
            interface _Gen$CodeSizeOverflow$$static extends ClassLike {
              _serialVersionUID: long;
              new(): Gen$CodeSizeOverflow;
            }
            let Gen$CodeSizeOverflow: _Gen$CodeSizeOverflow$$static;
            interface _Gen$CodeSizeOverflow {
            }
            interface Gen$CodeSizeOverflow extends CombineTypes<[_Gen$CodeSizeOverflow, java.lang.RuntimeException]> {}
            interface _Gen$GenContext$$static extends ClassLike {
              _new(): Gen$GenContext;
            }
            let Gen$GenContext: _Gen$GenContext$$static;
            interface _Gen$GenContext {
              _addCont(c: Code$Chain): void;
              _addExit(c: Code$Chain): void;
              _cont: Code$Chain;
              _exit: Code$Chain;
              _finalize: Gen$GenFinalizer;
              _gaps: javac.util.ListBuffer<int>;
              _isSwitch: boolean;
            }
            interface Gen$GenContext extends CombineTypes<[_Gen$GenContext, java.lang.Object]> {}
            interface _Gen$GenFinalizer$$static extends ClassLike {
              _new(this$0: Gen): Gen$GenFinalizer;
            }
            let Gen$GenFinalizer: _Gen$GenFinalizer$$static;
            interface _Gen$GenFinalizer {
              _afterBody(): void;
              _gen(): void;
              _genLast(): void;
              _hasFinalizer(): boolean;
            }
            interface Gen$GenFinalizer extends CombineTypes<[_Gen$GenFinalizer, java.lang.Object]> {}
            interface _Items$$static extends ClassLike {
              new(poolWriter: PoolWriter, code: Code, syms: javac.code.Symtab, types: javac.code.Types): Items;
            }
            let Items: _Items$$static;
            interface _Items {
              _makeAssignItem(lhs: Items$Item): Items$Item;
              _makeCondItem(opcode: int, trueJumps: Code$Chain, falseJumps: Code$Chain): Items$CondItem;
              _makeCondItem(opcode: int): Items$CondItem;
              _makeDynamicItem(member: javac.code.Symbol): Items$Item;
              _makeImmediateItem(type: javac.code.Type, value: any): Items$Item;
              _makeIndexedItem(type: javac.code.Type): Items$Item;
              _makeLocalItem(v: javac.code.Symbol$VarSymbol): Items$LocalItem;
              _makeLocalItem(type: javac.code.Type, reg: int): Items$LocalItem;
              _makeMemberItem(member: javac.code.Symbol, nonvirtual: boolean): Items$Item;
              _makeStackItem(type: javac.code.Type): Items$Item;
              _makeStaticItem(member: javac.code.Symbol): Items$Item;
              _makeSuperItem(): Items$Item;
              _makeThisItem(): Items$Item;
              _makeVoidItem(): Items$Item;
              _code: Code;
              _poolWriter: PoolWriter;
              _stackItem: Items$Item[];
              _superItem: Items$Item;
              _syms: javac.code.Symtab;
              _thisItem: Items$Item;
              _types: javac.code.Types;
              _voidItem: Items$Item;
            }
            interface Items extends CombineTypes<[_Items, java.lang.Object]> {}
            interface _Items$AssignItem$$static extends ClassLike {
              _new(this$0: Items, lhs: Items$Item): Items$AssignItem;
            }
            let Items$AssignItem: _Items$AssignItem$$static;
            interface _Items$AssignItem {
              _drop(): void;
              _duplicate(): void;
              _load(): Items$Item;
              _stash(toscode: int): void;
              toString(): string;
              _width(): int;
              _lhs: Items$Item;
              _this$0: Items;
            }
            interface Items$AssignItem extends CombineTypes<[_Items$AssignItem, com.sun.tools.javac.jvm.Items$Item]> {}
            interface _Items$CondItem$$static extends ClassLike {
              _new(this$0: Items, opcode: int, truejumps: Code$Chain, falsejumps: Code$Chain): Items$CondItem;
            }
            let Items$CondItem: _Items$CondItem$$static;
            interface _Items$CondItem {
              _drop(): void;
              _duplicate(): void;
              _isFalse(): boolean;
              _isTrue(): boolean;
              _jumpFalse(): Code$Chain;
              _jumpTrue(): Code$Chain;
              _load(): Items$Item;
              _mkCond(): Items$CondItem;
              _negate(): Items$CondItem;
              _stash(toscode: int): void;
              toString(): string;
              _width(): int;
              _falseJumps: Code$Chain;
              _opcode: int;
              _this$0: Items;
              _tree: javac.tree.JCTree;
              _trueJumps: Code$Chain;
            }
            interface Items$CondItem extends CombineTypes<[_Items$CondItem, com.sun.tools.javac.jvm.Items$Item]> {}
            interface _Items$DynamicItem$$static extends ClassLike {
              _new(this$0: Items, member: javac.code.Symbol): Items$DynamicItem;
            }
            let Items$DynamicItem: _Items$DynamicItem$$static;
            interface _Items$DynamicItem {
              _invoke(): Items$Item;
              _load(): Items$Item;
              _store(): void;
              toString(): string;
              _this$0: Items;
            }
            interface Items$DynamicItem extends CombineTypes<[_Items$DynamicItem, com.sun.tools.javac.jvm.Items$StaticItem]> {}
            interface _Items$ImmediateItem$$static extends ClassLike {
              _new(this$0: Items, type: javac.code.Type, value: any): Items$ImmediateItem;
            }
            let Items$ImmediateItem: _Items$ImmediateItem$$static;
            interface _Items$ImmediateItem {
              _coerce(targetcode: int): Items$Item;
              _isPosZero(x: float): boolean;
              _isPosZero(x: double): boolean;
              _ldc(): void;
              _load(): Items$Item;
              _mkCond(): Items$CondItem;
              _numericValue(): number;
              toString(): string;
              _this$0: Items;
              _value: PoolConstant$LoadableConstant;
            }
            interface Items$ImmediateItem extends CombineTypes<[_Items$ImmediateItem, com.sun.tools.javac.jvm.Items$Item]> {}
            interface _Items$IndexedItem$$static extends ClassLike {
              _new(this$0: Items, type: javac.code.Type): Items$IndexedItem;
            }
            let Items$IndexedItem: _Items$IndexedItem$$static;
            interface _Items$IndexedItem {
              _drop(): void;
              _duplicate(): void;
              _load(): Items$Item;
              _stash(toscode: int): void;
              _store(): void;
              toString(): string;
              _width(): int;
              _this$0: Items;
            }
            interface Items$IndexedItem extends CombineTypes<[_Items$IndexedItem, com.sun.tools.javac.jvm.Items$Item]> {}
            interface _Items$Item$$static extends ClassLike {
              _new(this$0: Items, typecode: int): Items$Item;
            }
            let Items$Item: _Items$Item$$static;
            interface _Items$Item {
              _coerce(targetcode: int): Items$Item;
              _coerce(targettype: javac.code.Type): Items$Item;
              _drop(): void;
              _duplicate(): void;
              _invoke(): Items$Item;
              _load(): Items$Item;
              _mkCond(): Items$CondItem;
              _stash(toscode: int): void;
              _store(): void;
              toString(): string;
(): string;
              _width(): int;
              _this$0: Items;
              _typecode: int;
            }
            interface Items$Item extends CombineTypes<[_Items$Item, java.lang.Object]> {}
            interface _Items$LocalItem$$static extends ClassLike {
              _new(this$0: Items, type: javac.code.Type, reg: int): Items$LocalItem;
            }
            let Items$LocalItem: _Items$LocalItem$$static;
            interface _Items$LocalItem {
              _incr(x: int): void;
              _load(): Items$Item;
              _store(): void;
              toString(): string;
              _reg: int;
              _this$0: Items;
              _type: javac.code.Type;
            }
            interface Items$LocalItem extends CombineTypes<[_Items$LocalItem, com.sun.tools.javac.jvm.Items$Item]> {}
            interface _Items$MemberItem$$static extends ClassLike {
              _new(this$0: Items, member: javac.code.Symbol, nonvirtual: boolean): Items$MemberItem;
            }
            let Items$MemberItem: _Items$MemberItem$$static;
            interface _Items$MemberItem {
              _drop(): void;
              _duplicate(): void;
              _invoke(): Items$Item;
              _load(): Items$Item;
              _stash(toscode: int): void;
              _store(): void;
              toString(): string;
              _width(): int;
              _member: javac.code.Symbol;
              _nonvirtual: boolean;
              _this$0: Items;
            }
            interface Items$MemberItem extends CombineTypes<[_Items$MemberItem, com.sun.tools.javac.jvm.Items$Item]> {}
            interface _Items$SelfItem$$static extends ClassLike {
              _new(this$0: Items, isSuper: boolean): Items$SelfItem;
            }
            let Items$SelfItem: _Items$SelfItem$$static;
            interface _Items$SelfItem {
              _load(): Items$Item;
              toString(): string;
              _isSuper: boolean;
              _this$0: Items;
            }
            interface Items$SelfItem extends CombineTypes<[_Items$SelfItem, com.sun.tools.javac.jvm.Items$Item]> {}
            interface _Items$StackItem$$static extends ClassLike {
              _new(this$0: Items, typecode: int): Items$StackItem;
            }
            let Items$StackItem: _Items$StackItem$$static;
            interface _Items$StackItem {
              _drop(): void;
              _duplicate(): void;
              _load(): Items$Item;
              _stash(toscode: int): void;
              toString(): string;
              _width(): int;
              _this$0: Items;
            }
            interface Items$StackItem extends CombineTypes<[_Items$StackItem, com.sun.tools.javac.jvm.Items$Item]> {}
            interface _Items$StaticItem$$static extends ClassLike {
              _new(this$0: Items, member: javac.code.Symbol): Items$StaticItem;
            }
            let Items$StaticItem: _Items$StaticItem$$static;
            interface _Items$StaticItem {
              _invoke(): Items$Item;
              _load(): Items$Item;
              _store(): void;
              toString(): string;
              _member: javac.code.Symbol;
              _this$0: Items;
            }
            interface Items$StaticItem extends CombineTypes<[_Items$StaticItem, com.sun.tools.javac.jvm.Items$Item]> {}
            interface _JNIWriter$$static extends ClassLike {
              _encode(name: JNIWriter$charSequence, mtype: JNIWriter$EncoderType): string;
              _encodeChar(ch: char): string;
              _hasFlag(m: javac.code.Symbol, flag: int): boolean;
              instance(context: javac.util.Context): JNIWriter;
              _isFinal(s: javac.code.Symbol): boolean;
              _isNative(s: javac.code.Symbol): boolean;
              _isStatic(s: javac.code.Symbol): boolean;
              _isSynthetic(s: javac.code.Symbol): boolean;
              _isalnum(ch: char): boolean;
              _isprint(ch: char): boolean;
              _printStaticDefines(out: java.io.PrintWriter, p: javac.util.Pair<javac.code.Symbol$ClassSymbol,javac.code.Symbol$VarSymbol>): void;
              _isWindows: boolean;
              _jniWriterKey: javac.util.Context$Key<JNIWriter>;
            }
            let JNIWriter: _JNIWriter$$static;
            interface _JNIWriter {
              _cppGuardBegin(out: java.io.PrintWriter): void;
              _cppGuardEnd(out: java.io.PrintWriter): void;
              _encodeMethod(msym: javac.code.Symbol, clazz: javac.code.Symbol$ClassSymbol, isOverloaded: boolean): string;
              _fileTop(out: java.io.PrintWriter): void;
              _guardBegin(out: java.io.PrintWriter, cname: string): void;
              _guardEnd(out: java.io.PrintWriter): void;
              _includes(out: java.io.PrintWriter): void;
              _jniType(t: javac.code.Type): string;
              _lazyInit(): void;
              needsHeader(c: javac.code.Symbol$ClassSymbol): boolean;
              _needsHeader(c: javac.code.Symbol$ClassSymbol, checkNestedClasses: boolean): boolean;
              write(c: javac.code.Symbol$ClassSymbol): javax.tools.FileObject;
              write(out: java.io.PrintWriter, sym: javac.code.Symbol$ClassSymbol): void;
              _writeMethods(out: java.io.PrintWriter, sym: javac.code.Symbol$ClassSymbol, cname: string): void;
              _writeStatics(out: java.io.PrintWriter, sym: javac.code.Symbol$ClassSymbol): void;
              _checkAll: boolean;
              _context: javac.util.Context;
              _fileManager: javax.tools.JavaFileManager;
              _filesWritten: java.util.HashMap<string,string>;
              _log: javac.util.Log;
              multiModuleMode: boolean;
              _syms: javac.code.Symtab;
              _types: javac.code.Types;
              _verbose: boolean;
            }
            interface JNIWriter extends CombineTypes<[_JNIWriter, java.lang.Object]> {}
            interface _JNIWriter$EncoderType$$static extends ClassLike {
              valueOf(name: string): JNIWriter$EncoderType;
              values(): JNIWriter$EncoderType[];
              readonly CLASS: JNIWriter$EncoderType;
              readonly FIELD: JNIWriter$EncoderType;
              readonly FIELDSTUB: JNIWriter$EncoderType;
              readonly JNI: JNIWriter$EncoderType;
              readonly SIGNATURE: JNIWriter$EncoderType;
            }
            let JNIWriter$EncoderType: _JNIWriter$EncoderType$$static;
            interface _JNIWriter$EncoderType {
            }
            interface JNIWriter$EncoderType extends CombineTypes<[_JNIWriter$EncoderType]> {}
            interface _JNIWriter$SimpleTypeVisitor$$static<R,P> extends ClassLike {
              _new(): JNIWriter$SimpleTypeVisitor<R,P>;
              _new(defaultValue: R): JNIWriter$SimpleTypeVisitor<R,P>;
            }
            let JNIWriter$SimpleTypeVisitor: _JNIWriter$SimpleTypeVisitor$$static<R,P>;
            interface _JNIWriter$SimpleTypeVisitor<R,P> {
              _defaultAction(t: javac.code.Type, p: P): R;
              visitArrayType(t: javac.code.Type$ArrayType, p: P): R;
              visitCapturedType(t: javac.code.Type$CapturedType, p: P): R;
              visitClassType(t: javac.code.Type$ClassType, p: P): R;
              visitErrorType(t: javac.code.Type$ErrorType, p: P): R;
              visitForAll(t: javac.code.Type$ForAll, p: P): R;
              visitMethodType(t: javac.code.Type$MethodType, p: P): R;
              visitModuleType(t: javac.code.Type$ModuleType, p: P): R;
              visitPackageType(t: javac.code.Type$PackageType, p: P): R;
              visitType(t: javac.code.Type, p: P): R;
              visitTypeVar(t: javac.code.Type$TypeVar, p: P): R;
              visitUndetVar(t: javac.code.Type$UndetVar, p: P): R;
              visitWildcardType(t: javac.code.Type$WildcardType, p: P): R;
              _DEFAULT_VALUE: R;
            }
            interface JNIWriter$SimpleTypeVisitor<R,P> extends CombineTypes<[_JNIWriter$SimpleTypeVisitor<R,P>, javac.code.Type$Visitor<R,P>, java.lang.Object]> {}
            interface _JNIWriter$TypeSignature$$static extends ClassLike {
              _SIG_ARRAY: string;
              _SIG_BOOLEAN: string;
              _SIG_BYTE: string;
              _SIG_CHAR: string;
              _SIG_CLASS: string;
              _SIG_DOUBLE: string;
              _SIG_FLOAT: string;
              _SIG_INT: string;
              _SIG_LONG: string;
              _SIG_SHORT: string;
              _SIG_VOID: string;
              new(types: javac.code.Types): JNIWriter$TypeSignature;
            }
            let JNIWriter$TypeSignature: _JNIWriter$TypeSignature$$static;
            interface _JNIWriter$TypeSignature {
              _getJvmSignature(type: javac.code.Type, useFlatname: boolean): JNIWriter$TypeSignature$stringBuilder;
              _getParameterSignature(mType: javac.code.Type, useFlatname: boolean): JNIWriter$TypeSignature$stringBuilder;
              _getReturnSignature(mType: javac.code.Type): JNIWriter$TypeSignature$stringBuilder;
              _getSignature(mType: javac.code.Type): JNIWriter$TypeSignature$stringBuilder;
              _elems: javac.model.JavacElements;
              _types: javac.code.Types;
            }
            interface JNIWriter$TypeSignature extends CombineTypes<[_JNIWriter$TypeSignature, java.lang.Object]> {}
            interface _JNIWriter$TypeSignature$JvmTypeVisitor$$static extends ClassLike {
              _new(useFlatname: boolean): JNIWriter$TypeSignature$JvmTypeVisitor;
            }
            let JNIWriter$TypeSignature$JvmTypeVisitor: _JNIWriter$TypeSignature$JvmTypeVisitor$$static;
            interface _JNIWriter$TypeSignature$JvmTypeVisitor {
              _getJvmPrimitiveSignature(t: javac.code.Type): string;
              _setDeclaredType(t: javac.code.Type, s: JNIWriter$TypeSignature$JvmTypeVisitor$stringBuilder): void;
              visitArrayType(t: javac.code.Type$ArrayType, s: JNIWriter$TypeSignature$JvmTypeVisitor$stringBuilder): javac.code.Type;
              visitArrayType(a0: javac.code.Type$ArrayType, a1: any): any;
              visitClassType(t: javac.code.Type$ClassType, s: JNIWriter$TypeSignature$JvmTypeVisitor$stringBuilder): javac.code.Type;
              visitClassType(a0: javac.code.Type$ClassType, a1: any): any;
              visitType(t: javac.code.Type, s: JNIWriter$TypeSignature$JvmTypeVisitor$stringBuilder): javac.code.Type;
              visitType(a0: javac.code.Type, a1: any): any;
              _useFlatname: boolean;
            }
            interface JNIWriter$TypeSignature$JvmTypeVisitor extends CombineTypes<[_JNIWriter$TypeSignature$JvmTypeVisitor, JNIWriter$SimpleTypeVisitor<javac.code.Type,jvm$stringBuilder>]> {}
            interface _JNIWriter$TypeSignature$SignatureException$$static extends ClassLike {
              _serialVersionUID: long;
              _new(reason: string): JNIWriter$TypeSignature$SignatureException;
            }
            let JNIWriter$TypeSignature$SignatureException: _JNIWriter$TypeSignature$SignatureException$$static;
            interface _JNIWriter$TypeSignature$SignatureException {
            }
            interface JNIWriter$TypeSignature$SignatureException extends CombineTypes<[_JNIWriter$TypeSignature$SignatureException, java.lang.Exception]> {}
            interface _ModuleNameReader$$static extends ClassLike {
              _INITIAL_BUFFER_SIZE: int;
              new(): ModuleNameReader;
            }
            let ModuleNameReader: _ModuleNameReader$$static;
            interface _ModuleNameReader {
              _checkZero(count: int, name: string): void;
              _nextChar(): char;
              _nextInt(): int;
              readModuleName(p: java.nio.file.Path): string;
              readModuleName(jfo: javax.tools.JavaFileObject): string;
              readModuleName(_in: java.io.InputStream): string;
              _utf8Mapper(internalize: boolean): PoolReader$Utf8Mapper<string>;
              _bp: int;
              _buf: javac.util.ByteBuffer;
              _reader: PoolReader;
            }
            interface ModuleNameReader extends CombineTypes<[_ModuleNameReader, java.lang.Object]> {}
            interface _ModuleNameReader$BadClassFile$$static extends ClassLike {
              _serialVersionUID: long;
              _new(msg: string): ModuleNameReader$BadClassFile;
            }
            let ModuleNameReader$BadClassFile: _ModuleNameReader$BadClassFile$$static;
            interface _ModuleNameReader$BadClassFile {
            }
            interface ModuleNameReader$BadClassFile extends CombineTypes<[_ModuleNameReader$BadClassFile, java.lang.Exception]> {}
            interface _PoolConstant$$static extends ClassLike {
            }
            let PoolConstant: _PoolConstant$$static;
            interface _PoolConstant {
              poolKey(types: javac.code.Types): any;
              poolTag(): int;
(): int;
            }
            interface PoolConstant extends CombineTypes<[_PoolConstant, java.lang.Object]> {}
            interface _PoolConstant$Dynamic$$static extends ClassLike {
            }
            let PoolConstant$Dynamic: _PoolConstant$Dynamic$$static;
            interface _PoolConstant$Dynamic {
              bootstrapMethod(): PoolConstant$LoadableConstant;
              bsmKey(types: javac.code.Types): PoolConstant$Dynamic$BsmKey;
              dynamicType(): PoolConstant;
              name(): javac.util.Name;
              poolKey(types: javac.code.Types): any;
              staticArgs(): PoolConstant$LoadableConstant[];
            }
            interface PoolConstant$Dynamic extends CombineTypes<[_PoolConstant$Dynamic, java.lang.Object, com.sun.tools.javac.jvm.PoolConstant]> {}
            interface _PoolConstant$Dynamic$BsmKey$$static extends ClassLike {
            }
            let PoolConstant$Dynamic$BsmKey: _PoolConstant$Dynamic$BsmKey$$static;
            interface _PoolConstant$Dynamic$BsmKey {
              equals(obj: any): boolean;
              hashCode(): int;
              readonly bsm: PoolConstant$LoadableConstant;
              _bsmKey: any;
              _staticArgKeys: javac.util.List<any>;
              readonly staticArgs: PoolConstant$LoadableConstant[];
            }
            interface PoolConstant$Dynamic$BsmKey extends CombineTypes<[_PoolConstant$Dynamic$BsmKey, java.lang.Object]> {}
            interface _PoolConstant$Dynamic$PoolKey$$static extends ClassLike {
              new(name: javac.util.Name, bsmKey: PoolConstant$Dynamic$BsmKey, dynamicType: any): PoolConstant$Dynamic$PoolKey;
            }
            let PoolConstant$Dynamic$PoolKey: _PoolConstant$Dynamic$PoolKey$$static;
            interface _PoolConstant$Dynamic$PoolKey {
              bsmKey(): PoolConstant$Dynamic$BsmKey;
              dynamicType(): any;
              equals(o: any): boolean;
              hashCode(): int;
              name(): javac.util.Name;
              toString(): string;
            }
            interface PoolConstant$Dynamic$PoolKey extends CombineTypes<[_PoolConstant$Dynamic$PoolKey, java.lang.Record]> {}
            interface _PoolConstant$LoadableConstant$$static extends ClassLike {
              Double(d: double): PoolConstant$LoadableConstant;
              Float(f: float): PoolConstant$LoadableConstant;
              Int(i: int): PoolConstant$LoadableConstant;
              Long(l: long): PoolConstant$LoadableConstant;
              String(s: string): PoolConstant$LoadableConstant;
            }
            let PoolConstant$LoadableConstant: _PoolConstant$LoadableConstant$$static;
            interface _PoolConstant$LoadableConstant {
            }
            interface PoolConstant$LoadableConstant extends CombineTypes<[_PoolConstant$LoadableConstant, java.lang.Object, com.sun.tools.javac.jvm.PoolConstant]> {}
            interface _PoolConstant$LoadableConstant$BasicConstant$$static extends ClassLike {
            }
            let PoolConstant$LoadableConstant$BasicConstant: _PoolConstant$LoadableConstant$BasicConstant$$static;
            interface _PoolConstant$LoadableConstant$BasicConstant {
              poolKey(types: javac.code.Types): any;
              poolTag(): int;
              _data: any;
              _tag: int;
            }
            interface PoolConstant$LoadableConstant$BasicConstant extends CombineTypes<[_PoolConstant$LoadableConstant$BasicConstant, java.lang.Object, com.sun.tools.javac.jvm.PoolConstant$LoadableConstant]> {}
            interface _PoolConstant$NameAndType$$static extends ClassLike {
              _new(name: javac.util.Name, type: javac.code.Type): PoolConstant$NameAndType;
            }
            let PoolConstant$NameAndType: _PoolConstant$NameAndType$$static;
            interface _PoolConstant$NameAndType {
              poolKey(types: javac.code.Types): any;
              poolTag(): int;
              _name: javac.util.Name;
              _type: javac.code.Type;
            }
            interface PoolConstant$NameAndType extends CombineTypes<[_PoolConstant$NameAndType, java.lang.Object, com.sun.tools.javac.jvm.PoolConstant]> {}
            interface _PoolReader$$static extends ClassLike {
              _classCP: java.util.BitSet;
              _constantCP: java.util.BitSet;
              _moduleCP: java.util.BitSet;
              _nameAndTypeCP: java.util.BitSet;
              _packageCP: java.util.BitSet;
              _utf8CP: java.util.BitSet;
              _new(buf: javac.util.ByteBuffer): PoolReader;
              _new(reader: ClassReader, names: javac.util.Names, syms: javac.code.Symtab): PoolReader;
              _new(reader: ClassReader, buf: javac.util.ByteBuffer, names: javac.util.Names, syms: javac.code.Symtab): PoolReader;
            }
            let PoolReader: _PoolReader$$static;
            interface _PoolReader {
              _getClass(index: int): javac.code.Symbol$ClassSymbol;
              _getConstant(index: int): any;
              _getModule(index: int): javac.code.Symbol$ModuleSymbol;
              _getName(index: int): javac.util.Name;
              _getNameAndType(index: int): PoolConstant$NameAndType;
              _getPackage(index: int): javac.code.Symbol$PackageSymbol;
              _getType(index: int): javac.code.Type;
              _getUtf8<Z>(index: int, mapper: PoolReader$Utf8Mapper<Z>): Z;
              _hasTag(index: int, tag: int): boolean;
              _peekClassName<Z>(index: int, mapper: PoolReader$Utf8Mapper<Z>): Z;
              _peekItemName<Z>(index: int, mapper: PoolReader$Utf8Mapper<Z>): Z;
              _peekModuleName<Z>(index: int, mapper: PoolReader$Utf8Mapper<Z>): Z;
              _peekName<Z>(index: int, mapper: PoolReader$Utf8Mapper<Z>): Z;
              _peekPackageName<Z>(index: int, mapper: PoolReader$Utf8Mapper<Z>): Z;
              _readPool(poolbuf: javac.util.ByteBuffer, offset: int): int;
              _readPoolInternal(poolbuf: javac.util.ByteBuffer, offset: int): int;
              _resolve(poolbuf: javac.util.ByteBuffer, tag: int, offset: int): any;
              _sizeof(tag: int): int;
              _buf: javac.util.ByteBuffer;
              _names: javac.util.Names;
              _pool: PoolReader$ImmutablePoolHelper;
              _reader: ClassReader;
              _syms: javac.code.Symtab;
              _utf8validation: javac.util.Convert$Validation;
            }
            interface PoolReader extends CombineTypes<[_PoolReader, java.lang.Object]> {}
            interface _PoolReader$ImmutablePoolHelper$$static extends ClassLike {
              new(this$0: PoolReader, poolbuf: javac.util.ByteBuffer, offsets: int[]): PoolReader$ImmutablePoolHelper;
            }
            let PoolReader$ImmutablePoolHelper: _PoolReader$ImmutablePoolHelper$$static;
            interface _PoolReader$ImmutablePoolHelper {
              _checkIndex(index: int): int;
              _offset(index: int): int;
              _readIfNeeded<P>(index: int, expectedTags: java.util.BitSet): P;
              _tag(index: int): int;
              _offsets: int[];
              _poolbuf: javac.util.ByteBuffer;
              _this$0: PoolReader;
              _values: any[];
            }
            interface PoolReader$ImmutablePoolHelper extends CombineTypes<[_PoolReader$ImmutablePoolHelper, java.lang.Object]> {}
            interface _PoolReader$Utf8Mapper$$static<X> extends ClassLike {
            }
            let PoolReader$Utf8Mapper: _PoolReader$Utf8Mapper$$static<X>;
            interface _PoolReader$Utf8Mapper<X> {
              map(a0: byte[], a1: int, a2: int): X;
(a0: byte[], a1: int, a2: int): X;
            }
            interface PoolReader$Utf8Mapper<X> extends CombineTypes<[_PoolReader$Utf8Mapper<X>, java.lang.Object]> {}
            interface _PoolWriter$$static extends ClassLike {
              readonly MAX_ENTRIES: int;
              readonly MAX_STRING_LENGTH: int;
              _POOL_BUF_SIZE: int;
              new(types: javac.code.Types, names: javac.util.Names): PoolWriter;
            }
            let PoolWriter: _PoolWriter$$static;
            interface _PoolWriter {
              _classSig(t: javac.code.Type): javac.util.Name;
              _descriptorType(s: javac.code.Symbol): javac.code.Type;
              _enterInner(c: javac.code.Symbol$ClassSymbol): void;
              _makeBootstrapEntry(dynamic: PoolConstant$Dynamic): int;
              _putClass(csym: javac.code.Symbol$ClassSymbol): int;
              _putClass(t: javac.code.Type): int;
              _putConstant(o: any): int;
              _putConstant(c: PoolConstant$LoadableConstant): int;
              _putDescriptor(t: javac.code.Type): int;
              _putDescriptor(s: javac.code.Symbol): int;
              _putDynamic(d: PoolConstant$Dynamic): int;
              _putMember(s: javac.code.Symbol): int;
              _putModule(mod: javac.code.Symbol$ModuleSymbol): int;
              _putName(name: javac.util.Name): int;
              _putNameAndType(s: javac.code.Symbol): int;
              _putPackage(pkg: javac.code.Symbol$PackageSymbol): int;
              _putSignature(s: javac.code.Symbol): int;
              _reset(): void;
              _size(): int;
              _typeSig(type: javac.code.Type): javac.util.Name;
              _writePool(out: java.io.OutputStream): void;
              _bootstrapMethods: java.util.Map<PoolConstant$Dynamic$BsmKey,int>;
              _innerClasses: java.util.LinkedHashSet<javac.code.Symbol$ClassSymbol>;
              _names: javac.util.Names;
              _pool: PoolWriter$WriteablePoolHelper;
              _signatureGen: PoolWriter$SharedSignatureGenerator;
              _types: javac.code.Types;
            }
            interface PoolWriter extends CombineTypes<[_PoolWriter, java.lang.Object]> {}
            interface _PoolWriter$SharedSignatureGenerator$$static extends ClassLike {
              _new(this$0: PoolWriter, types: javac.code.Types): PoolWriter$SharedSignatureGenerator;
            }
            let PoolWriter$SharedSignatureGenerator: _PoolWriter$SharedSignatureGenerator$$static;
            interface _PoolWriter$SharedSignatureGenerator {
              _append(ch: char): void;
              _append(ba: byte[]): void;
              _append(name: javac.util.Name): void;
              assembleSig(type: javac.code.Type): void;
              _classReference(c: javac.code.Symbol$ClassSymbol): void;
              _reset(): void;
              _toName(): javac.util.Name;
              _sigbuf: javac.util.ByteBuffer;
              _this$0: PoolWriter;
            }
            interface PoolWriter$SharedSignatureGenerator extends CombineTypes<[_PoolWriter$SharedSignatureGenerator, com.sun.tools.javac.code.Types$SignatureGenerator]> {}
            interface _PoolWriter$WriteablePoolHelper$$static extends ClassLike {
              _new(this$0: PoolWriter): PoolWriter$WriteablePoolHelper;
            }
            let PoolWriter$WriteablePoolHelper: _PoolWriter$WriteablePoolHelper$$static;
            interface _PoolWriter$WriteablePoolHelper {
              _reset(): void;
              _writeConstant(c: PoolConstant): void;
              _writeIfNeeded<P>(p: P): int;
              _currentIndex: int;
              _keysToPos: java.util.Map<any,int>;
              _overflowString: string;
              _poolbuf: javac.util.ByteBuffer;
              _this$0: PoolWriter;
              _todo: java.util.ArrayDeque<PoolConstant>;
            }
            interface PoolWriter$WriteablePoolHelper extends CombineTypes<[_PoolWriter$WriteablePoolHelper, java.lang.Object]> {}
            interface _Profile$$static extends ClassLike {
              instance(context: javac.util.Context): Profile;
              lookup(name: string): Profile;
              lookup(value: int): Profile;
              valueOf(name: string): Profile;
              values(): Profile[];
              readonly COMPACT1: Profile;
              readonly COMPACT2: Profile;
              readonly COMPACT3: Profile;
              readonly DEFAULT: Profile;
              _profileKey: javac.util.Context$Key<Profile>;
            }
            let Profile: _Profile$$static;
            interface _Profile {
              isValid(t: Target): boolean;
              readonly name: string;
              _targets: java.util.Set<Target>;
              readonly value: int;
            }
            interface Profile extends CombineTypes<[_Profile]> {}
            interface _StringConcat$$static extends ClassLike {
              instance(context: javac.util.Context): StringConcat;
              _makeConcat(context: javac.util.Context): StringConcat;
              _MAX_INDY_CONCAT_ARG_SLOTS: int;
              _TAG_ARG: char;
              _TAG_CONST: char;
              _concatKey: javac.util.Context$Key<StringConcat>;
              _new(context: javac.util.Context): StringConcat;
            }
            let StringConcat: _StringConcat$$static;
            interface _StringConcat {
              _collect(tree: javac.tree.JCTree, res: javac.util.List<javac.tree.JCTree>): javac.util.List<javac.tree.JCTree>;
              _collectAll(tree: javac.tree.JCTree): javac.util.List<javac.tree.JCTree>;
              _collectAll(lhs: javac.tree.JCTree$JCExpression, rhs: javac.tree.JCTree$JCExpression): javac.util.List<javac.tree.JCTree>;
              makeConcat(a0: javac.tree.JCTree$JCAssignOp): Items$Item;
              makeConcat(a0: javac.tree.JCTree$JCBinary): Items$Item;
              _gen: Gen;
              _make: javac.tree.TreeMaker;
              _names: javac.util.Names;
              _rs: javac.comp.Resolve;
              _sbAppends: java.util.Map<javac.code.Type,javac.code.Symbol>;
              _syms: javac.code.Symtab;
              _types: javac.code.Types;
            }
            interface StringConcat extends CombineTypes<[_StringConcat, java.lang.Object]> {}
            interface _StringConcat$Indy$$static extends ClassLike {
              new(context: javac.util.Context): StringConcat$Indy;
            }
            let StringConcat$Indy: _StringConcat$Indy$$static;
            interface _StringConcat$Indy {
              _emit(a0: javac.util.JCDiagnostic$DiagnosticPosition, a1: javac.util.List<javac.tree.JCTree>, a2: boolean, a3: javac.code.Type): void;
(a0: javac.util.JCDiagnostic$DiagnosticPosition, a1: javac.util.List<javac.tree.JCTree>, a2: boolean, a3: javac.code.Type): void;
              makeConcat(tree: javac.tree.JCTree$JCAssignOp): Items$Item;
              makeConcat(tree: javac.tree.JCTree$JCBinary): Items$Item;
              _shouldConvertToStringEagerly(argType: javac.code.Type): boolean;
              _split(args: javac.util.List<javac.tree.JCTree>): javac.util.List<javac.util.List<javac.tree.JCTree>>;
            }
            interface StringConcat$Indy extends CombineTypes<[_StringConcat$Indy, com.sun.tools.javac.jvm.StringConcat]> {}
            interface _StringConcat$IndyConstants$$static extends ClassLike {
              new(context: javac.util.Context): StringConcat$IndyConstants;
            }
            let StringConcat$IndyConstants: _StringConcat$IndyConstants$$static;
            interface _StringConcat$IndyConstants {
              _doCall(type: javac.code.Type, pos: javac.util.JCDiagnostic$DiagnosticPosition, recipe: string, staticArgs: javac.util.List<PoolConstant$LoadableConstant>, dynamicArgTypes: javac.util.List<javac.code.Type>): void;
              _emit(pos: javac.util.JCDiagnostic$DiagnosticPosition, args: javac.util.List<javac.tree.JCTree>, generateFirstArg: boolean, type: javac.code.Type): void;
            }
            interface StringConcat$IndyConstants extends CombineTypes<[_StringConcat$IndyConstants, com.sun.tools.javac.jvm.StringConcat$Indy]> {}
            interface _StringConcat$IndyPlain$$static extends ClassLike {
              new(context: javac.util.Context): StringConcat$IndyPlain;
            }
            let StringConcat$IndyPlain: _StringConcat$IndyPlain$$static;
            interface _StringConcat$IndyPlain {
              _doCall(type: javac.code.Type, pos: javac.util.JCDiagnostic$DiagnosticPosition, dynamicArgTypes: javac.util.List<javac.code.Type>): void;
              _emit(pos: javac.util.JCDiagnostic$DiagnosticPosition, args: javac.util.List<javac.tree.JCTree>, generateFirstArg: boolean, type: javac.code.Type): void;
            }
            interface StringConcat$IndyPlain extends CombineTypes<[_StringConcat$IndyPlain, com.sun.tools.javac.jvm.StringConcat$Indy]> {}
            interface _StringConcat$Inline$$static extends ClassLike {
              new(context: javac.util.Context): StringConcat$Inline;
            }
            let StringConcat$Inline: _StringConcat$Inline$$static;
            interface _StringConcat$Inline {
              _appendString(tree: javac.tree.JCTree): void;
              _builderToString(pos: javac.util.JCDiagnostic$DiagnosticPosition): void;
              makeConcat(tree: javac.tree.JCTree$JCAssignOp): Items$Item;
              makeConcat(tree: javac.tree.JCTree$JCBinary): Items$Item;
              _newStringBuilder(tree: javac.tree.JCTree): javac.util.JCDiagnostic$DiagnosticPosition;
            }
            interface StringConcat$Inline extends CombineTypes<[_StringConcat$Inline, com.sun.tools.javac.jvm.StringConcat]> {}
            interface _Target$$static extends ClassLike {
              instance(context: javac.util.Context): Target;
              lookup(name: string): Target;
              valueOf(name: string): Target;
              values(): Target[];
              readonly DEFAULT: Target;
              readonly JDK1_1: Target;
              readonly JDK1_10: Target;
              readonly JDK1_11: Target;
              readonly JDK1_12: Target;
              readonly JDK1_13: Target;
              readonly JDK1_14: Target;
              readonly JDK1_15: Target;
              readonly JDK1_16: Target;
              readonly JDK1_17: Target;
              readonly JDK1_18: Target;
              readonly JDK1_19: Target;
              readonly JDK1_2: Target;
              readonly JDK1_20: Target;
              readonly JDK1_21: Target;
              readonly JDK1_3: Target;
              readonly JDK1_4: Target;
              readonly JDK1_5: Target;
              readonly JDK1_6: Target;
              readonly JDK1_7: Target;
              readonly JDK1_8: Target;
              readonly JDK1_9: Target;
              _MAX: Target;
              readonly MIN: Target;
              _tab: java.util.Map<string,Target>;
              _targetKey: javac.util.Context$Key<Target>;
            }
            let Target: _Target$$static;
            interface _Target {
              allApiModulesAreRoots(): boolean;
              hasMethodParameters(): boolean;
              hasNestmateAccess(): boolean;
              hasSealedClasses(): boolean;
              hasStringConcatFactory(): boolean;
              hasVirtualPrivateInvoke(): boolean;
              isSupported(): boolean;
              multiReleaseValue(): string;
              obsoleteAccStrict(): boolean;
              optimizeOuterThis(): boolean;
              runtimeUseNestAccess(): boolean;
              syntheticNameChar(): char;
              readonly majorVersion: int;
              readonly minorVersion: int;
              readonly name: string;
            }
            interface Target extends CombineTypes<[_Target]> {}
            interface _UninitializedType$$static extends ClassLike {
              uninitializedObject(qtype: javac.code.Type, offset: int): UninitializedType;
              uninitializedThis(qtype: javac.code.Type): UninitializedType;
            }
            let UninitializedType: _UninitializedType$$static;
            interface _UninitializedType {
              _cloneWithMetadata(md: javac.util.List<javac.code.TypeMetadata>): UninitializedType;
              _cloneWithMetadata(a0: javac.util.List): javac.code.Type;
              _initializedType(): javac.code.Type;
              readonly offset: int;
            }
            interface UninitializedType extends CombineTypes<[_UninitializedType, com.sun.tools.javac.code.Type$DelegatedType]> {}
          }
          module launcher {
            interface _Main$$static extends ClassLike {
              main(args: string[]): void;
              main(...args: string[]): void;
              _bundleName: string;
              new(out: java.io.PrintStream): Main;
              new(out: java.io.PrintWriter): Main;
            }
            let Main: _Main$$static;
            interface _Main {
              _checkSecurityManager(): Main;
              _compile(file: java.nio.file.Path, javacOpts: java.util.List<string>, context: Main$Context): string;
              _execute(mainClassName: string, mainArgs: string[], context: Main$Context): void;
              _getFile(args: string[]): java.nio.file.Path;
              _getJavacOpts(runtimeArgs: string[]): java.util.List<string>;
              _getJavacOpts(...runtimeArgs: string[]): java.util.List<string>;
              _getMessage(error: javac.util.JCDiagnostic$Error): string;
              _readFile(file: java.nio.file.Path): javax.tools.JavaFileObject;
              run(runtimeArgs: string[], args: string[]): void;
              _errorPrefix: string;
              _out: java.io.PrintWriter;
              _resourceBundle: java.util.ResourceBundle;
            }
            interface Main extends CombineTypes<[_Main, java.lang.Object]> {}
            interface _Main$Context$$static extends ClassLike {
              _new(file: java.nio.file.Path): Main$Context;
            }
            let Main$Context: _Main$Context$$static;
            interface _Main$Context {
              _getClassLoader(parent: java.lang.ClassLoader): java.lang.ClassLoader;
              _getFileManager(delegate: javax.tools.StandardJavaFileManager): javax.tools.JavaFileManager;
              _file: java.nio.file.Path;
              _inMemoryClasses: java.util.Map<string,byte[]>;
            }
            interface Main$Context extends CombineTypes<[_Main$Context, java.lang.Object]> {}
            interface _Main$Fault$$static extends ClassLike {
              _serialVersionUID: long;
              _new(this$0: Main, error: javac.util.JCDiagnostic$Error): Main$Fault;
            }
            let Main$Fault: _Main$Fault$$static;
            interface _Main$Fault {
              _this$0: Main;
            }
            interface Main$Fault extends CombineTypes<[_Main$Fault, java.lang.Exception]> {}
            interface _Main$MainClassListener$$static extends ClassLike {
              _new(t: sun.source.util.JavacTask): Main$MainClassListener;
            }
            let Main$MainClassListener: _Main$MainClassListener$$static;
            interface _Main$MainClassListener {
              started(ev: sun.source.util.TaskEvent): void;
              _mainClass: javax.lang.model.element.TypeElement;
            }
            interface Main$MainClassListener extends CombineTypes<[_Main$MainClassListener, com.sun.source.util.TaskListener, java.lang.Object]> {}
            interface _Main$MemoryClassLoader$$static extends ClassLike {
              _DOT_CLASS_LENGTH: int;
              _new(sourceFileClasses: java.util.Map<string,byte[]>, parent: java.lang.ClassLoader, file: java.nio.file.Path): Main$MemoryClassLoader;
            }
            let Main$MemoryClassLoader: _Main$MemoryClassLoader$$static;
            interface _Main$MemoryClassLoader {
              _findClass(name: string): java.lang.Class<any>;
              findResource(name: string): java.net.URL;
              findResources(name: string): java.util.Enumeration<java.net.URL>;
              getResource(name: string): java.net.URL;
              getResources(name: string): java.util.Enumeration<java.net.URL>;
              _loadClass(name: string, resolve: boolean): java.lang.Class<any>;
              _toBinaryName(name: string): string;
              _PROTOCOL: string;
              _domain: java.security.ProtectionDomain;
              _handler: java.net.URLStreamHandler;
              _sourceFileClasses: java.util.Map<string,byte[]>;
            }
            interface Main$MemoryClassLoader extends CombineTypes<[_Main$MemoryClassLoader, java.lang.ClassLoader]> {}
            interface _Main$MemoryClassLoader$MemoryURLConnection$$static extends ClassLike {
              _new(u: java.net.URL, bytes: byte[]): Main$MemoryClassLoader$MemoryURLConnection;
            }
            let Main$MemoryClassLoader$MemoryURLConnection: _Main$MemoryClassLoader$MemoryURLConnection$$static;
            interface _Main$MemoryClassLoader$MemoryURLConnection {
              connect(): void;
              getContentLengthLong(): long;
              getContentType(): string;
              getInputStream(): java.io.InputStream;
              _bytes: byte[];
              _in: java.io.InputStream;
            }
            interface Main$MemoryClassLoader$MemoryURLConnection extends CombineTypes<[_Main$MemoryClassLoader$MemoryURLConnection, java.net.URLConnection]> {}
            interface _Main$MemoryClassLoader$MemoryURLStreamHandler$$static extends ClassLike {
            }
            let Main$MemoryClassLoader$MemoryURLStreamHandler: _Main$MemoryClassLoader$MemoryURLStreamHandler$$static;
            interface _Main$MemoryClassLoader$MemoryURLStreamHandler {
              openConnection(u: java.net.URL): java.net.URLConnection;
              _this$0: Main$MemoryClassLoader;
            }
            interface Main$MemoryClassLoader$MemoryURLStreamHandler extends CombineTypes<[_Main$MemoryClassLoader$MemoryURLStreamHandler, java.net.URLStreamHandler]> {}
            interface _Main$MemoryFileManager$$static extends ClassLike {
              _new(map: java.util.Map<string,byte[]>, delegate: javax.tools.JavaFileManager): Main$MemoryFileManager;
            }
            let Main$MemoryFileManager: _Main$MemoryFileManager$$static;
            interface _Main$MemoryFileManager {
              _createInMemoryClassFile(className: string): javax.tools.JavaFileObject;
              getJavaFileForOutput(location: javax.tools.JavaFileManager$Location, className: string, kind: javax.tools.JavaFileObject$Kind, sibling: javax.tools.FileObject): javax.tools.JavaFileObject;
              _map: java.util.Map<string,byte[]>;
            }
            interface Main$MemoryFileManager extends CombineTypes<[_Main$MemoryFileManager, javax.tools.ForwardingJavaFileManager<javax.tools.JavaFileManager>]> {}
          }
          module main {
            interface _Arguments$$static extends ClassLike {
              instance(context: javac.util.Context): Arguments;
              readonly argsKey: javac.util.Context$Key<Arguments>;
              _new(context: javac.util.Context): Arguments;
            }
            let Arguments: _Arguments$$static;
            interface _Arguments {
              allowEmpty(): void;
              _checkDirectory(option: Option): boolean;
              _checkOptionAllowed(allowed: boolean, r: Arguments$ErrorReporter, opts: Option[]): void;
              _checkOptionAllowed(allowed: boolean, r: Arguments$ErrorReporter, ...opts: Option[]): void;
              _doProcessArgs(args: java.lang.Iterable<string>, allowableOpts: java.util.Set<Option>, helper: OptionHelper, allowOperands: boolean, checkFileManager: boolean): boolean;
              _error(f: Option$InvalidValueException): void;
              getClassNames(): java.util.Set<string>;
              getDeferredFileManagerOptions(): java.util.Map<Option,string>;
              getDocLintOpts(): javac.util.List<string>;
              _getFileManager(): javax.tools.JavaFileManager;
              getFileObjects(): java.util.Set<javax.tools.JavaFileObject>;
              getPluginOpts(): java.util.Set<javac.util.List<string>>;
              handleReleaseOptions(additionalOptions: java.util.function.Predicate<java.lang.Iterable<string>>): boolean;
              init(ownName: string, args: java.lang.Iterable<string>): void;
              init(ownName: string, options: java.lang.Iterable<string>, classNames: java.lang.Iterable<string>, files: java.lang.Iterable<javax.tools.JavaFileObject>): void;
              init(ownName: string): void;
              isEmpty(): boolean;
              _processArgs(args: java.lang.Iterable<string>, allowableOpts: java.util.Set<Option>, helper: OptionHelper, allowOperands: boolean, checkFileManager: boolean): boolean;
              _report(diag: javac.util.JCDiagnostic$DiagnosticInfo): void;
              _reportDiag(diag: javac.util.JCDiagnostic$DiagnosticInfo): void;
              _toList<T>(items: java.lang.Iterable<T>): javac.util.ListBuffer<T>;
              _toSet<T>(items: java.lang.Iterable<T>): java.util.Set<T>;
              validate(): boolean;
              _validateAddExports(sv: javax.lang.model.SourceVersion): void;
              _validateAddModules(sv: javax.lang.model.SourceVersion): void;
              _validateAddReads(sv: javax.lang.model.SourceVersion): void;
              _validateDefaultModuleForCreatedFiles(sv: javax.lang.model.SourceVersion): void;
              _validateLimitModules(sv: javax.lang.model.SourceVersion): void;
              _apiHelper: OptionHelper;
              _classNames: java.util.Set<string>;
              _cmdLineHelper: OptionHelper;
              _context: javac.util.Context;
              _deferredFileManagerOptions: java.util.Map<Option,string>;
              _emptyAllowed: boolean;
              _errorMode: Arguments$ErrorMode;
              _errors: boolean;
              _fileManager: javax.tools.JavaFileManager;
              _fileObjects: java.util.Set<javax.tools.JavaFileObject>;
              _files: java.util.Set<java.nio.file.Path>;
              _log: javac.util.Log;
              _options: javac.util.Options;
              _ownName: string;
            }
            interface Arguments extends CombineTypes<[_Arguments, java.lang.Object]> {}
            interface _Arguments$ErrorMode$$static extends ClassLike {
              valueOf(name: string): Arguments$ErrorMode;
              values(): Arguments$ErrorMode[];
              readonly ILLEGAL_ARGUMENT: Arguments$ErrorMode;
              readonly ILLEGAL_STATE: Arguments$ErrorMode;
              readonly LOG: Arguments$ErrorMode;
            }
            let Arguments$ErrorMode: _Arguments$ErrorMode$$static;
            interface _Arguments$ErrorMode {
            }
            interface Arguments$ErrorMode extends CombineTypes<[_Arguments$ErrorMode]> {}
            interface _Arguments$ErrorReporter$$static extends ClassLike {
            }
            let Arguments$ErrorReporter: _Arguments$ErrorReporter$$static;
            interface _Arguments$ErrorReporter {
              report(a0: Option): void;
(a0: Option): void;
            }
            interface Arguments$ErrorReporter extends CombineTypes<[_Arguments$ErrorReporter, java.lang.Object]> {}
            interface _DelegatingJavaFileManager$$static extends ClassLike {
              installReleaseFileManager(context: javac.util.Context, releaseFM: javax.tools.JavaFileManager, originalFM: javax.tools.JavaFileManager): void;
            }
            let DelegatingJavaFileManager: _DelegatingJavaFileManager$$static;
            interface _DelegatingJavaFileManager {
              close(): void;
              contains(location: javax.tools.JavaFileManager$Location, fo: javax.tools.FileObject): boolean;
              _delegate(location: javax.tools.JavaFileManager$Location): javax.tools.JavaFileManager;
              flush(): void;
              getBaseFileManager(): javax.tools.JavaFileManager;
              getClassLoader(location: javax.tools.JavaFileManager$Location): java.lang.ClassLoader;
              getFileForInput(location: javax.tools.JavaFileManager$Location, packageName: string, relativeName: string): javax.tools.FileObject;
              getFileForOutput(location: javax.tools.JavaFileManager$Location, packageName: string, relativeName: string, sibling: javax.tools.FileObject): javax.tools.FileObject;
              getFileForOutputForOriginatingFiles(location: javax.tools.JavaFileManager$Location, packageName: string, relativeName: string, originatingFiles: javax.tools.FileObject[]): javax.tools.FileObject;
              getFileForOutputForOriginatingFiles(location: javax.tools.JavaFileManager$Location, packageName: string, relativeName: string, ...originatingFiles: javax.tools.FileObject[]): javax.tools.FileObject;
              getJavaFileForInput(location: javax.tools.JavaFileManager$Location, className: string, kind: javax.tools.JavaFileObject$Kind): javax.tools.JavaFileObject;
              getJavaFileForOutput(location: javax.tools.JavaFileManager$Location, className: string, kind: javax.tools.JavaFileObject$Kind, sibling: javax.tools.FileObject): javax.tools.JavaFileObject;
              getJavaFileForOutputForOriginatingFiles(location: javax.tools.JavaFileManager$Location, className: string, kind: javax.tools.JavaFileObject$Kind, originatingFiles: javax.tools.FileObject[]): javax.tools.JavaFileObject;
              getJavaFileForOutputForOriginatingFiles(location: javax.tools.JavaFileManager$Location, className: string, kind: javax.tools.JavaFileObject$Kind, ...originatingFiles: javax.tools.FileObject[]): javax.tools.JavaFileObject;
              getLocationForModule(location: javax.tools.JavaFileManager$Location, moduleName: string): javax.tools.JavaFileManager$Location;
              getLocationForModule(location: javax.tools.JavaFileManager$Location, fo: javax.tools.JavaFileObject): javax.tools.JavaFileManager$Location;
              getServiceLoader<S>(location: javax.tools.JavaFileManager$Location, service: java.lang.Class<S>): java.util.ServiceLoader<S>;
              handleOption(current: string, remaining: java.util.Iterator<string>): boolean;
              hasLocation(location: javax.tools.JavaFileManager$Location): boolean;
              inferBinaryName(location: javax.tools.JavaFileManager$Location, file: javax.tools.JavaFileObject): string;
              inferModuleName(location: javax.tools.JavaFileManager$Location): string;
              isSameFile(a: javax.tools.FileObject, b: javax.tools.FileObject): boolean;
              isSupportedOption(option: string): int;
              list(location: javax.tools.JavaFileManager$Location, packageName: string, kinds: java.util.Set<javax.tools.JavaFileObject$Kind>, recurse: boolean): java.lang.Iterable<javax.tools.JavaFileObject>;
              listLocationsForModules(location: javax.tools.JavaFileManager$Location): java.lang.Iterable<java.util.Set<javax.tools.JavaFileManager$Location>>;
              _baseFM: javax.tools.JavaFileManager;
              _releaseFM: javax.tools.JavaFileManager;
            }
            interface DelegatingJavaFileManager extends CombineTypes<[_DelegatingJavaFileManager, javax.tools.JavaFileManager, java.lang.Object]> {}
            interface _DelegatingJavaFileManager$DelegatingSJFM$$static extends ClassLike {
            }
            let DelegatingJavaFileManager$DelegatingSJFM: _DelegatingJavaFileManager$DelegatingSJFM$$static;
            interface _DelegatingJavaFileManager$DelegatingSJFM {
              asPath(file: javax.tools.FileObject): java.nio.file.Path;
              getJavaFileObjects(files: java.io.File[]): java.lang.Iterable<javax.tools.JavaFileObject>;
              getJavaFileObjects(...files: java.io.File[]): java.lang.Iterable<javax.tools.JavaFileObject>;
              getJavaFileObjects(paths: java.nio.file.Path[]): java.lang.Iterable<javax.tools.JavaFileObject>;
              getJavaFileObjects(...paths: java.nio.file.Path[]): java.lang.Iterable<javax.tools.JavaFileObject>;
              getJavaFileObjects(names: string[]): java.lang.Iterable<javax.tools.JavaFileObject>;
              getJavaFileObjects(...names: string[]): java.lang.Iterable<javax.tools.JavaFileObject>;
              getJavaFileObjectsFromFiles(files: java.lang.Iterable<java.io.File>): java.lang.Iterable<javax.tools.JavaFileObject>;
              getJavaFileObjectsFromPaths(paths: java.util.Collection<java.nio.file.Path>): java.lang.Iterable<javax.tools.JavaFileObject>;
              getJavaFileObjectsFromPaths(paths: java.lang.Iterable<java.nio.file.Path>): java.lang.Iterable<javax.tools.JavaFileObject>;
              getJavaFileObjectsFromStrings(names: java.lang.Iterable<string>): java.lang.Iterable<javax.tools.JavaFileObject>;
              getLocation(location: javax.tools.JavaFileManager$Location): java.lang.Iterable<java.io.File>;
              getLocationAsPaths(location: javax.tools.JavaFileManager$Location): java.lang.Iterable<java.nio.file.Path>;
              isSameFile(a: javax.tools.FileObject, b: javax.tools.FileObject): boolean;
              setLocation(location: javax.tools.JavaFileManager$Location, files: java.lang.Iterable<java.io.File>): void;
              setLocationForModule(location: javax.tools.JavaFileManager$Location, moduleName: string, paths: java.util.Collection<java.nio.file.Path>): void;
              setLocationFromPaths(location: javax.tools.JavaFileManager$Location, paths: java.util.Collection<java.nio.file.Path>): void;
              setPathFactory(f: javax.tools.StandardJavaFileManager$PathFactory): void;
              _baseSJFM: javax.tools.StandardJavaFileManager;
            }
            interface DelegatingJavaFileManager$DelegatingSJFM extends CombineTypes<[_DelegatingJavaFileManager$DelegatingSJFM, javax.tools.StandardJavaFileManager, com.sun.tools.javac.main.DelegatingJavaFileManager]> {}
            interface _JavaCompiler$$static extends ClassLike {
              _elapsed(then: long): long;
              _explicitAnnotationProcessingRequested(options: javac.util.Options, fileManager: javax.tools.JavaFileManager): boolean;
              fullVersion(): string;
              instance(context: javac.util.Context): JavaCompiler;
              _now(): long;
              version(): string;
              _version(key: string): string;
              _DEFAULT_COMPILE_POLICY: JavaCompiler$CompilePolicy;
              readonly compilerKey: javac.util.Context$Key<JavaCompiler>;
              _versionRB: java.util.ResourceBundle;
              _versionRBName: string;
              new(context: javac.util.Context): JavaCompiler;
            }
            let JavaCompiler: _JavaCompiler$$static;
            interface _JavaCompiler {
              attribute(envs: java.util.Queue<javac.comp.Env<javac.comp.AttrContext>>): java.util.Queue<javac.comp.Env<javac.comp.AttrContext>>;
              attribute(env: javac.comp.Env<javac.comp.AttrContext>): javac.comp.Env<javac.comp.AttrContext>;
              _checkReusable(): void;
              close(): void;
              compile(sourceFileObject: javac.util.List<javax.tools.JavaFileObject>): void;
              compile(sourceFileObjects: java.util.Collection<javax.tools.JavaFileObject>, classnames: java.util.Collection<string>, processors: java.lang.Iterable<javax.annotation.processing.Processor>, addModules: java.util.Collection<string>): void;
              continueAfterProcessAnnotations(): boolean;
              desugar(envs: java.util.Queue<javac.comp.Env<javac.comp.AttrContext>>): java.util.Queue<javac.util.Pair<javac.comp.Env<javac.comp.AttrContext>,javac.tree.JCTree$JCClassDecl>>;
              _desugar(env: javac.comp.Env<javac.comp.AttrContext>, results: java.util.Queue<javac.util.Pair<javac.comp.Env<javac.comp.AttrContext>,javac.tree.JCTree$JCClassDecl>>): void;
              enterDone(): void;
              enterTrees(roots: javac.util.List<javac.tree.JCTree$JCCompilationUnit>): javac.util.List<javac.tree.JCTree$JCCompilationUnit>;
              errorCount(): int;
              _explicitAnnotationProcessingRequested(): boolean;
              _findPackageInFile(fo: javax.tools.JavaFileObject): javac.util.Name;
              flow(envs: java.util.Queue<javac.comp.Env<javac.comp.AttrContext>>): java.util.Queue<javac.comp.Env<javac.comp.AttrContext>>;
              flow(env: javac.comp.Env<javac.comp.AttrContext>): java.util.Queue<javac.comp.Env<javac.comp.AttrContext>>;
              _flow(env: javac.comp.Env<javac.comp.AttrContext>, results: java.util.Queue<javac.comp.Env<javac.comp.AttrContext>>): void;
              _genCode(env: javac.comp.Env<javac.comp.AttrContext>, cdef: javac.tree.JCTree$JCClassDecl): javax.tools.JavaFileObject;
              generate(queue: java.util.Queue<javac.util.Pair<javac.comp.Env<javac.comp.AttrContext>,javac.tree.JCTree$JCClassDecl>>): void;
              generate(queue: java.util.Queue<javac.util.Pair<javac.comp.Env<javac.comp.AttrContext>,javac.tree.JCTree$JCClassDecl>>, results: java.util.Queue<javax.tools.JavaFileObject>): void;
              _groupByFile(envs: java.util.Queue<javac.comp.Env<javac.comp.AttrContext>>): java.util.Map<javac.tree.JCTree$JCCompilationUnit,java.util.Queue<javac.comp.Env<javac.comp.AttrContext>>>;
              initModules(roots: javac.util.List<javac.tree.JCTree$JCCompilationUnit>): javac.util.List<javac.tree.JCTree$JCCompilationUnit>;
              initProcessAnnotations(processors: java.lang.Iterable<javax.annotation.processing.Processor>, initialFiles: java.util.Collection<javax.tools.JavaFileObject>, initialClassNames: java.util.Collection<string>): void;
              isEnterDone(): boolean;
              _keepComments(): boolean;
              _newAnalyzeTaskEvent(env: javac.comp.Env<javac.comp.AttrContext>): sun.source.util.TaskEvent;
              newRound(): void;
              _parse(filename: javax.tools.JavaFileObject, content: JavaCompiler$charSequence): javac.tree.JCTree$JCCompilationUnit;
              _parse(filename: javax.tools.JavaFileObject, content: JavaCompiler$charSequence, silent: boolean): javac.tree.JCTree$JCCompilationUnit;
              parse(filename: string): javac.tree.JCTree$JCCompilationUnit;
              parse(filename: javax.tools.JavaFileObject): javac.tree.JCTree$JCCompilationUnit;
              _parseAndGetName(fo: javax.tools.JavaFileObject, tree2Name: java.util.function.Function<javac.tree.JCTree$JCCompilationUnit,javac.util.Name>): javac.util.Name;
              parseFiles(fileObjects: java.lang.Iterable<javax.tools.JavaFileObject>): javac.util.List<javac.tree.JCTree$JCCompilationUnit>;
              parseFiles(fileObjects: java.lang.Iterable<javax.tools.JavaFileObject>, force: boolean): javac.util.List<javac.tree.JCTree$JCCompilationUnit>;
              printCount(kind: string, count: int): void;
              _printNote(lines: string): void;
              _printSource(env: javac.comp.Env<javac.comp.AttrContext>, cdef: javac.tree.JCTree$JCClassDecl): javax.tools.JavaFileObject;
              _printSuppressedCount(shown: int, suppressed: int, diagKey: string): void;
              processAnnotations(roots: javac.util.List<javac.tree.JCTree$JCCompilationUnit>): void;
              processAnnotations(roots: javac.util.List<javac.tree.JCTree$JCCompilationUnit>, classnames: java.util.Collection<string>): void;
              _readModuleName(fo: javax.tools.JavaFileObject): javac.util.Name;
              readSource(filename: javax.tools.JavaFileObject): JavaCompiler$charSequence;
              _readSourceFile(c: javac.code.Symbol$ClassSymbol): void;
              readSourceFile(tree: javac.tree.JCTree$JCCompilationUnit, c: javac.code.Symbol$ClassSymbol): void;
              _removeMethodBodies(cdef: javac.tree.JCTree$JCClassDecl): javac.tree.JCTree$JCClassDecl;
              reportDeferredDiagnostics(): void;
              resolveBinaryNameOrIdent(name: string): javac.code.Symbol;
              resolveBinaryNameOrIdent(msym: javac.code.Symbol$ModuleSymbol, name: string): javac.code.Symbol;
              resolveIdent(msym: javac.code.Symbol$ModuleSymbol, name: string): javac.code.Symbol;
              setDeferredDiagnosticHandler(deferredDiagnosticHandler: javac.util.Log$DeferredDiagnosticHandler): void;
              _shouldStop(cs: javac.comp.CompileStates$CompileState): boolean;
              _stopIfError<T>(cs: javac.comp.CompileStates$CompileState, queue: java.util.Queue<T>): java.util.Queue<T>;
              _stopIfError<T>(cs: javac.comp.CompileStates$CompileState, list: javac.util.List<T>): javac.util.List<T>;
              _unrecoverableError(): boolean;
              warningCount(): int;
              _analyzer: javac.comp.Analyzer;
              _annotate: javac.comp.Annotate;
              _annotationProcessingOccurred: boolean;
              _attr: javac.comp.Attr;
              _chk: javac.comp.Check;
              closeables: javac.util.List<java.io.Closeable>;
              _compilePolicy: JavaCompiler$CompilePolicy;
              _compileStates: javac.comp.CompileStates;
              _completionFailureName: javac.util.Name;
              _context: javac.util.Context;
              _dcfh: javac.code.DeferredCompletionFailureHandler;
              _deferredDiagnosticHandler: javac.util.Log$DeferredDiagnosticHandler;
              _desugaredEnvs: java.util.HashMap<javac.comp.Env<javac.comp.AttrContext>,java.util.Queue<javac.util.Pair<javac.comp.Env<javac.comp.AttrContext>,javac.tree.JCTree$JCClassDecl>>>;
              _devVerbose: boolean;
              _diagFactory: javac.util.JCDiagnostic$Factory;
              _diags: javac.util.JCDiagnostic$Factory;
              elapsed_msec: long;
              _enter: javac.comp.Enter;
              _enterDone: boolean;
              _explicitAnnotationProcessingRequested: boolean;
              _fileManager: javax.tools.JavaFileManager;
              _finder: javac.code.ClassFinder;
              _flow: javac.comp.Flow;
              _gen: javac.jvm.Gen;
              genEndPos: boolean;
              _hasBeenUsed: boolean;
              _implicitSourceFilesRead: boolean;
              _implicitSourcePolicy: JavaCompiler$ImplicitSourcePolicy;
              _inputFiles: java.util.Set<javax.tools.JavaFileObject>;
              _jniWriter: javac.jvm.JNIWriter;
              keepComments: boolean;
              lineDebugInfo: boolean;
              log: javac.util.Log;
              _lower: javac.comp.Lower;
              _make: javac.tree.TreeMaker;
              _moduleFinder: javac.code.ModuleFinder;
              _modules: javac.comp.Modules;
              _names: javac.util.Names;
              _options: javac.util.Options;
              _optionsCheckingInitiallyDisabled: boolean;
              _parserFactory: javac.parser.ParserFactory;
              _preview: javac.code.Preview;
              _procEnvImpl: javac.processing.JavacProcessingEnvironment;
              _processAnnotations: boolean;
              _processPcks: boolean;
              _reader: javac.jvm.ClassReader;
              _rootClasses: javac.util.List<javac.tree.JCTree$JCClassDecl>;
              shouldStopPolicyIfError: javac.comp.CompileStates$CompileState;
              shouldStopPolicyIfNoError: javac.comp.CompileStates$CompileState;
              _silentFail: javac.code.Symbol;
              _source: javac.code.Source;
              _sourceCompleter: javac.code.Symbol$Completer;
              sourceOutput: boolean;
              _start_msec: long;
              _syms: javac.code.Symtab;
              _taskListener: javac.api.MultiTaskListener;
              todo: javac.comp.Todo;
              _transTypes: javac.comp.TransTypes;
              _types: javac.code.Types;
              verbose: boolean;
              verboseCompilePolicy: boolean;
              _werror: boolean;
              _writer: javac.jvm.ClassWriter;
            }
            interface JavaCompiler extends CombineTypes<[_JavaCompiler, java.lang.Object]> {}
            interface _JavaCompiler$CompilePolicy$$static extends ClassLike {
              _decode(option: string): JavaCompiler$CompilePolicy;
              valueOf(name: string): JavaCompiler$CompilePolicy;
              values(): JavaCompiler$CompilePolicy[];
              readonly BY_FILE: JavaCompiler$CompilePolicy;
              readonly BY_TODO: JavaCompiler$CompilePolicy;
              readonly SIMPLE: JavaCompiler$CompilePolicy;
            }
            let JavaCompiler$CompilePolicy: _JavaCompiler$CompilePolicy$$static;
            interface _JavaCompiler$CompilePolicy {
            }
            interface JavaCompiler$CompilePolicy extends CombineTypes<[_JavaCompiler$CompilePolicy]> {}
            interface _JavaCompiler$ImplicitSourcePolicy$$static extends ClassLike {
              _decode(option: string): JavaCompiler$ImplicitSourcePolicy;
              valueOf(name: string): JavaCompiler$ImplicitSourcePolicy;
              values(): JavaCompiler$ImplicitSourcePolicy[];
              readonly CLASS: JavaCompiler$ImplicitSourcePolicy;
              readonly NONE: JavaCompiler$ImplicitSourcePolicy;
              readonly UNSET: JavaCompiler$ImplicitSourcePolicy;
            }
            let JavaCompiler$ImplicitSourcePolicy: _JavaCompiler$ImplicitSourcePolicy$$static;
            interface _JavaCompiler$ImplicitSourcePolicy {
            }
            interface JavaCompiler$ImplicitSourcePolicy extends CombineTypes<[_JavaCompiler$ImplicitSourcePolicy]> {}
            interface _JavaCompiler$InitialFileParser$$static extends ClassLike {
              instance(context: javac.util.Context): JavaCompiler$InitialFileParserIntf;
              readonly initialParserKey: javac.util.Context$Key<JavaCompiler$InitialFileParserIntf>;
            }
            let JavaCompiler$InitialFileParser: _JavaCompiler$InitialFileParser$$static;
            interface _JavaCompiler$InitialFileParser {
              parse(fileObjects: java.lang.Iterable<javax.tools.JavaFileObject>): javac.util.List<javac.tree.JCTree$JCCompilationUnit>;
              _compiler: JavaCompiler;
            }
            interface JavaCompiler$InitialFileParser extends CombineTypes<[_JavaCompiler$InitialFileParser, java.lang.Object, com.sun.tools.javac.main.JavaCompiler$InitialFileParserIntf]> {}
            interface _JavaCompiler$InitialFileParserIntf$$static extends ClassLike {
            }
            let JavaCompiler$InitialFileParserIntf: _JavaCompiler$InitialFileParserIntf$$static;
            interface _JavaCompiler$InitialFileParserIntf {
              parse(a0: java.lang.Iterable<javax.tools.JavaFileObject>): javac.util.List<javac.tree.JCTree$JCCompilationUnit>;
(a0: java.lang.Iterable<javax.tools.JavaFileObject>): javac.util.List<javac.tree.JCTree$JCCompilationUnit>;
            }
            interface JavaCompiler$InitialFileParserIntf extends CombineTypes<[_JavaCompiler$InitialFileParserIntf, java.lang.Object]> {}
            interface _JavacToolProvider$$static extends ClassLike {
              new(): JavacToolProvider;
            }
            let JavacToolProvider: _JavacToolProvider$$static;
            interface _JavacToolProvider {
              description(): java.util.Optional<string>;
              name(): string;
              run(out: java.io.PrintWriter, err: java.io.PrintWriter, args: string[]): int;
              run(out: java.io.PrintWriter, err: java.io.PrintWriter, ...args: string[]): int;
            }
            interface JavacToolProvider extends CombineTypes<[_JavacToolProvider, java.lang.Object, java.util.spi.ToolProvider]> {}
            interface _Main$$static extends ClassLike {
              _ENV_OPT_NAME: string;
              readonly javacBundleName: string;
              new(name: string): Main;
              new(name: string, out: java.io.PrintWriter): Main;
              new(name: string, out: java.io.PrintWriter, err: java.io.PrintWriter): Main;
            }
            let Main: _Main$$static;
            interface _Main {
              _apMessage(ex: javac.processing.AnnotationProcessingError): void;
              _bugMessage(ex: java.lang.Throwable): void;
              compile(args: string[]): Main$Result;
              compile(argv: string[], context: javac.util.Context): Main$Result;
              _feMessage(ex: java.lang.Throwable, options: javac.util.Options): void;
              _ioMessage(ex: java.lang.Throwable): void;
              _pluginMessage(ex: java.lang.Throwable): void;
              _printArgumentsToFile(params: string[]): void;
              _printArgumentsToFile(...params: string[]): void;
              _reportDiag(diag: javac.util.JCDiagnostic$DiagnosticInfo): void;
              _reportHelper(diag: javac.util.JCDiagnostic$DiagnosticInfo): void;
              _resourceMessage(ex: java.lang.Throwable): void;
              _showClass(className: string): void;
              _twoClassLoadersInUse(iae: java.lang.IllegalAccessError): boolean;
              _apiMode: boolean;
              _fileManager: javax.tools.JavaFileManager;
              log: javac.util.Log;
              _ownName: string;
              _stdErr: java.io.PrintWriter;
              _stdOut: java.io.PrintWriter;
            }
            interface Main extends CombineTypes<[_Main, java.lang.Object]> {}
            interface _Main$Result$$static extends ClassLike {
              valueOf(name: string): Main$Result;
              values(): Main$Result[];
              readonly ABNORMAL: Main$Result;
              readonly CMDERR: Main$Result;
              readonly ERROR: Main$Result;
              readonly OK: Main$Result;
              readonly SYSERR: Main$Result;
            }
            let Main$Result: _Main$Result$$static;
            interface _Main$Result {
              isOK(): boolean;
              readonly exitCode: int;
            }
            interface Main$Result extends CombineTypes<[_Main$Result]> {}
            interface _Option$$static extends ClassLike {
              _findSeparator(word: string): int;
              _getJavaCompilerOptions(): java.util.Set<Option>;
              getJavacFileManagerOptions(): java.util.Set<Option>;
              getJavacToolOptions(): java.util.Set<Option>;
              _getOptions(group: Option$OptionGroup): java.util.Set<Option>;
              _getXLintChoices(): java.util.Set<string>;
              lookup(arg: string): Option;
              lookup(arg: string, options: java.util.Set<Option>): Option;
              _showHelp(log: javac.util.Log, kind: Option$OptionKind): void;
              valueOf(name: string): Option;
              values(): Option[];
              readonly A: Option;
              readonly ADD_EXPORTS: Option;
              readonly ADD_MODULES: Option;
              readonly ADD_OPENS: Option;
              readonly ADD_READS: Option;
              readonly AT: Option;
              readonly BOOT_CLASS_PATH: Option;
              readonly CLASS_PATH: Option;
              _COMPACT_FORMAT: string;
              readonly D: Option;
              readonly DEBUG: Option;
              _DEFAULT_MAX_LINE_LENGTH: int;
              readonly DEFAULT_MODULE_FOR_CREATED_FILES: Option;
              _DEFAULT_SYNOPSIS_WIDTH: int;
              readonly DEPRECATION: Option;
              readonly DIAGS: Option;
              readonly DJAVA_ENDORSED_DIRS: Option;
              readonly DJAVA_EXT_DIRS: Option;
              readonly DOE: Option;
              readonly ENCODING: Option;
              readonly ENDORSEDDIRS: Option;
              readonly EXTDIRS: Option;
              readonly FULLVERSION: Option;
              readonly G: Option;
              readonly G_CUSTOM: Option;
              readonly G_NONE: Option;
              readonly H: Option;
              readonly HELP: Option;
              readonly HELP_LINT: Option;
              readonly IMPLICIT: Option;
              readonly INHERIT_RUNTIME_ENVIRONMENT: Option;
              readonly J: Option;
              _LARGE_INDENT: string;
              readonly LIMIT_MODULES: Option;
              readonly MODULE: Option;
              readonly MODULE_PATH: Option;
              readonly MODULE_SOURCE_PATH: Option;
              readonly MODULE_VERSION: Option;
              readonly MOREINFO: Option;
              readonly MULTIRELEASE: Option;
              readonly NOWARN: Option;
              readonly O: Option;
              readonly PARAMETERS: Option;
              readonly PATCH_MODULE: Option;
              readonly PLUGIN: Option;
              readonly PREVIEW: Option;
              readonly PRINTSOURCE: Option;
              readonly PROC: Option;
              readonly PROCESSOR: Option;
              readonly PROCESSOR_MODULE_PATH: Option;
              readonly PROCESSOR_PATH: Option;
              readonly PROFILE: Option;
              readonly PROMPT: Option;
              readonly RELEASE: Option;
              readonly S: Option;
              readonly SHOULDSTOP: Option;
              _SMALL_INDENT: string;
              readonly SOURCE: Option;
              readonly SOURCEFILE: Option;
              readonly SOURCE_PATH: Option;
              readonly SYSTEM: Option;
              readonly TARGET: Option;
              readonly UPGRADE_MODULE_PATH: Option;
              readonly VERBOSE: Option;
              readonly VERSION: Option;
              readonly WARNUNCHECKED: Option;
              readonly WERROR: Option;
              readonly X: Option;
              readonly XBOOTCLASSPATH: Option;
              readonly XBOOTCLASSPATH_APPEND: Option;
              readonly XBOOTCLASSPATH_PREPEND: Option;
              readonly XD: Option;
              readonly XDIAGS: Option;
              readonly XDOCLINT: Option;
              readonly XDOCLINT_CUSTOM: Option;
              readonly XDOCLINT_PACKAGE: Option;
              readonly XJCOV: Option;
              readonly XLINT: Option;
              readonly XLINT_CUSTOM: Option;
              readonly XMAXERRS: Option;
              readonly XMAXWARNS: Option;
              readonly XPKGINFO: Option;
              readonly XPREFER: Option;
              readonly XPRINT: Option;
              readonly XPRINTPROCESSORINFO: Option;
              readonly XPRINTROUNDS: Option;
              readonly XSTDOUT: Option;
              readonly XXUSERPATHSFIRST: Option;
            }
            let Option: _Option$$static;
            interface _Option {
              getArgKind(): Option$ArgKind;
              getKind(): Option$OptionKind;
              getPattern(): java.util.regex.Pattern;
              getPrimaryName(): string;
              handleOption(helper: OptionHelper, arg: string, rest: java.util.Iterator<string>): void;
              hasArg(): boolean;
              hasSeparateArg(): boolean;
              _help(log: javac.util.Log): void;
              _help(log: javac.util.Log, descr: string): void;
              _helpSynopsis(name: string, log: javac.util.Log): string;
              matches(option: string): boolean;
              _matches(option: string, name: string): boolean;
              process(helper: OptionHelper, option: string): void;
              process(helper: OptionHelper, option: string, arg: string): void;
              _argKind: Option$ArgKind;
              _argsNameKey: string;
              _choiceKind: Option$ChoiceKind;
              _choices: java.util.Set<string>;
              _descrKey: string;
              _group: Option$OptionGroup;
              _kind: Option$OptionKind;
              readonly names: string[];
              readonly primaryName: string;
            }
            interface Option extends CombineTypes<[_Option]> {}
            interface _Option$ArgKind$$static extends ClassLike {
              valueOf(name: string): Option$ArgKind;
              values(): Option$ArgKind[];
              readonly ADJACENT: Option$ArgKind;
              readonly NONE: Option$ArgKind;
              readonly REQUIRED: Option$ArgKind;
            }
            let Option$ArgKind: _Option$ArgKind$$static;
            interface _Option$ArgKind {
            }
            interface Option$ArgKind extends CombineTypes<[_Option$ArgKind]> {}
            interface _Option$ChoiceKind$$static extends ClassLike {
              valueOf(name: string): Option$ChoiceKind;
              values(): Option$ChoiceKind[];
              readonly ANYOF: Option$ChoiceKind;
              readonly ONEOF: Option$ChoiceKind;
            }
            let Option$ChoiceKind: _Option$ChoiceKind$$static;
            interface _Option$ChoiceKind {
            }
            interface Option$ChoiceKind extends CombineTypes<[_Option$ChoiceKind]> {}
            interface _Option$HiddenGroup$$static extends ClassLike {
              valueOf(name: string): Option$HiddenGroup;
              values(): Option$HiddenGroup[];
              readonly DEBUG: Option$HiddenGroup;
              readonly DIAGS: Option$HiddenGroup;
              readonly SHOULDSTOP: Option$HiddenGroup;
            }
            let Option$HiddenGroup: _Option$HiddenGroup$$static;
            interface _Option$HiddenGroup {
              process(helper: OptionHelper, option: string, arg: string): void;
              _text: string;
            }
            interface Option$HiddenGroup extends CombineTypes<[_Option$HiddenGroup]> {}
            interface _Option$InvalidValueException$$static extends ClassLike {
              _serialVersionUID: long;
              new(msg: string): Option$InvalidValueException;
              new(msg: string, cause: java.lang.Throwable): Option$InvalidValueException;
            }
            let Option$InvalidValueException: _Option$InvalidValueException$$static;
            interface _Option$InvalidValueException {
            }
            interface Option$InvalidValueException extends CombineTypes<[_Option$InvalidValueException, java.lang.Exception]> {}
            interface _Option$OptionGroup$$static extends ClassLike {
              valueOf(name: string): Option$OptionGroup;
              values(): Option$OptionGroup[];
              readonly BASIC: Option$OptionGroup;
              readonly FILEMANAGER: Option$OptionGroup;
              readonly INFO: Option$OptionGroup;
              readonly OPERAND: Option$OptionGroup;
            }
            let Option$OptionGroup: _Option$OptionGroup$$static;
            interface _Option$OptionGroup {
            }
            interface Option$OptionGroup extends CombineTypes<[_Option$OptionGroup]> {}
            interface _Option$OptionKind$$static extends ClassLike {
              valueOf(name: string): Option$OptionKind;
              values(): Option$OptionKind[];
              readonly EXTENDED: Option$OptionKind;
              readonly HIDDEN: Option$OptionKind;
              readonly STANDARD: Option$OptionKind;
            }
            let Option$OptionKind: _Option$OptionKind$$static;
            interface _Option$OptionKind {
            }
            interface Option$OptionKind extends CombineTypes<[_Option$OptionKind]> {}
            interface _Option$PkgInfo$$static extends ClassLike {
              get(options: javac.util.Options): Option$PkgInfo;
              valueOf(name: string): Option$PkgInfo;
              values(): Option$PkgInfo[];
              readonly ALWAYS: Option$PkgInfo;
              readonly LEGACY: Option$PkgInfo;
              readonly NONEMPTY: Option$PkgInfo;
            }
            let Option$PkgInfo: _Option$PkgInfo$$static;
            interface _Option$PkgInfo {
            }
            interface Option$PkgInfo extends CombineTypes<[_Option$PkgInfo]> {}
            interface _OptionHelper$$static extends ClassLike {
              new(): OptionHelper;
            }
            let OptionHelper: _OptionHelper$$static;
            interface _OptionHelper {
              _addClassName(a0: string): void;
              _addFile(a0: java.nio.file.Path): void;
              get(a0: Option): string;
              getLog(): javac.util.Log;
              getOwnName(): string;
              handleFileManagerOption(a0: Option, a1: string): boolean;
              _newInvalidValueException(error: javac.util.JCDiagnostic$Error): Option$InvalidValueException;
              put(a0: string, a1: string): void;
              remove(a0: string): void;
            }
            interface OptionHelper extends CombineTypes<[_OptionHelper, java.lang.Object]> {}
            interface _OptionHelper$GrumpyHelper$$static extends ClassLike {
              new(log: javac.util.Log): OptionHelper$GrumpyHelper;
            }
            let OptionHelper$GrumpyHelper: _OptionHelper$GrumpyHelper$$static;
            interface _OptionHelper$GrumpyHelper {
              addClassName(s: string): void;
              addFile(p: java.nio.file.Path): void;
              get(option: Option): string;
              getLog(): javac.util.Log;
              getOwnName(): string;
              handleFileManagerOption(option: Option, value: string): boolean;
              put(name: string, value: string): void;
              remove(name: string): void;
              _log: javac.util.Log;
            }
            interface OptionHelper$GrumpyHelper extends CombineTypes<[_OptionHelper$GrumpyHelper, com.sun.tools.javac.main.OptionHelper]> {}
          }
          module model {
            interface _AnnotationProxyMaker$$static extends ClassLike {
              generateAnnotation<A>(anno: javac.code.Attribute$Compound, annoType: java.lang.Class<A>): A;
            }
            let AnnotationProxyMaker: _AnnotationProxyMaker$$static;
            interface _AnnotationProxyMaker {
              _generateAnnotation(): java.lang.annotation.Annotation;
              _generateValue(meth: javac.code.Symbol$MethodSymbol, attr: javac.code.Attribute): any;
              _getAllReflectedValues(): java.util.Map<string,any>;
              _getAllValues(): java.util.Map<javac.code.Symbol$MethodSymbol,javac.code.Attribute>;
              _anno: javac.code.Attribute$Compound;
              _annoType: java.lang.Class<java.lang.annotation.Annotation>;
            }
            interface AnnotationProxyMaker extends CombineTypes<[_AnnotationProxyMaker, java.lang.Object]> {}
            interface _AnnotationProxyMaker$MirroredTypeExceptionProxy$$static extends ClassLike {
              _serialVersionUID: long;
              _new(t: javax.lang.model.type.TypeMirror): AnnotationProxyMaker$MirroredTypeExceptionProxy;
            }
            let AnnotationProxyMaker$MirroredTypeExceptionProxy: _AnnotationProxyMaker$MirroredTypeExceptionProxy$$static;
            interface _AnnotationProxyMaker$MirroredTypeExceptionProxy {
              equals(obj: any): boolean;
              _generateException(): java.lang.RuntimeException;
              hashCode(): int;
              _readObject(s: java.io.ObjectInputStream): void;
              toString(): string;
              _type: javax.lang.model.type.TypeMirror;
              _typeString: string;
            }
            interface AnnotationProxyMaker$MirroredTypeExceptionProxy extends CombineTypes<[_AnnotationProxyMaker$MirroredTypeExceptionProxy, sun.reflect.annotation.ExceptionProxy]> {}
            interface _AnnotationProxyMaker$MirroredTypesExceptionProxy$$static extends ClassLike {
              _serialVersionUID: long;
              _new(ts: javac.util.List<javax.lang.model.type.TypeMirror>): AnnotationProxyMaker$MirroredTypesExceptionProxy;
            }
            let AnnotationProxyMaker$MirroredTypesExceptionProxy: _AnnotationProxyMaker$MirroredTypesExceptionProxy$$static;
            interface _AnnotationProxyMaker$MirroredTypesExceptionProxy {
              equals(obj: any): boolean;
              _generateException(): java.lang.RuntimeException;
              hashCode(): int;
              _readObject(s: java.io.ObjectInputStream): void;
              toString(): string;
              _typeStrings: string;
              _types: javac.util.List<javax.lang.model.type.TypeMirror>;
            }
            interface AnnotationProxyMaker$MirroredTypesExceptionProxy extends CombineTypes<[_AnnotationProxyMaker$MirroredTypesExceptionProxy, sun.reflect.annotation.ExceptionProxy]> {}
            interface _AnnotationProxyMaker$ValueVisitor$$static extends ClassLike {
              _new(a0: AnnotationProxyMaker, meth: javac.code.Symbol$MethodSymbol): AnnotationProxyMaker$ValueVisitor;
            }
            let AnnotationProxyMaker$ValueVisitor: _AnnotationProxyMaker$ValueVisitor$$static;
            interface _AnnotationProxyMaker$ValueVisitor {
              _getValue(attr: javac.code.Attribute): any;
              _typeMismatch(method: java.lang.reflect.Method, attr: javac.code.Attribute): void;
              visitArray(a: javac.code.Attribute$Array): void;
              visitClass(c: javac.code.Attribute$Class): void;
              visitCompound(c: javac.code.Attribute$Compound): void;
              visitConstant(c: javac.code.Attribute$Constant): void;
              visitEnum(e: javac.code.Attribute$Enum): void;
              visitError(e: javac.code.Attribute$Error): void;
              _meth: javac.code.Symbol$MethodSymbol;
              _returnClass: java.lang.Class<any>;
              _this$0: AnnotationProxyMaker;
              _value: any;
            }
            interface AnnotationProxyMaker$ValueVisitor extends CombineTypes<[_AnnotationProxyMaker$ValueVisitor, com.sun.tools.javac.code.Attribute$Visitor, java.lang.Object]> {}
            interface _FilteredMemberList$$static extends ClassLike {
              _unwanted(s: javac.code.Symbol): boolean;
              new(scope: javac.code.Scope): FilteredMemberList;
            }
            let FilteredMemberList: _FilteredMemberList$$static;
            interface _FilteredMemberList {
              get(index: int): javac.code.Symbol;
              get(a0: int): any;
              iterator(): java.util.Iterator<javac.code.Symbol>;
              size(): int;
              _scope: javac.code.Scope;
            }
            interface FilteredMemberList extends CombineTypes<[_FilteredMemberList, java.util.AbstractList<javac.code.Symbol>]> {}
            interface _JavacElements$$static extends ClassLike {
              _cast<T>(clazz: java.lang.Class<T>, o: any): T;
              _containsAnnoOfType(annos: javac.util.List<javac.code.Attribute$Compound>, type: javac.code.Type): boolean;
              instance(context: javac.util.Context): JavacElements;
              _new(context: javac.util.Context): JavacElements;
            }
            let JavacElements: _JavacElements$$static;
            interface _JavacElements {
              _addMembers(scope: javac.code.Scope$WriteableScope, type: javac.code.Type): void;
              _doGetElement<S>(module: javax.lang.model.element.ModuleElement, methodName: string, name: JavacElements$charSequence, clazz: java.lang.Class<S>): S;
              _doGetPackageElement(module: javax.lang.model.element.ModuleElement, name: JavacElements$charSequence): javac.code.Symbol$PackageSymbol;
              _doGetTypeElement(module: javax.lang.model.element.ModuleElement, name: JavacElements$charSequence): javac.code.Symbol$ClassSymbol;
              _ensureEntered(methodName: string): void;
              getAllAnnotationMirrors(e: javax.lang.model.element.Element): javac.util.List<javac.code.Attribute$Compound>;
              getAllAnnotationMirrors(a0: javax.lang.model.element.Element): java.util.List;
              getAllMembers(element: javax.lang.model.element.TypeElement): FilteredMemberList;
              getAllMembers(a0: javax.lang.model.element.TypeElement): java.util.List;
              getAllModuleElements(): java.util.Set<javax.lang.model.element.ModuleElement>;
              getBinaryName(type: javax.lang.model.element.TypeElement): javac.util.Name;
              getBinaryName(a0: javax.lang.model.element.TypeElement): javax.lang.model.element.Name;
              getConstantExpression(value: any): string;
              getDocComment(e: javax.lang.model.element.Element): string;
              getElementValuesWithDefaults(a: javax.lang.model.element.AnnotationMirror): java.util.Map<javac.code.Symbol$MethodSymbol,javac.code.Attribute>;
              _getEnterEnv(sym: javac.code.Symbol): javac.comp.Env<javac.comp.AttrContext>;
              getFileObjectOf(e: javax.lang.model.element.Element): javax.tools.JavaFileObject;
              getModuleElement(name: JavacElements$charSequence): javac.code.Symbol$ModuleSymbol;
              getModuleElement(a0: JavacElements$charSequence): javax.lang.model.element.ModuleElement;
              getModuleOf(e: javax.lang.model.element.Element): javax.lang.model.element.ModuleElement;
              getName(cs: JavacElements$charSequence): javac.util.Name;
              getName(a0: JavacElements$charSequence): javax.lang.model.element.Name;
              getOrigin(e: javax.lang.model.element.Element): javax.lang.model.util.Elements$Origin;
              getOrigin(c: javax.lang.model.AnnotatedConstruct, a: javax.lang.model.element.AnnotationMirror): javax.lang.model.util.Elements$Origin;
              getOrigin(m: javax.lang.model.element.ModuleElement, directive: javax.lang.model.element.ModuleElement$Directive): javax.lang.model.util.Elements$Origin;
              getOutermostTypeElement(e: javax.lang.model.element.Element): javax.lang.model.element.TypeElement;
              getPackageElement(name: JavacElements$charSequence): javac.code.Symbol$PackageSymbol;
              getPackageElement(module: javax.lang.model.element.ModuleElement, name: JavacElements$charSequence): javac.code.Symbol$PackageSymbol;
              getPackageElement(a0: javax.lang.model.element.ModuleElement, a1: JavacElements$charSequence): javax.lang.model.element.PackageElement;
              getPackageElement(a0: JavacElements$charSequence): javax.lang.model.element.PackageElement;
              getPackageOf(e: javax.lang.model.element.Element): javax.lang.model.element.PackageElement;
              getTree(e: javax.lang.model.element.Element): javac.tree.JCTree;
              _getTreeAndTopLevel(e: javax.lang.model.element.Element): javac.util.Pair<javac.tree.JCTree,javac.tree.JCTree$JCCompilationUnit>;
              getTreeAndTopLevel(e: javax.lang.model.element.Element, a: javax.lang.model.element.AnnotationMirror, v: javax.lang.model.element.AnnotationValue): javac.util.Pair<javac.tree.JCTree,javac.tree.JCTree$JCCompilationUnit>;
              getTypeElement(name: JavacElements$charSequence): javac.code.Symbol$ClassSymbol;
              getTypeElement(module: javax.lang.model.element.ModuleElement, name: JavacElements$charSequence): javac.code.Symbol$ClassSymbol;
              getTypeElement(a0: javax.lang.model.element.ModuleElement, a1: JavacElements$charSequence): javax.lang.model.element.TypeElement;
              getTypeElement(a0: JavacElements$charSequence): javax.lang.model.element.TypeElement;
              hides(hiderEl: javax.lang.model.element.Element, hideeEl: javax.lang.model.element.Element): boolean;
              isAutomaticModule(module: javax.lang.model.element.ModuleElement): boolean;
              isCanonicalConstructor(e: javax.lang.model.element.ExecutableElement): boolean;
              isCompactConstructor(e: javax.lang.model.element.ExecutableElement): boolean;
              isDeprecated(e: javax.lang.model.element.Element): boolean;
              isFunctionalInterface(element: javax.lang.model.element.TypeElement): boolean;
              _isInherited(annotype: javac.code.Type): boolean;
              _matchAnnoToTree(findme: javax.lang.model.element.AnnotationMirror, e: javax.lang.model.element.Element, tree: javac.tree.JCTree): javac.tree.JCTree;
              _matchAnnoToTree(findme: javac.code.Attribute$Compound, annos: javac.util.List<javac.code.Attribute$Compound>, trees: javac.util.List<javac.tree.JCTree$JCAnnotation>): javac.tree.JCTree;
              _matchAttributeToTree(findme: javac.code.Attribute, attr: javac.code.Attribute, tree: javac.tree.JCTree): javac.tree.JCTree;
              _nameToSymbol<S>(module: javac.code.Symbol$ModuleSymbol, nameStr: string, clazz: java.lang.Class<S>): S;
              newRound(): void;
              overrides(riderEl: javax.lang.model.element.ExecutableElement, rideeEl: javax.lang.model.element.ExecutableElement, typeEl: javax.lang.model.element.TypeElement): boolean;
              printElements(w: java.io.Writer, elements: javax.lang.model.element.Element[]): void;
              printElements(w: java.io.Writer, ...elements: javax.lang.model.element.Element[]): void;
              _scanForAssign(sym: javac.code.Symbol$MethodSymbol, tree: javac.tree.JCTree): javac.tree.JCTree$JCExpression;
              _unboundNameToSymbol<S>(methodName: string, nameStr: string, clazz: java.lang.Class<S>): S;
              _allowModules: boolean;
              _alreadyWarnedDuplicates: java.util.Set<string>;
              _enter: javac.comp.Enter;
              _javaCompiler: javac.main.JavaCompiler;
              _javacTaskImpl: javac.api.JavacTaskImpl;
              _log: javac.util.Log;
              _modules: javac.comp.Modules;
              _names: javac.util.Names;
              _resolve: javac.comp.Resolve;
              _resultCache: java.util.Map<javac.util.Pair<string,string>,java.util.Optional<javac.code.Symbol>>;
              _syms: javac.code.Symtab;
              _types: javac.code.Types;
            }
            interface JavacElements extends CombineTypes<[_JavacElements, java.lang.Object, javax.lang.model.util.Elements]> {}
            interface _JavacTypes$$static extends ClassLike {
              _cast<T>(clazz: java.lang.Class<T>, o: any): T;
              instance(context: javac.util.Context): JavacTypes;
              _EXEC_OR_PKG_OR_MOD: java.util.Set<javax.lang.model.type.TypeKind>;
              _new(context: javac.util.Context): JavacTypes;
            }
            let JavacTypes: _JavacTypes$$static;
            interface _JavacTypes {
              asElement(t: javax.lang.model.type.TypeMirror): javax.lang.model.element.Element;
              asMemberOf(containing: javax.lang.model.type.DeclaredType, element: javax.lang.model.element.Element): javax.lang.model.type.TypeMirror;
              boxedClass(p: javax.lang.model.type.PrimitiveType): javax.lang.model.element.TypeElement;
              capture(t: javax.lang.model.type.TypeMirror): javax.lang.model.type.TypeMirror;
              contains(t1: javax.lang.model.type.TypeMirror, t2: javax.lang.model.type.TypeMirror): boolean;
              directSupertypes(t: javax.lang.model.type.TypeMirror): java.util.List<javac.code.Type>;
              erasure(t: javax.lang.model.type.TypeMirror): javax.lang.model.type.TypeMirror;
              getArrayType(componentType: javax.lang.model.type.TypeMirror): javax.lang.model.type.ArrayType;
              getDeclaredType(typeElem: javax.lang.model.element.TypeElement, typeArgs: javax.lang.model.type.TypeMirror[]): javax.lang.model.type.DeclaredType;
              getDeclaredType(typeElem: javax.lang.model.element.TypeElement, ...typeArgs: javax.lang.model.type.TypeMirror[]): javax.lang.model.type.DeclaredType;
              getDeclaredType(enclosing: javax.lang.model.type.DeclaredType, typeElem: javax.lang.model.element.TypeElement, typeArgs: javax.lang.model.type.TypeMirror[]): javax.lang.model.type.DeclaredType;
              getDeclaredType(enclosing: javax.lang.model.type.DeclaredType, typeElem: javax.lang.model.element.TypeElement, ...typeArgs: javax.lang.model.type.TypeMirror[]): javax.lang.model.type.DeclaredType;
              _getDeclaredType0(outer: javac.code.Type, sym: javac.code.Symbol$ClassSymbol, typeArgs: javax.lang.model.type.TypeMirror[]): javax.lang.model.type.DeclaredType;
              _getDeclaredType0(outer: javac.code.Type, sym: javac.code.Symbol$ClassSymbol, ...typeArgs: javax.lang.model.type.TypeMirror[]): javax.lang.model.type.DeclaredType;
              getNoType(kind: javax.lang.model.type.TypeKind): javax.lang.model.type.NoType;
              getNullType(): javax.lang.model.type.NullType;
              getOverriddenMethods(elem: javax.lang.model.element.Element): java.util.Set<javac.code.Symbol$MethodSymbol>;
              getPrimitiveType(kind: javax.lang.model.type.TypeKind): javax.lang.model.type.PrimitiveType;
              getWildcardType(extendsBound: javax.lang.model.type.TypeMirror, superBound: javax.lang.model.type.TypeMirror): javax.lang.model.type.WildcardType;
              isAssignable(t1: javax.lang.model.type.TypeMirror, t2: javax.lang.model.type.TypeMirror): boolean;
              isSameType(t1: javax.lang.model.type.TypeMirror, t2: javax.lang.model.type.TypeMirror): boolean;
              isSubsignature(m1: javax.lang.model.type.ExecutableType, m2: javax.lang.model.type.ExecutableType): boolean;
              isSubtype(t1: javax.lang.model.type.TypeMirror, t2: javax.lang.model.type.TypeMirror): boolean;
              unboxedType(t: javax.lang.model.type.TypeMirror): javax.lang.model.type.PrimitiveType;
              _validateTypeNotIn(t: javax.lang.model.type.TypeMirror, invalidKinds: java.util.Set<javax.lang.model.type.TypeKind>): void;
              _syms: javac.code.Symtab;
              _types: javac.code.Types;
            }
            interface JavacTypes extends CombineTypes<[_JavacTypes, java.lang.Object, javax.lang.model.util.Types]> {}
          }
          module parser {
            interface _DocCommentParser$$static extends ClassLike {
              new(fac: ParserFactory, diagSource: javac.util.DiagnosticSource, comment: Tokens$Comment, isFileContent: boolean): DocCommentParser;
              new(fac: ParserFactory, diagSource: javac.util.DiagnosticSource, comment: Tokens$Comment): DocCommentParser;
            }
            let DocCommentParser: _DocCommentParser$$static;
            interface _DocCommentParser {
              _addPendingText(list: javac.util.ListBuffer<javac.tree.DCTree>, textEnd: int): void;
              _attrValueChar(list: javac.util.ListBuffer<javac.tree.DCTree>): void;
              _blockContent(): javac.util.List<javac.tree.DCTree>;
              _blockContent(phase: DocCommentParser$Phase): javac.util.List<javac.tree.DCTree>;
              _blockTag(): javac.tree.DCTree;
              _blockTags(): javac.util.List<javac.tree.DCTree>;
              _createTagParsers(): java.util.Map<javac.util.Name,DocCommentParser$TagParser>;
              _entity(list: javac.util.ListBuffer<javac.tree.DCTree>): void;
              _entity(): javac.tree.DCTree;
              _erroneous(code: string, pos: int): javac.tree.DCTree$DCErroneous;
              _erroneous(code: string, pos: int, pref: int): javac.tree.DCTree$DCErroneous;
              _html(): javac.tree.DCTree;
              _htmlAttrs(): javac.util.List<javac.tree.DCTree>;
              _identifier(): javac.tree.DCTree$DCIdentifier;
              _inlineContent(): javac.util.List<javac.tree.DCTree>;
              _inlineTag(list: javac.util.ListBuffer<javac.tree.DCTree>): void;
              _inlineTag(): javac.tree.DCTree;
              _inlineText(whitespacePolicy: DocCommentParser$WhitespaceRetentionPolicy): javac.tree.DCTree$DCText;
              _inlineWord(): javac.tree.DCTree$DCText;
              _isDecimalDigit(ch: char): boolean;
              _isEndBody(): boolean;
              _isEndPreamble(): boolean;
              _isHexDigit(ch: char): boolean;
              _isHorizontalWhitespace(ch: char): boolean;
              _isIdentifierStart(ch: char): boolean;
              _isJavaIdentifierStart(ch: char): boolean;
              _isUnquotedAttrValueTerminator(ch: char): boolean;
              _isWhitespace(ch: char): boolean;
              _newString(start: int, end: int): string;
              _nextChar(): void;
              parse(): javac.tree.DCTree$DCDocComment;
              _peek(s: string): boolean;
              _peekChar(): char;
              _quotedString(): javac.tree.DCTree$DCText;
              _readAttributeName(): javac.util.Name;
              _readIdentifier(): javac.util.Name;
              _readJavaIdentifier(): javac.util.Name;
              _readSystemPropertyName(): javac.util.Name;
              _readTagName(): javac.util.Name;
              _reference(mode: ReferenceParser$Mode): javac.tree.DCTree$DCReference;
              _skipWhitespace(): void;
              _bp: int;
              _buf: char[];
              _buflen: int;
              _ch: char;
              _comment: Tokens$Comment;
              _diagSource: javac.util.DiagnosticSource;
              _diags: javac.util.JCDiagnostic$Factory;
              _fac: ParserFactory;
              _isFileContent: boolean;
              _lastNonWhite: int;
              _m: javac.tree.DocTreeMaker;
              _names: javac.util.Names;
              _newline: boolean;
              _tagParsers: java.util.Map<javac.util.Name,DocCommentParser$TagParser>;
              _textStart: int;
            }
            interface DocCommentParser extends CombineTypes<[_DocCommentParser, java.lang.Object]> {}
            interface _DocCommentParser$ParseException$$static extends ClassLike {
              _serialVersionUID: long;
              _new(key: string): DocCommentParser$ParseException;
              _new(pos: int, key: string): DocCommentParser$ParseException;
            }
            let DocCommentParser$ParseException: _DocCommentParser$ParseException$$static;
            interface _DocCommentParser$ParseException {
              _pos: int;
            }
            interface DocCommentParser$ParseException extends CombineTypes<[_DocCommentParser$ParseException, java.lang.Exception]> {}
            interface _DocCommentParser$Phase$$static extends ClassLike {
              valueOf(name: string): DocCommentParser$Phase;
              values(): DocCommentParser$Phase[];
              readonly BODY: DocCommentParser$Phase;
              readonly POSTAMBLE: DocCommentParser$Phase;
              readonly PREAMBLE: DocCommentParser$Phase;
            }
            let DocCommentParser$Phase: _DocCommentParser$Phase$$static;
            interface _DocCommentParser$Phase {
            }
            interface DocCommentParser$Phase extends CombineTypes<[_DocCommentParser$Phase]> {}
            interface _DocCommentParser$TagParser$$static extends ClassLike {
              _new(k: DocCommentParser$TagParser$Kind, tk: sun.source.doctree.DocTree$Kind): DocCommentParser$TagParser;
              _new(k: DocCommentParser$TagParser$Kind, tk: sun.source.doctree.DocTree$Kind, retainWhiteSpace: boolean): DocCommentParser$TagParser;
            }
            let DocCommentParser$TagParser: _DocCommentParser$TagParser$$static;
            interface _DocCommentParser$TagParser {
              _allowsBlock(): boolean;
              _allowsInline(): boolean;
              _getTreeKind(): sun.source.doctree.DocTree$Kind;
              _parse(pos: int, kind: DocCommentParser$TagParser$Kind): javac.tree.DCTree;
              _parse(pos: int): javac.tree.DCTree;
              _kind: DocCommentParser$TagParser$Kind;
              _retainWhiteSpace: boolean;
              _treeKind: sun.source.doctree.DocTree$Kind;
            }
            interface DocCommentParser$TagParser extends CombineTypes<[_DocCommentParser$TagParser, java.lang.Object]> {}
            interface _DocCommentParser$TagParser$Kind$$static extends ClassLike {
              valueOf(name: string): DocCommentParser$TagParser$Kind;
              values(): DocCommentParser$TagParser$Kind[];
              readonly BLOCK: DocCommentParser$TagParser$Kind;
              readonly EITHER: DocCommentParser$TagParser$Kind;
              readonly INLINE: DocCommentParser$TagParser$Kind;
            }
            let DocCommentParser$TagParser$Kind: _DocCommentParser$TagParser$Kind$$static;
            interface _DocCommentParser$TagParser$Kind {
            }
            interface DocCommentParser$TagParser$Kind extends CombineTypes<[_DocCommentParser$TagParser$Kind]> {}
            interface _DocCommentParser$WhitespaceRetentionPolicy$$static extends ClassLike {
              valueOf(name: string): DocCommentParser$WhitespaceRetentionPolicy;
              values(): DocCommentParser$WhitespaceRetentionPolicy[];
              readonly REMOVE_ALL: DocCommentParser$WhitespaceRetentionPolicy;
              readonly REMOVE_FIRST_SPACE: DocCommentParser$WhitespaceRetentionPolicy;
              readonly RETAIN_ALL: DocCommentParser$WhitespaceRetentionPolicy;
            }
            let DocCommentParser$WhitespaceRetentionPolicy: _DocCommentParser$WhitespaceRetentionPolicy$$static;
            interface _DocCommentParser$WhitespaceRetentionPolicy {
            }
            interface DocCommentParser$WhitespaceRetentionPolicy extends CombineTypes<[_DocCommentParser$WhitespaceRetentionPolicy]> {}
            interface _JavaTokenizer$$static extends ClassLike {
              _NOT_FOUND: int;
              _scannerDebug: boolean;
              _new(fac: ScannerFactory, cb: java.nio.CharBuffer): JavaTokenizer;
              _new(fac: ScannerFactory, array: char[], length: int): JavaTokenizer;
            }
            let JavaTokenizer: _JavaTokenizer$$static;
            interface _JavaTokenizer {
              _acceptOneOfThenPut(ch1: char, ch2: char): boolean;
              _acceptThenPut(ch: char): boolean;
              _appendComment(comments: javac.util.List<Tokens$Comment>, comment: Tokens$Comment): javac.util.List<Tokens$Comment>;
              _checkIdent(): void;
              _checkSourceLevel(pos: int, feature: javac.code.Source$Feature): void;
              errPos(): int;
              errPos(pos: int): void;
              _fragment(string: string): javac.util.List<string>;
              _getFragments(string: string, comments: javac.util.List<Tokens$Comment>): Tokens$Token;
              getLineMap(): javac.util.Position$LineMap;
              _isSpecial(ch: char): boolean;
              _lexError(pos: int, key: javac.util.JCDiagnostic$Error): void;
              _lexError(flags: javac.util.JCDiagnostic$DiagnosticFlag, pos: int, key: javac.util.JCDiagnostic$Error): void;
              _lexWarning(lc: javac.code.Lint$LintCategory, pos: int, key: javac.util.JCDiagnostic$Warning): void;
              _processComment(pos: int, endPos: int, style: Tokens$Comment$CommentStyle): Tokens$Comment;
              _processLineTerminator(pos: int, endPos: int): void;
              _processWhiteSpace(pos: int, endPos: int): void;
              _put(ch: char): void;
              _put(): void;
              _put(string: string): void;
              _putCodePoint(codePoint: int): void;
              _putThenNext(): char;
              readToken(): Tokens$Token;
              _scanDigits(pos: int, digitRadix: int): void;
              _scanEmbeddedExpression(pos: int, endPos: int): void;
              _scanFraction(pos: int): void;
              _scanFractionAndSuffix(pos: int): void;
              _scanHexExponentAndSuffix(pos: int): void;
              _scanHexFractionAndSuffix(pos: int, seendigit: boolean): void;
              _scanIdent(): void;
              _scanLitChar(pos: int): void;
              _scanNumber(pos: int, radix: int): void;
              _scanOperator(): void;
              _scanString(pos: int): void;
              _skipIllegalUnderscores(): void;
              _skipLineTerminator(): void;
              _errPos: int;
              _fac: ScannerFactory;
              _fragmentRanges: javac.util.List<int>;
              _hasEscapeSequences: boolean;
              _hasStringTemplateErrors: boolean;
              _isStringTemplate: boolean;
              _isTextBlock: boolean;
              _lint: javac.code.Lint;
              _log: javac.util.Log;
              _name: javac.util.Name;
              _names: javac.util.Names;
              _pendingTokens: javac.util.List<Tokens$Token>;
              _preview: javac.code.Preview;
              _radix: int;
              _sb: parser$stringBuilder;
              _source: javac.code.Source;
              _tk: Tokens$TokenKind;
              _tokens: Tokens;
            }
            interface JavaTokenizer extends CombineTypes<[_JavaTokenizer, com.sun.tools.javac.parser.UnicodeReader]> {}
            interface _JavaTokenizer$BasicComment$$static extends ClassLike {
              _new(cs: Tokens$Comment$CommentStyle, reader: UnicodeReader, pos: int, endPos: int): JavaTokenizer$BasicComment;
            }
            let JavaTokenizer$BasicComment: _JavaTokenizer$BasicComment$$static;
            interface _JavaTokenizer$BasicComment {
              getSourcePos(pos: int): int;
              getStyle(): Tokens$Comment$CommentStyle;
              getText(): string;
              isDeprecated(): boolean;
              _putLine(line: UnicodeReader): void;
              _scanDocComment(): void;
              _trimEndOfComment(line: UnicodeReader): UnicodeReader;
              _trimJavadocComment(line: UnicodeReader): UnicodeReader;
              _cs: Tokens$Comment$CommentStyle;
              _deprecatedFlag: boolean;
              _scanned: boolean;
            }
            interface JavaTokenizer$BasicComment extends CombineTypes<[_JavaTokenizer$BasicComment, com.sun.tools.javac.parser.UnicodeReader$PositionTrackingReader, com.sun.tools.javac.parser.Tokens$Comment]> {}
            interface _JavacParser$$static extends ClassLike {
              _earlier(pos1: int, pos2: int): int;
              _optag(token: Tokens$TokenKind): javac.tree.JCTree$Tag;
              _prec(token: Tokens$TokenKind): int;
              _typetag(token: Tokens$TokenKind): javac.code.TypeTag;
              _unoptag(token: Tokens$TokenKind): javac.tree.JCTree$Tag;
              _DIAMOND: int;
              _EXPR: int;
              _NOLAMBDA: int;
              _NOPARAMS: int;
              _RECOVERY_THRESHOLD: int;
              _TYPE: int;
              _TYPEARG: int;
              _decisionTable: javac.util.JCDiagnostic$Fragment[][];
              _infixPrecedenceLevels: int;
              _new(fac: ParserFactory, S: Lexer, keepDocComments: boolean, keepLineMap: boolean, keepEndPositions: boolean): JavacParser;
              _new(fac: ParserFactory, S: Lexer, keepDocComments: boolean, keepLineMap: boolean, keepEndPositions: boolean, parseModuleInfo: boolean): JavacParser;
              _new(parser: JavacParser, S: Lexer): JavacParser;
            }
            let JavacParser: _JavacParser$$static;
            interface _JavacParser {
              accept(tk: Tokens$TokenKind): void;
              accept(tk: Tokens$TokenKind, errorProvider: java.util.function.Function<Tokens$TokenKind,javac.util.JCDiagnostic$Error>): void;
              _allowedAfterSealedOrNonSealed(next: Tokens$Token, local: boolean, currentIsNonSealed: boolean): boolean;
              _analyzeParens(): JavacParser$ParensResult;
              _analyzePattern(lookahead: int): JavacParser$PatternResult;
              _annotation(pos: int, kind: javac.tree.JCTree$Tag): javac.tree.JCTree$JCAnnotation;
              _annotationFieldValue(): javac.tree.JCTree$JCExpression;
              _annotationFieldValues(): javac.util.List<javac.tree.JCTree$JCExpression>;
              _annotationFieldValuesOpt(): javac.util.List<javac.tree.JCTree$JCExpression>;
              _annotationValue(): javac.tree.JCTree$JCExpression;
              _annotationsOpt(kind: javac.tree.JCTree$Tag): javac.util.List<javac.tree.JCTree$JCAnnotation>;
              _arguments(): javac.util.List<javac.tree.JCTree$JCExpression>;
              _arguments(typeArgs: javac.util.List<javac.tree.JCTree$JCExpression>, t: javac.tree.JCTree$JCExpression): javac.tree.JCTree$JCExpression;
              _argumentsOpt(typeArgs: javac.util.List<javac.tree.JCTree$JCExpression>, t: javac.tree.JCTree$JCExpression): javac.tree.JCTree$JCExpression;
              _arrayCreatorRest(newpos: int, elemtype: javac.tree.JCTree$JCExpression): javac.tree.JCTree$JCExpression;
              _arrayInitializer(newpos: int, t: javac.tree.JCTree$JCExpression): javac.tree.JCTree$JCExpression;
              _arrayInitializerElements(newpos: int, t: javac.tree.JCTree$JCExpression): javac.util.List<javac.tree.JCTree$JCExpression>;
              _attach(tree: javac.tree.JCTree, dc: Tokens$Comment): void;
              _basicType(): javac.tree.JCTree$JCPrimitiveTypeTree;
              _block(pos: int, flags: long): javac.tree.JCTree$JCBlock;
              block(): javac.tree.JCTree$JCBlock;
              _blockStatement(): javac.util.List<javac.tree.JCTree$JCStatement>;
              _blockStatements(): javac.util.List<javac.tree.JCTree$JCStatement>;
              _bracketsOpt(t: javac.tree.JCTree$JCExpression, annotations: javac.util.List<javac.tree.JCTree$JCAnnotation>): javac.tree.JCTree$JCExpression;
              _bracketsOpt(t: javac.tree.JCTree$JCExpression): javac.tree.JCTree$JCExpression;
              _bracketsOptCont(t: javac.tree.JCTree$JCExpression, pos: int, annotations: javac.util.List<javac.tree.JCTree$JCAnnotation>): javac.tree.JCTree$JCExpression;
              _bracketsSuffix(t: javac.tree.JCTree$JCExpression): javac.tree.JCTree$JCExpression;
              _catchClause(): javac.tree.JCTree$JCCatch;
              _catchTypes(): javac.util.List<javac.tree.JCTree$JCExpression>;
              _checkExprStat(t: javac.tree.JCTree$JCExpression): javac.tree.JCTree$JCExpression;
              _checkNoMods(mods: long): void;
              _checkNoMods(pos: int, mods: long): void;
              _checkSourceLevel(feature: javac.code.Source$Feature): void;
              _checkSourceLevel(pos: int, feature: javac.code.Source$Feature): void;
              _classCreatorRest(newpos: int, encl: javac.tree.JCTree$JCExpression, typeArgs: javac.util.List<javac.tree.JCTree$JCExpression>, t: javac.tree.JCTree$JCExpression): javac.tree.JCTree$JCNewClass;
              _classDeclaration(mods: javac.tree.JCTree$JCModifiers, dc: Tokens$Comment): javac.tree.JCTree$JCClassDecl;
              _classInterfaceOrRecordBody(className: javac.util.Name, isInterface: boolean, isRecord: boolean): javac.util.List<javac.tree.JCTree>;
              _classOrInterfaceOrRecordBodyDeclaration(mods: javac.tree.JCTree$JCModifiers, className: javac.util.Name, isInterface: boolean, isRecord: boolean): javac.util.List<javac.tree.JCTree>;
              _classOrRecordOrInterfaceOrEnumDeclaration(mods: javac.tree.JCTree$JCModifiers, dc: Tokens$Comment): javac.tree.JCTree$JCStatement;
              _constructUnnamedClass(origDefs: javac.util.List<javac.tree.JCTree>): javac.util.List<javac.tree.JCTree>;
              _constructorOrMethodOrFieldDeclaration(mods: javac.tree.JCTree$JCModifiers, className: javac.util.Name, isInterface: boolean, isRecord: boolean, dc: Tokens$Comment): javac.util.List<javac.tree.JCTree>;
              _creator(newpos: int, typeArgs: javac.util.List<javac.tree.JCTree$JCExpression>): javac.tree.JCTree$JCExpression;
              _doRecover(startPos: int, action: JavacParser$ErrorRecoveryAction, errorKey: javac.util.JCDiagnostic$Error): javac.tree.JCTree$JCStatement;
              _enumBody(enumName: javac.util.Name): javac.util.List<javac.tree.JCTree>;
              _enumDeclaration(mods: javac.tree.JCTree$JCModifiers, dc: Tokens$Comment): javac.tree.JCTree$JCClassDecl;
              _enumeratorDeclaration(enumName: javac.util.Name): javac.tree.JCTree;
              _estimateEnumeratorOrMember(enumName: javac.util.Name): JavacParser$EnumeratorEstimate;
              _foldIfNeeded(tree: javac.tree.JCTree$JCExpression, litBuf: javac.util.ListBuffer<javac.tree.JCTree$JCLiteral>, opStack: javac.util.ListBuffer<javac.tree.JCTree$JCExpression>, last: boolean): boolean;
              _foldStrings(tree: javac.tree.JCTree$JCExpression): javac.tree.JCTree$JCExpression;
              _forInit(): javac.util.List<javac.tree.JCTree$JCStatement>;
              _forUpdate(): javac.util.List<javac.tree.JCTree$JCExpressionStatement>;
              _formalParameter(lambdaParameter: boolean, recordComponent: boolean): javac.tree.JCTree$JCVariableDecl;
              _formalParameters(): javac.util.List<javac.tree.JCTree$JCVariableDecl>;
              _formalParameters(lambdaParameters: boolean, recordComponents: boolean): javac.util.List<javac.tree.JCTree$JCVariableDecl>;
              getEndPos(tree: javac.tree.JCTree): int;
              getStartPos(tree: javac.tree.JCTree): int;
              ident(): javac.util.Name;
              _ident(allowClass: boolean): javac.util.Name;
              _ident(allowClass: boolean, asVariable: boolean): javac.util.Name;
              identOrUnderscore(): javac.util.Name;
              _illegal(pos: int): javac.tree.JCTree$JCExpression;
              _illegal(): javac.tree.JCTree$JCExpression;
              _implicitParameter(): javac.tree.JCTree$JCVariableDecl;
              _implicitParameters(hasParens: boolean): javac.util.List<javac.tree.JCTree$JCVariableDecl>;
              _importDeclaration(): javac.tree.JCTree;
              _innerCreator(newpos: int, typeArgs: javac.util.List<javac.tree.JCTree$JCExpression>, encl: javac.tree.JCTree$JCExpression): javac.tree.JCTree$JCExpression;
              _insertAnnotationsToMostInner(type: javac.tree.JCTree$JCExpression, annos: javac.util.List<javac.tree.JCTree$JCAnnotation>, createNewLevel: boolean): javac.tree.JCTree$JCExpression;
              _interfaceDeclaration(mods: javac.tree.JCTree$JCModifiers, dc: Tokens$Comment): javac.tree.JCTree$JCClassDecl;
              _isDeclaration(): boolean;
              _isInvalidUnqualifiedMethodIdentifier(pos: int, name: javac.util.Name): boolean;
              _isMode(mode: int): boolean;
              _isNonSealedClassStart(local: boolean): boolean;
              _isNonSealedIdentifier(someToken: Tokens$Token, lookAheadOffset: int): boolean;
              _isRecordStart(): boolean;
              _isSealedClassStart(local: boolean): boolean;
              _isUnboundMemberRef(): boolean;
              _isZero(s: string): boolean;
              _lambdaExpression(args: javac.util.List<javac.tree.JCTree$JCVariableDecl>, pos: int): javac.tree.JCTree$JCExpression;
              _lambdaExpressionOrStatement(hasParens: boolean, explicitParams: boolean, pos: int): javac.tree.JCTree$JCExpression;
              _lambdaExpressionOrStatementRest(args: javac.util.List<javac.tree.JCTree$JCVariableDecl>, pos: int): javac.tree.JCTree$JCExpression;
              _lambdaStatement(args: javac.util.List<javac.tree.JCTree$JCVariableDecl>, pos: int, pos2: int): javac.tree.JCTree$JCExpression;
              _literal(prefix: javac.util.Name): javac.tree.JCTree$JCExpression;
              _literal(prefix: javac.util.Name, pos: int): javac.tree.JCTree$JCExpression;
              _localVariableDeclarations(mods: javac.tree.JCTree$JCModifiers, type: javac.tree.JCTree$JCExpression): javac.util.List<javac.tree.JCTree$JCStatement>;
              _memberReferenceSuffix(t: javac.tree.JCTree$JCExpression): javac.tree.JCTree$JCExpression;
              _memberReferenceSuffix(pos1: int, t: javac.tree.JCTree$JCExpression): javac.tree.JCTree$JCExpression;
              _merge(litBuf: javac.util.ListBuffer<javac.tree.JCTree$JCLiteral>, opStack: javac.util.ListBuffer<javac.tree.JCTree$JCExpression>): boolean;
              _methodDeclaratorRest(pos: int, mods: javac.tree.JCTree$JCModifiers, type: javac.tree.JCTree$JCExpression, name: javac.util.Name, typarams: javac.util.List<javac.tree.JCTree$JCTypeParameter>, isInterface: boolean, isVoid: boolean, isRecord: boolean, dc: Tokens$Comment): javac.tree.JCTree;
              _modifiersOpt(): javac.tree.JCTree$JCModifiers;
              _modifiersOpt(partial: javac.tree.JCTree$JCModifiers): javac.tree.JCTree$JCModifiers;
              _moduleDecl(mods: javac.tree.JCTree$JCModifiers, kind: sun.source.tree.ModuleTree$ModuleKind, dc: Tokens$Comment): javac.tree.JCTree$JCModuleDecl;
              _moduleDirectiveList(): javac.util.List<javac.tree.JCTree$JCDirective>;
              _moreStatementExpressions<T>(pos: int, first: javac.tree.JCTree$JCExpression, stats: T): T;
              _newDocCommentTable(keepDocComments: boolean, fac: ParserFactory): javac.tree.DocCommentTable;
              _newEndPosTable(keepEndPositions: boolean): JavacParser$AbstractEndPosTable;
              _newOdStack(): javac.tree.JCTree$JCExpression[];
              _newOpStack(): Tokens$Token[];
              nextToken(): void;
              _optFinal(flags: long): javac.tree.JCTree$JCModifiers;
              _parExpression(): javac.tree.JCTree$JCExpression;
              _parseCaseLabel(allowDefault: boolean): javac.tree.JCTree$JCCaseLabel;
              parseCompilationUnit(): javac.tree.JCTree$JCCompilationUnit;
              parseExpression(): javac.tree.JCTree$JCExpression;
              _parseGuard(label: javac.tree.JCTree$JCCaseLabel): javac.tree.JCTree$JCExpression;
              parsePattern(pos: int, mods: javac.tree.JCTree$JCModifiers, parsedType: javac.tree.JCTree$JCExpression, allowVar: boolean, checkGuard: boolean): javac.tree.JCTree$JCPattern;
              parseSimpleStatement(): javac.tree.JCTree$JCStatement;
              parseStatement(): javac.tree.JCTree$JCStatement;
              _parseStatementAsBlock(): javac.tree.JCTree$JCStatement;
              parseType(): javac.tree.JCTree$JCExpression;
              parseType(allowVar: boolean): javac.tree.JCTree$JCExpression;
              parseType(allowVar: boolean, annotations: javac.util.List<javac.tree.JCTree$JCAnnotation>): javac.tree.JCTree$JCExpression;
              _peekToken(tk: java.util.function.Predicate<Tokens$TokenKind>): boolean;
              _peekToken(lookahead: int, tk: java.util.function.Predicate<Tokens$TokenKind>): boolean;
              _peekToken(tk1: java.util.function.Predicate<Tokens$TokenKind>, tk2: java.util.function.Predicate<Tokens$TokenKind>): boolean;
              _peekToken(lookahead: int, tk1: java.util.function.Predicate<Tokens$TokenKind>, tk2: java.util.function.Predicate<Tokens$TokenKind>): boolean;
              _peekToken(tk1: java.util.function.Predicate<Tokens$TokenKind>, tk2: java.util.function.Predicate<Tokens$TokenKind>, tk3: java.util.function.Predicate<Tokens$TokenKind>): boolean;
              _peekToken(lookahead: int, tk1: java.util.function.Predicate<Tokens$TokenKind>, tk2: java.util.function.Predicate<Tokens$TokenKind>, tk3: java.util.function.Predicate<Tokens$TokenKind>): boolean;
              _peekToken(kinds: java.util.function.Predicate<Tokens$TokenKind>[]): boolean;
              _peekToken(...kinds: java.util.function.Predicate<Tokens$TokenKind>[]): boolean;
              _peekToken(lookahead: int, kinds: java.util.function.Predicate<Tokens$TokenKind>[]): boolean;
              _peekToken(lookahead: int, ...kinds: java.util.function.Predicate<Tokens$TokenKind>[]): boolean;
              _permitsClause(mods: javac.tree.JCTree$JCModifiers, classOrInterface: string): javac.util.List<javac.tree.JCTree$JCExpression>;
              qualident(allowAnnos: boolean): javac.tree.JCTree$JCExpression;
              _qualidentList(allowAnnos: boolean): javac.util.List<javac.tree.JCTree$JCExpression>;
              _recordDeclaration(mods: javac.tree.JCTree$JCModifiers, dc: Tokens$Comment): javac.tree.JCTree$JCClassDecl;
              _reportSyntaxError(pos: int, errorKey: javac.util.JCDiagnostic$Error): void;
              _reportSyntaxError(diagPos: javac.util.JCDiagnostic$DiagnosticPosition, errorKey: javac.util.JCDiagnostic$Error): void;
              _resource(): javac.tree.JCTree;
              _resources(): javac.util.List<javac.tree.JCTree>;
              _restrictedTypeName(e: javac.tree.JCTree$JCExpression, shouldWarn: boolean): javac.util.Name;
              _restrictedTypeNameStartingAtSource(name: javac.util.Name, pos: int, shouldWarn: boolean): javac.code.Source;
              _selectExprMode(): void;
              _selectTypeMode(): void;
              _setErrorEndPos(errPos: int): void;
              _setLastMode(mode: int): void;
              _setMode(mode: int): void;
              _skip(stopAtImport: boolean, stopAtMemberDecl: boolean, stopAtIdentifier: boolean, stopAtStatement: boolean): void;
              _skipAnnotation(lookahead: int): int;
              _storeEnd(tree: javac.tree.JCTree, endpos: int): void;
              _stringLiteral(tree: javac.tree.JCTree): javac.tree.JCTree$JCLiteral;
              _stringTemplate(processor: javac.tree.JCTree$JCExpression): javac.tree.JCTree$JCExpression;
              _strval(prefix: javac.util.Name): string;
              _superSuffix(typeArgs: javac.util.List<javac.tree.JCTree$JCExpression>, t: javac.tree.JCTree$JCExpression): javac.tree.JCTree$JCExpression;
              _switchBlockStatementGroup(): javac.util.List<javac.tree.JCTree$JCCase>;
              _switchBlockStatementGroups(): javac.util.List<javac.tree.JCTree$JCCase>;
              _switchExpressionStatementGroup(): javac.util.List<javac.tree.JCTree$JCCase>;
              _syntaxError(pos: int, errorKey: javac.util.JCDiagnostic$Error): javac.tree.JCTree$JCErroneous;
              _syntaxError(pos: int, errs: javac.util.List<javac.tree.JCTree>, errorKey: javac.util.JCDiagnostic$Error): javac.tree.JCTree$JCErroneous;
              _term(newmode: int): javac.tree.JCTree$JCExpression;
              _term(): javac.tree.JCTree$JCExpression;
              _term1(): javac.tree.JCTree$JCExpression;
              _term1Rest(t: javac.tree.JCTree$JCExpression): javac.tree.JCTree$JCExpression;
              _term2(): javac.tree.JCTree$JCExpression;
              _term2Rest(t: javac.tree.JCTree$JCExpression, minprec: int): javac.tree.JCTree$JCExpression;
              _term3(): javac.tree.JCTree$JCExpression;
              _term3Rest(t: javac.tree.JCTree$JCExpression, typeArgs: javac.util.List<javac.tree.JCTree$JCExpression>): javac.tree.JCTree$JCExpression;
              _termRest(t: javac.tree.JCTree$JCExpression): javac.tree.JCTree$JCExpression;
              _to<T>(t: T): T;
              _toP<T>(t: T): T;
              token(): Tokens$Token;
              _topLevelMethodOrFieldDeclaration(mods: javac.tree.JCTree$JCModifiers): javac.util.List<javac.tree.JCTree>;
              _typeAnnotationsOpt(): javac.util.List<javac.tree.JCTree$JCAnnotation>;
              _typeArgument(): javac.tree.JCTree$JCExpression;
              _typeArguments(diamondAllowed: boolean): javac.util.List<javac.tree.JCTree$JCExpression>;
              _typeArguments(t: javac.tree.JCTree$JCExpression, diamondAllowed: boolean): javac.tree.JCTree$JCTypeApply;
              _typeArgumentsOpt(t: javac.tree.JCTree$JCExpression): javac.tree.JCTree$JCExpression;
              _typeArgumentsOpt(): javac.util.List<javac.tree.JCTree$JCExpression>;
              _typeArgumentsOpt(useMode: int): javac.util.List<javac.tree.JCTree$JCExpression>;
              _typeDeclaration(mods: javac.tree.JCTree$JCModifiers, docComment: Tokens$Comment): javac.tree.JCTree;
              _typeList(): javac.util.List<javac.tree.JCTree$JCExpression>;
              _typeName(): javac.util.Name;
              _typeParameter(): javac.tree.JCTree$JCTypeParameter;
              _typeParametersOpt(): javac.util.List<javac.tree.JCTree$JCTypeParameter>;
              _typeParametersOpt(parseEmpty: boolean): javac.util.List<javac.tree.JCTree$JCTypeParameter>;
              unannotatedType(allowVar: boolean): javac.tree.JCTree$JCExpression;
              unannotatedType(allowVar: boolean, newmode: int): javac.tree.JCTree$JCExpression;
              _variableDeclarator(mods: javac.tree.JCTree$JCModifiers, type: javac.tree.JCTree$JCExpression, reqInit: boolean, dc: Tokens$Comment, localDecl: boolean): javac.tree.JCTree$JCVariableDecl;
              _variableDeclaratorId(mods: javac.tree.JCTree$JCModifiers, type: javac.tree.JCTree$JCExpression, catchParameter: boolean, lambdaParameter: boolean, recordComponent: boolean): javac.tree.JCTree$JCVariableDecl;
              _variableDeclaratorRest(pos: int, mods: javac.tree.JCTree$JCModifiers, type: javac.tree.JCTree$JCExpression, name: javac.util.Name, reqInit: boolean, dc: Tokens$Comment, localDecl: boolean, compound: boolean): javac.tree.JCTree$JCVariableDecl;
              variableDeclarators<T>(mods: javac.tree.JCTree$JCModifiers, type: javac.tree.JCTree$JCExpression, vdefs: T, localDecl: boolean): T;
              _variableDeclaratorsRest<T>(pos: int, mods: javac.tree.JCTree$JCModifiers, type: javac.tree.JCTree$JCExpression, name: javac.util.Name, reqInit: boolean, dc: Tokens$Comment, vdefs: T, localDecl: boolean): T;
              variableInitializer(): javac.tree.JCTree$JCExpression;
              _wasTypeMode(): boolean;
              _F: javac.tree.TreeMaker;
              _LAX_IDENTIFIER: java.util.function.Predicate<Tokens$TokenKind>;
              _S: Lexer;
              _allowRecords: boolean;
              _allowSealedTypes: boolean;
              _allowStringFolding: boolean;
              _allowThisIdent: boolean;
              _allowYieldStatement: boolean;
              _count: int;
              _docComments: javac.tree.DocCommentTable;
              _endPosTable: JavacParser$AbstractEndPosTable;
              _errorPos: int;
              _errorTree: javac.tree.JCTree$JCErroneous;
              _keepDocComments: boolean;
              _keepLineMap: boolean;
              _lastmode: int;
              _log: javac.util.Log;
              _mode: int;
              _names: javac.util.Names;
              _odStackSupply: java.util.ArrayList<javac.tree.JCTree$JCExpression[]>;
              _opStackSupply: java.util.ArrayList<Tokens$Token[]>;
              _parseModuleInfo: boolean;
              _permitTypeAnnotationsPushBack: boolean;
              _preview: javac.code.Preview;
              _receiverParam: javac.tree.JCTree$JCVariableDecl;
              _source: javac.code.Source;
              _token: Tokens$Token;
              _typeAnnotationsPushedBack: javac.util.List<javac.tree.JCTree$JCAnnotation>;
            }
            interface JavacParser extends CombineTypes<[_JavacParser, com.sun.tools.javac.parser.Parser, java.lang.Object]> {}
            interface _JavacParser$AbstractEndPosTable$$static extends ClassLike {
              new(parser: JavacParser): JavacParser$AbstractEndPosTable;
            }
            let JavacParser$AbstractEndPosTable: _JavacParser$AbstractEndPosTable$$static;
            interface _JavacParser$AbstractEndPosTable {
              setErrorEndPos(errPos: int): void;
              setParser(parser: JavacParser): void;
              _to<T>(a0: T): T;
              _toP<T>(a0: T): T;
              errorEndPos: int;
              _parser: JavacParser;
            }
            interface JavacParser$AbstractEndPosTable extends CombineTypes<[_JavacParser$AbstractEndPosTable, com.sun.tools.javac.tree.EndPosTable, java.lang.Object]> {}
            interface _JavacParser$BasicErrorRecoveryAction$$static extends ClassLike {
              valueOf(name: string): JavacParser$BasicErrorRecoveryAction;
              values(): JavacParser$BasicErrorRecoveryAction[];
              readonly BLOCK_STMT: JavacParser$BasicErrorRecoveryAction;
              readonly CATCH_CLAUSE: JavacParser$BasicErrorRecoveryAction;
            }
            let JavacParser$BasicErrorRecoveryAction: _JavacParser$BasicErrorRecoveryAction$$static;
            interface _JavacParser$BasicErrorRecoveryAction {
            }
            interface JavacParser$BasicErrorRecoveryAction extends CombineTypes<[_JavacParser$BasicErrorRecoveryAction, JavacParser$ErrorRecoveryAction]> {}
            interface _JavacParser$EmptyEndPosTable$$static extends ClassLike {
              _new(parser: JavacParser): JavacParser$EmptyEndPosTable;
            }
            let JavacParser$EmptyEndPosTable: _JavacParser$EmptyEndPosTable$$static;
            interface _JavacParser$EmptyEndPosTable {
              getEndPos(tree: javac.tree.JCTree): int;
              replaceTree(oldTree: javac.tree.JCTree, newTree: javac.tree.JCTree): int;
              storeEnd(tree: javac.tree.JCTree, endpos: int): void;
              _to<T>(t: T): T;
              _toP<T>(t: T): T;
            }
            interface JavacParser$EmptyEndPosTable extends CombineTypes<[_JavacParser$EmptyEndPosTable, com.sun.tools.javac.parser.JavacParser$AbstractEndPosTable]> {}
            interface _JavacParser$EnumeratorEstimate$$static extends ClassLike {
              valueOf(name: string): JavacParser$EnumeratorEstimate;
              values(): JavacParser$EnumeratorEstimate[];
              readonly ENUMERATOR: JavacParser$EnumeratorEstimate;
              readonly MEMBER: JavacParser$EnumeratorEstimate;
              readonly UNKNOWN: JavacParser$EnumeratorEstimate;
            }
            let JavacParser$EnumeratorEstimate: _JavacParser$EnumeratorEstimate$$static;
            interface _JavacParser$EnumeratorEstimate {
            }
            interface JavacParser$EnumeratorEstimate extends CombineTypes<[_JavacParser$EnumeratorEstimate]> {}
            interface _JavacParser$ErrorRecoveryAction$$static extends ClassLike {
            }
            let JavacParser$ErrorRecoveryAction: _JavacParser$ErrorRecoveryAction$$static;
            interface _JavacParser$ErrorRecoveryAction {
              doRecover(a0: JavacParser): javac.tree.JCTree;
(a0: JavacParser): javac.tree.JCTree;
            }
            interface JavacParser$ErrorRecoveryAction extends CombineTypes<[_JavacParser$ErrorRecoveryAction, java.lang.Object]> {}
            interface _JavacParser$LambdaClassifier$$static extends ClassLike {
              _new(this$0: JavacParser): JavacParser$LambdaClassifier;
            }
            let JavacParser$LambdaClassifier: _JavacParser$LambdaClassifier$$static;
            interface _JavacParser$LambdaClassifier {
              _addParameter(param: javac.tree.JCTree$JCVariableDecl): void;
              _reduce(newKind: JavacParser$LambdaParameterKind): void;
              _result(): JavacParser$LambdaParameterKind;
              _diagFragment: javac.util.JCDiagnostic$Fragment;
              _kind: JavacParser$LambdaParameterKind;
              _this$0: JavacParser;
            }
            interface JavacParser$LambdaClassifier extends CombineTypes<[_JavacParser$LambdaClassifier, java.lang.Object]> {}
            interface _JavacParser$LambdaParameterKind$$static extends ClassLike {
              valueOf(name: string): JavacParser$LambdaParameterKind;
              values(): JavacParser$LambdaParameterKind[];
              readonly ERROR: JavacParser$LambdaParameterKind;
              readonly EXPLICIT: JavacParser$LambdaParameterKind;
              readonly IMPLICIT: JavacParser$LambdaParameterKind;
              readonly VAR: JavacParser$LambdaParameterKind;
            }
            let JavacParser$LambdaParameterKind: _JavacParser$LambdaParameterKind$$static;
            interface _JavacParser$LambdaParameterKind {
              _index: int;
            }
            interface JavacParser$LambdaParameterKind extends CombineTypes<[_JavacParser$LambdaParameterKind]> {}
            interface _JavacParser$ParensResult$$static extends ClassLike {
              valueOf(name: string): JavacParser$ParensResult;
              values(): JavacParser$ParensResult[];
              readonly CAST: JavacParser$ParensResult;
              readonly EXPLICIT_LAMBDA: JavacParser$ParensResult;
              readonly IMPLICIT_LAMBDA: JavacParser$ParensResult;
              readonly PARENS: JavacParser$ParensResult;
            }
            let JavacParser$ParensResult: _JavacParser$ParensResult$$static;
            interface _JavacParser$ParensResult {
            }
            interface JavacParser$ParensResult extends CombineTypes<[_JavacParser$ParensResult]> {}
            interface _JavacParser$PatternResult$$static extends ClassLike {
              valueOf(name: string): JavacParser$PatternResult;
              values(): JavacParser$PatternResult[];
              readonly EXPRESSION: JavacParser$PatternResult;
              readonly PATTERN: JavacParser$PatternResult;
            }
            let JavacParser$PatternResult: _JavacParser$PatternResult$$static;
            interface _JavacParser$PatternResult {
            }
            interface JavacParser$PatternResult extends CombineTypes<[_JavacParser$PatternResult]> {}
            interface _JavacParser$SimpleEndPosTable$$static extends ClassLike {
              _new(parser: JavacParser): JavacParser$SimpleEndPosTable;
            }
            let JavacParser$SimpleEndPosTable: _JavacParser$SimpleEndPosTable$$static;
            interface _JavacParser$SimpleEndPosTable {
              getEndPos(tree: javac.tree.JCTree): int;
              replaceTree(oldTree: javac.tree.JCTree, newTree: javac.tree.JCTree): int;
              storeEnd(tree: javac.tree.JCTree, endpos: int): void;
              _to<T>(t: T): T;
              _toP<T>(t: T): T;
              _endPosMap: javac.util.IntHashTable;
            }
            interface JavacParser$SimpleEndPosTable extends CombineTypes<[_JavacParser$SimpleEndPosTable, com.sun.tools.javac.parser.JavacParser$AbstractEndPosTable]> {}
            interface _JavadocTokenizer$$static extends ClassLike {
              _new(fac: ScannerFactory, cb: java.nio.CharBuffer): JavadocTokenizer;
              _new(fac: ScannerFactory, array: char[], length: int): JavadocTokenizer;
            }
            let JavadocTokenizer: _JavadocTokenizer$$static;
            interface _JavadocTokenizer {
              getLineMap(): javac.util.Position$LineMap;
              _processComment(pos: int, endPos: int, style: Tokens$Comment$CommentStyle): Tokens$Comment;
              _fac: ScannerFactory;
            }
            interface JavadocTokenizer extends CombineTypes<[_JavadocTokenizer, com.sun.tools.javac.parser.JavaTokenizer]> {}
            interface _JavadocTokenizer$JavadocComment$$static extends ClassLike {
              _new(cs: Tokens$Comment$CommentStyle, reader: UnicodeReader, pos: int, endPos: int): JavadocTokenizer$JavadocComment;
            }
            let JavadocTokenizer$JavadocComment: _JavadocTokenizer$JavadocComment$$static;
            interface _JavadocTokenizer$JavadocComment {
              getSourcePos(pos: int): int;
              getText(): string;
              _putLine(line: UnicodeReader): void;
              _scanDocComment(): void;
              _docComment: string;
              _firstLine: boolean;
              _offsetMap: JavadocTokenizer$OffsetMap;
              _sb: parser$stringBuilder;
            }
            interface JavadocTokenizer$JavadocComment extends CombineTypes<[_JavadocTokenizer$JavadocComment, com.sun.tools.javac.parser.JavaTokenizer$BasicComment]> {}
            interface _JavadocTokenizer$OffsetMap$$static extends ClassLike {
              _NOFFSETS: int;
              _POS_OFFSET: int;
              _SB_OFFSET: int;
              _new(): JavadocTokenizer$OffsetMap;
            }
            let JavadocTokenizer$OffsetMap: _JavadocTokenizer$OffsetMap$$static;
            interface _JavadocTokenizer$OffsetMap {
              _add(sbOffset: int, posOffset: int): void;
              _ensure(need: int): void;
              _getSourcePos(pos: int): int;
              _lastPosOffset(): int;
              _lastSBOffset(): int;
              _shouldAdd(sbOffset: int, posOffset: int): boolean;
              _trim(): void;
              _map: int[];
              _size: int;
            }
            interface JavadocTokenizer$OffsetMap extends CombineTypes<[_JavadocTokenizer$OffsetMap, java.lang.Object]> {}
            interface _LazyDocCommentTable$$static extends ClassLike {
              _new(fac: ParserFactory): LazyDocCommentTable;
            }
            let LazyDocCommentTable: _LazyDocCommentTable$$static;
            interface _LazyDocCommentTable {
              getComment(tree: javac.tree.JCTree): Tokens$Comment;
              getCommentText(tree: javac.tree.JCTree): string;
              getCommentTree(tree: javac.tree.JCTree): javac.tree.DCTree$DCDocComment;
              hasComment(tree: javac.tree.JCTree): boolean;
              putComment(tree: javac.tree.JCTree, c: Tokens$Comment): void;
              _diagSource: javac.util.DiagnosticSource;
              _fac: ParserFactory;
              _table: java.util.Map<javac.tree.JCTree,LazyDocCommentTable$Entry>;
            }
            interface LazyDocCommentTable extends CombineTypes<[_LazyDocCommentTable, java.lang.Object, com.sun.tools.javac.tree.DocCommentTable]> {}
            interface _LazyDocCommentTable$Entry$$static extends ClassLike {
              _new(c: Tokens$Comment): LazyDocCommentTable$Entry;
            }
            let LazyDocCommentTable$Entry: _LazyDocCommentTable$Entry$$static;
            interface _LazyDocCommentTable$Entry {
              _comment: Tokens$Comment;
              _tree: javac.tree.DCTree$DCDocComment;
            }
            interface LazyDocCommentTable$Entry extends CombineTypes<[_LazyDocCommentTable$Entry, java.lang.Object]> {}
            interface _Lexer$$static extends ClassLike {
            }
            let Lexer: _Lexer$$static;
            interface _Lexer {
              errPos(): int;
              errPos(a0: int): void;
              getLineMap(): javac.util.Position$LineMap;
              nextToken(): void;
              prevToken(): Tokens$Token;
              setPrevToken(a0: Tokens$Token): void;
              split(): Tokens$Token;
              token(): Tokens$Token;
              token(a0: int): Tokens$Token;
            }
            interface Lexer extends CombineTypes<[_Lexer, java.lang.Object]> {}
            interface _Parser$$static extends ClassLike {
            }
            let Parser: _Parser$$static;
            interface _Parser {
              parseCompilationUnit(): javac.tree.JCTree$JCCompilationUnit;
              parseExpression(): javac.tree.JCTree$JCExpression;
              parseStatement(): javac.tree.JCTree$JCStatement;
              parseType(): javac.tree.JCTree$JCExpression;
            }
            interface Parser extends CombineTypes<[_Parser, java.lang.Object]> {}
            interface _ParserFactory$$static extends ClassLike {
              instance(context: javac.util.Context): ParserFactory;
              _parserFactoryKey: javac.util.Context$Key<ParserFactory>;
              _new(context: javac.util.Context): ParserFactory;
            }
            let ParserFactory: _ParserFactory$$static;
            interface _ParserFactory {
              newParser(input: ParserFactory$charSequence, keepDocComments: boolean, keepEndPos: boolean, keepLineMap: boolean): JavacParser;
              newParser(input: ParserFactory$charSequence, keepDocComments: boolean, keepEndPos: boolean, keepLineMap: boolean, parseModuleInfo: boolean): JavacParser;
              _F: javac.tree.TreeMaker;
              _docTreeMaker: javac.tree.DocTreeMaker;
              _locale: java.util.Locale;
              _log: javac.util.Log;
              _names: javac.util.Names;
              _options: javac.util.Options;
              _preview: javac.code.Preview;
              _scannerFactory: ScannerFactory;
              _source: javac.code.Source;
              _tokens: Tokens;
            }
            interface ParserFactory extends CombineTypes<[_ParserFactory, java.lang.Object]> {}
            interface _ReferenceParser$$static extends ClassLike {
              new(fac: ParserFactory): ReferenceParser;
            }
            let ReferenceParser: _ReferenceParser$$static;
            interface _ReferenceParser {
              _checkDiags(h: javac.util.Log$DeferredDiagnosticHandler, offset: int): void;
              parse(sig: string, mode: ReferenceParser$Mode): ReferenceParser$Reference;
              _parseMember(sig: string, beginIndex: int, endIndex: int, dh: javac.util.Log$DeferredDiagnosticHandler): javac.util.Name;
              _parseModule(sig: string, beginIndex: int, endIndex: int, dh: javac.util.Log$DeferredDiagnosticHandler): javac.tree.JCTree$JCExpression;
              _parseParams(sig: string, beginIndex: int, endIndex: int, dh: javac.util.Log$DeferredDiagnosticHandler): javac.util.List<javac.tree.JCTree>;
              _parseType(sig: string, beginIndex: int, endIndex: int, dh: javac.util.Log$DeferredDiagnosticHandler): javac.tree.JCTree;
              _fac: ParserFactory;
            }
            interface ReferenceParser extends CombineTypes<[_ReferenceParser, java.lang.Object]> {}
            interface _ReferenceParser$Mode$$static extends ClassLike {
              valueOf(name: string): ReferenceParser$Mode;
              values(): ReferenceParser$Mode[];
              readonly MEMBER_DISALLOWED: ReferenceParser$Mode;
              readonly MEMBER_OPTIONAL: ReferenceParser$Mode;
              readonly MEMBER_REQUIRED: ReferenceParser$Mode;
            }
            let ReferenceParser$Mode: _ReferenceParser$Mode$$static;
            interface _ReferenceParser$Mode {
            }
            interface ReferenceParser$Mode extends CombineTypes<[_ReferenceParser$Mode]> {}
            interface _ReferenceParser$ParseException$$static extends ClassLike {
              _serialVersionUID: long;
              _new(pos: int, message: string): ReferenceParser$ParseException;
            }
            let ReferenceParser$ParseException: _ReferenceParser$ParseException$$static;
            interface _ReferenceParser$ParseException {
              _pos: int;
            }
            interface ReferenceParser$ParseException extends CombineTypes<[_ReferenceParser$ParseException, java.lang.Exception]> {}
            interface _ReferenceParser$Reference$$static extends ClassLike {
              _new(moduleName: javac.tree.JCTree$JCExpression, qualExpr: javac.tree.JCTree, member: javac.util.Name, paramTypes: javac.util.List<javac.tree.JCTree>): ReferenceParser$Reference;
            }
            let ReferenceParser$Reference: _ReferenceParser$Reference$$static;
            interface _ReferenceParser$Reference {
              readonly member: javac.util.Name;
              readonly moduleName: javac.tree.JCTree$JCExpression;
              readonly paramTypes: javac.util.List<javac.tree.JCTree>;
              readonly qualExpr: javac.tree.JCTree;
            }
            interface ReferenceParser$Reference extends CombineTypes<[_ReferenceParser$Reference, java.lang.Object]> {}
            interface _ReferenceParser$TypeAnnotationFinder$$static extends ClassLike {
              _new(): ReferenceParser$TypeAnnotationFinder;
            }
            let ReferenceParser$TypeAnnotationFinder: _ReferenceParser$TypeAnnotationFinder$$static;
            interface _ReferenceParser$TypeAnnotationFinder {
              reduce(t1: sun.source.tree.Tree, t2: sun.source.tree.Tree): sun.source.tree.Tree;
              reduce(a0: any, a1: any): any;
              visitAnnotatedType(t: sun.source.tree.AnnotatedTypeTree, ignore: java.lang.Void): sun.source.tree.Tree;
              visitAnnotatedType(a0: sun.source.tree.AnnotatedTypeTree, a1: any): any;
            }
            interface ReferenceParser$TypeAnnotationFinder extends CombineTypes<[_ReferenceParser$TypeAnnotationFinder, sun.source.util.TreeScanner<sun.source.tree.Tree,java.lang.Void>]> {}
            interface _Scanner$$static extends ClassLike {
              _new(fac: ScannerFactory, buf: java.nio.CharBuffer): Scanner;
              _new(fac: ScannerFactory, buf: char[], inputLength: int): Scanner;
              _new(fac: ScannerFactory, tokenizer: JavaTokenizer): Scanner;
            }
            let Scanner: _Scanner$$static;
            interface _Scanner {
              _ensureLookahead(lookahead: int): void;
              errPos(): int;
              errPos(pos: int): void;
              getLineMap(): javac.util.Position$LineMap;
              nextToken(): void;
              prevToken(): Tokens$Token;
              setPrevToken(prevToken: Tokens$Token): void;
              split(): Tokens$Token;
              token(): Tokens$Token;
              token(lookahead: int): Tokens$Token;
              _prevToken: Tokens$Token;
              _savedTokens: java.util.List<Tokens$Token>;
              _token: Tokens$Token;
              _tokenizer: JavaTokenizer;
              _tokens: Tokens;
            }
            interface Scanner extends CombineTypes<[_Scanner, java.lang.Object, com.sun.tools.javac.parser.Lexer]> {}
            interface _ScannerFactory$$static extends ClassLike {
              instance(context: javac.util.Context): ScannerFactory;
              readonly scannerFactoryKey: javac.util.Context$Key<ScannerFactory>;
              _new(context: javac.util.Context): ScannerFactory;
            }
            let ScannerFactory: _ScannerFactory$$static;
            interface _ScannerFactory {
              newScanner(input: ScannerFactory$charSequence, keepDocComments: boolean): Scanner;
              newScanner(input: char[], inputLength: int, keepDocComments: boolean): Scanner;
              _lint: javac.code.Lint;
              _log: javac.util.Log;
              _names: javac.util.Names;
              _preview: javac.code.Preview;
              _source: javac.code.Source;
              _tokens: Tokens;
            }
            interface ScannerFactory extends CombineTypes<[_ScannerFactory, java.lang.Object]> {}
            interface _TextBlockSupport$$static extends ClassLike {
              _checkWhitespace(string: string): java.util.Set<TextBlockSupport$WhitespaceChecks>;
              _indexOfNonWhitespace(string: string): int;
              _new(): TextBlockSupport;
            }
            let TextBlockSupport: _TextBlockSupport$$static;
            interface _TextBlockSupport {
            }
            interface TextBlockSupport extends CombineTypes<[_TextBlockSupport, java.lang.Object]> {}
            interface _TextBlockSupport$WhitespaceChecks$$static extends ClassLike {
              valueOf(name: string): TextBlockSupport$WhitespaceChecks;
              values(): TextBlockSupport$WhitespaceChecks[];
              readonly INCONSISTENT: TextBlockSupport$WhitespaceChecks;
              readonly TRAILING: TextBlockSupport$WhitespaceChecks;
            }
            let TextBlockSupport$WhitespaceChecks: _TextBlockSupport$WhitespaceChecks$$static;
            interface _TextBlockSupport$WhitespaceChecks {
            }
            interface TextBlockSupport$WhitespaceChecks extends CombineTypes<[_TextBlockSupport$WhitespaceChecks]> {}
            interface _Tokens$$static extends ClassLike {
              instance(context: javac.util.Context): Tokens;
              readonly DUMMY: Tokens$Token;
              readonly tokensKey: javac.util.Context$Key<Tokens>;
              _new(context: javac.util.Context): Tokens;
            }
            let Tokens: _Tokens$$static;
            interface _Tokens {
              _lookupKind(name: javac.util.Name): Tokens$TokenKind;
              _lookupKind(name: string): Tokens$TokenKind;
              _keywords: java.util.Map<string,Tokens$TokenKind>;
              _names: javac.util.Names;
            }
            interface Tokens extends CombineTypes<[_Tokens, java.lang.Object]> {}
            interface _Tokens$Comment$$static extends ClassLike {
            }
            let Tokens$Comment: _Tokens$Comment$$static;
            interface _Tokens$Comment {
              getSourcePos(a0: int): int;
              getStyle(): Tokens$Comment$CommentStyle;
              getText(): string;
              isDeprecated(): boolean;
            }
            interface Tokens$Comment extends CombineTypes<[_Tokens$Comment, java.lang.Object]> {}
            interface _Tokens$Comment$CommentStyle$$static extends ClassLike {
              valueOf(name: string): Tokens$Comment$CommentStyle;
              values(): Tokens$Comment$CommentStyle[];
              readonly BLOCK: Tokens$Comment$CommentStyle;
              readonly JAVADOC: Tokens$Comment$CommentStyle;
              readonly LINE: Tokens$Comment$CommentStyle;
            }
            let Tokens$Comment$CommentStyle: _Tokens$Comment$CommentStyle$$static;
            interface _Tokens$Comment$CommentStyle {
            }
            interface Tokens$Comment$CommentStyle extends CombineTypes<[_Tokens$Comment$CommentStyle]> {}
            interface _Tokens$NamedToken$$static extends ClassLike {
              new(kind: Tokens$TokenKind, pos: int, endPos: int, name: javac.util.Name, comments: javac.util.List<Tokens$Comment>): Tokens$NamedToken;
            }
            let Tokens$NamedToken: _Tokens$NamedToken$$static;
            interface _Tokens$NamedToken {
              _checkKind(): void;
              name(): javac.util.Name;
              readonly name: javac.util.Name;
            }
            interface Tokens$NamedToken extends CombineTypes<[_Tokens$NamedToken, com.sun.tools.javac.parser.Tokens$Token]> {}
            interface _Tokens$NumericToken$$static extends ClassLike {
              new(kind: Tokens$TokenKind, pos: int, endPos: int, stringVal: string, radix: int, comments: javac.util.List<Tokens$Comment>): Tokens$NumericToken;
            }
            let Tokens$NumericToken: _Tokens$NumericToken$$static;
            interface _Tokens$NumericToken {
              _checkKind(): void;
              radix(): int;
              readonly radix: int;
            }
            interface Tokens$NumericToken extends CombineTypes<[_Tokens$NumericToken, com.sun.tools.javac.parser.Tokens$StringToken]> {}
            interface _Tokens$StringToken$$static extends ClassLike {
              new(kind: Tokens$TokenKind, pos: int, endPos: int, stringVal: string, comments: javac.util.List<Tokens$Comment>): Tokens$StringToken;
            }
            let Tokens$StringToken: _Tokens$StringToken$$static;
            interface _Tokens$StringToken {
              _checkKind(): void;
              stringVal(): string;
              readonly stringVal: string;
            }
            interface Tokens$StringToken extends CombineTypes<[_Tokens$StringToken, com.sun.tools.javac.parser.Tokens$Token]> {}
            interface _Tokens$Token$$static extends ClassLike {
              _new(kind: Tokens$TokenKind, pos: int, endPos: int, comments: javac.util.List<Tokens$Comment>): Tokens$Token;
            }
            let Tokens$Token: _Tokens$Token$$static;
            interface _Tokens$Token {
              _checkKind(): void;
              comment(style: Tokens$Comment$CommentStyle): Tokens$Comment;
              deprecatedFlag(): boolean;
              _getComments(style: Tokens$Comment$CommentStyle): javac.util.List<Tokens$Comment>;
              name(): javac.util.Name;
              radix(): int;
              _split(tokens: Tokens): Tokens$Token[];
              stringVal(): string;
              readonly comments: javac.util.List<Tokens$Comment>;
              readonly endPos: int;
              readonly kind: Tokens$TokenKind;
              readonly pos: int;
            }
            interface Tokens$Token extends CombineTypes<[_Tokens$Token, java.lang.Object]> {}
            interface _Tokens$Token$Tag$$static extends ClassLike {
              valueOf(name: string): Tokens$Token$Tag;
              values(): Tokens$Token$Tag[];
              readonly DEFAULT: Tokens$Token$Tag;
              readonly NAMED: Tokens$Token$Tag;
              readonly NUMERIC: Tokens$Token$Tag;
              readonly STRING: Tokens$Token$Tag;
            }
            let Tokens$Token$Tag: _Tokens$Token$Tag$$static;
            interface _Tokens$Token$Tag {
            }
            interface Tokens$Token$Tag extends CombineTypes<[_Tokens$Token$Tag]> {}
            interface _Tokens$TokenKind$$static extends ClassLike {
              valueOf(name: string): Tokens$TokenKind;
              values(): Tokens$TokenKind[];
              readonly ABSTRACT: Tokens$TokenKind;
              readonly AMP: Tokens$TokenKind;
              readonly AMPAMP: Tokens$TokenKind;
              readonly AMPEQ: Tokens$TokenKind;
              readonly ARROW: Tokens$TokenKind;
              readonly ASSERT: Tokens$TokenKind;
              readonly BANG: Tokens$TokenKind;
              readonly BANGEQ: Tokens$TokenKind;
              readonly BAR: Tokens$TokenKind;
              readonly BARBAR: Tokens$TokenKind;
              readonly BAREQ: Tokens$TokenKind;
              readonly BOOLEAN: Tokens$TokenKind;
              readonly BREAK: Tokens$TokenKind;
              readonly BYTE: Tokens$TokenKind;
              readonly CARET: Tokens$TokenKind;
              readonly CARETEQ: Tokens$TokenKind;
              readonly CASE: Tokens$TokenKind;
              readonly CATCH: Tokens$TokenKind;
              readonly CHAR: Tokens$TokenKind;
              readonly CHARLITERAL: Tokens$TokenKind;
              readonly CLASS: Tokens$TokenKind;
              readonly COLCOL: Tokens$TokenKind;
              readonly COLON: Tokens$TokenKind;
              readonly COMMA: Tokens$TokenKind;
              readonly CONST: Tokens$TokenKind;
              readonly CONTINUE: Tokens$TokenKind;
              readonly CUSTOM: Tokens$TokenKind;
              readonly DEFAULT: Tokens$TokenKind;
              readonly DO: Tokens$TokenKind;
              readonly DOT: Tokens$TokenKind;
              readonly DOUBLE: Tokens$TokenKind;
              readonly DOUBLELITERAL: Tokens$TokenKind;
              readonly ELLIPSIS: Tokens$TokenKind;
              readonly ELSE: Tokens$TokenKind;
              readonly ENUM: Tokens$TokenKind;
              readonly EOF: Tokens$TokenKind;
              readonly EQ: Tokens$TokenKind;
              readonly EQEQ: Tokens$TokenKind;
              readonly ERROR: Tokens$TokenKind;
              readonly EXTENDS: Tokens$TokenKind;
              readonly FALSE: Tokens$TokenKind;
              readonly FINAL: Tokens$TokenKind;
              readonly FINALLY: Tokens$TokenKind;
              readonly FLOAT: Tokens$TokenKind;
              readonly FLOATLITERAL: Tokens$TokenKind;
              readonly FOR: Tokens$TokenKind;
              readonly GOTO: Tokens$TokenKind;
              readonly GT: Tokens$TokenKind;
              readonly GTEQ: Tokens$TokenKind;
              readonly GTGT: Tokens$TokenKind;
              readonly GTGTEQ: Tokens$TokenKind;
              readonly GTGTGT: Tokens$TokenKind;
              readonly GTGTGTEQ: Tokens$TokenKind;
              readonly IDENTIFIER: Tokens$TokenKind;
              readonly IF: Tokens$TokenKind;
              readonly IMPLEMENTS: Tokens$TokenKind;
              readonly IMPORT: Tokens$TokenKind;
              readonly INSTANCEOF: Tokens$TokenKind;
              readonly INT: Tokens$TokenKind;
              readonly INTERFACE: Tokens$TokenKind;
              readonly INTLITERAL: Tokens$TokenKind;
              readonly LBRACE: Tokens$TokenKind;
              readonly LBRACKET: Tokens$TokenKind;
              readonly LONG: Tokens$TokenKind;
              readonly LONGLITERAL: Tokens$TokenKind;
              readonly LPAREN: Tokens$TokenKind;
              readonly LT: Tokens$TokenKind;
              readonly LTEQ: Tokens$TokenKind;
              readonly LTLT: Tokens$TokenKind;
              readonly LTLTEQ: Tokens$TokenKind;
              readonly MONKEYS_AT: Tokens$TokenKind;
              readonly NATIVE: Tokens$TokenKind;
              readonly NEW: Tokens$TokenKind;
              readonly NULL: Tokens$TokenKind;
              readonly PACKAGE: Tokens$TokenKind;
              readonly PERCENT: Tokens$TokenKind;
              readonly PERCENTEQ: Tokens$TokenKind;
              readonly PLUS: Tokens$TokenKind;
              readonly PLUSEQ: Tokens$TokenKind;
              readonly PLUSPLUS: Tokens$TokenKind;
              readonly PRIVATE: Tokens$TokenKind;
              readonly PROTECTED: Tokens$TokenKind;
              readonly PUBLIC: Tokens$TokenKind;
              readonly QUES: Tokens$TokenKind;
              readonly RBRACE: Tokens$TokenKind;
              readonly RBRACKET: Tokens$TokenKind;
              readonly RETURN: Tokens$TokenKind;
              readonly RPAREN: Tokens$TokenKind;
              readonly SEMI: Tokens$TokenKind;
              readonly SHORT: Tokens$TokenKind;
              readonly SLASH: Tokens$TokenKind;
              readonly SLASHEQ: Tokens$TokenKind;
              readonly STAR: Tokens$TokenKind;
              readonly STAREQ: Tokens$TokenKind;
              readonly STATIC: Tokens$TokenKind;
              readonly STRICTFP: Tokens$TokenKind;
              readonly STRINGFRAGMENT: Tokens$TokenKind;
              readonly STRINGLITERAL: Tokens$TokenKind;
              readonly SUB: Tokens$TokenKind;
              readonly SUBEQ: Tokens$TokenKind;
              readonly SUBSUB: Tokens$TokenKind;
              readonly SUPER: Tokens$TokenKind;
              readonly SWITCH: Tokens$TokenKind;
              readonly SYNCHRONIZED: Tokens$TokenKind;
              readonly THIS: Tokens$TokenKind;
              readonly THROW: Tokens$TokenKind;
              readonly THROWS: Tokens$TokenKind;
              readonly TILDE: Tokens$TokenKind;
              readonly TRANSIENT: Tokens$TokenKind;
              readonly TRUE: Tokens$TokenKind;
              readonly TRY: Tokens$TokenKind;
              readonly UNDERSCORE: Tokens$TokenKind;
              readonly VOID: Tokens$TokenKind;
              readonly VOLATILE: Tokens$TokenKind;
              readonly WHILE: Tokens$TokenKind;
            }
            let Tokens$TokenKind: _Tokens$TokenKind$$static;
            interface _Tokens$TokenKind {
              getKind(): string;
              test(that: Tokens$TokenKind): boolean;
              test(a0: any): boolean;
              toString(): string;
              toString(locale: java.util.Locale, messages: javac.api.Messages): string;
              readonly name: string;
              readonly tag: Tokens$Token$Tag;
            }
            interface Tokens$TokenKind extends CombineTypes<[_Tokens$TokenKind, java.util.function.Predicate<Tokens$TokenKind>, javac.api.Formattable]> {}
            interface _UnicodeReader$$static extends ClassLike {
              _new(sf: ScannerFactory, array: char[], length: int): UnicodeReader;
              _new(log: javac.util.Log, array: char[], length: int): UnicodeReader;
              _new(log: javac.util.Log, array: char[], offset: int, pos: int, endPos: int): UnicodeReader;
            }
            let UnicodeReader: _UnicodeReader$$static;
            interface _UnicodeReader {
              _accept(ch: char): boolean;
              _accept(string: string): boolean;
              _acceptOneOf(ch1: char, ch2: char): boolean;
              _acceptOneOf(ch1: char, ch2: char, ch3: char): boolean;
              _buffer(): char[];
              _digit(pos: int, digitRadix: int): int;
              _get(): char;
              _getCodepoint(): int;
              getRawCharacters(): char[];
              getRawCharacters(beginIndex: int, endIndex: int): char[];
              getRawString(beginIndex: int, endIndex: int): string;
              getRawString(): string;
              _inRange(lo: char, hi: char): boolean;
              _is(ch: char): boolean;
              _isASCII(): boolean;
              _isAvailable(): boolean;
              _isEOLN(): boolean;
              _isOneOf(ch1: char, ch2: char): boolean;
              _isOneOf(ch1: char, ch2: char, ch3: char): boolean;
              _isOneOf(ch1: char, ch2: char, ch3: char, ch4: char): boolean;
              _isOneOf(ch1: char, ch2: char, ch3: char, ch4: char, ch5: char, ch6: char): boolean;
              _isSurrogate(): boolean;
              _isWhitespace(): boolean;
              _length(): int;
              _lineReader(): UnicodeReader;
              _lineReader(pos: int, endPos: int): UnicodeReader;
              _next(): char;
              _nextCodePoint(): void;
              _nextCodeUnit(): void;
              _nextUnicodeInputCharacter(): void;
              _position(): int;
              _reset(pos: int): void;
              _skip(ch: char): int;
              _skipToEOLN(): void;
              _skipWhitespace(): void;
              _unicodeEscape(): UnicodeReader$UnicodeEscapeResult;
              _buffer: char[];
              _character: char;
              _codepoint: int;
              _length: int;
              _log: javac.util.Log;
              _offset: int;
              _position: int;
              _wasBackslash: boolean;
              _wasUnicodeEscape: boolean;
              _width: int;
            }
            interface UnicodeReader extends CombineTypes<[_UnicodeReader, java.lang.Object]> {}
            interface _UnicodeReader$PositionTrackingReader$$static extends ClassLike {
              _new(reader: UnicodeReader, pos: int, endPos: int): UnicodeReader$PositionTrackingReader;
            }
            let UnicodeReader$PositionTrackingReader: _UnicodeReader$PositionTrackingReader$$static;
            interface _UnicodeReader$PositionTrackingReader {
              _column(): int;
              _next(): char;
              _column: int;
            }
            interface UnicodeReader$PositionTrackingReader extends CombineTypes<[_UnicodeReader$PositionTrackingReader, com.sun.tools.javac.parser.UnicodeReader]> {}
            interface _UnicodeReader$UnicodeEscapeResult$$static extends ClassLike {
              valueOf(name: string): UnicodeReader$UnicodeEscapeResult;
              values(): UnicodeReader$UnicodeEscapeResult[];
              readonly BACKSLASH: UnicodeReader$UnicodeEscapeResult;
              readonly BROKEN_ESCAPE: UnicodeReader$UnicodeEscapeResult;
              readonly VALID_ESCAPE: UnicodeReader$UnicodeEscapeResult;
            }
            let UnicodeReader$UnicodeEscapeResult: _UnicodeReader$UnicodeEscapeResult$$static;
            interface _UnicodeReader$UnicodeEscapeResult {
            }
            interface UnicodeReader$UnicodeEscapeResult extends CombineTypes<[_UnicodeReader$UnicodeEscapeResult]> {}
            interface _VirtualParser$$static extends ClassLike {
              tryParse(parser: JavacParser, parserAction: java.util.function.Consumer<JavacParser>): boolean;
              new(parser: JavacParser): VirtualParser;
            }
            let VirtualParser: _VirtualParser$$static;
            interface _VirtualParser {
              hasErrors(): boolean;
              _reportSyntaxError(pos: int, errorKey: javac.util.JCDiagnostic$Error): void;
              _reportSyntaxError(diagPos: javac.util.JCDiagnostic$DiagnosticPosition, errorKey: javac.util.JCDiagnostic$Error): void;
              _syntaxError(pos: int, errorKey: javac.util.JCDiagnostic$Error): javac.tree.JCTree$JCErroneous;
              _syntaxError(pos: int, errs: javac.util.List<javac.tree.JCTree>, errorKey: javac.util.JCDiagnostic$Error): javac.tree.JCTree$JCErroneous;
              _hasErrors: boolean;
            }
            interface VirtualParser extends CombineTypes<[_VirtualParser, com.sun.tools.javac.parser.JavacParser]> {}
            interface _VirtualParser$VirtualScanner$$static extends ClassLike {
              new(s: Lexer): VirtualParser$VirtualScanner;
            }
            let VirtualParser$VirtualScanner: _VirtualParser$VirtualScanner$$static;
            interface _VirtualParser$VirtualScanner {
              commit(): void;
              errPos(): int;
              errPos(pos: int): void;
              getLineMap(): javac.util.Position$LineMap;
              nextToken(): void;
              prevToken(): Tokens$Token;
              setPrevToken(prevToken: Tokens$Token): void;
              split(): Tokens$Token;
              token(): Tokens$Token;
              token(lookahead: int): Tokens$Token;
              _S: Lexer;
              _offset: int;
              _prevToken: Tokens$Token;
              _token: Tokens$Token;
            }
            interface VirtualParser$VirtualScanner extends CombineTypes<[_VirtualParser$VirtualScanner, java.lang.Object, com.sun.tools.javac.parser.Lexer]> {}
          }
          module platform {
            interface _JDKPlatformProvider$$static extends ClassLike {
              _findCtSym(): java.nio.file.Path;
              _targetNumericVersion(target: javac.jvm.Target): string;
              readonly NUMERICAL_COMPARATOR: java.util.Comparator<string>;
              _SUPPORTED_JAVA_PLATFORM_VERSIONS: java.util.Set<string>;
              _symbolFileLocation: string[];
              new(): JDKPlatformProvider;
            }
            let JDKPlatformProvider: _JDKPlatformProvider$$static;
            interface _JDKPlatformProvider {
              getPlatform(platformName: string, options: string): PlatformDescription;
              getSupportedPlatformNames(): java.lang.Iterable<string>;
            }
            interface JDKPlatformProvider extends CombineTypes<[_JDKPlatformProvider, java.lang.Object, com.sun.tools.javac.platform.PlatformProvider]> {}
            interface _JDKPlatformProvider$PlatformDescriptionImpl$$static extends ClassLike {
              _setModule(fm: javax.tools.StandardJavaFileManager, mod: java.nio.file.Path): void;
              _new(sourceVersion: string): JDKPlatformProvider$PlatformDescriptionImpl;
            }
            let JDKPlatformProvider$PlatformDescriptionImpl: _JDKPlatformProvider$PlatformDescriptionImpl$$static;
            interface _JDKPlatformProvider$PlatformDescriptionImpl {
              close(): void;
              getAdditionalOptions(): java.util.List<string>;
              getAnnotationProcessors(): java.util.List<PlatformDescription$PluginInfo<javax.annotation.processing.Processor>>;
              getFileManager(): javax.tools.JavaFileManager;
              getPlugins(): java.util.List<PlatformDescription$PluginInfo<sun.source.util.Plugin>>;
              getSourceVersion(): string;
              getTargetVersion(): string;
              _ctSym2FileSystem: java.util.Map<java.nio.file.Path,java.nio.file.FileSystem>;
              _ctSymVersion: string;
              _sourceVersion: string;
            }
            interface JDKPlatformProvider$PlatformDescriptionImpl extends CombineTypes<[_JDKPlatformProvider$PlatformDescriptionImpl, com.sun.tools.javac.platform.PlatformDescription, java.lang.Object]> {}
            interface _JDKPlatformProvider$PlatformDescriptionImpl$SigJavaFileObject$$static extends ClassLike {
              new(fileObject: javax.tools.JavaFileObject): JDKPlatformProvider$PlatformDescriptionImpl$SigJavaFileObject;
            }
            let JDKPlatformProvider$PlatformDescriptionImpl$SigJavaFileObject: _JDKPlatformProvider$PlatformDescriptionImpl$SigJavaFileObject$$static;
            interface _JDKPlatformProvider$PlatformDescriptionImpl$SigJavaFileObject {
              getDelegate(): javax.tools.JavaFileObject;
              getKind(): javax.tools.JavaFileObject$Kind;
              isNameCompatible(simpleName: string, kind: javax.tools.JavaFileObject$Kind): boolean;
            }
            interface JDKPlatformProvider$PlatformDescriptionImpl$SigJavaFileObject extends CombineTypes<[_JDKPlatformProvider$PlatformDescriptionImpl$SigJavaFileObject, javax.tools.ForwardingJavaFileObject<javax.tools.JavaFileObject>]> {}
            interface _PlatformDescription$$static extends ClassLike {
            }
            let PlatformDescription: _PlatformDescription$$static;
            interface _PlatformDescription {
              close(): void;
              getAdditionalOptions(): java.util.List<string>;
              getAnnotationProcessors(): java.util.List<PlatformDescription$PluginInfo<javax.annotation.processing.Processor>>;
              getFileManager(): javax.tools.JavaFileManager;
              getPlugins(): java.util.List<PlatformDescription$PluginInfo<sun.source.util.Plugin>>;
              getSourceVersion(): string;
              getTargetVersion(): string;
            }
            interface PlatformDescription extends CombineTypes<[_PlatformDescription, java.io.Closeable, java.lang.Object]> {}
            interface _PlatformDescription$PluginInfo$$static<T> extends ClassLike {
            }
            let PlatformDescription$PluginInfo: _PlatformDescription$PluginInfo$$static<T>;
            interface _PlatformDescription$PluginInfo<T> {
              getName(): string;
              getOptions(): java.util.Map<string,string>;
              getPlugin(): T;
            }
            interface PlatformDescription$PluginInfo<T> extends CombineTypes<[_PlatformDescription$PluginInfo<T>, java.lang.Object]> {}
            interface _PlatformProvider$$static extends ClassLike {
            }
            let PlatformProvider: _PlatformProvider$$static;
            interface _PlatformProvider {
              getPlatform(a0: string, a1: string): PlatformDescription;
              getSupportedPlatformNames(): java.lang.Iterable<string>;
            }
            interface PlatformProvider extends CombineTypes<[_PlatformProvider, java.lang.Object]> {}
            interface _PlatformProvider$PlatformNotSupported$$static extends ClassLike {
              _serialVersionUID: long;
              new(): PlatformProvider$PlatformNotSupported;
            }
            let PlatformProvider$PlatformNotSupported: _PlatformProvider$PlatformNotSupported$$static;
            interface _PlatformProvider$PlatformNotSupported {
            }
            interface PlatformProvider$PlatformNotSupported extends CombineTypes<[_PlatformProvider$PlatformNotSupported, java.lang.Exception]> {}
            interface _PlatformUtils$$static extends ClassLike {
              lookupPlatformDescription(platformString: string): PlatformDescription;
              new(): PlatformUtils;
            }
            let PlatformUtils: _PlatformUtils$$static;
            interface _PlatformUtils {
            }
            interface PlatformUtils extends CombineTypes<[_PlatformUtils, java.lang.Object]> {}
          }
          module processing {
            interface _AnnotationProcessingError$$static extends ClassLike {
              _serialVersionUID: long;
              _new(cause: java.lang.Throwable): AnnotationProcessingError;
            }
            let AnnotationProcessingError: _AnnotationProcessingError$$static;
            interface _AnnotationProcessingError {
            }
            interface AnnotationProcessingError extends CombineTypes<[_AnnotationProcessingError, java.lang.Error]> {}
            interface _JavacFiler$$static extends ClassLike {
              _ALREADY_OPENED: string;
              _NOT_FOR_READING: string;
              _NOT_FOR_WRITING: string;
              _new(context: javac.util.Context): JavacFiler;
            }
            let JavacFiler: _JavacFiler$$static;
            interface _JavacFiler {
              _checkFileReopening(fileObject: javax.tools.FileObject, forWriting: boolean): void;
              _checkName(name: string): void;
              _checkName(name: string, allowUnnamedPackageInfo: boolean): void;
              _checkNameAndExistence(mod: javac.code.Symbol$ModuleSymbol, typename: string, allowUnnamedPackageInfo: boolean): void;
              _checkOrInferModule(moduleAndPkg: JavacFiler$charSequence): javac.util.Pair<javac.code.Symbol$ModuleSymbol,string>;
              _checkOrInferModule(location: javax.tools.JavaFileManager$Location, moduleAndPkg: JavacFiler$charSequence, write: boolean): JavacFiler$Tuple3<javax.tools.JavaFileManager$Location,javac.code.Symbol$ModuleSymbol,string>;
              _clearRoundState(): void;
              close(): void;
              _closeFileObject(mod: javac.code.Symbol$ModuleSymbol, typeName: string, fileObject: javax.tools.FileObject): void;
              _containedInInitialInputs(typename: string): boolean;
              createClassFile(nameAndModule: JavacFiler$charSequence, originatingElements: javax.lang.model.element.Element[]): javax.tools.JavaFileObject;
              createClassFile(nameAndModule: JavacFiler$charSequence, ...originatingElements: javax.lang.model.element.Element[]): javax.tools.JavaFileObject;
              createResource(location: javax.tools.JavaFileManager$Location, moduleAndPkg: JavacFiler$charSequence, relativeName: JavacFiler$charSequence, originatingElements: javax.lang.model.element.Element[]): javax.tools.FileObject;
              createResource(location: javax.tools.JavaFileManager$Location, moduleAndPkg: JavacFiler$charSequence, relativeName: JavacFiler$charSequence, ...originatingElements: javax.lang.model.element.Element[]): javax.tools.FileObject;
              createSourceFile(nameAndModule: JavacFiler$charSequence, originatingElements: javax.lang.model.element.Element[]): javax.tools.JavaFileObject;
              createSourceFile(nameAndModule: JavacFiler$charSequence, ...originatingElements: javax.lang.model.element.Element[]): javax.tools.JavaFileObject;
              _createSourceOrClassFile(mod: javac.code.Symbol$ModuleSymbol, isSourceFile: boolean, name: string, originatingElements: javax.lang.model.element.Element[]): javax.tools.JavaFileObject;
              _createSourceOrClassFile(mod: javac.code.Symbol$ModuleSymbol, isSourceFile: boolean, name: string, ...originatingElements: javax.lang.model.element.Element[]): javax.tools.JavaFileObject;
              displayState(): void;
              getGeneratedClasses(): java.util.Map<javac.code.Symbol$ModuleSymbol,java.util.Map<string,javax.tools.JavaFileObject>>;
              getGeneratedSourceFileObjects(): java.util.Set<javax.tools.JavaFileObject>;
              getGeneratedSourceNames(): java.util.Set<string>;
              getResource(location: javax.tools.JavaFileManager$Location, moduleAndPkg: JavacFiler$charSequence, relativeName: JavacFiler$charSequence): javax.tools.FileObject;
              _inferModule(pkg: string): javac.code.Symbol$ModuleSymbol;
              _isInFileObjectHistory(fileObject: javax.tools.FileObject, forWriting: boolean): boolean;
              _isPackageInfo(name: string, allowUnnamedPackageInfo: boolean): boolean;
              _locationCheck(location: javax.tools.JavaFileManager$Location): void;
              newFiles(): boolean;
              newRound(): void;
              _originatingFiles(originatingElements: javax.lang.model.element.Element[]): javax.tools.JavaFileObject[];
              setInitialState(initialInputs: java.util.Collection<javax.tools.JavaFileObject>, initialClassNames: java.util.Collection<string>): void;
              _setLastRound(lastRound: boolean): void;
              toString(): string;
              warnIfUnclosedFiles(): void;
              _aggregateGeneratedClassNames: java.util.Set<javac.util.Pair<javac.code.Symbol$ModuleSymbol,string>>;
              _aggregateGeneratedSourceNames: java.util.Set<javac.util.Pair<javac.code.Symbol$ModuleSymbol,string>>;
              _context: javac.util.Context;
              _defaultTargetModule: string;
              _elementUtils: javac.model.JavacElements;
              _fileManager: javax.tools.JavaFileManager;
              _fileObjectHistory: java.util.Set<javax.tools.FileObject>;
              _generatedClasses: java.util.Map<javac.code.Symbol$ModuleSymbol,java.util.Map<string,javax.tools.JavaFileObject>>;
              _generatedSourceFileObjects: java.util.Set<javax.tools.JavaFileObject>;
              _generatedSourceNames: java.util.Set<string>;
              _initialClassNames: java.util.Set<string>;
              _initialInputs: java.util.Set<javax.tools.FileObject>;
              _lastRound: boolean;
              _lint: boolean;
              _log: javac.util.Log;
              _modules: javac.comp.Modules;
              _names: javac.util.Names;
              _openTypeNames: java.util.Set<string>;
              _syms: javac.code.Symtab;
            }
            interface JavacFiler extends CombineTypes<[_JavacFiler, javax.annotation.processing.Filer, java.io.Closeable, java.lang.Object]> {}
            interface _JavacFiler$FilerInputFileObject$$static extends ClassLike {
              _new(a0: JavacFiler, fileObject: javax.tools.FileObject): JavacFiler$FilerInputFileObject;
            }
            let JavacFiler$FilerInputFileObject: _JavacFiler$FilerInputFileObject$$static;
            interface _JavacFiler$FilerInputFileObject {
              delete(): boolean;
              openOutputStream(): java.io.OutputStream;
              openWriter(): java.io.Writer;
            }
            interface JavacFiler$FilerInputFileObject extends CombineTypes<[_JavacFiler$FilerInputFileObject, javax.tools.ForwardingFileObject<javax.tools.FileObject>]> {}
            interface _JavacFiler$FilerInputJavaFileObject$$static extends ClassLike {
              _new(a0: JavacFiler, javaFileObject: javax.tools.JavaFileObject): JavacFiler$FilerInputJavaFileObject;
            }
            let JavacFiler$FilerInputJavaFileObject: _JavacFiler$FilerInputJavaFileObject$$static;
            interface _JavacFiler$FilerInputJavaFileObject {
              getAccessLevel(): javax.lang.model.element.Modifier;
              getKind(): javax.tools.JavaFileObject$Kind;
              getNestingKind(): javax.lang.model.element.NestingKind;
              isNameCompatible(simpleName: string, kind: javax.tools.JavaFileObject$Kind): boolean;
              _javaFileObject: javax.tools.JavaFileObject;
            }
            interface JavacFiler$FilerInputJavaFileObject extends CombineTypes<[_JavacFiler$FilerInputJavaFileObject, javax.tools.JavaFileObject, com.sun.tools.javac.processing.JavacFiler$FilerInputFileObject]> {}
            interface _JavacFiler$FilerOutputFileObject$$static extends ClassLike {
              _new(a0: JavacFiler, mod: javac.code.Symbol$ModuleSymbol, name: string, fileObject: javax.tools.FileObject): JavacFiler$FilerOutputFileObject;
            }
            let JavacFiler$FilerOutputFileObject: _JavacFiler$FilerOutputFileObject$$static;
            interface _JavacFiler$FilerOutputFileObject {
              delete(): boolean;
              getCharContent(ignoreEncodingErrors: boolean): JavacFiler$FilerOutputFileObject$charSequence;
              openInputStream(): java.io.InputStream;
              openOutputStream(): java.io.OutputStream;
              openReader(ignoreEncodingErrors: boolean): java.io.Reader;
              openWriter(): java.io.Writer;
              _mod: javac.code.Symbol$ModuleSymbol;
              _name: string;
              _opened: boolean;
              _this$0: JavacFiler;
            }
            interface JavacFiler$FilerOutputFileObject extends CombineTypes<[_JavacFiler$FilerOutputFileObject, javax.tools.ForwardingFileObject<javax.tools.FileObject>]> {}
            interface _JavacFiler$FilerOutputJavaFileObject$$static extends ClassLike {
              _new(a0: JavacFiler, mod: javac.code.Symbol$ModuleSymbol, name: string, javaFileObject: javax.tools.JavaFileObject): JavacFiler$FilerOutputJavaFileObject;
            }
            let JavacFiler$FilerOutputJavaFileObject: _JavacFiler$FilerOutputJavaFileObject$$static;
            interface _JavacFiler$FilerOutputJavaFileObject {
              getAccessLevel(): javax.lang.model.element.Modifier;
              getKind(): javax.tools.JavaFileObject$Kind;
              getNestingKind(): javax.lang.model.element.NestingKind;
              isNameCompatible(simpleName: string, kind: javax.tools.JavaFileObject$Kind): boolean;
              _javaFileObject: javax.tools.JavaFileObject;
            }
            interface JavacFiler$FilerOutputJavaFileObject extends CombineTypes<[_JavacFiler$FilerOutputJavaFileObject, javax.tools.JavaFileObject, com.sun.tools.javac.processing.JavacFiler$FilerOutputFileObject]> {}
            interface _JavacFiler$FilerOutputStream$$static extends ClassLike {
              _new(a0: JavacFiler, mod: javac.code.Symbol$ModuleSymbol, typeName: string, fileObject: javax.tools.FileObject): JavacFiler$FilerOutputStream;
            }
            let JavacFiler$FilerOutputStream: _JavacFiler$FilerOutputStream$$static;
            interface _JavacFiler$FilerOutputStream {
              close(): void;
              write(b: byte[], off: int, len: int): void;
              _closed: boolean;
              _fileObject: javax.tools.FileObject;
              _mod: javac.code.Symbol$ModuleSymbol;
              _this$0: JavacFiler;
              _typeName: string;
            }
            interface JavacFiler$FilerOutputStream extends CombineTypes<[_JavacFiler$FilerOutputStream, java.io.FilterOutputStream]> {}
            interface _JavacFiler$FilerWriter$$static extends ClassLike {
              _new(a0: JavacFiler, mod: javac.code.Symbol$ModuleSymbol, typeName: string, fileObject: javax.tools.FileObject): JavacFiler$FilerWriter;
            }
            let JavacFiler$FilerWriter: _JavacFiler$FilerWriter$$static;
            interface _JavacFiler$FilerWriter {
              close(): void;
              _closed: boolean;
              _fileObject: javax.tools.FileObject;
              _mod: javac.code.Symbol$ModuleSymbol;
              _this$0: JavacFiler;
              _typeName: string;
            }
            interface JavacFiler$FilerWriter extends CombineTypes<[_JavacFiler$FilerWriter, java.io.FilterWriter]> {}
            interface _JavacFiler$Tuple3$$static<A,B,C> extends ClassLike {
              new(a: A, b: B, c: C): JavacFiler$Tuple3<A,B,C>;
            }
            let JavacFiler$Tuple3: _JavacFiler$Tuple3$$static<A,B,C>;
            interface _JavacFiler$Tuple3<A,B,C> {
              _a: A;
              _b: B;
              _c: C;
            }
            interface JavacFiler$Tuple3<A,B,C> extends CombineTypes<[_JavacFiler$Tuple3<A,B,C>, java.lang.Object]> {}
            interface _JavacMessager$$static extends ClassLike {
              _new(context: javac.util.Context, processingEnv: JavacProcessingEnvironment): JavacMessager;
            }
            let JavacMessager: _JavacMessager$$static;
            interface _JavacMessager {
              errorCount(): int;
              errorRaised(): boolean;
              newRound(): void;
              printError(msg: string): void;
              printMessage(kind: javax.tools.Diagnostic$Kind, msg: JavacMessager$charSequence): void;
              printMessage(kind: javax.tools.Diagnostic$Kind, msg: JavacMessager$charSequence, e: javax.lang.model.element.Element): void;
              printMessage(kind: javax.tools.Diagnostic$Kind, msg: JavacMessager$charSequence, e: javax.lang.model.element.Element, a: javax.lang.model.element.AnnotationMirror): void;
              printMessage(kind: javax.tools.Diagnostic$Kind, msg: JavacMessager$charSequence, e: javax.lang.model.element.Element, a: javax.lang.model.element.AnnotationMirror, v: javax.lang.model.element.AnnotationValue): void;
              printNotice(msg: string): void;
              printWarning(msg: string): void;
              toString(): string;
              warningCount(): int;
              _errorCount: int;
              _log: javac.util.Log;
              _processingEnv: JavacProcessingEnvironment;
              _warningCount: int;
            }
            interface JavacMessager extends CombineTypes<[_JavacMessager, java.lang.Object, javax.annotation.processing.Messager]> {}
            interface _JavacProcessingEnvironment$$static extends ClassLike {
              _importStringToPattern(allowModules: boolean, s: string, p: javax.annotation.processing.Processor, log: javac.util.Log, lint: boolean): java.util.regex.Pattern;
              instance(context: javac.util.Context): JavacProcessingEnvironment;
              isValidOptionName(optionName: string): boolean;
              _join<T>(list1: javac.util.List<T>, list2: javac.util.List<T>): javac.util.List<T>;
              _warnAndNoMatches(s: string, p: javax.annotation.processing.Processor, log: javac.util.Log, lint: boolean): java.util.regex.Pattern;
              readonly noMatches: java.util.regex.Pattern;
              _new(context: javac.util.Context): JavacProcessingEnvironment;
            }
            let JavacProcessingEnvironment: _JavacProcessingEnvironment$$static;
            interface _JavacProcessingEnvironment {
              atLeastOneProcessor(): boolean;
              _callProcessor(proc: javax.annotation.processing.Processor, tes: java.util.Set<javax.lang.model.element.TypeElement>, renv: javax.annotation.processing.RoundEnvironment): boolean;
              close(): void;
              _discoverAndRunProcs(annotationsPresent: java.util.Set<javax.lang.model.element.TypeElement>, topLevelClasses: javac.util.List<javac.code.Symbol$ClassSymbol>, packageInfoFiles: javac.util.List<javac.code.Symbol$PackageSymbol>, moduleInfoFiles: javac.util.List<javac.code.Symbol$ModuleSymbol>): void;
              doProcessing(roots: javac.util.List<javac.tree.JCTree$JCCompilationUnit>, classSymbols: javac.util.List<javac.code.Symbol$ClassSymbol>, pckSymbols: java.lang.Iterable<javac.code.Symbol$PackageSymbol>, deferredDiagnosticHandler: javac.util.Log$DeferredDiagnosticHandler): boolean;
              getContext(): javac.util.Context;
              getElementUtils(): javac.model.JavacElements;
              getElementUtils(): javax.lang.model.util.Elements;
              getFiler(): JavacFiler;
              getFiler(): javax.annotation.processing.Filer;
              getLocale(): java.util.Locale;
              getMessager(): javax.annotation.processing.Messager;
              _getModuleInfoFiles(units: javac.util.List<javac.tree.JCTree$JCCompilationUnit>): javac.util.List<javac.code.Symbol$ModuleSymbol>;
              getOptions(): java.util.Map<string,string>;
              _getPackageInfoFiles(units: javac.util.List<javac.tree.JCTree$JCCompilationUnit>): javac.util.List<javac.code.Symbol$PackageSymbol>;
              _getPackageInfoFilesFromClasses(syms: javac.util.List<javac.code.Symbol$ClassSymbol>): javac.util.List<javac.code.Symbol$PackageSymbol>;
              getProcessorClassLoader(): java.lang.ClassLoader;
              getServiceLoader<S>(service: java.lang.Class<S>): java.util.ServiceLoader<S>;
              getSourceVersion(): javax.lang.model.SourceVersion;
              getSpecifiedPackages(): java.util.Set<javac.code.Symbol$PackageSymbol>;
              _getTopLevelClasses(units: javac.util.List<javac.tree.JCTree$JCCompilationUnit>): javac.util.List<javac.code.Symbol$ClassSymbol>;
              _getTopLevelClassesFromClasses(syms: javac.util.List<javac.code.Symbol$ClassSymbol>): javac.util.List<javac.code.Symbol$ClassSymbol>;
              getTypeUtils(): javac.model.JavacTypes;
              getTypeUtils(): javax.lang.model.util.Types;
              _handleException(key: string, e: java.lang.Exception): void;
              _handleServiceLoaderUnavailability(key: string, e: java.lang.Exception): java.util.Iterator<javax.annotation.processing.Processor>;
              _initPlatformAnnotations(): java.util.Set<string>;
              _initProcessorIterator(processors: java.lang.Iterable<javax.annotation.processing.Processor>): void;
              _initProcessorLoader(): void;
              _initProcessorOptions(): java.util.Map<string,string>;
              _initUnmatchedProcessorOptions(): java.util.Set<string>;
              _isModuleInfo(fo: javax.tools.JavaFileObject, kind: javax.tools.JavaFileObject$Kind): boolean;
              _isPkgInfo(fo: javax.tools.JavaFileObject, kind: javax.tools.JavaFileObject$Kind): boolean;
              _isPkgInfo(sym: javac.code.Symbol$ClassSymbol): boolean;
              isPreviewEnabled(): boolean;
              _moreToDo(): boolean;
              _needClassLoader(procNames: string, workingpath: java.lang.Iterable<java.nio.file.Path>): boolean;
              setProcessors(processors: java.lang.Iterable<javax.annotation.processing.Processor>): void;
              toString(): string;
              _warnIfUnmatchedOptions(): void;
              _annotate: javac.comp.Annotate;
              _chk: javac.comp.Check;
              _compiler: javac.main.JavaCompiler;
              _context: javac.util.Context;
              _dcfh: javac.code.DeferredCompletionFailureHandler;
              _diags: javac.util.JCDiagnostic$Factory;
              _discoveredProcs: JavacProcessingEnvironment$DiscoveredProcessors;
              _elementUtils: javac.model.JavacElements;
              _enter: javac.comp.Enter;
              _fatalErrors: boolean;
              _fileManager: javax.tools.JavaFileManager;
              _filer: JavacFiler;
              _initialCompleter: javac.code.Symbol$Completer;
              _lint: boolean;
              _log: javac.util.Log;
              _messager: JavacMessager;
              _messages: javac.util.JavacMessages;
              _modules: javac.comp.Modules;
              _names: javac.util.Names;
              _options: javac.util.Options;
              _platformAnnotations: java.util.Set<string>;
              _preview: javac.code.Preview;
              _printProcessorInfo: boolean;
              _printRounds: boolean;
              _processorClassLoader: java.lang.ClassLoader;
              _processorLoaderException: java.lang.SecurityException;
              _processorOptions: java.util.Map<string,string>;
              _serviceLoader: java.util.ServiceLoader<javax.annotation.processing.Processor>;
              _showResolveErrors: boolean;
              _source: javac.code.Source;
              _specifiedPackages: java.util.Set<javac.code.Symbol$PackageSymbol>;
              _symtab: javac.code.Symtab;
              _taskListener: javac.api.MultiTaskListener;
              _treeCleaner: javac.tree.TreeScanner;
              _typeUtils: javac.model.JavacTypes;
              _types: javac.code.Types;
              _unmatchedProcessorOptions: java.util.Set<string>;
              _verbose: boolean;
              _werror: boolean;
            }
            interface JavacProcessingEnvironment extends CombineTypes<[_JavacProcessingEnvironment, java.io.Closeable, javax.annotation.processing.ProcessingEnvironment, java.lang.Object]> {}
            interface _JavacProcessingEnvironment$ComputeAnnotationSet$$static extends ClassLike {
              new(elements: javax.lang.model.util.Elements): JavacProcessingEnvironment$ComputeAnnotationSet;
            }
            let JavacProcessingEnvironment$ComputeAnnotationSet: _JavacProcessingEnvironment$ComputeAnnotationSet$$static;
            interface _JavacProcessingEnvironment$ComputeAnnotationSet {
              _addAnnotations(e: javax.lang.model.element.Element, p: java.util.Set<javax.lang.model.element.TypeElement>): void;
              scan(e: javax.lang.model.element.Element, p: java.util.Set<javax.lang.model.element.TypeElement>): java.util.Set<javax.lang.model.element.TypeElement>;
              scan(a0: javax.lang.model.element.Element, a1: any): any;
              visitExecutable(e: javax.lang.model.element.ExecutableElement, p: java.util.Set<javax.lang.model.element.TypeElement>): java.util.Set<javax.lang.model.element.TypeElement>;
              visitExecutable(a0: javax.lang.model.element.ExecutableElement, a1: any): any;
              visitPackage(e: javax.lang.model.element.PackageElement, p: java.util.Set<javax.lang.model.element.TypeElement>): java.util.Set<javax.lang.model.element.TypeElement>;
              visitPackage(a0: javax.lang.model.element.PackageElement, a1: any): any;
              visitType(e: javax.lang.model.element.TypeElement, p: java.util.Set<javax.lang.model.element.TypeElement>): java.util.Set<javax.lang.model.element.TypeElement>;
              visitType(a0: javax.lang.model.element.TypeElement, a1: any): any;
              _elements: javax.lang.model.util.Elements;
            }
            interface JavacProcessingEnvironment$ComputeAnnotationSet extends CombineTypes<[_JavacProcessingEnvironment$ComputeAnnotationSet, javax.lang.model.util.ElementScanner14<java.util.Set<javax.lang.model.element.TypeElement>,java.util.Set<javax.lang.model.element.TypeElement>>]> {}
            interface _JavacProcessingEnvironment$DiscoveredProcessors$$static extends ClassLike {
              _new(this$0: java.util.Iterator<javax.annotation.processing.Processor>): JavacProcessingEnvironment$DiscoveredProcessors;
            }
            let JavacProcessingEnvironment$DiscoveredProcessors: _JavacProcessingEnvironment$DiscoveredProcessors$$static;
            interface _JavacProcessingEnvironment$DiscoveredProcessors {
              close(): void;
              iterator(): JavacProcessingEnvironment$DiscoveredProcessors$ProcessorStateIterator;
              iterator(): java.util.Iterator;
              _procStateList: java.util.ArrayList<JavacProcessingEnvironment$ProcessorState>;
              _processorIterator: java.util.Iterator<javax.annotation.processing.Processor>;
              _this$0: JavacProcessingEnvironment;
            }
            interface JavacProcessingEnvironment$DiscoveredProcessors extends CombineTypes<[_JavacProcessingEnvironment$DiscoveredProcessors, java.lang.Object, java.lang.Iterable<JavacProcessingEnvironment$ProcessorState>]> {}
            interface _JavacProcessingEnvironment$DiscoveredProcessors$ProcessorStateIterator$$static extends ClassLike {
              _new(this$1: JavacProcessingEnvironment$DiscoveredProcessors, psi: JavacProcessingEnvironment$DiscoveredProcessors): JavacProcessingEnvironment$DiscoveredProcessors$ProcessorStateIterator;
            }
            let JavacProcessingEnvironment$DiscoveredProcessors$ProcessorStateIterator: _JavacProcessingEnvironment$DiscoveredProcessors$ProcessorStateIterator$$static;
            interface _JavacProcessingEnvironment$DiscoveredProcessors$ProcessorStateIterator {
              hasNext(): boolean;
              next(): JavacProcessingEnvironment$ProcessorState;
              next(): any;
              remove(): void;
              runContributingProcs(re: javax.annotation.processing.RoundEnvironment): void;
              _innerIter: java.util.Iterator<JavacProcessingEnvironment$ProcessorState>;
              _onProcIterator: boolean;
              _psi: JavacProcessingEnvironment$DiscoveredProcessors;
              _this$1: JavacProcessingEnvironment$DiscoveredProcessors;
            }
            interface JavacProcessingEnvironment$DiscoveredProcessors$ProcessorStateIterator extends CombineTypes<[_JavacProcessingEnvironment$DiscoveredProcessors$ProcessorStateIterator, java.lang.Object, java.util.Iterator<JavacProcessingEnvironment$ProcessorState>]> {}
            interface _JavacProcessingEnvironment$ImplicitCompleter$$static extends ClassLike {
              new(this$0: JavacProcessingEnvironment, topLevel: javac.tree.JCTree$JCCompilationUnit): JavacProcessingEnvironment$ImplicitCompleter;
            }
            let JavacProcessingEnvironment$ImplicitCompleter: _JavacProcessingEnvironment$ImplicitCompleter$$static;
            interface _JavacProcessingEnvironment$ImplicitCompleter {
              complete(sym: javac.code.Symbol): void;
              _this$0: JavacProcessingEnvironment;
              _topLevel: javac.tree.JCTree$JCCompilationUnit;
            }
            interface JavacProcessingEnvironment$ImplicitCompleter extends CombineTypes<[_JavacProcessingEnvironment$ImplicitCompleter, java.lang.Object, com.sun.tools.javac.code.Symbol$Completer]> {}
            interface _JavacProcessingEnvironment$NameProcessIterator$$static extends ClassLike {
              _new(names: string, processorCL: java.lang.ClassLoader, log: javac.util.Log): JavacProcessingEnvironment$NameProcessIterator;
            }
            let JavacProcessingEnvironment$NameProcessIterator: _JavacProcessingEnvironment$NameProcessIterator$$static;
            interface _JavacProcessingEnvironment$NameProcessIterator {
              _ensureReadable(targetClass: java.lang.Class<any>): void;
              _getNextProcessor(processorName: string): javax.annotation.processing.Processor;
              hasNext(): boolean;
              next(): javax.annotation.processing.Processor;
              next(): any;
              remove(): void;
              _log: javac.util.Log;
              _names: java.util.Iterator<string>;
              _nextProc: javax.annotation.processing.Processor;
              _processorCL: java.lang.ClassLoader;
            }
            interface JavacProcessingEnvironment$NameProcessIterator extends CombineTypes<[_JavacProcessingEnvironment$NameProcessIterator, java.util.Iterator<javax.annotation.processing.Processor>, java.lang.Object]> {}
            interface _JavacProcessingEnvironment$NameServiceIterator$$static extends ClassLike {
              new(a0: java.util.ServiceLoader<javax.annotation.processing.Processor>, loader: javac.util.Log, log: string): JavacProcessingEnvironment$NameServiceIterator;
            }
            let JavacProcessingEnvironment$NameServiceIterator: _JavacProcessingEnvironment$NameServiceIterator$$static;
            interface _JavacProcessingEnvironment$NameServiceIterator {
              _internalHasNext(): boolean;
              _internalNext(): javax.annotation.processing.Processor;
              _namedProcessorsMap: java.util.Map<string,javax.annotation.processing.Processor>;
              _nextProc: javax.annotation.processing.Processor;
              _processorNames: java.util.Iterator<string>;
            }
            interface JavacProcessingEnvironment$NameServiceIterator extends CombineTypes<[_JavacProcessingEnvironment$NameServiceIterator, com.sun.tools.javac.processing.JavacProcessingEnvironment$ServiceIterator]> {}
            interface _JavacProcessingEnvironment$ProcessorState$$static extends ClassLike {
              _new(p: javax.annotation.processing.Processor, log: javac.util.Log, source: javac.code.Source, dcfh: javac.code.DeferredCompletionFailureHandler, allowModules: boolean, env: javax.annotation.processing.ProcessingEnvironment, lint: boolean): JavacProcessingEnvironment$ProcessorState;
            }
            let JavacProcessingEnvironment$ProcessorState: _JavacProcessingEnvironment$ProcessorState$$static;
            interface _JavacProcessingEnvironment$ProcessorState {
              annotationSupported(annotationName: string): boolean;
              _checkOptionName(optionName: string, log: javac.util.Log): boolean;
              _checkSourceVersionCompatibility(source: javac.code.Source, log: javac.util.Log): void;
              removeSupportedOptions(unmatchedProcessorOptions: java.util.Set<string>): void;
              contributed: boolean;
              processor: javax.annotation.processing.Processor;
              _supportedAnnotationPatterns: java.util.Set<java.util.regex.Pattern>;
              _supportedAnnotationStrings: java.util.Set<string>;
              _supportedOptionNames: java.util.Set<string>;
            }
            interface JavacProcessingEnvironment$ProcessorState extends CombineTypes<[_JavacProcessingEnvironment$ProcessorState, java.lang.Object]> {}
            interface _JavacProcessingEnvironment$Round$$static extends ClassLike {
              _new(this$0: javac.util.List<javac.tree.JCTree$JCCompilationUnit>, roots: javac.util.List<javac.code.Symbol$ClassSymbol>, classSymbols: java.util.Set<javac.tree.JCTree$JCCompilationUnit>, treesToClean: javac.util.Log$DeferredDiagnosticHandler): JavacProcessingEnvironment$Round;
            }
            let JavacProcessingEnvironment$Round: _JavacProcessingEnvironment$Round$$static;
            interface _JavacProcessingEnvironment$Round {
              _enterClassFiles(modulesAndClassFiles: java.util.Map<javac.code.Symbol$ModuleSymbol,java.util.Map<string,javax.tools.JavaFileObject>>): javac.util.List<javac.code.Symbol$ClassSymbol>;
              _enterTrees(roots: javac.util.List<javac.tree.JCTree$JCCompilationUnit>): void;
              _errorCount(): int;
              _finalCompiler(): void;
              _findAnnotationsPresent(): void;
              _newRound(): void;
              _next(newSourceFiles: java.util.Set<javax.tools.JavaFileObject>, newClassFiles: java.util.Map<javac.code.Symbol$ModuleSymbol,java.util.Map<string,javax.tools.JavaFileObject>>): JavacProcessingEnvironment$Round;
              _printRoundInfo(lastRound: boolean): void;
              _run(lastRound: boolean, errorStatus: boolean): void;
              _showDiagnostics(showAll: boolean): void;
              _unrecoverableError(): boolean;
              _warningCount(): int;
              _ACCEPT_ALL: java.util.function.Predicate<javac.util.JCDiagnostic>;
              _ACCEPT_NON_RECOVERABLE: java.util.function.Predicate<javac.util.JCDiagnostic>;
              _annotationsPresent: java.util.Set<javax.lang.model.element.TypeElement>;
              _deferredDiagnosticHandler: javac.util.Log$DeferredDiagnosticHandler;
              _genClassFiles: java.util.Map<javac.code.Symbol$ModuleSymbol,java.util.Map<string,javax.tools.JavaFileObject>>;
              _moduleInfoFiles: javac.util.List<javac.code.Symbol$ModuleSymbol>;
              _number: int;
              _packageInfoFiles: javac.util.List<javac.code.Symbol$PackageSymbol>;
              _roots: javac.util.List<javac.tree.JCTree$JCCompilationUnit>;
              _this$0: JavacProcessingEnvironment;
              _topLevelClasses: javac.util.List<javac.code.Symbol$ClassSymbol>;
              _treesToClean: java.util.Set<javac.tree.JCTree$JCCompilationUnit>;
            }
            interface JavacProcessingEnvironment$Round extends CombineTypes<[_JavacProcessingEnvironment$Round, java.lang.Object]> {}
            interface _JavacProcessingEnvironment$ServiceIterator$$static extends ClassLike {
              _new(a0: JavacProcessingEnvironment, classLoader: java.lang.ClassLoader, log: javac.util.Log): JavacProcessingEnvironment$ServiceIterator;
              _new(a0: java.util.ServiceLoader<javax.annotation.processing.Processor>, loader: javac.util.Log): JavacProcessingEnvironment$ServiceIterator;
            }
            let JavacProcessingEnvironment$ServiceIterator: _JavacProcessingEnvironment$ServiceIterator$$static;
            interface _JavacProcessingEnvironment$ServiceIterator {
              close(): void;
              hasNext(): boolean;
              _internalHasNext(): boolean;
              _internalNext(): javax.annotation.processing.Processor;
              next(): javax.annotation.processing.Processor;
              next(): any;
              remove(): void;
              _iterator: java.util.Iterator<javax.annotation.processing.Processor>;
              _loader: java.util.ServiceLoader<javax.annotation.processing.Processor>;
              _log: javac.util.Log;
            }
            interface JavacProcessingEnvironment$ServiceIterator extends CombineTypes<[_JavacProcessingEnvironment$ServiceIterator, java.util.Iterator<javax.annotation.processing.Processor>, java.lang.Object]> {}
            interface _JavacRoundEnvironment$$static extends ClassLike {
              _NOT_AN_ANNOTATION_TYPE: string;
              _new(processingOver: boolean, errorRaised: boolean, rootElements: java.util.Set<javax.lang.model.element.Element>, processingEnv: JavacProcessingEnvironment): JavacRoundEnvironment;
            }
            let JavacRoundEnvironment: _JavacRoundEnvironment$$static;
            interface _JavacRoundEnvironment {
              _annotationToElement(annotation: java.lang.Class<java.lang.annotation.Annotation>): javax.lang.model.element.TypeElement;
              errorRaised(): boolean;
              getElementsAnnotatedWith(a: javax.lang.model.element.TypeElement): java.util.Set<javax.lang.model.element.Element>;
              getElementsAnnotatedWith(a: java.lang.Class<java.lang.annotation.Annotation>): java.util.Set<javax.lang.model.element.Element>;
              getElementsAnnotatedWithAny(annotations: javax.lang.model.element.TypeElement[]): java.util.Set<javax.lang.model.element.Element>;
              getElementsAnnotatedWithAny(...annotations: javax.lang.model.element.TypeElement[]): java.util.Set<javax.lang.model.element.Element>;
              getElementsAnnotatedWithAny(annotations: java.util.Set<java.lang.Class<java.lang.annotation.Annotation>>): java.util.Set<javax.lang.model.element.Element>;
              getRootElements(): java.util.Set<javax.lang.model.element.Element>;
              _mirrorAsElement(annotationMirror: javax.lang.model.element.AnnotationMirror): javax.lang.model.element.Element;
              processingOver(): boolean;
              _throwIfNotAnnotation(a: java.lang.Class<java.lang.annotation.Annotation>): void;
              _throwIfNotAnnotation(a: javax.lang.model.element.TypeElement): void;
              toString(): string;
              _allowModules: boolean;
              _eltUtils: javax.lang.model.util.Elements;
              _errorRaised: boolean;
              _processingEnv: javax.annotation.processing.ProcessingEnvironment;
              _processingOver: boolean;
              _rootElements: java.util.Set<javax.lang.model.element.Element>;
            }
            interface JavacRoundEnvironment extends CombineTypes<[_JavacRoundEnvironment, javax.annotation.processing.RoundEnvironment, java.lang.Object]> {}
            interface _JavacRoundEnvironment$AnnotationSetMultiScanner$$static extends ClassLike {
              _new(a0: java.util.Set<javax.lang.model.element.Element>): JavacRoundEnvironment$AnnotationSetMultiScanner;
            }
            let JavacRoundEnvironment$AnnotationSetMultiScanner: _JavacRoundEnvironment$AnnotationSetMultiScanner$$static;
            interface _JavacRoundEnvironment$AnnotationSetMultiScanner {
              scan(e: javax.lang.model.element.Element, annotations: java.util.Set<javax.lang.model.element.TypeElement>): java.util.Set<javax.lang.model.element.Element>;
              scan(a0: javax.lang.model.element.Element, a1: any): any;
              visitModule(e: javax.lang.model.element.ModuleElement, annotations: java.util.Set<javax.lang.model.element.TypeElement>): java.util.Set<javax.lang.model.element.Element>;
              visitModule(a0: javax.lang.model.element.ModuleElement, a1: any): any;
              visitPackage(e: javax.lang.model.element.PackageElement, annotations: java.util.Set<javax.lang.model.element.TypeElement>): java.util.Set<javax.lang.model.element.Element>;
              visitPackage(a0: javax.lang.model.element.PackageElement, a1: any): any;
              _annotatedElements: java.util.Set<javax.lang.model.element.Element>;
              _this$0: JavacRoundEnvironment;
            }
            interface JavacRoundEnvironment$AnnotationSetMultiScanner extends CombineTypes<[_JavacRoundEnvironment$AnnotationSetMultiScanner, javax.lang.model.util.ElementScanner14<java.util.Set<javax.lang.model.element.Element>,java.util.Set<javax.lang.model.element.TypeElement>>]> {}
            interface _JavacRoundEnvironment$AnnotationSetScanner$$static extends ClassLike {
              _new(a0: java.util.Set<javax.lang.model.element.Element>): JavacRoundEnvironment$AnnotationSetScanner;
            }
            let JavacRoundEnvironment$AnnotationSetScanner: _JavacRoundEnvironment$AnnotationSetScanner$$static;
            interface _JavacRoundEnvironment$AnnotationSetScanner {
              scan(e: javax.lang.model.element.Element, annotation: javax.lang.model.element.TypeElement): java.util.Set<javax.lang.model.element.Element>;
              scan(a0: javax.lang.model.element.Element, a1: any): any;
              visitModule(e: javax.lang.model.element.ModuleElement, annotation: javax.lang.model.element.TypeElement): java.util.Set<javax.lang.model.element.Element>;
              visitModule(a0: javax.lang.model.element.ModuleElement, a1: any): any;
              visitPackage(e: javax.lang.model.element.PackageElement, annotation: javax.lang.model.element.TypeElement): java.util.Set<javax.lang.model.element.Element>;
              visitPackage(a0: javax.lang.model.element.PackageElement, a1: any): any;
              _annotatedElements: java.util.Set<javax.lang.model.element.Element>;
              _this$0: JavacRoundEnvironment;
            }
            interface JavacRoundEnvironment$AnnotationSetScanner extends CombineTypes<[_JavacRoundEnvironment$AnnotationSetScanner, javax.lang.model.util.ElementScanner14<java.util.Set<javax.lang.model.element.Element>,javax.lang.model.element.TypeElement>]> {}
            interface _PrintingProcessor$$static extends ClassLike {
              new(): PrintingProcessor;
            }
            let PrintingProcessor: _PrintingProcessor$$static;
            interface _PrintingProcessor {
              _print(element: javax.lang.model.element.Element): void;
              process(tes: java.util.Set<javax.lang.model.element.TypeElement>, renv: javax.annotation.processing.RoundEnvironment): boolean;
              setWriter(w: java.io.Writer): void;
              _writer: java.io.PrintWriter;
            }
            interface PrintingProcessor extends CombineTypes<[_PrintingProcessor, javax.annotation.processing.AbstractProcessor]> {}
            interface _PrintingProcessor$PrintingElementVisitor$$static extends ClassLike {
              _spaces: string[];
              new(w: java.io.Writer, elementUtils: javax.lang.model.util.Elements): PrintingProcessor$PrintingElementVisitor;
            }
            let PrintingProcessor$PrintingElementVisitor: _PrintingProcessor$PrintingElementVisitor$$static;
            interface _PrintingProcessor$PrintingElementVisitor {
              _annotationsToString(e: javax.lang.model.element.Element): string;
              _defaultAction(e: javax.lang.model.element.Element, newLine: boolean): PrintingProcessor$PrintingElementVisitor;
              _defaultAction(a0: javax.lang.model.element.Element, a1: any): any;
              flush(): void;
              _indent(): void;
              _printAnnotations(e: javax.lang.model.element.Element): void;
              _printDirective(directive: javax.lang.model.element.ModuleElement$Directive): void;
              _printDocComment(e: javax.lang.model.element.Element): void;
              _printFormalTypeParameters(e: javax.lang.model.element.Parameterizable, pad: boolean): void;
              _printInterfaces(e: javax.lang.model.element.TypeElement): void;
              _printModifiers(e: javax.lang.model.element.Element): void;
              _printParameters(e: javax.lang.model.element.ExecutableElement): void;
              _printPermittedSubclasses(e: javax.lang.model.element.TypeElement): void;
              _printThrows(e: javax.lang.model.element.ExecutableElement): void;
              _printedContainerAnnotation(e: javax.lang.model.element.Element, annotationMirror: javax.lang.model.element.AnnotationMirror): boolean;
              visitExecutable(e: javax.lang.model.element.ExecutableElement, p: boolean): PrintingProcessor$PrintingElementVisitor;
              visitExecutable(a0: javax.lang.model.element.ExecutableElement, a1: any): any;
              visitModule(e: javax.lang.model.element.ModuleElement, p: boolean): PrintingProcessor$PrintingElementVisitor;
              visitModule(a0: javax.lang.model.element.ModuleElement, a1: any): any;
              visitPackage(e: javax.lang.model.element.PackageElement, p: boolean): PrintingProcessor$PrintingElementVisitor;
              visitPackage(a0: javax.lang.model.element.PackageElement, a1: any): any;
              visitRecordComponent(e: javax.lang.model.element.RecordComponentElement, p: boolean): PrintingProcessor$PrintingElementVisitor;
              visitRecordComponent(a0: javax.lang.model.element.RecordComponentElement, a1: any): any;
              visitType(e: javax.lang.model.element.TypeElement, p: boolean): PrintingProcessor$PrintingElementVisitor;
              visitType(a0: javax.lang.model.element.TypeElement, a1: any): any;
              visitTypeParameter(e: javax.lang.model.element.TypeParameterElement, p: boolean): PrintingProcessor$PrintingElementVisitor;
              visitTypeParameter(a0: javax.lang.model.element.TypeParameterElement, a1: any): any;
              visitVariable(e: javax.lang.model.element.VariableElement, newLine: boolean): PrintingProcessor$PrintingElementVisitor;
              visitVariable(a0: javax.lang.model.element.VariableElement, a1: any): any;
              _elementUtils: javax.lang.model.util.Elements;
              _indentation: int;
              _writer: java.io.PrintWriter;
            }
            interface PrintingProcessor$PrintingElementVisitor extends CombineTypes<[_PrintingProcessor$PrintingElementVisitor, javax.lang.model.util.SimpleElementVisitor14<PrintingProcessor$PrintingElementVisitor,boolean>]> {}
            interface _PrintingProcessor$PrintingElementVisitor$PrintDirective$$static extends ClassLike {
              _new(writer: java.io.PrintWriter): PrintingProcessor$PrintingElementVisitor$PrintDirective;
            }
            let PrintingProcessor$PrintingElementVisitor$PrintDirective: _PrintingProcessor$PrintingElementVisitor$PrintDirective$$static;
            interface _PrintingProcessor$PrintingElementVisitor$PrintDirective {
              _printModuleList(modules: java.util.List<javax.lang.model.element.ModuleElement>): void;
              _printNameableList(nameables: java.util.List<javax.lang.model.element.QualifiedNameable>): void;
              visitExports(d: javax.lang.model.element.ModuleElement$ExportsDirective, p: java.lang.Void): java.lang.Void;
              visitExports(a0: javax.lang.model.element.ModuleElement$ExportsDirective, a1: any): any;
              visitOpens(d: javax.lang.model.element.ModuleElement$OpensDirective, p: java.lang.Void): java.lang.Void;
              visitOpens(a0: javax.lang.model.element.ModuleElement$OpensDirective, a1: any): any;
              visitProvides(d: javax.lang.model.element.ModuleElement$ProvidesDirective, p: java.lang.Void): java.lang.Void;
              visitProvides(a0: javax.lang.model.element.ModuleElement$ProvidesDirective, a1: any): any;
              visitRequires(d: javax.lang.model.element.ModuleElement$RequiresDirective, p: java.lang.Void): java.lang.Void;
              visitRequires(a0: javax.lang.model.element.ModuleElement$RequiresDirective, a1: any): any;
              visitUses(d: javax.lang.model.element.ModuleElement$UsesDirective, p: java.lang.Void): java.lang.Void;
              visitUses(a0: javax.lang.model.element.ModuleElement$UsesDirective, a1: any): any;
              _writer: java.io.PrintWriter;
            }
            interface PrintingProcessor$PrintingElementVisitor$PrintDirective extends CombineTypes<[_PrintingProcessor$PrintingElementVisitor$PrintDirective, java.lang.Object, javax.lang.model.element.ModuleElement$DirectiveVisitor<java.lang.Void,java.lang.Void>]> {}
            interface _ServiceProxy$$static extends ClassLike {
              _fail(service: java.lang.Class<any>, msg: string): void;
              _fail(service: java.lang.Class<any>, u: java.net.URL, line: int, msg: string): void;
              hasService(service: java.lang.Class<any>, urls: java.net.URL[]): boolean;
              _parse(service: java.lang.Class<any>, u: java.net.URL): boolean;
              _prefix: string;
              _new(): ServiceProxy;
            }
            let ServiceProxy: _ServiceProxy$$static;
            interface _ServiceProxy {
            }
            interface ServiceProxy extends CombineTypes<[_ServiceProxy, java.lang.Object]> {}
            interface _ServiceProxy$ServiceConfigurationError$$static extends ClassLike {
              _serialVersionUID: long;
              _new(msg: string): ServiceProxy$ServiceConfigurationError;
            }
            let ServiceProxy$ServiceConfigurationError: _ServiceProxy$ServiceConfigurationError$$static;
            interface _ServiceProxy$ServiceConfigurationError {
            }
            interface ServiceProxy$ServiceConfigurationError extends CombineTypes<[_ServiceProxy$ServiceConfigurationError, java.lang.Error]> {}
          }
          module resources {
            interface _CompilerProperties$$static extends ClassLike {
              new(): CompilerProperties;
            }
            let CompilerProperties: _CompilerProperties$$static;
            interface _CompilerProperties {
            }
            interface CompilerProperties extends CombineTypes<[_CompilerProperties, java.lang.Object]> {}
            interface _CompilerProperties$Errors$$static extends ClassLike {
              AbstractCantBeAccessedDirectly(arg0: javac.code.Kinds$KindName, arg1: javac.code.Symbol, arg2: javac.code.Symbol): javac.util.JCDiagnostic$Error;
              AbstractCantBeInstantiated(arg0: javac.code.Symbol): javac.util.JCDiagnostic$Error;
              AddExportsWithRelease(arg0: javac.code.Symbol): javac.util.JCDiagnostic$Error;
              AddReadsWithRelease(arg0: javac.code.Symbol): javac.util.JCDiagnostic$Error;
              AlreadyAnnotated(arg0: javac.code.Kinds$KindName, arg1: javac.code.Symbol): javac.util.JCDiagnostic$Error;
              AlreadyDefined(arg0: javac.code.Kinds$KindName, arg1: javac.code.Symbol, arg2: javac.code.Kinds$KindName, arg3: javac.code.Symbol): javac.util.JCDiagnostic$Error;
              AlreadyDefinedInClinit(arg0: javac.code.Kinds$KindName, arg1: javac.code.Symbol, arg2: javac.code.Kinds$KindName, arg3: javac.code.Kinds$KindName, arg4: javac.code.Symbol): javac.util.JCDiagnostic$Error;
              AlreadyDefinedSingleImport(arg0: javac.code.Symbol): javac.util.JCDiagnostic$Error;
              AlreadyDefinedStaticSingleImport(arg0: javac.code.Symbol): javac.util.JCDiagnostic$Error;
              AlreadyDefinedThisUnit(arg0: javac.code.Symbol): javac.util.JCDiagnostic$Error;
              AnnotationMissingDefaultValue(arg0: javac.code.Type, arg1: java.util.List<javac.util.Name>): javac.util.JCDiagnostic$Error;
              AnnotationMissingDefaultValue1(arg0: javac.code.Type, arg1: java.util.List<javac.util.Name>): javac.util.JCDiagnostic$Error;
              AnnotationNotValidForType(arg0: javac.code.Type): javac.util.JCDiagnostic$Error;
              AnnotationTypeNotApplicableToType(arg0: javac.code.Type): javac.util.JCDiagnostic$Error;
              AnnotationUnrecognizedAttributeName(arg0: javac.code.Type, arg1: javac.util.Name): javac.util.JCDiagnostic$Error;
              AnonymousDiamondMethodDoesNotOverrideSuperclass(arg0: javac.util.JCDiagnostic): javac.util.JCDiagnostic$Error;
              AnonymousDiamondMethodDoesNotOverrideSuperclass(arg0: javac.util.JCDiagnostic$Fragment): javac.util.JCDiagnostic$Error;
              ArrayAndVarargs(arg0: javac.code.Symbol, arg1: javac.code.Symbol, arg2: javac.code.Symbol): javac.util.JCDiagnostic$Error;
              ArrayReqButFound(arg0: javac.code.Type): javac.util.JCDiagnostic$Error;
              BadFileName(arg0: string): javac.util.JCDiagnostic$Error;
              BadFunctionalIntfAnno1(arg0: javac.util.JCDiagnostic): javac.util.JCDiagnostic$Error;
              BadFunctionalIntfAnno1(arg0: javac.util.JCDiagnostic$Fragment): javac.util.JCDiagnostic$Error;
              BadInitializer(arg0: string): javac.util.JCDiagnostic$Error;
              BadNameForOption(arg0: javac.main.Option, arg1: string): javac.util.JCDiagnostic$Error;
              BadValueForOption(arg0: string, arg1: string): javac.util.JCDiagnostic$Error;
              CallMustBeFirstStmtInCtor(arg0: javac.util.Name): javac.util.JCDiagnostic$Error;
              CallToSuperNotAllowedInEnumCtor(arg0: javac.code.Symbol): javac.util.JCDiagnostic$Error;
              CannotAssignNotDeclaredGuard(arg0: javac.code.Symbol): javac.util.JCDiagnostic$Error;
              CannotGenerateClass(arg0: javac.code.Symbol, arg1: javac.util.JCDiagnostic$Fragment): javac.util.JCDiagnostic$Error;
              CantAccess(arg0: javac.code.Symbol, arg1: javac.util.JCDiagnostic): javac.util.JCDiagnostic$Error;
              CantAccess(arg0: javac.code.Symbol, arg1: javac.util.JCDiagnostic$Fragment): javac.util.JCDiagnostic$Error;
              CantApplyDiamond(arg0: javac.util.JCDiagnostic, arg1: java.lang.Void): javac.util.JCDiagnostic$Error;
              CantApplyDiamond(arg0: javac.util.JCDiagnostic$Fragment, arg1: java.lang.Void): javac.util.JCDiagnostic$Error;
              CantApplyDiamond1(arg0: javac.util.JCDiagnostic, arg1: javac.util.JCDiagnostic): javac.util.JCDiagnostic$Error;
              CantApplyDiamond1(arg0: javac.util.JCDiagnostic, arg1: javac.util.JCDiagnostic$Fragment): javac.util.JCDiagnostic$Error;
              CantApplyDiamond1(arg0: javac.util.JCDiagnostic$Fragment, arg1: javac.util.JCDiagnostic): javac.util.JCDiagnostic$Error;
              CantApplyDiamond1(arg0: javac.util.JCDiagnostic$Fragment, arg1: javac.util.JCDiagnostic$Fragment): javac.util.JCDiagnostic$Error;
              CantApplyDiamond1(arg0: javac.code.Type, arg1: javac.util.JCDiagnostic): javac.util.JCDiagnostic$Error;
              CantApplyDiamond1(arg0: javac.code.Type, arg1: javac.util.JCDiagnostic$Fragment): javac.util.JCDiagnostic$Error;
              CantApplySymbol(arg0: javac.code.Kinds$Kind, arg1: javac.util.Name, arg2: java.util.List<javac.code.Type>, arg3: java.util.List<javac.code.Type>, arg4: javac.code.Kinds$Kind, arg5: javac.code.Type, arg6: javac.util.JCDiagnostic): javac.util.JCDiagnostic$Error;
              CantApplySymbol(arg0: javac.code.Kinds$Kind, arg1: javac.util.Name, arg2: java.util.List<javac.code.Type>, arg3: java.util.List<javac.code.Type>, arg4: javac.code.Kinds$Kind, arg5: javac.code.Type, arg6: javac.util.JCDiagnostic$Fragment): javac.util.JCDiagnostic$Error;
              CantApplySymbol(arg0: javac.code.Kinds$Kind, arg1: javac.util.Name, arg2: java.util.List<javac.code.Type>, arg3: javac.util.JCDiagnostic, arg4: javac.code.Kinds$Kind, arg5: javac.code.Type, arg6: javac.util.JCDiagnostic): javac.util.JCDiagnostic$Error;
              CantApplySymbol(arg0: javac.code.Kinds$Kind, arg1: javac.util.Name, arg2: java.util.List<javac.code.Type>, arg3: javac.util.JCDiagnostic, arg4: javac.code.Kinds$Kind, arg5: javac.code.Type, arg6: javac.util.JCDiagnostic$Fragment): javac.util.JCDiagnostic$Error;
              CantApplySymbol(arg0: javac.code.Kinds$Kind, arg1: javac.util.Name, arg2: java.util.List<javac.code.Type>, arg3: javac.util.JCDiagnostic$Fragment, arg4: javac.code.Kinds$Kind, arg5: javac.code.Type, arg6: javac.util.JCDiagnostic): javac.util.JCDiagnostic$Error;
              CantApplySymbol(arg0: javac.code.Kinds$Kind, arg1: javac.util.Name, arg2: java.util.List<javac.code.Type>, arg3: javac.util.JCDiagnostic$Fragment, arg4: javac.code.Kinds$Kind, arg5: javac.code.Type, arg6: javac.util.JCDiagnostic$Fragment): javac.util.JCDiagnostic$Error;
              CantApplySymbol(arg0: javac.code.Kinds$Kind, arg1: javac.util.Name, arg2: javac.util.JCDiagnostic, arg3: java.util.List<javac.code.Type>, arg4: javac.code.Kinds$Kind, arg5: javac.code.Type, arg6: javac.util.JCDiagnostic): javac.util.JCDiagnostic$Error;
              CantApplySymbol(arg0: javac.code.Kinds$Kind, arg1: javac.util.Name, arg2: javac.util.JCDiagnostic, arg3: java.util.List<javac.code.Type>, arg4: javac.code.Kinds$Kind, arg5: javac.code.Type, arg6: javac.util.JCDiagnostic$Fragment): javac.util.JCDiagnostic$Error;
              CantApplySymbol(arg0: javac.code.Kinds$Kind, arg1: javac.util.Name, arg2: javac.util.JCDiagnostic, arg3: javac.util.JCDiagnostic, arg4: javac.code.Kinds$Kind, arg5: javac.code.Type, arg6: javac.util.JCDiagnostic): javac.util.JCDiagnostic$Error;
              CantApplySymbol(arg0: javac.code.Kinds$Kind, arg1: javac.util.Name, arg2: javac.util.JCDiagnostic, arg3: javac.util.JCDiagnostic, arg4: javac.code.Kinds$Kind, arg5: javac.code.Type, arg6: javac.util.JCDiagnostic$Fragment): javac.util.JCDiagnostic$Error;
              CantApplySymbol(arg0: javac.code.Kinds$Kind, arg1: javac.util.Name, arg2: javac.util.JCDiagnostic, arg3: javac.util.JCDiagnostic$Fragment, arg4: javac.code.Kinds$Kind, arg5: javac.code.Type, arg6: javac.util.JCDiagnostic): javac.util.JCDiagnostic$Error;
              CantApplySymbol(arg0: javac.code.Kinds$Kind, arg1: javac.util.Name, arg2: javac.util.JCDiagnostic, arg3: javac.util.JCDiagnostic$Fragment, arg4: javac.code.Kinds$Kind, arg5: javac.code.Type, arg6: javac.util.JCDiagnostic$Fragment): javac.util.JCDiagnostic$Error;
              CantApplySymbol(arg0: javac.code.Kinds$Kind, arg1: javac.util.Name, arg2: javac.util.JCDiagnostic$Fragment, arg3: java.util.List<javac.code.Type>, arg4: javac.code.Kinds$Kind, arg5: javac.code.Type, arg6: javac.util.JCDiagnostic): javac.util.JCDiagnostic$Error;
              CantApplySymbol(arg0: javac.code.Kinds$Kind, arg1: javac.util.Name, arg2: javac.util.JCDiagnostic$Fragment, arg3: java.util.List<javac.code.Type>, arg4: javac.code.Kinds$Kind, arg5: javac.code.Type, arg6: javac.util.JCDiagnostic$Fragment): javac.util.JCDiagnostic$Error;
              CantApplySymbol(arg0: javac.code.Kinds$Kind, arg1: javac.util.Name, arg2: javac.util.JCDiagnostic$Fragment, arg3: javac.util.JCDiagnostic, arg4: javac.code.Kinds$Kind, arg5: javac.code.Type, arg6: javac.util.JCDiagnostic): javac.util.JCDiagnostic$Error;
              CantApplySymbol(arg0: javac.code.Kinds$Kind, arg1: javac.util.Name, arg2: javac.util.JCDiagnostic$Fragment, arg3: javac.util.JCDiagnostic, arg4: javac.code.Kinds$Kind, arg5: javac.code.Type, arg6: javac.util.JCDiagnostic$Fragment): javac.util.JCDiagnostic$Error;
              CantApplySymbol(arg0: javac.code.Kinds$Kind, arg1: javac.util.Name, arg2: javac.util.JCDiagnostic$Fragment, arg3: javac.util.JCDiagnostic$Fragment, arg4: javac.code.Kinds$Kind, arg5: javac.code.Type, arg6: javac.util.JCDiagnostic): javac.util.JCDiagnostic$Error;
              CantApplySymbol(arg0: javac.code.Kinds$Kind, arg1: javac.util.Name, arg2: javac.util.JCDiagnostic$Fragment, arg3: javac.util.JCDiagnostic$Fragment, arg4: javac.code.Kinds$Kind, arg5: javac.code.Type, arg6: javac.util.JCDiagnostic$Fragment): javac.util.JCDiagnostic$Error;
              CantApplySymbolNoargs(arg0: javac.code.Kinds$Kind, arg1: javac.util.Name, arg2: javac.code.Kinds$Kind, arg3: javac.code.Type, arg4: javac.util.JCDiagnostic): javac.util.JCDiagnostic$Error;
              CantApplySymbolNoargs(arg0: javac.code.Kinds$Kind, arg1: javac.util.Name, arg2: javac.code.Kinds$Kind, arg3: javac.code.Type, arg4: javac.util.JCDiagnostic$Fragment): javac.util.JCDiagnostic$Error;
              CantApplySymbols(arg0: javac.code.Kinds$Kind, arg1: javac.util.Name, arg2: java.util.List<javac.code.Type>): javac.util.JCDiagnostic$Error;
              CantAssignValToVar(arg0: java.util.Set<javac.code.Flags$Flag>, arg1: javac.code.Symbol): javac.util.JCDiagnostic$Error;
              CantAssignValToVar(arg0: string, arg1: javac.code.Symbol): javac.util.JCDiagnostic$Error;
              CantAttachTypeAnnotations(arg0: java.util.List<javac.code.Attribute$Compound>, arg1: javac.code.Symbol, arg2: javac.util.Name, arg3: javac.util.JCDiagnostic): javac.util.JCDiagnostic$Error;
              CantAttachTypeAnnotations(arg0: java.util.List<javac.code.Attribute$Compound>, arg1: javac.code.Symbol, arg2: javac.util.Name, arg3: javac.util.JCDiagnostic$Fragment): javac.util.JCDiagnostic$Error;
              CantDeref(arg0: javac.code.Type): javac.util.JCDiagnostic$Error;
              CantInferLocalVarType(arg0: javac.util.Name, arg1: javac.util.JCDiagnostic): javac.util.JCDiagnostic$Error;
              CantInferLocalVarType(arg0: javac.util.Name, arg1: javac.util.JCDiagnostic$Fragment): javac.util.JCDiagnostic$Error;
              CantInheritDiffArg(arg0: javac.code.Symbol, arg1: string, arg2: string): javac.util.JCDiagnostic$Error;
              CantInheritFromFinal(arg0: javac.code.Symbol): javac.util.JCDiagnostic$Error;
              CantInheritFromSealed(arg0: javac.code.Symbol): javac.util.JCDiagnostic$Error;
              CantRefBeforeCtorCalled(arg0: javac.code.Symbol): javac.util.JCDiagnostic$Error;
              CantRefBeforeCtorCalled(arg0: string): javac.util.JCDiagnostic$Error;
              CantRefNonEffectivelyFinalVar(arg0: javac.code.Symbol, arg1: javac.util.JCDiagnostic): javac.util.JCDiagnostic$Error;
              CantRefNonEffectivelyFinalVar(arg0: javac.code.Symbol, arg1: javac.util.JCDiagnostic$Fragment): javac.util.JCDiagnostic$Error;
              CantResolve(arg0: javac.code.Kinds$KindName, arg1: javac.util.Name, arg2: java.lang.Void, arg3: java.lang.Void): javac.util.JCDiagnostic$Error;
              CantResolveArgs(arg0: javac.code.Kinds$KindName, arg1: javac.util.Name, arg2: java.lang.Void, arg3: java.util.List<javac.code.Type>): javac.util.JCDiagnostic$Error;
              CantResolveArgsParams(arg0: javac.code.Kinds$KindName, arg1: javac.util.Name, arg2: java.util.List<javac.code.Type>, arg3: java.util.List<javac.code.Type>): javac.util.JCDiagnostic$Error;
              CantResolveLocation(arg0: javac.code.Kinds$KindName, arg1: javac.util.Name, arg2: java.lang.Void, arg3: java.lang.Void, arg4: javac.util.JCDiagnostic): javac.util.JCDiagnostic$Error;
              CantResolveLocation(arg0: javac.code.Kinds$KindName, arg1: javac.util.Name, arg2: java.lang.Void, arg3: java.lang.Void, arg4: javac.util.JCDiagnostic$Fragment): javac.util.JCDiagnostic$Error;
              CantResolveLocationArgs(arg0: javac.code.Kinds$KindName, arg1: javac.util.Name, arg2: java.lang.Void, arg3: java.util.List<javac.code.Type>, arg4: javac.util.JCDiagnostic): javac.util.JCDiagnostic$Error;
              CantResolveLocationArgs(arg0: javac.code.Kinds$KindName, arg1: javac.util.Name, arg2: java.lang.Void, arg3: java.util.List<javac.code.Type>, arg4: javac.util.JCDiagnostic$Fragment): javac.util.JCDiagnostic$Error;
              CantResolveLocationArgsParams(arg0: javac.code.Kinds$KindName, arg1: javac.util.Name, arg2: java.util.List<javac.code.Type>, arg3: java.util.List, arg4: javac.util.JCDiagnostic): javac.util.JCDiagnostic$Error;
              CantResolveLocationArgsParams(arg0: javac.code.Kinds$KindName, arg1: javac.util.Name, arg2: java.util.List<javac.code.Type>, arg3: java.util.List, arg4: javac.util.JCDiagnostic$Fragment): javac.util.JCDiagnostic$Error;
              CantTypeAnnotateScoping(arg0: java.util.List<javac.code.Attribute$Compound>): javac.util.JCDiagnostic$Error;
              CantTypeAnnotateScoping1(arg0: javac.code.Attribute$Compound): javac.util.JCDiagnostic$Error;
              ClashWithPkgOfSameName(arg0: javac.code.Kinds$KindName, arg1: javac.code.Symbol): javac.util.JCDiagnostic$Error;
              ClassCantWrite(arg0: javac.code.Symbol, arg1: string): javac.util.JCDiagnostic$Error;
              ClassInModuleCantExtendSealedInDiffModule(arg0: javac.code.Symbol, arg1: javac.code.Symbol): javac.util.JCDiagnostic$Error;
              ClassInUnnamedModuleCantExtendSealedInDiffPackage(arg0: javac.code.Symbol): javac.util.JCDiagnostic$Error;
              ClassPublicShouldBeInFile(arg0: javac.code.Kinds$KindName, arg1: javac.util.Name): javac.util.JCDiagnostic$Error;
              ConcreteInheritanceConflict(arg0: javac.code.Symbol, arg1: javac.code.Type, arg2: javac.code.Symbol, arg3: javac.code.Type, arg4: javac.code.Type): javac.util.JCDiagnostic$Error;
              ConflictingExports(arg0: javac.code.Symbol): javac.util.JCDiagnostic$Error;
              ConflictingExportsToModule(arg0: javac.code.Symbol): javac.util.JCDiagnostic$Error;
              ConflictingOpens(arg0: javac.code.Symbol): javac.util.JCDiagnostic$Error;
              ConflictingOpensToModule(arg0: javac.code.Symbol): javac.util.JCDiagnostic$Error;
              ConstantLabelNotCompatible(arg0: javac.code.Type, arg1: javac.code.Type): javac.util.JCDiagnostic$Error;
              CyclicAnnotationElement(arg0: javac.code.Symbol): javac.util.JCDiagnostic$Error;
              CyclicInheritance(arg0: javac.code.Symbol): javac.util.JCDiagnostic$Error;
              CyclicInheritance(arg0: javac.code.Type): javac.util.JCDiagnostic$Error;
              CyclicRequires(arg0: javac.code.Symbol): javac.util.JCDiagnostic$Error;
              DeconstructionPatternOnlyRecords(arg0: javac.code.Symbol): javac.util.JCDiagnostic$Error;
              DefaultOverridesObjectMember(arg0: javac.util.Name, arg1: javac.code.Kinds$KindName, arg2: javac.code.Symbol): javac.util.JCDiagnostic$Error;
              DoesNotOverrideAbstract(arg0: javac.code.Symbol, arg1: javac.code.Symbol, arg2: javac.code.Symbol): javac.util.JCDiagnostic$Error;
              DoesntExist(arg0: javac.code.Symbol): javac.util.JCDiagnostic$Error;
              DuplicateAnnotationInvalidRepeated(arg0: javac.code.Type): javac.util.JCDiagnostic$Error;
              DuplicateAnnotationMemberValue(arg0: javac.util.Name, arg1: javac.code.Type): javac.util.JCDiagnostic$Error;
              DuplicateAnnotationMissingContainer(arg0: javac.code.Type): javac.util.JCDiagnostic$Error;
              DuplicateClass(arg0: javac.util.Name): javac.util.JCDiagnostic$Error;
              DuplicateModule(arg0: javac.code.Symbol): javac.util.JCDiagnostic$Error;
              DuplicateModuleOnPath(arg0: javac.util.JCDiagnostic$Fragment, arg1: javac.util.Name): javac.util.JCDiagnostic$Error;
              DuplicateProvides(arg0: javac.code.Symbol, arg1: javac.code.Symbol): javac.util.JCDiagnostic$Error;
              DuplicateRequires(arg0: javac.code.Symbol): javac.util.JCDiagnostic$Error;
              DuplicateUses(arg0: javac.code.Symbol): javac.util.JCDiagnostic$Error;
              EnclClassRequired(arg0: javac.code.Symbol): javac.util.JCDiagnostic$Error;
              EnclosingClassTypeNonDenotable(arg0: javac.code.Type): javac.util.JCDiagnostic$Error;
              ErrorReadingFile(arg0: java.io.File, arg1: string): javac.util.JCDiagnostic$Error;
              ErrorReadingFile(arg0: javax.tools.JavaFileObject, arg1: string): javac.util.JCDiagnostic$Error;
              ErrorReadingFile(arg0: java.nio.file.Path, arg1: string): javac.util.JCDiagnostic$Error;
              ErrorWritingFile(arg0: string, arg1: string): javac.util.JCDiagnostic$Error;
              ExceptAlreadyCaught(arg0: javac.code.Type): javac.util.JCDiagnostic$Error;
              ExceptNeverThrownInTry(arg0: javac.code.Type): javac.util.JCDiagnostic$Error;
              Expected(arg0: javac.parser.Tokens$TokenKind): javac.util.JCDiagnostic$Error;
              Expected2(arg0: javac.parser.Tokens$TokenKind, arg1: javac.parser.Tokens$TokenKind): javac.util.JCDiagnostic$Error;
              Expected3(arg0: javac.parser.Tokens$TokenKind, arg1: javac.parser.Tokens$TokenKind, arg2: javac.parser.Tokens$TokenKind): javac.util.JCDiagnostic$Error;
              Expected4(arg0: javac.parser.Tokens$TokenKind, arg1: javac.parser.Tokens$TokenKind, arg2: javac.parser.Tokens$TokenKind, arg3: string): javac.util.JCDiagnostic$Error;
              ExpectedStr(arg0: string): javac.util.JCDiagnostic$Error;
              FeatureNotSupportedInSource(arg0: javac.util.JCDiagnostic, arg1: string, arg2: string): javac.util.JCDiagnostic$Error;
              FeatureNotSupportedInSource(arg0: javac.util.JCDiagnostic$Fragment, arg1: string, arg2: string): javac.util.JCDiagnostic$Error;
              FeatureNotSupportedInSourcePlural(arg0: javac.util.JCDiagnostic, arg1: string, arg2: string): javac.util.JCDiagnostic$Error;
              FeatureNotSupportedInSourcePlural(arg0: javac.util.JCDiagnostic$Fragment, arg1: string, arg2: string): javac.util.JCDiagnostic$Error;
              FileNotDirectory(arg0: string): javac.util.JCDiagnostic$Error;
              FileNotFile(arg0: any): javac.util.JCDiagnostic$Error;
              FileNotFound(arg0: string): javac.util.JCDiagnostic$Error;
              FilePatchedAndMsp(arg0: javac.util.Name, arg1: javac.util.Name): javac.util.JCDiagnostic$Error;
              FinalParameterMayNotBeAssigned(arg0: javac.code.Symbol): javac.util.JCDiagnostic$Error;
              FirstStatementMustBeCallToAnotherConstructor(arg0: javac.code.Symbol): javac.util.JCDiagnostic$Error;
              ForeachNotApplicableToType(arg0: javac.code.Type, arg1: javac.util.JCDiagnostic): javac.util.JCDiagnostic$Error;
              ForeachNotApplicableToType(arg0: javac.code.Type, arg1: javac.util.JCDiagnostic$Fragment): javac.util.JCDiagnostic$Error;
              IclsCantHaveStaticDecl(arg0: javac.code.Symbol): javac.util.JCDiagnostic$Error;
              IllegalArgumentForOption(arg0: string, arg1: string): javac.util.JCDiagnostic$Error;
              IllegalChar(arg0: string): javac.util.JCDiagnostic$Error;
              IllegalCharForEncoding(arg0: string, arg1: string): javac.util.JCDiagnostic$Error;
              IllegalCombinationOfModifiers(arg0: java.util.Set<javac.code.Flags$Flag>, arg1: java.util.Set<javac.code.Flags$Flag>): javac.util.JCDiagnostic$Error;
              IllegalDefaultSuperCall(arg0: javac.code.Symbol, arg1: javac.util.JCDiagnostic): javac.util.JCDiagnostic$Error;
              IllegalDefaultSuperCall(arg0: javac.code.Symbol, arg1: javac.util.JCDiagnostic$Fragment): javac.util.JCDiagnostic$Error;
              IllegalDefaultSuperCall(arg0: javac.code.Type, arg1: javac.util.JCDiagnostic): javac.util.JCDiagnostic$Error;
              IllegalDefaultSuperCall(arg0: javac.code.Type, arg1: javac.util.JCDiagnostic$Fragment): javac.util.JCDiagnostic$Error;
              IllegalInitializerForType(arg0: javac.code.Type): javac.util.JCDiagnostic$Error;
              IllegalQualNotIcls(arg0: javac.code.Symbol): javac.util.JCDiagnostic$Error;
              IllegalRecordComponentName(arg0: javac.code.Symbol): javac.util.JCDiagnostic$Error;
              IllegalRefToRestrictedType(arg0: javac.util.Name): javac.util.JCDiagnostic$Error;
              IllegalStaticIntfMethCall(arg0: javac.code.Type): javac.util.JCDiagnostic$Error;
              ImportRequiresCanonical(arg0: javac.code.Symbol): javac.util.JCDiagnostic$Error;
              IncomparableTypes(arg0: javac.code.Type, arg1: javac.code.Type): javac.util.JCDiagnostic$Error;
              IncompatibleDiffRetSameType(arg0: javac.code.Type, arg1: javac.util.Name, arg2: java.util.List<javac.code.Type>): javac.util.JCDiagnostic$Error;
              IncompatibleThrownTypesInMref(arg0: java.util.List<javac.code.Type>): javac.util.JCDiagnostic$Error;
              IncorrectConstructorReceiverName(arg0: javac.code.Type, arg1: javac.code.Type): javac.util.JCDiagnostic$Error;
              IncorrectConstructorReceiverType(arg0: javac.code.Type, arg1: javac.code.Type): javac.util.JCDiagnostic$Error;
              IncorrectNumberOfNestedPatterns(arg0: java.util.List<javac.code.Type>, arg1: java.util.List<javac.code.Type>): javac.util.JCDiagnostic$Error;
              IncorrectReceiverName(arg0: javac.code.Type, arg1: javac.code.Type): javac.util.JCDiagnostic$Error;
              IncorrectReceiverType(arg0: javac.code.Type, arg1: javac.code.Type): javac.util.JCDiagnostic$Error;
              InstanceofReifiableNotSafe(arg0: javac.code.Type, arg1: javac.code.Type): javac.util.JCDiagnostic$Error;
              IntNumberTooLarge(arg0: string): javac.util.JCDiagnostic$Error;
              IntfAnnotationCantHaveTypeParams(arg0: javac.code.Symbol): javac.util.JCDiagnostic$Error;
              IntfAnnotationMemberClash(arg0: javac.code.Symbol, arg1: javac.code.Type): javac.util.JCDiagnostic$Error;
              InvalidAKey(arg0: string): javac.util.JCDiagnostic$Error;
              InvalidAccessorMethodInRecord(arg0: javac.code.Symbol, arg1: javac.util.JCDiagnostic$Fragment): javac.util.JCDiagnostic$Error;
              InvalidCanonicalConstructorInRecord(arg0: javac.util.JCDiagnostic$Fragment, arg1: javac.util.Name, arg2: javac.util.JCDiagnostic$Fragment): javac.util.JCDiagnostic$Error;
              InvalidFlag(arg0: string): javac.util.JCDiagnostic$Error;
              InvalidLambdaParameterDeclaration(arg0: javac.util.JCDiagnostic$Fragment): javac.util.JCDiagnostic$Error;
              InvalidModuleSpecifier(arg0: string): javac.util.JCDiagnostic$Error;
              InvalidMref(arg0: javac.code.Kinds$KindName, arg1: javac.util.JCDiagnostic): javac.util.JCDiagnostic$Error;
              InvalidMref(arg0: javac.code.Kinds$KindName, arg1: javac.util.JCDiagnostic$Fragment): javac.util.JCDiagnostic$Error;
              InvalidPath(arg0: string): javac.util.JCDiagnostic$Error;
              InvalidPermitsClause(arg0: javac.util.JCDiagnostic$Fragment): javac.util.JCDiagnostic$Error;
              InvalidProfile(arg0: string): javac.util.JCDiagnostic$Error;
              InvalidRepeatableAnnotation(arg0: javac.code.Symbol): javac.util.JCDiagnostic$Error;
              InvalidRepeatableAnnotationElemNondefault(arg0: javac.code.Symbol, arg1: javac.code.Symbol): javac.util.JCDiagnostic$Error;
              InvalidRepeatableAnnotationElemNondefault(arg0: javac.code.Type, arg1: javac.code.Symbol): javac.util.JCDiagnostic$Error;
              InvalidRepeatableAnnotationIncompatibleTarget(arg0: javac.code.Symbol, arg1: javac.code.Symbol): javac.util.JCDiagnostic$Error;
              InvalidRepeatableAnnotationInvalidValue(arg0: javac.code.Type): javac.util.JCDiagnostic$Error;
              InvalidRepeatableAnnotationMultipleValues(arg0: javac.code.Type, arg1: int): javac.util.JCDiagnostic$Error;
              InvalidRepeatableAnnotationNoValue(arg0: javac.code.Symbol): javac.util.JCDiagnostic$Error;
              InvalidRepeatableAnnotationNoValue(arg0: javac.code.Type): javac.util.JCDiagnostic$Error;
              InvalidRepeatableAnnotationNotApplicable(arg0: javac.code.Type, arg1: javac.code.Symbol): javac.util.JCDiagnostic$Error;
              InvalidRepeatableAnnotationNotApplicableInContext(arg0: javac.code.Type): javac.util.JCDiagnostic$Error;
              InvalidRepeatableAnnotationNotDocumented(arg0: javac.code.Symbol, arg1: javac.code.Symbol): javac.util.JCDiagnostic$Error;
              InvalidRepeatableAnnotationNotInherited(arg0: javac.code.Symbol, arg1: javac.code.Symbol): javac.util.JCDiagnostic$Error;
              InvalidRepeatableAnnotationRepeatedAndContainerPresent(arg0: javac.code.Symbol): javac.util.JCDiagnostic$Error;
              InvalidRepeatableAnnotationRetention(arg0: javac.code.Symbol, arg1: string, arg2: javac.code.Symbol, arg3: string): javac.util.JCDiagnostic$Error;
              InvalidRepeatableAnnotationValueReturn(arg0: javac.code.Symbol, arg1: javac.code.Type, arg2: javac.code.Type): javac.util.JCDiagnostic$Error;
              InvalidRepeatableAnnotationValueReturn(arg0: javac.code.Type, arg1: javac.code.Type, arg2: javac.code.Type): javac.util.JCDiagnostic$Error;
              InvalidSource(arg0: string): javac.util.JCDiagnostic$Error;
              InvalidSupertypeRecord(arg0: javac.code.Symbol): javac.util.JCDiagnostic$Error;
              InvalidTarget(arg0: string): javac.util.JCDiagnostic$Error;
              IsPreview(arg0: javac.code.Symbol): javac.util.JCDiagnostic$Error;
              LabelAlreadyInUse(arg0: javac.util.Name): javac.util.JCDiagnostic$Error;
              LimitStringOverflow(arg0: string): javac.util.JCDiagnostic$Error;
              LocalClassesCantExtendSealed(arg0: javac.util.JCDiagnostic$Fragment): javac.util.JCDiagnostic$Error;
              LocnBadModuleInfo(arg0: java.nio.file.Path): javac.util.JCDiagnostic$Error;
              LocnCantGetModuleNameForJar(arg0: java.nio.file.Path): javac.util.JCDiagnostic$Error;
              LocnCantReadDirectory(arg0: java.nio.file.Path): javac.util.JCDiagnostic$Error;
              LocnCantReadFile(arg0: java.nio.file.Path): javac.util.JCDiagnostic$Error;
              LocnInvalidArgForXpatch(arg0: string): javac.util.JCDiagnostic$Error;
              LocnModuleInfoNotAllowedOnPatchPath(arg0: javax.tools.JavaFileObject): javac.util.JCDiagnostic$Error;
              ModNotAllowedHere(arg0: java.util.Set<javac.code.Flags$Flag>): javac.util.JCDiagnostic$Error;
              ModifierNotAllowedHere(arg0: javac.util.Name): javac.util.JCDiagnostic$Error;
              ModuleNameMismatch(arg0: javac.util.Name, arg1: javac.util.Name): javac.util.JCDiagnostic$Error;
              ModuleNonZeroOpens(arg0: javac.util.Name): javac.util.JCDiagnostic$Error;
              ModuleNotFound(arg0: javac.code.Symbol): javac.util.JCDiagnostic$Error;
              ModuleNotFoundInModuleSourcePath(arg0: string): javac.util.JCDiagnostic$Error;
              MultiModuleOutdirCannotBeExplodedModule(arg0: java.nio.file.Path): javac.util.JCDiagnostic$Error;
              MulticatchParameterMayNotBeAssigned(arg0: javac.code.Symbol): javac.util.JCDiagnostic$Error;
              MulticatchTypesMustBeDisjoint(arg0: javac.code.Type, arg1: javac.code.Type): javac.util.JCDiagnostic$Error;
              NameClashSameErasure(arg0: javac.code.Symbol, arg1: javac.code.Symbol): javac.util.JCDiagnostic$Error;
              NameClashSameErasureNoHide(arg0: javac.code.Symbol, arg1: javac.code.Symbol, arg2: javac.code.Symbol, arg3: javac.code.Symbol): javac.util.JCDiagnostic$Error;
              NameClashSameErasureNoOverride(arg0: javac.util.Name, arg1: java.util.List<javac.code.Type>, arg2: javac.code.Symbol, arg3: javac.util.Name, arg4: java.util.List<javac.code.Type>, arg5: javac.code.Symbol): javac.util.JCDiagnostic$Error;
              NameClashSameErasureNoOverride1(arg0: string, arg1: javac.util.Name, arg2: javac.util.Name, arg3: java.util.List<javac.code.Type>, arg4: javac.code.Symbol, arg5: javac.util.Name, arg6: java.util.List<javac.code.Type>, arg7: javac.code.Symbol): javac.util.JCDiagnostic$Error;
              NoAnnotationMember(arg0: javac.util.Name, arg1: javac.code.Type): javac.util.JCDiagnostic$Error;
              NoEnclInstanceOfTypeInScope(arg0: javac.code.Symbol): javac.util.JCDiagnostic$Error;
              NoSuperclass(arg0: javac.code.Type): javac.util.JCDiagnostic$Error;
              NoValueForOption(arg0: string): javac.util.JCDiagnostic$Error;
              NoZipfsForArchive(arg0: java.nio.file.Path): javac.util.JCDiagnostic$Error;
              NonSealedWithNoSealedSupertype(arg0: javac.code.Symbol): javac.util.JCDiagnostic$Error;
              NonStaticCantBeRef(arg0: javac.code.Kinds$Kind, arg1: javac.code.Symbol): javac.util.JCDiagnostic$Error;
              NotAProcessorType(arg0: javac.code.Symbol): javac.util.JCDiagnostic$Error;
              NotAnnotationType(arg0: javac.code.Type): javac.util.JCDiagnostic$Error;
              NotDefAccessClassIntfCantAccess(arg0: javac.code.Symbol, arg1: javac.code.Symbol): javac.util.JCDiagnostic$Error;
              NotDefAccessClassIntfCantAccessReason(arg0: javac.code.Symbol, arg1: javac.code.Symbol, arg2: javac.code.Symbol, arg3: javac.util.JCDiagnostic): javac.util.JCDiagnostic$Error;
              NotDefAccessClassIntfCantAccessReason(arg0: javac.code.Symbol, arg1: javac.code.Symbol, arg2: javac.code.Symbol, arg3: javac.util.JCDiagnostic$Fragment): javac.util.JCDiagnostic$Error;
              NotDefAccessPackageCantAccess(arg0: javac.code.Symbol, arg1: javac.code.Symbol, arg2: javac.util.JCDiagnostic): javac.util.JCDiagnostic$Error;
              NotDefAccessPackageCantAccess(arg0: javac.code.Symbol, arg1: javac.code.Symbol, arg2: javac.util.JCDiagnostic$Fragment): javac.util.JCDiagnostic$Error;
              NotDefPublic(arg0: javac.code.Symbol, arg1: javac.code.Symbol): javac.util.JCDiagnostic$Error;
              NotDefPublicCantAccess(arg0: javac.code.Symbol, arg1: javac.code.Symbol): javac.util.JCDiagnostic$Error;
              NotEnclClass(arg0: javac.code.Symbol): javac.util.JCDiagnostic$Error;
              NotInProfile(arg0: javac.code.Symbol, arg1: any): javac.util.JCDiagnostic$Error;
              NotLoopLabel(arg0: javac.util.Name): javac.util.JCDiagnostic$Error;
              NotWithinBounds(arg0: javac.code.Type, arg1: javac.code.Type): javac.util.JCDiagnostic$Error;
              NotWithinBounds(arg0: javac.code.Type, arg1: javac.code.Symbol): javac.util.JCDiagnostic$Error;
              OperatorCantBeApplied(arg0: javac.util.Name, arg1: javac.code.Type): javac.util.JCDiagnostic$Error;
              OperatorCantBeApplied1(arg0: javac.util.Name, arg1: javac.code.Type, arg2: javac.code.Type): javac.util.JCDiagnostic$Error;
              OptionNotAllowedWithTarget(arg0: javac.main.Option, arg1: javac.jvm.Target): javac.util.JCDiagnostic$Error;
              OptionRemovedSource(arg0: string, arg1: string): javac.util.JCDiagnostic$Error;
              OptionRemovedTarget(arg0: javac.jvm.Target, arg1: javac.jvm.Target): javac.util.JCDiagnostic$Error;
              OptionTooMany(arg0: string): javac.util.JCDiagnostic$Error;
              Orphaned(arg0: javac.parser.Tokens$TokenKind): javac.util.JCDiagnostic$Error;
              OverrideIncompatibleRet(arg0: javac.util.JCDiagnostic, arg1: javac.code.Type, arg2: javac.code.Type): javac.util.JCDiagnostic$Error;
              OverrideIncompatibleRet(arg0: javac.util.JCDiagnostic$Fragment, arg1: javac.code.Type, arg2: javac.code.Type): javac.util.JCDiagnostic$Error;
              OverrideMeth(arg0: javac.util.JCDiagnostic, arg1: java.util.Set<javac.code.Flags$Flag>): javac.util.JCDiagnostic$Error;
              OverrideMeth(arg0: javac.util.JCDiagnostic$Fragment, arg1: java.util.Set<javac.code.Flags$Flag>): javac.util.JCDiagnostic$Error;
              OverrideMethDoesntThrow(arg0: javac.util.JCDiagnostic, arg1: javac.code.Type): javac.util.JCDiagnostic$Error;
              OverrideMethDoesntThrow(arg0: javac.util.JCDiagnostic$Fragment, arg1: javac.code.Type): javac.util.JCDiagnostic$Error;
              OverrideStatic(arg0: javac.util.JCDiagnostic): javac.util.JCDiagnostic$Error;
              OverrideStatic(arg0: javac.util.JCDiagnostic$Fragment): javac.util.JCDiagnostic$Error;
              OverrideWeakerAccess(arg0: javac.util.JCDiagnostic, arg1: java.util.Set<javac.code.Flags$Flag>): javac.util.JCDiagnostic$Error;
              OverrideWeakerAccess(arg0: javac.util.JCDiagnostic, arg1: string): javac.util.JCDiagnostic$Error;
              OverrideWeakerAccess(arg0: javac.util.JCDiagnostic$Fragment, arg1: java.util.Set<javac.code.Flags$Flag>): javac.util.JCDiagnostic$Error;
              OverrideWeakerAccess(arg0: javac.util.JCDiagnostic$Fragment, arg1: string): javac.util.JCDiagnostic$Error;
              PackageClashFromRequires(arg0: javac.code.Symbol, arg1: javac.util.Name, arg2: javac.code.Symbol, arg3: javac.code.Symbol): javac.util.JCDiagnostic$Error;
              PackageClashFromRequiresInUnnamed(arg0: javac.util.Name, arg1: javac.code.Symbol, arg2: javac.code.Symbol): javac.util.JCDiagnostic$Error;
              PackageEmptyOrNotFound(arg0: javac.code.Symbol): javac.util.JCDiagnostic$Error;
              PackageInOtherModule(arg0: javac.code.Symbol): javac.util.JCDiagnostic$Error;
              PackageNotVisible(arg0: javac.code.Symbol, arg1: javac.util.JCDiagnostic): javac.util.JCDiagnostic$Error;
              PackageNotVisible(arg0: javac.code.Symbol, arg1: javac.util.JCDiagnostic$Fragment): javac.util.JCDiagnostic$Error;
              PkgClashesWithClassOfSameName(arg0: javac.code.Symbol): javac.util.JCDiagnostic$Error;
              PluginNotFound(arg0: string): javac.util.JCDiagnostic$Error;
              PreviewFeatureDisabled(arg0: javac.util.JCDiagnostic): javac.util.JCDiagnostic$Error;
              PreviewFeatureDisabled(arg0: javac.util.JCDiagnostic$Fragment): javac.util.JCDiagnostic$Error;
              PreviewFeatureDisabledClassfile(arg0: javax.tools.JavaFileObject, arg1: string): javac.util.JCDiagnostic$Error;
              PreviewFeatureDisabledPlural(arg0: javac.util.JCDiagnostic): javac.util.JCDiagnostic$Error;
              PreviewFeatureDisabledPlural(arg0: javac.util.JCDiagnostic$Fragment): javac.util.JCDiagnostic$Error;
              PreviewNotLatest(arg0: string, arg1: javac.code.Source): javac.util.JCDiagnostic$Error;
              ProbFoundReq(arg0: javac.util.JCDiagnostic): javac.util.JCDiagnostic$Error;
              ProbFoundReq(arg0: javac.util.JCDiagnostic$Fragment): javac.util.JCDiagnostic$Error;
              ProcBadConfigFile(arg0: string): javac.util.JCDiagnostic$Error;
              ProcCantAccess(arg0: javac.code.Symbol, arg1: javac.util.JCDiagnostic, arg2: string): javac.util.JCDiagnostic$Error;
              ProcCantAccess(arg0: javac.code.Symbol, arg1: javac.util.JCDiagnostic$Fragment, arg2: string): javac.util.JCDiagnostic$Error;
              ProcCantAccess1(arg0: javac.code.Symbol, arg1: javac.util.JCDiagnostic): javac.util.JCDiagnostic$Error;
              ProcCantAccess1(arg0: javac.code.Symbol, arg1: javac.util.JCDiagnostic$Fragment): javac.util.JCDiagnostic$Error;
              ProcCantFindClass(arg0: string): javac.util.JCDiagnostic$Error;
              ProcCantLoadClass(arg0: string): javac.util.JCDiagnostic$Error;
              ProcMessager(arg0: string): javac.util.JCDiagnostic$Error;
              ProcNoExplicitAnnotationProcessingRequested(arg0: java.util.Collection<string>): javac.util.JCDiagnostic$Error;
              ProcProcessorBadOptionName(arg0: string, arg1: string): javac.util.JCDiagnostic$Error;
              ProcProcessorCantInstantiate(arg0: string): javac.util.JCDiagnostic$Error;
              ProcProcessorNotFound(arg0: string): javac.util.JCDiagnostic$Error;
              ProcProcessorWrongType(arg0: string): javac.util.JCDiagnostic$Error;
              ProcessorTypeCannotBeARawType(arg0: javac.code.Symbol): javac.util.JCDiagnostic$Error;
              QualifiedNewOfStaticClass(arg0: javac.code.Symbol): javac.util.JCDiagnostic$Error;
              RefAmbiguous(arg0: javac.util.Name, arg1: javac.code.Kinds$Kind, arg2: javac.code.Symbol, arg3: javac.code.Symbol, arg4: javac.code.Kinds$Kind, arg5: javac.code.Symbol, arg6: javac.code.Symbol): javac.util.JCDiagnostic$Error;
              ReleaseBootclasspathConflict(arg0: javac.main.Option): javac.util.JCDiagnostic$Error;
              RepeatedProvidesForService(arg0: javac.code.Symbol): javac.util.JCDiagnostic$Error;
              RepeatedValueForModuleSourcePath(arg0: string): javac.util.JCDiagnostic$Error;
              RepeatedValueForPatchModule(arg0: string): javac.util.JCDiagnostic$Error;
              ReportAccess(arg0: javac.code.Symbol, arg1: java.util.Set<javax.lang.model.element.Modifier>, arg2: javac.code.Symbol): javac.util.JCDiagnostic$Error;
              ReqArg(arg0: string): javac.util.JCDiagnostic$Error;
              RestrictedTypeNotAllowed(arg0: javac.util.Name, arg1: javac.code.Source): javac.util.JCDiagnostic$Error;
              RestrictedTypeNotAllowedArray(arg0: javac.util.Name): javac.util.JCDiagnostic$Error;
              RestrictedTypeNotAllowedCompound(arg0: javac.util.Name): javac.util.JCDiagnostic$Error;
              RestrictedTypeNotAllowedHere(arg0: javac.util.Name): javac.util.JCDiagnostic$Error;
              SameBinaryName(arg0: javac.util.Name, arg1: javac.util.Name): javac.util.JCDiagnostic$Error;
              SelectorTypeNotAllowed(arg0: javac.code.Type): javac.util.JCDiagnostic$Error;
              ServiceDefinitionIsEnum(arg0: javac.code.Symbol): javac.util.JCDiagnostic$Error;
              ServiceImplementationDoesntHaveANoArgsConstructor(arg0: javac.code.Symbol): javac.util.JCDiagnostic$Error;
              ServiceImplementationIsAbstract(arg0: javac.code.Symbol): javac.util.JCDiagnostic$Error;
              ServiceImplementationIsInner(arg0: javac.code.Symbol): javac.util.JCDiagnostic$Error;
              ServiceImplementationNoArgsConstructorNotPublic(arg0: javac.code.Symbol): javac.util.JCDiagnostic$Error;
              ServiceImplementationNotInRightModule(arg0: javac.code.Symbol): javac.util.JCDiagnostic$Error;
              SourceCantOverwriteInputFile(arg0: javax.tools.JavaFileObject): javac.util.JCDiagnostic$Error;
              StackSimError(arg0: javac.code.Symbol): javac.util.JCDiagnostic$Error;
              TooManyPatchedModules(arg0: java.util.Set<string>): javac.util.JCDiagnostic$Error;
              TryResourceMayNotBeAssigned(arg0: javac.code.Symbol): javac.util.JCDiagnostic$Error;
              TryWithResourcesExprEffectivelyFinalVar(arg0: javac.code.Symbol): javac.util.JCDiagnostic$Error;
              TwoClassLoaders2(arg0: java.net.URL, arg1: java.net.URL): javac.util.JCDiagnostic$Error;
              TypeDoesntTakeParams(arg0: javac.code.Symbol): javac.util.JCDiagnostic$Error;
              TypeFoundReq(arg0: any, arg1: javac.util.JCDiagnostic): javac.util.JCDiagnostic$Error;
              TypeFoundReq(arg0: any, arg1: javac.util.JCDiagnostic$Fragment): javac.util.JCDiagnostic$Error;
              TypesIncompatible(arg0: javac.code.Type, arg1: javac.code.Type, arg2: javac.util.JCDiagnostic$Fragment): javac.util.JCDiagnostic$Error;
              UndefLabel(arg0: javac.util.Name): javac.util.JCDiagnostic$Error;
              UnexpectedType(arg0: java.util.Set<javac.code.Kinds$KindName>, arg1: java.util.Set<javac.code.Kinds$KindName>): javac.util.JCDiagnostic$Error;
              UnmatchedQuote(arg0: string): javac.util.JCDiagnostic$Error;
              UnreportedExceptionDefaultConstructor(arg0: javac.code.Type): javac.util.JCDiagnostic$Error;
              UnreportedExceptionImplicitClose(arg0: javac.code.Type, arg1: javac.util.Name): javac.util.JCDiagnostic$Error;
              UnreportedExceptionNeedToCatchOrThrow(arg0: javac.code.Type): javac.util.JCDiagnostic$Error;
              UnsupportedEncoding(arg0: string): javac.util.JCDiagnostic$Error;
              UnsupportedReleaseVersion(arg0: string): javac.util.JCDiagnostic$Error;
              VarMightAlreadyBeAssigned(arg0: javac.code.Symbol): javac.util.JCDiagnostic$Error;
              VarMightBeAssignedInLoop(arg0: javac.code.Symbol): javac.util.JCDiagnostic$Error;
              VarMightNotHaveBeenInitialized(arg0: javac.code.Symbol): javac.util.JCDiagnostic$Error;
              VarNotInitializedInDefaultConstructor(arg0: javac.code.Symbol): javac.util.JCDiagnostic$Error;
              VarargsInvalidTrustmeAnno(arg0: javac.code.Symbol, arg1: javac.util.JCDiagnostic): javac.util.JCDiagnostic$Error;
              VarargsInvalidTrustmeAnno(arg0: javac.code.Symbol, arg1: javac.util.JCDiagnostic$Fragment): javac.util.JCDiagnostic$Error;
              WrongNumberTypeArgs(arg0: string): javac.util.JCDiagnostic$Error;
              readonly AbstractMethCantHaveBody: javac.util.JCDiagnostic$Error;
              readonly AddmodsAllModulePathInvalid: javac.util.JCDiagnostic$Error;
              readonly AnnotationDeclNotAllowedHere: javac.util.JCDiagnostic$Error;
              readonly AnnotationMissingElementValue: javac.util.JCDiagnostic$Error;
              readonly AnnotationTypeNotApplicable: javac.util.JCDiagnostic$Error;
              readonly AnnotationValueMustBeAnnotation: javac.util.JCDiagnostic$Error;
              readonly AnnotationValueMustBeClassLiteral: javac.util.JCDiagnostic$Error;
              readonly AnnotationValueMustBeNameValue: javac.util.JCDiagnostic$Error;
              readonly AnnotationValueNotAllowableType: javac.util.JCDiagnostic$Error;
              readonly AnonClassImplIntfNoArgs: javac.util.JCDiagnostic$Error;
              readonly AnonClassImplIntfNoQualForNew: javac.util.JCDiagnostic$Error;
              readonly AnonClassImplIntfNoTypeargs: javac.util.JCDiagnostic$Error;
              readonly ArrayAndReceiver: javac.util.JCDiagnostic$Error;
              readonly ArrayDimensionMissing: javac.util.JCDiagnostic$Error;
              readonly AssertAsIdentifier: javac.util.JCDiagnostic$Error;
              readonly AttributeValueMustBeConstant: javac.util.JCDiagnostic$Error;
              readonly BadFunctionalIntfAnno: javac.util.JCDiagnostic$Error;
              readonly BreakOutsideSwitchExpression: javac.util.JCDiagnostic$Error;
              readonly BreakOutsideSwitchLoop: javac.util.JCDiagnostic$Error;
              readonly CannotCreateArrayWithDiamond: javac.util.JCDiagnostic$Error;
              readonly CannotCreateArrayWithTypeArguments: javac.util.JCDiagnostic$Error;
              readonly CantAssignValToThis: javac.util.JCDiagnostic$Error;
              readonly CantExtendIntfAnnotation: javac.util.JCDiagnostic$Error;
              readonly CantInheritFromAnon: javac.util.JCDiagnostic$Error;
              readonly CantReadFile: javac.util.JCDiagnostic$Error;
              readonly CantSelectStaticClassFromParamType: javac.util.JCDiagnostic$Error;
              readonly CatchWithoutTry: javac.util.JCDiagnostic$Error;
              readonly ClassNotAllowed: javac.util.JCDiagnostic$Error;
              readonly ConstExprReq: javac.util.JCDiagnostic$Error;
              readonly ContOutsideLoop: javac.util.JCDiagnostic$Error;
              readonly ContinueOutsideSwitchExpression: javac.util.JCDiagnostic$Error;
              readonly DcBadEntity: javac.util.JCDiagnostic$Error;
              readonly DcBadInlineTag: javac.util.JCDiagnostic$Error;
              readonly DcGtExpected: javac.util.JCDiagnostic$Error;
              readonly DcIdentifierExpected: javac.util.JCDiagnostic$Error;
              readonly DcInvalidHtml: javac.util.JCDiagnostic$Error;
              readonly DcMalformedHtml: javac.util.JCDiagnostic$Error;
              readonly DcMissingSemicolon: javac.util.JCDiagnostic$Error;
              readonly DcNoContent: javac.util.JCDiagnostic$Error;
              readonly DcNoTagName: javac.util.JCDiagnostic$Error;
              readonly DcNoTitle: javac.util.JCDiagnostic$Error;
              readonly DcNoUrl: javac.util.JCDiagnostic$Error;
              readonly DcRefAnnotationsNotAllowed: javac.util.JCDiagnostic$Error;
              readonly DcRefBadParens: javac.util.JCDiagnostic$Error;
              readonly DcRefSyntaxError: javac.util.JCDiagnostic$Error;
              readonly DcRefUnexpectedInput: javac.util.JCDiagnostic$Error;
              readonly DcUnexpectedContent: javac.util.JCDiagnostic$Error;
              readonly DcUnterminatedInlineTag: javac.util.JCDiagnostic$Error;
              readonly DcUnterminatedSignature: javac.util.JCDiagnostic$Error;
              readonly DcUnterminatedString: javac.util.JCDiagnostic$Error;
              readonly DeconstructionPatternVarNotAllowed: javac.util.JCDiagnostic$Error;
              readonly DefaultAllowedInIntfAnnotationMember: javac.util.JCDiagnostic$Error;
              readonly DefaultLabelNotAllowed: javac.util.JCDiagnostic$Error;
              readonly DotClassExpected: javac.util.JCDiagnostic$Error;
              readonly DuplicateCaseLabel: javac.util.JCDiagnostic$Error;
              readonly DuplicateDefaultLabel: javac.util.JCDiagnostic$Error;
              readonly DuplicateUnconditionalPattern: javac.util.JCDiagnostic$Error;
              readonly ElseWithoutIf: javac.util.JCDiagnostic$Error;
              readonly EmptyAArgument: javac.util.JCDiagnostic$Error;
              readonly EmptyCharLit: javac.util.JCDiagnostic$Error;
              readonly EnumAnnotationMustBeEnumConstant: javac.util.JCDiagnostic$Error;
              readonly EnumAsIdentifier: javac.util.JCDiagnostic$Error;
              readonly EnumCantBeGeneric: javac.util.JCDiagnostic$Error;
              readonly EnumCantBeInstantiated: javac.util.JCDiagnostic$Error;
              readonly EnumConstantExpected: javac.util.JCDiagnostic$Error;
              readonly EnumConstantNotExpected: javac.util.JCDiagnostic$Error;
              readonly EnumLabelMustBeEnumConstant: javac.util.JCDiagnostic$Error;
              readonly EnumLabelMustBeUnqualifiedEnum: javac.util.JCDiagnostic$Error;
              readonly EnumNoFinalize: javac.util.JCDiagnostic$Error;
              readonly EnumNoSubclassing: javac.util.JCDiagnostic$Error;
              readonly EnumTypesNotExtensible: javac.util.JCDiagnostic$Error;
              readonly Error: javac.util.JCDiagnostic$Error;
              readonly ExpectedModule: javac.util.JCDiagnostic$Error;
              readonly ExpectedModuleOrOpen: javac.util.JCDiagnostic$Error;
              readonly ExpressionNotAllowableAsAnnotationValue: javac.util.JCDiagnostic$Error;
              readonly ExtraneousSemicolon: javac.util.JCDiagnostic$Error;
              readonly FileSbOnSourceOrPatchPathForModule: javac.util.JCDiagnostic$Error;
              readonly FinallyWithoutTry: javac.util.JCDiagnostic$Error;
              readonly FlowsThroughFromPattern: javac.util.JCDiagnostic$Error;
              readonly FlowsThroughToPattern: javac.util.JCDiagnostic$Error;
              readonly FpNumberTooLarge: javac.util.JCDiagnostic$Error;
              readonly FpNumberTooSmall: javac.util.JCDiagnostic$Error;
              readonly GenericArrayCreation: javac.util.JCDiagnostic$Error;
              readonly GenericThrowable: javac.util.JCDiagnostic$Error;
              readonly GuardHasConstantExpressionFalse: javac.util.JCDiagnostic$Error;
              readonly GuardNotAllowed: javac.util.JCDiagnostic$Error;
              readonly IllegalArrayCreationBothDimensionAndInitialization: javac.util.JCDiagnostic$Error;
              readonly IllegalDot: javac.util.JCDiagnostic$Error;
              readonly IllegalEnumStaticRef: javac.util.JCDiagnostic$Error;
              readonly IllegalEscChar: javac.util.JCDiagnostic$Error;
              readonly IllegalForwardRef: javac.util.JCDiagnostic$Error;
              readonly IllegalLineEndInCharLit: javac.util.JCDiagnostic$Error;
              readonly IllegalNonasciiDigit: javac.util.JCDiagnostic$Error;
              readonly IllegalParenthesizedExpression: javac.util.JCDiagnostic$Error;
              readonly IllegalSelfRef: javac.util.JCDiagnostic$Error;
              readonly IllegalStartOfExpr: javac.util.JCDiagnostic$Error;
              readonly IllegalStartOfStmt: javac.util.JCDiagnostic$Error;
              readonly IllegalStartOfType: javac.util.JCDiagnostic$Error;
              readonly IllegalTextBlockOpen: javac.util.JCDiagnostic$Error;
              readonly IllegalUnderscore: javac.util.JCDiagnostic$Error;
              readonly IllegalUnicodeEsc: javac.util.JCDiagnostic$Error;
              readonly ImproperlyFormedTypeInnerRawParam: javac.util.JCDiagnostic$Error;
              readonly ImproperlyFormedTypeParamMissing: javac.util.JCDiagnostic$Error;
              readonly InitializerMustBeAbleToCompleteNormally: javac.util.JCDiagnostic$Error;
              readonly InitializerNotAllowed: javac.util.JCDiagnostic$Error;
              readonly InstanceInitializerNotAllowedInRecords: javac.util.JCDiagnostic$Error;
              readonly IntfAnnotationMembersCantHaveParams: javac.util.JCDiagnostic$Error;
              readonly IntfAnnotationMembersCantHaveTypeParams: javac.util.JCDiagnostic$Error;
              readonly IntfExpectedHere: javac.util.JCDiagnostic$Error;
              readonly IntfMethCantHaveBody: javac.util.JCDiagnostic$Error;
              readonly IntfNotAllowedHere: javac.util.JCDiagnostic$Error;
              readonly InvalidAnnotationMemberType: javac.util.JCDiagnostic$Error;
              readonly InvalidBinaryNumber: javac.util.JCDiagnostic$Error;
              readonly InvalidCaseLabelCombination: javac.util.JCDiagnostic$Error;
              readonly InvalidHexNumber: javac.util.JCDiagnostic$Error;
              readonly InvalidMethDeclRetTypeReq: javac.util.JCDiagnostic$Error;
              readonly InvalidModuleDirective: javac.util.JCDiagnostic$Error;
              readonly InvalidYield: javac.util.JCDiagnostic$Error;
              readonly IoException: javac.util.JCDiagnostic$Error;
              readonly LambdaBodyNeitherValueNorVoidCompatible: javac.util.JCDiagnostic$Error;
              readonly LimitCode: javac.util.JCDiagnostic$Error;
              readonly LimitCodeTooLargeForTryStmt: javac.util.JCDiagnostic$Error;
              readonly LimitDimensions: javac.util.JCDiagnostic$Error;
              readonly LimitLocals: javac.util.JCDiagnostic$Error;
              readonly LimitParameters: javac.util.JCDiagnostic$Error;
              readonly LimitPool: javac.util.JCDiagnostic$Error;
              readonly LimitPoolInClass: javac.util.JCDiagnostic$Error;
              readonly LimitStack: javac.util.JCDiagnostic$Error;
              readonly LimitString: javac.util.JCDiagnostic$Error;
              readonly LocalEnum: javac.util.JCDiagnostic$Error;
              readonly MalformedFpLit: javac.util.JCDiagnostic$Error;
              readonly MatchBindingExists: javac.util.JCDiagnostic$Error;
              readonly MethodDoesNotOverrideSuperclass: javac.util.JCDiagnostic$Error;
              readonly MissingMethBodyOrDeclAbstract: javac.util.JCDiagnostic$Error;
              readonly MissingRetStmt: javac.util.JCDiagnostic$Error;
              readonly ModuleDeclSbInModuleInfoJava: javac.util.JCDiagnostic$Error;
              readonly ModuleNotFoundOnModuleSourcePath: javac.util.JCDiagnostic$Error;
              readonly ModulesourcepathMustBeSpecifiedWithDashMOption: javac.util.JCDiagnostic$Error;
              readonly MultipleValuesForModuleSourcePath: javac.util.JCDiagnostic$Error;
              readonly NameReservedForInternalUse: javac.util.JCDiagnostic$Error;
              readonly NativeMethCantHaveBody: javac.util.JCDiagnostic$Error;
              readonly NewNotAllowedInAnnotation: javac.util.JCDiagnostic$Error;
              readonly NoAnnotationsOnDotClass: javac.util.JCDiagnostic$Error;
              readonly NoIntfExpectedHere: javac.util.JCDiagnostic$Error;
              readonly NoJavaLang: javac.util.JCDiagnostic$Error;
              readonly NoMatchEntry: javac.util.JCDiagnostic$Error;
              readonly NoOpensUnlessStrong: javac.util.JCDiagnostic$Error;
              readonly NoOutputDir: javac.util.JCDiagnostic$Error;
              readonly NoPkgInModuleInfoJava: javac.util.JCDiagnostic$Error;
              readonly NoSourceFiles: javac.util.JCDiagnostic$Error;
              readonly NoSourceFilesClasses: javac.util.JCDiagnostic$Error;
              readonly NoSwitchExpression: javac.util.JCDiagnostic$Error;
              readonly NoSwitchExpressionQualify: javac.util.JCDiagnostic$Error;
              readonly NonSealedOrSealedExpected: javac.util.JCDiagnostic$Error;
              readonly NonSealedSealedOrFinalExpected: javac.util.JCDiagnostic$Error;
              readonly NotExhaustive: javac.util.JCDiagnostic$Error;
              readonly NotExhaustiveStatement: javac.util.JCDiagnostic$Error;
              readonly NotInModuleOnModuleSourcePath: javac.util.JCDiagnostic$Error;
              readonly NotStmt: javac.util.JCDiagnostic$Error;
              readonly OutputDirMustBeSpecifiedWithDashMOption: javac.util.JCDiagnostic$Error;
              readonly PatternDominated: javac.util.JCDiagnostic$Error;
              readonly PatternExpected: javac.util.JCDiagnostic$Error;
              readonly PatternOrEnumReq: javac.util.JCDiagnostic$Error;
              readonly PatternTypeCannotInfer: javac.util.JCDiagnostic$Error;
              readonly PkgAnnotationsSbInPackageInfoJava: javac.util.JCDiagnostic$Error;
              readonly PrematureEof: javac.util.JCDiagnostic$Error;
              readonly PreviewWithoutSourceOrRelease: javac.util.JCDiagnostic$Error;
              readonly ProcCantCreateLoader: javac.util.JCDiagnostic$Error;
              readonly ProcNoService: javac.util.JCDiagnostic$Error;
              readonly ProcServiceProblem: javac.util.JCDiagnostic$Error;
              readonly ProcessorMissingFromStringTemplateExpression: javac.util.JCDiagnostic$Error;
              readonly ProcessorpathNoProcessormodulepath: javac.util.JCDiagnostic$Error;
              readonly ProfileBootclasspathConflict: javac.util.JCDiagnostic$Error;
              readonly ReceiverParameterNotApplicableConstructorToplevelClass: javac.util.JCDiagnostic$Error;
              readonly RecordCannotDeclareInstanceFields: javac.util.JCDiagnostic$Error;
              readonly RecordCantDeclareFieldModifiers: javac.util.JCDiagnostic$Error;
              readonly RecordComponentAndOldArraySyntax: javac.util.JCDiagnostic$Error;
              readonly RecordPatternsAnnotationsNotAllowed: javac.util.JCDiagnostic$Error;
              readonly RecursiveCtorInvocation: javac.util.JCDiagnostic$Error;
              readonly RepeatedAnnotationTarget: javac.util.JCDiagnostic$Error;
              readonly RepeatedInterface: javac.util.JCDiagnostic$Error;
              readonly RepeatedModifier: javac.util.JCDiagnostic$Error;
              readonly RetOutsideMeth: javac.util.JCDiagnostic$Error;
              readonly ReturnOutsideSwitchExpression: javac.util.JCDiagnostic$Error;
              readonly RuleCompletesNormally: javac.util.JCDiagnostic$Error;
              readonly SealedClassMustHaveSubclasses: javac.util.JCDiagnostic$Error;
              readonly SealedOrNonSealedLocalClassesNotAllowed: javac.util.JCDiagnostic$Error;
              readonly ServiceImplementationMustBeSubtypeOfServiceInterface: javac.util.JCDiagnostic$Error;
              readonly ServiceImplementationProviderReturnMustBeSubtypeOfServiceInterface: javac.util.JCDiagnostic$Error;
              readonly SignatureDoesntMatchIntf: javac.util.JCDiagnostic$Error;
              readonly SignatureDoesntMatchSupertype: javac.util.JCDiagnostic$Error;
              readonly SourcepathModulesourcepathConflict: javac.util.JCDiagnostic$Error;
              readonly StaticDeclarationNotAllowedInInnerClasses: javac.util.JCDiagnostic$Error;
              readonly StaticImpOnlyClassesAndInterfaces: javac.util.JCDiagnostic$Error;
              readonly StaticMethodsCannotBeAnnotatedWithOverride: javac.util.JCDiagnostic$Error;
              readonly StringConstReq: javac.util.JCDiagnostic$Error;
              readonly StringTemplateIsNotWellFormed: javac.util.JCDiagnostic$Error;
              readonly SwitchCaseUnexpectedStatement: javac.util.JCDiagnostic$Error;
              readonly SwitchExpressionCompletesNormally: javac.util.JCDiagnostic$Error;
              readonly SwitchExpressionEmpty: javac.util.JCDiagnostic$Error;
              readonly SwitchExpressionNoResultExpressions: javac.util.JCDiagnostic$Error;
              readonly SwitchMixingCaseTypes: javac.util.JCDiagnostic$Error;
              readonly TextBlockTemplateIsNotWellFormed: javac.util.JCDiagnostic$Error;
              readonly ThisAsIdentifier: javac.util.JCDiagnostic$Error;
              readonly ThrowsNotAllowedInIntfAnnotation: javac.util.JCDiagnostic$Error;
              readonly TooManyModules: javac.util.JCDiagnostic$Error;
              readonly TryWithResourcesExprNeedsVar: javac.util.JCDiagnostic$Error;
              readonly TryWithoutCatchFinallyOrResourceDecls: javac.util.JCDiagnostic$Error;
              readonly TwoClassLoaders1: javac.util.JCDiagnostic$Error;
              readonly TypeVarCantBeDeref: javac.util.JCDiagnostic$Error;
              readonly TypeVarMayNotBeFollowedByOtherBounds: javac.util.JCDiagnostic$Error;
              readonly TypeVarMoreThanOnce: javac.util.JCDiagnostic$Error;
              readonly TypeVarMoreThanOnceInResult: javac.util.JCDiagnostic$Error;
              readonly UnclosedCharLit: javac.util.JCDiagnostic$Error;
              readonly UnclosedComment: javac.util.JCDiagnostic$Error;
              readonly UnclosedStrLit: javac.util.JCDiagnostic$Error;
              readonly UnclosedTextBlock: javac.util.JCDiagnostic$Error;
              readonly UnconditionalPatternAndDefault: javac.util.JCDiagnostic$Error;
              readonly UnderscoreAsIdentifier: javac.util.JCDiagnostic$Error;
              readonly UnexpectedLambda: javac.util.JCDiagnostic$Error;
              readonly UnexpectedMref: javac.util.JCDiagnostic$Error;
              readonly UnnamedClassDoesNotHaveMainMethod: javac.util.JCDiagnostic$Error;
              readonly UnnamedClassShouldNotHavePackageDeclaration: javac.util.JCDiagnostic$Error;
              readonly UnnamedPkgNotAllowedNamedModules: javac.util.JCDiagnostic$Error;
              readonly UnreachableStmt: javac.util.JCDiagnostic$Error;
              readonly UseOfUnderscoreNotAllowed: javac.util.JCDiagnostic$Error;
              readonly UseOfUnderscoreNotAllowedWithBrackets: javac.util.JCDiagnostic$Error;
              readonly VarargsAndOldArraySyntax: javac.util.JCDiagnostic$Error;
              readonly VarargsAndReceiver: javac.util.JCDiagnostic$Error;
              readonly VarargsMustBeLast: javac.util.JCDiagnostic$Error;
              readonly VariableNotAllowed: javac.util.JCDiagnostic$Error;
              readonly VoidNotAllowedHere: javac.util.JCDiagnostic$Error;
              readonly WarningsAndWerror: javac.util.JCDiagnostic$Error;
              readonly WrongReceiver: javac.util.JCDiagnostic$Error;
              new(): CompilerProperties$Errors;
            }
            let CompilerProperties$Errors: _CompilerProperties$Errors$$static;
            interface _CompilerProperties$Errors {
            }
            interface CompilerProperties$Errors extends CombineTypes<[_CompilerProperties$Errors, java.lang.Object]> {}
            interface _CompilerProperties$Fragments$$static extends ClassLike {
              AccessorReturnTypeDoesntMatch(arg0: javac.code.Symbol, arg1: javac.code.Symbol): javac.util.JCDiagnostic$Fragment;
              AnachronisticModuleInfo(arg0: string, arg1: string): javac.util.JCDiagnostic$Fragment;
              AnonymousClass(arg0: javac.util.Name): javac.util.JCDiagnostic$Fragment;
              ApplicableMethodFound(arg0: int, arg1: javac.code.Symbol, arg2: java.lang.Void): javac.util.JCDiagnostic$Fragment;
              ApplicableMethodFound1(arg0: int, arg1: javac.code.Symbol, arg2: javac.util.JCDiagnostic): javac.util.JCDiagnostic$Fragment;
              ApplicableMethodFound1(arg0: int, arg1: javac.code.Symbol, arg2: javac.util.JCDiagnostic$Fragment): javac.util.JCDiagnostic$Fragment;
              ApplicableMethodFound2(arg0: int, arg1: javac.util.JCDiagnostic$Fragment, arg2: javac.code.Symbol): javac.util.JCDiagnostic$Fragment;
              ApplicableMethodFound3(arg0: int, arg1: javac.util.JCDiagnostic$Fragment, arg2: javac.code.Symbol, arg3: javac.util.JCDiagnostic): javac.util.JCDiagnostic$Fragment;
              ApplicableMethodFound3(arg0: int, arg1: javac.util.JCDiagnostic$Fragment, arg2: javac.code.Symbol, arg3: javac.util.JCDiagnostic$Fragment): javac.util.JCDiagnostic$Fragment;
              BadClassFile(arg0: javac.util.Name): javac.util.JCDiagnostic$Fragment;
              BadClassFileHeader(arg0: java.io.File, arg1: javac.util.JCDiagnostic): javac.util.JCDiagnostic$Fragment;
              BadClassFileHeader(arg0: java.io.File, arg1: javac.util.JCDiagnostic$Fragment): javac.util.JCDiagnostic$Fragment;
              BadClassFileHeader(arg0: javax.tools.JavaFileObject, arg1: javac.util.JCDiagnostic): javac.util.JCDiagnostic$Fragment;
              BadClassFileHeader(arg0: javax.tools.JavaFileObject, arg1: javac.util.JCDiagnostic$Fragment): javac.util.JCDiagnostic$Fragment;
              BadClassFileHeader(arg0: java.nio.file.Path, arg1: javac.util.JCDiagnostic): javac.util.JCDiagnostic$Fragment;
              BadClassFileHeader(arg0: java.nio.file.Path, arg1: javac.util.JCDiagnostic$Fragment): javac.util.JCDiagnostic$Fragment;
              BadClassTruncatedAtOffset(arg0: int): javac.util.JCDiagnostic$Fragment;
              BadConstPoolEntry(arg0: java.io.File, arg1: string, arg2: int): javac.util.JCDiagnostic$Fragment;
              BadConstPoolEntry(arg0: javax.tools.JavaFileObject, arg1: string, arg2: int): javac.util.JCDiagnostic$Fragment;
              BadConstPoolEntry(arg0: java.nio.file.Path, arg1: string, arg2: int): javac.util.JCDiagnostic$Fragment;
              BadConstPoolIndex(arg0: java.io.File, arg1: int, arg2: int): javac.util.JCDiagnostic$Fragment;
              BadConstPoolIndex(arg0: javax.tools.JavaFileObject, arg1: int, arg2: int): javac.util.JCDiagnostic$Fragment;
              BadConstPoolIndex(arg0: java.nio.file.Path, arg1: int, arg2: int): javac.util.JCDiagnostic$Fragment;
              BadConstantRange(arg0: string, arg1: javac.code.Symbol, arg2: javac.code.Type): javac.util.JCDiagnostic$Fragment;
              BadConstantValue(arg0: string, arg1: javac.code.Symbol, arg2: string): javac.util.JCDiagnostic$Fragment;
              BadConstantValueType(arg0: javac.code.Type): javac.util.JCDiagnostic$Fragment;
              BadEnclosingMethod(arg0: javac.code.Symbol): javac.util.JCDiagnostic$Fragment;
              BadInstanceMethodInUnboundLookup(arg0: javac.code.Kinds$Kind, arg1: javac.code.Symbol): javac.util.JCDiagnostic$Fragment;
              BadIntersectionTargetForFunctionalExpr(arg0: javac.util.JCDiagnostic): javac.util.JCDiagnostic$Fragment;
              BadIntersectionTargetForFunctionalExpr(arg0: javac.util.JCDiagnostic$Fragment): javac.util.JCDiagnostic$Fragment;
              BadSourceFileHeader(arg0: java.io.File, arg1: javac.util.JCDiagnostic): javac.util.JCDiagnostic$Fragment;
              BadSourceFileHeader(arg0: java.io.File, arg1: javac.util.JCDiagnostic$Fragment): javac.util.JCDiagnostic$Fragment;
              BadSourceFileHeader(arg0: javax.tools.JavaFileObject, arg1: javac.util.JCDiagnostic): javac.util.JCDiagnostic$Fragment;
              BadSourceFileHeader(arg0: javax.tools.JavaFileObject, arg1: javac.util.JCDiagnostic$Fragment): javac.util.JCDiagnostic$Fragment;
              BadSourceFileHeader(arg0: java.nio.file.Path, arg1: javac.util.JCDiagnostic): javac.util.JCDiagnostic$Fragment;
              BadSourceFileHeader(arg0: java.nio.file.Path, arg1: javac.util.JCDiagnostic$Fragment): javac.util.JCDiagnostic$Fragment;
              BadStaticMethodInBoundLookup(arg0: javac.code.Kinds$Kind, arg1: javac.code.Symbol): javac.util.JCDiagnostic$Fragment;
              BadStaticMethodInUnboundLookup(arg0: javac.code.Kinds$Kind, arg1: javac.code.Symbol): javac.util.JCDiagnostic$Fragment;
              BadUtf8ByteSequenceAt(arg0: int): javac.util.JCDiagnostic$Fragment;
              CanonicalMustNotHaveStrongerAccess(arg0: java.util.Set<javac.code.Flags$Flag>): javac.util.JCDiagnostic$Fragment;
              CanonicalMustNotHaveStrongerAccess(arg0: string): javac.util.JCDiagnostic$Fragment;
              CantAccessInnerClsConstr(arg0: javac.code.Symbol, arg1: java.util.List<javac.code.Type>, arg2: javac.code.Type): javac.util.JCDiagnostic$Fragment;
              CantApplyArrayCtor(arg0: java.util.List<javac.code.Type>, arg1: java.util.List<javac.code.Type>, arg2: javac.util.JCDiagnostic): javac.util.JCDiagnostic$Fragment;
              CantApplyArrayCtor(arg0: java.util.List<javac.code.Type>, arg1: java.util.List<javac.code.Type>, arg2: javac.util.JCDiagnostic$Fragment): javac.util.JCDiagnostic$Fragment;
              CantApplyArrayCtor(arg0: java.util.List<javac.code.Type>, arg1: javac.util.JCDiagnostic, arg2: javac.util.JCDiagnostic): javac.util.JCDiagnostic$Fragment;
              CantApplyArrayCtor(arg0: java.util.List<javac.code.Type>, arg1: javac.util.JCDiagnostic, arg2: javac.util.JCDiagnostic$Fragment): javac.util.JCDiagnostic$Fragment;
              CantApplyArrayCtor(arg0: java.util.List<javac.code.Type>, arg1: javac.util.JCDiagnostic$Fragment, arg2: javac.util.JCDiagnostic): javac.util.JCDiagnostic$Fragment;
              CantApplyArrayCtor(arg0: java.util.List<javac.code.Type>, arg1: javac.util.JCDiagnostic$Fragment, arg2: javac.util.JCDiagnostic$Fragment): javac.util.JCDiagnostic$Fragment;
              CantApplyArrayCtor(arg0: javac.util.JCDiagnostic, arg1: java.util.List<javac.code.Type>, arg2: javac.util.JCDiagnostic): javac.util.JCDiagnostic$Fragment;
              CantApplyArrayCtor(arg0: javac.util.JCDiagnostic, arg1: java.util.List<javac.code.Type>, arg2: javac.util.JCDiagnostic$Fragment): javac.util.JCDiagnostic$Fragment;
              CantApplyArrayCtor(arg0: javac.util.JCDiagnostic, arg1: javac.util.JCDiagnostic, arg2: javac.util.JCDiagnostic): javac.util.JCDiagnostic$Fragment;
              CantApplyArrayCtor(arg0: javac.util.JCDiagnostic, arg1: javac.util.JCDiagnostic, arg2: javac.util.JCDiagnostic$Fragment): javac.util.JCDiagnostic$Fragment;
              CantApplyArrayCtor(arg0: javac.util.JCDiagnostic, arg1: javac.util.JCDiagnostic$Fragment, arg2: javac.util.JCDiagnostic): javac.util.JCDiagnostic$Fragment;
              CantApplyArrayCtor(arg0: javac.util.JCDiagnostic, arg1: javac.util.JCDiagnostic$Fragment, arg2: javac.util.JCDiagnostic$Fragment): javac.util.JCDiagnostic$Fragment;
              CantApplyArrayCtor(arg0: javac.util.JCDiagnostic$Fragment, arg1: java.util.List<javac.code.Type>, arg2: javac.util.JCDiagnostic): javac.util.JCDiagnostic$Fragment;
              CantApplyArrayCtor(arg0: javac.util.JCDiagnostic$Fragment, arg1: java.util.List<javac.code.Type>, arg2: javac.util.JCDiagnostic$Fragment): javac.util.JCDiagnostic$Fragment;
              CantApplyArrayCtor(arg0: javac.util.JCDiagnostic$Fragment, arg1: javac.util.JCDiagnostic, arg2: javac.util.JCDiagnostic): javac.util.JCDiagnostic$Fragment;
              CantApplyArrayCtor(arg0: javac.util.JCDiagnostic$Fragment, arg1: javac.util.JCDiagnostic, arg2: javac.util.JCDiagnostic$Fragment): javac.util.JCDiagnostic$Fragment;
              CantApplyArrayCtor(arg0: javac.util.JCDiagnostic$Fragment, arg1: javac.util.JCDiagnostic$Fragment, arg2: javac.util.JCDiagnostic): javac.util.JCDiagnostic$Fragment;
              CantApplyArrayCtor(arg0: javac.util.JCDiagnostic$Fragment, arg1: javac.util.JCDiagnostic$Fragment, arg2: javac.util.JCDiagnostic$Fragment): javac.util.JCDiagnostic$Fragment;
              CantApplyDiamond1(arg0: javac.util.JCDiagnostic, arg1: javac.util.JCDiagnostic): javac.util.JCDiagnostic$Fragment;
              CantApplyDiamond1(arg0: javac.util.JCDiagnostic, arg1: javac.util.JCDiagnostic$Fragment): javac.util.JCDiagnostic$Fragment;
              CantApplyDiamond1(arg0: javac.util.JCDiagnostic$Fragment, arg1: javac.util.JCDiagnostic): javac.util.JCDiagnostic$Fragment;
              CantApplyDiamond1(arg0: javac.util.JCDiagnostic$Fragment, arg1: javac.util.JCDiagnostic$Fragment): javac.util.JCDiagnostic$Fragment;
              CantApplyDiamond1(arg0: javac.code.Type, arg1: javac.util.JCDiagnostic): javac.util.JCDiagnostic$Fragment;
              CantApplyDiamond1(arg0: javac.code.Type, arg1: javac.util.JCDiagnostic$Fragment): javac.util.JCDiagnostic$Fragment;
              CantApplySymbol(arg0: javac.code.Kinds$Kind, arg1: javac.util.Name, arg2: java.util.List<javac.code.Type>, arg3: java.util.List<javac.code.Type>, arg4: javac.code.Kinds$Kind, arg5: javac.code.Type, arg6: javac.util.JCDiagnostic): javac.util.JCDiagnostic$Fragment;
              CantApplySymbol(arg0: javac.code.Kinds$Kind, arg1: javac.util.Name, arg2: java.util.List<javac.code.Type>, arg3: java.util.List<javac.code.Type>, arg4: javac.code.Kinds$Kind, arg5: javac.code.Type, arg6: javac.util.JCDiagnostic$Fragment): javac.util.JCDiagnostic$Fragment;
              CantApplySymbol(arg0: javac.code.Kinds$Kind, arg1: javac.util.Name, arg2: java.util.List<javac.code.Type>, arg3: javac.util.JCDiagnostic, arg4: javac.code.Kinds$Kind, arg5: javac.code.Type, arg6: javac.util.JCDiagnostic): javac.util.JCDiagnostic$Fragment;
              CantApplySymbol(arg0: javac.code.Kinds$Kind, arg1: javac.util.Name, arg2: java.util.List<javac.code.Type>, arg3: javac.util.JCDiagnostic, arg4: javac.code.Kinds$Kind, arg5: javac.code.Type, arg6: javac.util.JCDiagnostic$Fragment): javac.util.JCDiagnostic$Fragment;
              CantApplySymbol(arg0: javac.code.Kinds$Kind, arg1: javac.util.Name, arg2: java.util.List<javac.code.Type>, arg3: javac.util.JCDiagnostic$Fragment, arg4: javac.code.Kinds$Kind, arg5: javac.code.Type, arg6: javac.util.JCDiagnostic): javac.util.JCDiagnostic$Fragment;
              CantApplySymbol(arg0: javac.code.Kinds$Kind, arg1: javac.util.Name, arg2: java.util.List<javac.code.Type>, arg3: javac.util.JCDiagnostic$Fragment, arg4: javac.code.Kinds$Kind, arg5: javac.code.Type, arg6: javac.util.JCDiagnostic$Fragment): javac.util.JCDiagnostic$Fragment;
              CantApplySymbol(arg0: javac.code.Kinds$Kind, arg1: javac.util.Name, arg2: javac.util.JCDiagnostic, arg3: java.util.List<javac.code.Type>, arg4: javac.code.Kinds$Kind, arg5: javac.code.Type, arg6: javac.util.JCDiagnostic): javac.util.JCDiagnostic$Fragment;
              CantApplySymbol(arg0: javac.code.Kinds$Kind, arg1: javac.util.Name, arg2: javac.util.JCDiagnostic, arg3: java.util.List<javac.code.Type>, arg4: javac.code.Kinds$Kind, arg5: javac.code.Type, arg6: javac.util.JCDiagnostic$Fragment): javac.util.JCDiagnostic$Fragment;
              CantApplySymbol(arg0: javac.code.Kinds$Kind, arg1: javac.util.Name, arg2: javac.util.JCDiagnostic, arg3: javac.util.JCDiagnostic, arg4: javac.code.Kinds$Kind, arg5: javac.code.Type, arg6: javac.util.JCDiagnostic): javac.util.JCDiagnostic$Fragment;
              CantApplySymbol(arg0: javac.code.Kinds$Kind, arg1: javac.util.Name, arg2: javac.util.JCDiagnostic, arg3: javac.util.JCDiagnostic, arg4: javac.code.Kinds$Kind, arg5: javac.code.Type, arg6: javac.util.JCDiagnostic$Fragment): javac.util.JCDiagnostic$Fragment;
              CantApplySymbol(arg0: javac.code.Kinds$Kind, arg1: javac.util.Name, arg2: javac.util.JCDiagnostic, arg3: javac.util.JCDiagnostic$Fragment, arg4: javac.code.Kinds$Kind, arg5: javac.code.Type, arg6: javac.util.JCDiagnostic): javac.util.JCDiagnostic$Fragment;
              CantApplySymbol(arg0: javac.code.Kinds$Kind, arg1: javac.util.Name, arg2: javac.util.JCDiagnostic, arg3: javac.util.JCDiagnostic$Fragment, arg4: javac.code.Kinds$Kind, arg5: javac.code.Type, arg6: javac.util.JCDiagnostic$Fragment): javac.util.JCDiagnostic$Fragment;
              CantApplySymbol(arg0: javac.code.Kinds$Kind, arg1: javac.util.Name, arg2: javac.util.JCDiagnostic$Fragment, arg3: java.util.List<javac.code.Type>, arg4: javac.code.Kinds$Kind, arg5: javac.code.Type, arg6: javac.util.JCDiagnostic): javac.util.JCDiagnostic$Fragment;
              CantApplySymbol(arg0: javac.code.Kinds$Kind, arg1: javac.util.Name, arg2: javac.util.JCDiagnostic$Fragment, arg3: java.util.List<javac.code.Type>, arg4: javac.code.Kinds$Kind, arg5: javac.code.Type, arg6: javac.util.JCDiagnostic$Fragment): javac.util.JCDiagnostic$Fragment;
              CantApplySymbol(arg0: javac.code.Kinds$Kind, arg1: javac.util.Name, arg2: javac.util.JCDiagnostic$Fragment, arg3: javac.util.JCDiagnostic, arg4: javac.code.Kinds$Kind, arg5: javac.code.Type, arg6: javac.util.JCDiagnostic): javac.util.JCDiagnostic$Fragment;
              CantApplySymbol(arg0: javac.code.Kinds$Kind, arg1: javac.util.Name, arg2: javac.util.JCDiagnostic$Fragment, arg3: javac.util.JCDiagnostic, arg4: javac.code.Kinds$Kind, arg5: javac.code.Type, arg6: javac.util.JCDiagnostic$Fragment): javac.util.JCDiagnostic$Fragment;
              CantApplySymbol(arg0: javac.code.Kinds$Kind, arg1: javac.util.Name, arg2: javac.util.JCDiagnostic$Fragment, arg3: javac.util.JCDiagnostic$Fragment, arg4: javac.code.Kinds$Kind, arg5: javac.code.Type, arg6: javac.util.JCDiagnostic): javac.util.JCDiagnostic$Fragment;
              CantApplySymbol(arg0: javac.code.Kinds$Kind, arg1: javac.util.Name, arg2: javac.util.JCDiagnostic$Fragment, arg3: javac.util.JCDiagnostic$Fragment, arg4: javac.code.Kinds$Kind, arg5: javac.code.Type, arg6: javac.util.JCDiagnostic$Fragment): javac.util.JCDiagnostic$Fragment;
              CantApplySymbols(arg0: javac.code.Kinds$Kind, arg1: javac.util.Name, arg2: java.util.List<javac.code.Type>): javac.util.JCDiagnostic$Fragment;
              CantHide(arg0: javac.code.Symbol, arg1: javac.code.Symbol, arg2: javac.code.Symbol, arg3: javac.code.Symbol): javac.util.JCDiagnostic$Fragment;
              CantImplement(arg0: javac.code.Symbol, arg1: javac.code.Symbol, arg2: javac.code.Symbol, arg3: javac.code.Symbol): javac.util.JCDiagnostic$Fragment;
              CantOverride(arg0: javac.code.Symbol, arg1: javac.code.Symbol, arg2: javac.code.Symbol, arg3: javac.code.Symbol): javac.util.JCDiagnostic$Fragment;
              CantResolveArgs(arg0: javac.code.Kinds$KindName, arg1: javac.util.Name, arg2: java.lang.Void, arg3: java.util.List<javac.code.Type>): javac.util.JCDiagnostic$Fragment;
              CantResolveLocationArgs(arg0: javac.code.Kinds$KindName, arg1: javac.util.Name, arg2: java.lang.Void, arg3: java.util.List<javac.code.Type>, arg4: javac.util.JCDiagnostic): javac.util.JCDiagnostic$Fragment;
              CantResolveLocationArgs(arg0: javac.code.Kinds$KindName, arg1: javac.util.Name, arg2: java.lang.Void, arg3: java.util.List<javac.code.Type>, arg4: javac.util.JCDiagnostic$Fragment): javac.util.JCDiagnostic$Fragment;
              CantResolveLocationArgsParams(arg0: javac.code.Kinds$KindName, arg1: javac.util.Name, arg2: java.util.List<javac.code.Type>, arg3: java.util.List, arg4: javac.util.JCDiagnostic): javac.util.JCDiagnostic$Fragment;
              CantResolveLocationArgsParams(arg0: javac.code.Kinds$KindName, arg1: javac.util.Name, arg2: java.util.List<javac.code.Type>, arg3: java.util.List, arg4: javac.util.JCDiagnostic$Fragment): javac.util.JCDiagnostic$Fragment;
              CapturedType(arg0: int): javac.util.JCDiagnostic$Fragment;
              ClashesWith(arg0: javac.code.Symbol, arg1: javac.code.Symbol, arg2: javac.code.Symbol, arg3: javac.code.Symbol): javac.util.JCDiagnostic$Fragment;
              ClassFileNotFound(arg0: javac.util.Name): javac.util.JCDiagnostic$Fragment;
              ClassIsNotSealed(arg0: string): javac.util.JCDiagnostic$Fragment;
              CountError(arg0: int): javac.util.JCDiagnostic$Fragment;
              CountErrorPlural(arg0: int): javac.util.JCDiagnostic$Fragment;
              CountErrorRecompile(arg0: int, arg1: int): javac.util.JCDiagnostic$Fragment;
              CountWarn(arg0: int): javac.util.JCDiagnostic$Fragment;
              CountWarnPlural(arg0: int): javac.util.JCDiagnostic$Fragment;
              CountWarnRecompile(arg0: int, arg1: int): javac.util.JCDiagnostic$Fragment;
              Descriptor(arg0: javac.util.Name, arg1: java.util.List<javac.code.Type>, arg2: javac.code.Type, arg3: java.util.List<javac.code.Type>): javac.util.JCDiagnostic$Fragment;
              DescriptorThrows(arg0: javac.util.Name, arg1: java.util.List<javac.code.Type>, arg2: javac.code.Type, arg3: java.util.List<javac.code.Type>): javac.util.JCDiagnostic$Fragment;
              Diamond(arg0: javac.code.Symbol): javac.util.JCDiagnostic$Fragment;
              DiamondAndExplicitParams(arg0: javac.code.Type): javac.util.JCDiagnostic$Fragment;
              DiamondInvalidArg(arg0: java.util.List<javac.code.Type>, arg1: javac.util.JCDiagnostic): javac.util.JCDiagnostic$Fragment;
              DiamondInvalidArg(arg0: java.util.List<javac.code.Type>, arg1: javac.util.JCDiagnostic$Fragment): javac.util.JCDiagnostic$Fragment;
              DiamondInvalidArgs(arg0: java.util.List<javac.code.Type>, arg1: javac.util.JCDiagnostic): javac.util.JCDiagnostic$Fragment;
              DiamondInvalidArgs(arg0: java.util.List<javac.code.Type>, arg1: javac.util.JCDiagnostic$Fragment): javac.util.JCDiagnostic$Fragment;
              DiamondNonGeneric(arg0: javac.code.Type): javac.util.JCDiagnostic$Fragment;
              DoesntExtendSealed(arg0: javac.code.Type): javac.util.JCDiagnostic$Fragment;
              EqBounds(arg0: java.util.List<javac.code.Type>): javac.util.JCDiagnostic$Fragment;
              ExceptionMessage(arg0: string): javac.util.JCDiagnostic$Fragment;
              ExplicitParamDoNotConformToBounds(arg0: javac.code.Type, arg1: java.util.List<javac.code.Type>): javac.util.JCDiagnostic$Fragment;
              FatalErrCantLocateCtor(arg0: javac.code.Type): javac.util.JCDiagnostic$Fragment;
              FatalErrCantLocateField(arg0: javac.util.Name): javac.util.JCDiagnostic$Fragment;
              FatalErrCantLocateMeth(arg0: javac.util.Name): javac.util.JCDiagnostic$Fragment;
              FeatureNotSupportedInSource(arg0: javac.util.JCDiagnostic, arg1: string, arg2: string): javac.util.JCDiagnostic$Fragment;
              FeatureNotSupportedInSource(arg0: javac.util.JCDiagnostic$Fragment, arg1: string, arg2: string): javac.util.JCDiagnostic$Fragment;
              FeatureNotSupportedInSourcePlural(arg0: javac.util.JCDiagnostic, arg1: string, arg2: string): javac.util.JCDiagnostic$Fragment;
              FeatureNotSupportedInSourcePlural(arg0: javac.util.JCDiagnostic$Fragment, arg1: string, arg2: string): javac.util.JCDiagnostic$Fragment;
              FileDoesNotContainPackage(arg0: javac.code.Symbol): javac.util.JCDiagnostic$Fragment;
              FileDoesntContainClass(arg0: javac.util.Name): javac.util.JCDiagnostic$Fragment;
              IllegalSignature(arg0: javac.code.Symbol, arg1: javac.code.Type): javac.util.JCDiagnostic$Fragment;
              InaccessibleVarargsType(arg0: javac.code.Type, arg1: javac.code.Kinds$Kind, arg2: javac.code.Symbol): javac.util.JCDiagnostic$Fragment;
              InapplicableMethod(arg0: javac.code.Kinds$KindName, arg1: javac.code.Symbol, arg2: javac.code.Symbol, arg3: javac.util.JCDiagnostic): javac.util.JCDiagnostic$Fragment;
              InapplicableMethod(arg0: javac.code.Kinds$KindName, arg1: javac.code.Symbol, arg2: javac.code.Symbol, arg3: javac.util.JCDiagnostic$Fragment): javac.util.JCDiagnostic$Fragment;
              IncompatibleAbstractDefault(arg0: javac.code.Kinds$KindName, arg1: javac.code.Type, arg2: javac.util.Name, arg3: java.util.List<javac.code.Type>, arg4: javac.code.Symbol, arg5: javac.code.Symbol): javac.util.JCDiagnostic$Fragment;
              IncompatibleAbstracts(arg0: javac.code.Kinds$KindName, arg1: javac.code.Symbol): javac.util.JCDiagnostic$Fragment;
              IncompatibleBounds(arg0: javac.code.Type, arg1: javac.util.JCDiagnostic$Fragment, arg2: javac.util.JCDiagnostic$Fragment): javac.util.JCDiagnostic$Fragment;
              IncompatibleDescsInFunctionalIntf(arg0: javac.code.Kinds$KindName, arg1: javac.code.Symbol): javac.util.JCDiagnostic$Fragment;
              IncompatibleDiffRet(arg0: javac.util.Name, arg1: java.util.List<javac.code.Type>): javac.util.JCDiagnostic$Fragment;
              IncompatibleEqBounds(arg0: javac.code.Type, arg1: java.util.List<javac.code.Type>): javac.util.JCDiagnostic$Fragment;
              IncompatibleRetTypeInLambda(arg0: javac.util.JCDiagnostic): javac.util.JCDiagnostic$Fragment;
              IncompatibleRetTypeInLambda(arg0: javac.util.JCDiagnostic$Fragment): javac.util.JCDiagnostic$Fragment;
              IncompatibleRetTypeInMref(arg0: javac.util.JCDiagnostic): javac.util.JCDiagnostic$Fragment;
              IncompatibleRetTypeInMref(arg0: javac.util.JCDiagnostic$Fragment): javac.util.JCDiagnostic$Fragment;
              IncompatibleTypeInConditional(arg0: javac.util.JCDiagnostic): javac.util.JCDiagnostic$Fragment;
              IncompatibleTypeInConditional(arg0: javac.util.JCDiagnostic$Fragment): javac.util.JCDiagnostic$Fragment;
              IncompatibleTypeInSwitchExpression(arg0: javac.util.JCDiagnostic): javac.util.JCDiagnostic$Fragment;
              IncompatibleTypeInSwitchExpression(arg0: javac.util.JCDiagnostic$Fragment): javac.util.JCDiagnostic$Fragment;
              IncompatibleUnrelatedDefaults(arg0: javac.code.Kinds$KindName, arg1: javac.code.Type, arg2: javac.util.Name, arg3: java.util.List<javac.code.Type>, arg4: javac.code.Symbol, arg5: javac.code.Symbol): javac.util.JCDiagnostic$Fragment;
              IncompatibleUpperBounds(arg0: javac.code.Type, arg1: java.util.List<javac.code.Type>): javac.util.JCDiagnostic$Fragment;
              InconvertibleTypes(arg0: javac.code.Type, arg1: javac.code.Type): javac.util.JCDiagnostic$Fragment;
              InferArgLengthMismatch(arg0: java.util.List<javac.code.Type>): javac.util.JCDiagnostic$Fragment;
              InferNoConformingAssignmentExists(arg0: java.util.List<javac.code.Type>, arg1: javac.util.JCDiagnostic): javac.util.JCDiagnostic$Fragment;
              InferNoConformingAssignmentExists(arg0: java.util.List<javac.code.Type>, arg1: javac.util.JCDiagnostic$Fragment): javac.util.JCDiagnostic$Fragment;
              InferNoConformingInstanceExists(arg0: java.util.List<javac.code.Type>, arg1: javac.code.Type, arg2: javac.code.Type): javac.util.JCDiagnostic$Fragment;
              InferVarargsArgumentMismatch(arg0: java.util.List<javac.code.Type>, arg1: javac.util.JCDiagnostic): javac.util.JCDiagnostic$Fragment;
              InferVarargsArgumentMismatch(arg0: java.util.List<javac.code.Type>, arg1: javac.util.JCDiagnostic$Fragment): javac.util.JCDiagnostic$Fragment;
              InferredDoNotConformToEqBounds(arg0: javac.code.Type, arg1: java.util.List<javac.code.Type>): javac.util.JCDiagnostic$Fragment;
              InferredDoNotConformToLowerBounds(arg0: javac.code.Type, arg1: java.util.List<javac.code.Type>): javac.util.JCDiagnostic$Fragment;
              InferredDoNotConformToUpperBounds(arg0: javac.code.Type, arg1: java.util.List<javac.code.Type>): javac.util.JCDiagnostic$Fragment;
              IntersectionType(arg0: int): javac.util.JCDiagnostic$Fragment;
              InvalidDefaultInterface(arg0: string, arg1: string): javac.util.JCDiagnostic$Fragment;
              InvalidGenericLambdaTarget(arg0: javac.code.Type, arg1: javac.code.Kinds$KindName, arg2: javac.code.Symbol): javac.util.JCDiagnostic$Fragment;
              InvalidMref(arg0: javac.code.Kinds$KindName, arg1: javac.util.JCDiagnostic): javac.util.JCDiagnostic$Fragment;
              InvalidMref(arg0: javac.code.Kinds$KindName, arg1: javac.util.JCDiagnostic$Fragment): javac.util.JCDiagnostic$Fragment;
              InvalidStaticInterface(arg0: string, arg1: string): javac.util.JCDiagnostic$Fragment;
              IsATypeVariable(arg0: javac.code.Type): javac.util.JCDiagnostic$Fragment;
              IsDuplicated(arg0: javac.code.Type): javac.util.JCDiagnostic$Fragment;
              Location(arg0: javac.code.Kinds$KindName, arg1: javac.code.Type, arg2: java.lang.Void): javac.util.JCDiagnostic$Fragment;
              Location(arg0: javac.code.Kinds$KindName, arg1: javac.code.Symbol, arg2: java.lang.Void): javac.util.JCDiagnostic$Fragment;
              Location1(arg0: javac.code.Kinds$KindName, arg1: javac.code.Symbol, arg2: javac.code.Type): javac.util.JCDiagnostic$Fragment;
              LowerBounds(arg0: java.util.List<javac.code.Type>): javac.util.JCDiagnostic$Fragment;
              MethodDescriptorInvalid(arg0: javac.util.Name): javac.util.JCDiagnostic$Fragment;
              MissingRetVal(arg0: javac.code.Type): javac.util.JCDiagnostic$Fragment;
              ModuleNameMismatch(arg0: javac.util.Name, arg1: javac.util.Name): javac.util.JCDiagnostic$Fragment;
              ModuleNonZeroOpens(arg0: javac.util.Name): javac.util.JCDiagnostic$Fragment;
              MustNotBeSupertype(arg0: javac.code.Type): javac.util.JCDiagnostic$Fragment;
              NoAbstracts(arg0: javac.code.Kinds$KindName, arg1: javac.code.Symbol): javac.util.JCDiagnostic$Fragment;
              NoConformingAssignmentExists(arg0: javac.util.JCDiagnostic): javac.util.JCDiagnostic$Fragment;
              NoConformingAssignmentExists(arg0: javac.util.JCDiagnostic$Fragment): javac.util.JCDiagnostic$Fragment;
              NoSuitableFunctionalIntfInst(arg0: javac.code.Type): javac.util.JCDiagnostic$Fragment;
              NoUniqueMaximalInstanceExists(arg0: javac.code.Type, arg1: java.util.List<javac.code.Type>): javac.util.JCDiagnostic$Fragment;
              NoUniqueMinimalInstanceExists(arg0: javac.code.Type, arg1: java.util.List<javac.code.Type>): javac.util.JCDiagnostic$Fragment;
              NotAFunctionalIntf(arg0: javac.code.Symbol): javac.util.JCDiagnostic$Fragment;
              NotAFunctionalIntf1(arg0: javac.code.Symbol, arg1: javac.util.JCDiagnostic): javac.util.JCDiagnostic$Fragment;
              NotAFunctionalIntf1(arg0: javac.code.Symbol, arg1: javac.util.JCDiagnostic$Fragment): javac.util.JCDiagnostic$Fragment;
              NotAnIntfComponent(arg0: javac.code.Symbol): javac.util.JCDiagnostic$Fragment;
              NotAnIntfComponent(arg0: javac.code.Type): javac.util.JCDiagnostic$Fragment;
              NotApplicableMethodFound(arg0: int, arg1: javac.code.Symbol, arg2: javac.util.JCDiagnostic): javac.util.JCDiagnostic$Fragment;
              NotApplicableMethodFound(arg0: int, arg1: javac.code.Symbol, arg2: javac.util.JCDiagnostic$Fragment): javac.util.JCDiagnostic$Fragment;
              NotApplicableTypes(arg0: javac.code.Type, arg1: javac.code.Type): javac.util.JCDiagnostic$Fragment;
              NotDefAccessClassIntfCantAccess(arg0: javac.code.Symbol, arg1: javac.code.Symbol): javac.util.JCDiagnostic$Fragment;
              NotDefAccessClassIntfCantAccessReason(arg0: javac.code.Symbol, arg1: javac.code.Symbol, arg2: javac.code.Symbol, arg3: javac.util.JCDiagnostic): javac.util.JCDiagnostic$Fragment;
              NotDefAccessClassIntfCantAccessReason(arg0: javac.code.Symbol, arg1: javac.code.Symbol, arg2: javac.code.Symbol, arg3: javac.util.JCDiagnostic$Fragment): javac.util.JCDiagnostic$Fragment;
              NotDefAccessDoesNotRead(arg0: javac.code.Symbol, arg1: javac.code.Symbol, arg2: javac.code.Symbol): javac.util.JCDiagnostic$Fragment;
              NotDefAccessDoesNotReadFromUnnamed(arg0: javac.code.Symbol, arg1: javac.code.Symbol): javac.util.JCDiagnostic$Fragment;
              NotDefAccessDoesNotReadUnnamed(arg0: javac.code.Symbol, arg1: javac.code.Symbol): javac.util.JCDiagnostic$Fragment;
              NotDefAccessNotExported(arg0: javac.code.Symbol, arg1: javac.code.Symbol): javac.util.JCDiagnostic$Fragment;
              NotDefAccessNotExportedFromUnnamed(arg0: javac.code.Symbol, arg1: javac.code.Symbol): javac.util.JCDiagnostic$Fragment;
              NotDefAccessNotExportedToModule(arg0: javac.code.Symbol, arg1: javac.code.Symbol, arg2: javac.code.Symbol): javac.util.JCDiagnostic$Fragment;
              NotDefAccessNotExportedToModuleFromUnnamed(arg0: javac.code.Symbol, arg1: javac.code.Symbol): javac.util.JCDiagnostic$Fragment;
              NotDefAccessPackageCantAccess(arg0: javac.code.Symbol, arg1: javac.code.Symbol, arg2: javac.util.JCDiagnostic): javac.util.JCDiagnostic$Fragment;
              NotDefAccessPackageCantAccess(arg0: javac.code.Symbol, arg1: javac.code.Symbol, arg2: javac.util.JCDiagnostic$Fragment): javac.util.JCDiagnostic$Fragment;
              NotDefPublicCantAccess(arg0: javac.code.Symbol, arg1: javac.code.Symbol): javac.util.JCDiagnostic$Fragment;
              OverriddenDefault(arg0: javac.code.Symbol, arg1: javac.code.Type): javac.util.JCDiagnostic$Fragment;
              PackageNotVisible(arg0: javac.code.Symbol, arg1: javac.util.JCDiagnostic): javac.util.JCDiagnostic$Fragment;
              PackageNotVisible(arg0: javac.code.Symbol, arg1: javac.util.JCDiagnostic$Fragment): javac.util.JCDiagnostic$Fragment;
              PartialInstSig(arg0: javac.code.Type): javac.util.JCDiagnostic$Fragment;
              PossibleLossOfPrecision(arg0: javac.code.Type, arg1: javac.code.Type): javac.util.JCDiagnostic$Fragment;
              ProbFoundReq(arg0: javac.util.JCDiagnostic): javac.util.JCDiagnostic$Fragment;
              ProbFoundReq(arg0: javac.util.JCDiagnostic$Fragment): javac.util.JCDiagnostic$Fragment;
              RedundantSupertype(arg0: javac.code.Symbol, arg1: javac.code.Type): javac.util.JCDiagnostic$Fragment;
              RedundantSupertype(arg0: javac.code.Symbol, arg1: javac.code.Symbol): javac.util.JCDiagnostic$Fragment;
              RefAmbiguous(arg0: javac.util.Name, arg1: javac.code.Kinds$Kind, arg2: javac.code.Symbol, arg3: javac.code.Symbol, arg4: javac.code.Kinds$Kind, arg5: javac.code.Symbol, arg6: javac.code.Symbol): javac.util.JCDiagnostic$Fragment;
              ReportAccess(arg0: javac.code.Symbol, arg1: java.util.Set<javax.lang.model.element.Modifier>, arg2: javac.code.Symbol): javac.util.JCDiagnostic$Fragment;
              SyntheticNameConflict(arg0: javac.code.Symbol, arg1: javac.code.Symbol): javac.util.JCDiagnostic$Fragment;
              ThrowsClauseNotAllowedForCanonicalConstructor(arg0: javac.util.JCDiagnostic$Fragment): javac.util.JCDiagnostic$Fragment;
              TryNotApplicableToType(arg0: javac.util.JCDiagnostic): javac.util.JCDiagnostic$Fragment;
              TryNotApplicableToType(arg0: javac.util.JCDiagnostic$Fragment): javac.util.JCDiagnostic$Fragment;
              TypeCaptureof(arg0: javac.util.Name, arg1: javac.code.Type): javac.util.JCDiagnostic$Fragment;
              TypeParameter(arg0: javac.code.Type): javac.util.JCDiagnostic$Fragment;
              TypeVar(arg0: javac.util.Name, arg1: int): javac.util.JCDiagnostic$Fragment;
              UncheckedClashWith(arg0: javac.code.Symbol, arg1: javac.code.Symbol, arg2: javac.code.Symbol, arg3: javac.code.Symbol): javac.util.JCDiagnostic$Fragment;
              UncheckedImplement(arg0: javac.code.Symbol, arg1: javac.code.Symbol, arg2: javac.code.Symbol, arg3: javac.code.Symbol): javac.util.JCDiagnostic$Fragment;
              UncheckedOverride(arg0: javac.code.Symbol, arg1: javac.code.Symbol, arg2: javac.code.Symbol, arg3: javac.code.Symbol): javac.util.JCDiagnostic$Fragment;
              UpperBounds(arg0: java.util.List<javac.code.Type>): javac.util.JCDiagnostic$Fragment;
              VarargsArgumentMismatch(arg0: javac.util.JCDiagnostic): javac.util.JCDiagnostic$Fragment;
              VarargsArgumentMismatch(arg0: javac.util.JCDiagnostic$Fragment): javac.util.JCDiagnostic$Fragment;
              VarargsClashWith(arg0: javac.code.Symbol, arg1: javac.code.Symbol, arg2: javac.code.Symbol, arg3: javac.code.Symbol): javac.util.JCDiagnostic$Fragment;
              VarargsImplement(arg0: javac.code.Symbol, arg1: javac.code.Symbol, arg2: javac.code.Symbol, arg3: javac.code.Symbol): javac.util.JCDiagnostic$Fragment;
              VarargsOverride(arg0: javac.code.Symbol, arg1: javac.code.Symbol, arg2: javac.code.Symbol, arg3: javac.code.Symbol): javac.util.JCDiagnostic$Fragment;
              VarargsTrustmeOnNonVarargsAccessor(arg0: javac.code.Symbol): javac.util.JCDiagnostic$Fragment;
              VarargsTrustmeOnNonVarargsMeth(arg0: javac.code.Symbol): javac.util.JCDiagnostic$Fragment;
              VarargsTrustmeOnReifiableVarargs(arg0: javac.code.Type): javac.util.JCDiagnostic$Fragment;
              VarargsTrustmeOnVirtualVarargs(arg0: javac.code.Symbol): javac.util.JCDiagnostic$Fragment;
              VarargsTrustmeOnVirtualVarargsFinalOnly(arg0: javac.code.Symbol): javac.util.JCDiagnostic$Fragment;
              VerboseCheckingAttribution(arg0: javac.code.Symbol): javac.util.JCDiagnostic$Fragment;
              VerboseClasspath(arg0: string): javac.util.JCDiagnostic$Fragment;
              VerboseLoading(arg0: string): javac.util.JCDiagnostic$Fragment;
              VerboseParsingDone(arg0: string): javac.util.JCDiagnostic$Fragment;
              VerboseParsingStarted(arg0: java.io.File): javac.util.JCDiagnostic$Fragment;
              VerboseParsingStarted(arg0: javax.tools.JavaFileObject): javac.util.JCDiagnostic$Fragment;
              VerboseParsingStarted(arg0: java.nio.file.Path): javac.util.JCDiagnostic$Fragment;
              VerboseSourcepath(arg0: string): javac.util.JCDiagnostic$Fragment;
              VerboseTotal(arg0: string): javac.util.JCDiagnostic$Fragment;
              VerboseWroteFile(arg0: java.io.File): javac.util.JCDiagnostic$Fragment;
              VerboseWroteFile(arg0: javax.tools.JavaFileObject): javac.util.JCDiagnostic$Fragment;
              VerboseWroteFile(arg0: java.nio.file.Path): javac.util.JCDiagnostic$Fragment;
              WhereCaptured(arg0: javac.code.Type, arg1: javac.code.Type, arg2: javac.code.Type, arg3: javac.code.Type): javac.util.JCDiagnostic$Fragment;
              WhereCaptured1(arg0: javac.code.Type, arg1: javac.code.Type, arg2: java.lang.Void, arg3: javac.code.Type): javac.util.JCDiagnostic$Fragment;
              WhereDescriptionCaptured1(arg0: java.util.Set<javac.code.Type>): javac.util.JCDiagnostic$Fragment;
              WhereDescriptionIntersection(arg0: java.util.Set<javac.code.Type>): javac.util.JCDiagnostic$Fragment;
              WhereDescriptionIntersection1(arg0: java.util.Set<javac.code.Type>): javac.util.JCDiagnostic$Fragment;
              WhereDescriptionTypevar(arg0: java.util.Set<javac.code.Type>): javac.util.JCDiagnostic$Fragment;
              WhereDescriptionTypevar1(arg0: java.util.Set<javac.code.Type>): javac.util.JCDiagnostic$Fragment;
              WhereFreshTypevar(arg0: javac.code.Type, arg1: java.util.List<javac.code.Type>): javac.util.JCDiagnostic$Fragment;
              WhereIntersection(arg0: javac.code.Type, arg1: java.util.List<javac.code.Type>): javac.util.JCDiagnostic$Fragment;
              WhereTypevar(arg0: javac.code.Type, arg1: java.util.List<javac.code.Type>, arg2: javac.code.Kinds$Kind, arg3: javac.code.Symbol): javac.util.JCDiagnostic$Fragment;
              WhereTypevar1(arg0: javac.code.Type, arg1: java.util.List<javac.code.Type>, arg2: javac.code.Kinds$Kind, arg3: javac.code.Symbol): javac.util.JCDiagnostic$Fragment;
              WrongNumberTypeArgs(arg0: string): javac.util.JCDiagnostic$Fragment;
              XPrintProcessorInfo(arg0: string, arg1: string, arg2: boolean): javac.util.JCDiagnostic$Fragment;
              XPrintRounds(arg0: int, arg1: string, arg2: java.util.Set<javac.code.Symbol>, arg3: boolean): javac.util.JCDiagnostic$Fragment;
              readonly AccessorMethodCantThrowException: javac.util.JCDiagnostic$Fragment;
              readonly AccessorMethodMustNotBeGeneric: javac.util.JCDiagnostic$Fragment;
              readonly AccessorMethodMustNotBeStatic: javac.util.JCDiagnostic$Fragment;
              readonly Anonymous: javac.util.JCDiagnostic$Fragment;
              readonly ArgLengthMismatch: javac.util.JCDiagnostic$Fragment;
              readonly BadClassSignature: javac.util.JCDiagnostic$Fragment;
              readonly BadConstPoolTag: javac.util.JCDiagnostic$Fragment;
              readonly BadConstPoolTagAt: javac.util.JCDiagnostic$Fragment;
              readonly BadEnclosingClass: javac.util.JCDiagnostic$Fragment;
              readonly BadModuleInfoName: javac.util.JCDiagnostic$Fragment;
              readonly BadRequiresFlag: javac.util.JCDiagnostic$Fragment;
              readonly BadRuntimeInvisibleParamAnnotations: javac.util.JCDiagnostic$Fragment;
              readonly BadSignature: javac.util.JCDiagnostic$Fragment;
              readonly BadTypeAnnotationValue: javac.util.JCDiagnostic$Fragment;
              readonly Bound: javac.util.JCDiagnostic$Fragment;
              readonly Canonical: javac.util.JCDiagnostic$Fragment;
              readonly CanonicalCantHaveReturnStatement: javac.util.JCDiagnostic$Fragment;
              readonly CanonicalMustNotContainExplicitConstructorInvocation: javac.util.JCDiagnostic$Fragment;
              readonly CanonicalMustNotDeclareTypeVariables: javac.util.JCDiagnostic$Fragment;
              readonly CanonicalWithNameMismatch: javac.util.JCDiagnostic$Fragment;
              readonly CantResolveModules: javac.util.JCDiagnostic$Fragment;
              readonly ClassFileWrongClass: javac.util.JCDiagnostic$Fragment;
              readonly Compact: javac.util.JCDiagnostic$Fragment;
              readonly ConditionalTargetCantBeVoid: javac.util.JCDiagnostic$Fragment;
              readonly DiamondAnonymousMethodsImplicitlyOverride: javac.util.JCDiagnostic$Fragment;
              readonly FatalErrCantClose: javac.util.JCDiagnostic$Fragment;
              readonly FeatureCaseNull: javac.util.JCDiagnostic$Fragment;
              readonly FeatureDeconstructionPatterns: javac.util.JCDiagnostic$Fragment;
              readonly FeatureDiamondAndAnonClass: javac.util.JCDiagnostic$Fragment;
              readonly FeatureModules: javac.util.JCDiagnostic$Fragment;
              readonly FeatureMultipleCaseLabels: javac.util.JCDiagnostic$Fragment;
              readonly FeaturePatternMatchingInstanceof: javac.util.JCDiagnostic$Fragment;
              readonly FeaturePatternSwitch: javac.util.JCDiagnostic$Fragment;
              readonly FeaturePrivateIntfMethods: javac.util.JCDiagnostic$Fragment;
              readonly FeatureRecords: javac.util.JCDiagnostic$Fragment;
              readonly FeatureReifiableTypesInstanceof: javac.util.JCDiagnostic$Fragment;
              readonly FeatureSealedClasses: javac.util.JCDiagnostic$Fragment;
              readonly FeatureStringTemplates: javac.util.JCDiagnostic$Fragment;
              readonly FeatureSwitchExpressions: javac.util.JCDiagnostic$Fragment;
              readonly FeatureSwitchRules: javac.util.JCDiagnostic$Fragment;
              readonly FeatureTextBlocks: javac.util.JCDiagnostic$Fragment;
              readonly FeatureUnconditionalPatternsInInstanceof: javac.util.JCDiagnostic$Fragment;
              readonly FeatureUnnamedClasses: javac.util.JCDiagnostic$Fragment;
              readonly FeatureUnnamedVariables: javac.util.JCDiagnostic$Fragment;
              readonly FeatureVarInTryWithResources: javac.util.JCDiagnostic$Fragment;
              readonly FeatureVarSyntaxInImplicitLambda: javac.util.JCDiagnostic$Fragment;
              readonly FileDoesNotContainModule: javac.util.JCDiagnostic$Fragment;
              readonly Guard: javac.util.JCDiagnostic$Fragment;
              readonly IllegalFlagCombo: javac.util.JCDiagnostic$Fragment;
              readonly IllegalStartOfClassFile: javac.util.JCDiagnostic$Fragment;
              readonly ImplicitAndExplicitNotAllowed: javac.util.JCDiagnostic$Fragment;
              readonly IncompatibleArgTypesInLambda: javac.util.JCDiagnostic$Fragment;
              readonly IncompatibleArgTypesInMref: javac.util.JCDiagnostic$Fragment;
              readonly InnerCls: javac.util.JCDiagnostic$Fragment;
              readonly KindnameAnnotation: javac.util.JCDiagnostic$Fragment;
              readonly KindnameClass: javac.util.JCDiagnostic$Fragment;
              readonly KindnameConstructor: javac.util.JCDiagnostic$Fragment;
              readonly KindnameEnum: javac.util.JCDiagnostic$Fragment;
              readonly KindnameInstanceInit: javac.util.JCDiagnostic$Fragment;
              readonly KindnameInterface: javac.util.JCDiagnostic$Fragment;
              readonly KindnameMethod: javac.util.JCDiagnostic$Fragment;
              readonly KindnameModule: javac.util.JCDiagnostic$Fragment;
              readonly KindnamePackage: javac.util.JCDiagnostic$Fragment;
              readonly KindnameRecord: javac.util.JCDiagnostic$Fragment;
              readonly KindnameRecordComponent: javac.util.JCDiagnostic$Fragment;
              readonly KindnameStatic: javac.util.JCDiagnostic$Fragment;
              readonly KindnameStaticInit: javac.util.JCDiagnostic$Fragment;
              readonly KindnameTypeVariable: javac.util.JCDiagnostic$Fragment;
              readonly KindnameTypeVariableBound: javac.util.JCDiagnostic$Fragment;
              readonly KindnameValue: javac.util.JCDiagnostic$Fragment;
              readonly KindnameVariable: javac.util.JCDiagnostic$Fragment;
              readonly Lambda: javac.util.JCDiagnostic$Fragment;
              readonly Local: javac.util.JCDiagnostic$Fragment;
              readonly LocalArrayMissingTarget: javac.util.JCDiagnostic$Fragment;
              readonly LocalCantInferNull: javac.util.JCDiagnostic$Fragment;
              readonly LocalCantInferVoid: javac.util.JCDiagnostic$Fragment;
              readonly LocalLambdaMissingTarget: javac.util.JCDiagnostic$Fragment;
              readonly LocalMissingInit: javac.util.JCDiagnostic$Fragment;
              readonly LocalMrefMissingTarget: javac.util.JCDiagnostic$Fragment;
              readonly LocalSelfRef: javac.util.JCDiagnostic$Fragment;
              readonly LocnModule_path: javac.util.JCDiagnostic$Fragment;
              readonly LocnModule_source_path: javac.util.JCDiagnostic$Fragment;
              readonly LocnSystem_modules: javac.util.JCDiagnostic$Fragment;
              readonly LocnUpgrade_module_path: javac.util.JCDiagnostic$Fragment;
              readonly MalformedVarargMethod: javac.util.JCDiagnostic$Fragment;
              readonly MethodMustBePublic: javac.util.JCDiagnostic$Fragment;
              readonly ModuleInfoDefinitionExpected: javac.util.JCDiagnostic$Fragment;
              readonly ModuleInfoInvalidSuperClass: javac.util.JCDiagnostic$Fragment;
              readonly MrefInferAndExplicitParams: javac.util.JCDiagnostic$Fragment;
              readonly MustNotBeSameClass: javac.util.JCDiagnostic$Fragment;
              readonly NoArgs: javac.util.JCDiagnostic$Fragment;
              readonly NonStatic: javac.util.JCDiagnostic$Fragment;
              readonly ResumeAbort: javac.util.JCDiagnostic$Fragment;
              readonly SourceUnavailable: javac.util.JCDiagnostic$Fragment;
              readonly StatExprExpected: javac.util.JCDiagnostic$Fragment;
              readonly Static: javac.util.JCDiagnostic$Fragment;
              readonly StaticMrefWithTargs: javac.util.JCDiagnostic$Fragment;
              readonly SwitchExpressionTargetCantBeVoid: javac.util.JCDiagnostic$Fragment;
              readonly TokenBadSymbol: javac.util.JCDiagnostic$Fragment;
              readonly TokenCharacter: javac.util.JCDiagnostic$Fragment;
              readonly TokenDouble: javac.util.JCDiagnostic$Fragment;
              readonly TokenEndOfInput: javac.util.JCDiagnostic$Fragment;
              readonly TokenFloat: javac.util.JCDiagnostic$Fragment;
              readonly TokenIdentifier: javac.util.JCDiagnostic$Fragment;
              readonly TokenInteger: javac.util.JCDiagnostic$Fragment;
              readonly TokenLongInteger: javac.util.JCDiagnostic$Fragment;
              readonly TokenString: javac.util.JCDiagnostic$Fragment;
              readonly TypeCaptureof1: javac.util.JCDiagnostic$Fragment;
              readonly TypeMustBeIdenticalToCorrespondingRecordComponentType: javac.util.JCDiagnostic$Fragment;
              readonly TypeNone: javac.util.JCDiagnostic$Fragment;
              readonly TypeNull: javac.util.JCDiagnostic$Fragment;
              readonly TypeReqArrayOrIterable: javac.util.JCDiagnostic$Fragment;
              readonly TypeReqClass: javac.util.JCDiagnostic$Fragment;
              readonly TypeReqClassArray: javac.util.JCDiagnostic$Fragment;
              readonly TypeReqExact: javac.util.JCDiagnostic$Fragment;
              readonly TypeReqRef: javac.util.JCDiagnostic$Fragment;
              readonly UnableToAccessFile: javac.util.JCDiagnostic$Fragment;
              readonly Unbound: javac.util.JCDiagnostic$Fragment;
              readonly UncheckedAssign: javac.util.JCDiagnostic$Fragment;
              readonly UncheckedCastToType: javac.util.JCDiagnostic$Fragment;
              readonly UndeclTypeVar: javac.util.JCDiagnostic$Fragment;
              readonly UnexpectedConstPoolTagAt: javac.util.JCDiagnostic$Fragment;
              readonly UnexpectedRetVal: javac.util.JCDiagnostic$Fragment;
              readonly UnicodeStrNotSupported: javac.util.JCDiagnostic$Fragment;
              readonly UnnamedModule: javac.util.JCDiagnostic$Fragment;
              readonly UnnamedPackage: javac.util.JCDiagnostic$Fragment;
              readonly UserSelectedCompletionFailure: javac.util.JCDiagnostic$Fragment;
              readonly VarAndExplicitNotAllowed: javac.util.JCDiagnostic$Fragment;
              readonly VarAndImplicitNotAllowed: javac.util.JCDiagnostic$Fragment;
              readonly VersionNotAvailable: javac.util.JCDiagnostic$Fragment;
              readonly WhereDescriptionCaptured: javac.util.JCDiagnostic$Fragment;
              readonly WrongVersion: javac.util.JCDiagnostic$Fragment;
              new(): CompilerProperties$Fragments;
            }
            let CompilerProperties$Fragments: _CompilerProperties$Fragments$$static;
            interface _CompilerProperties$Fragments {
            }
            interface CompilerProperties$Fragments extends CombineTypes<[_CompilerProperties$Fragments, java.lang.Object]> {}
            interface _CompilerProperties$Notes$$static extends ClassLike {
              DeferredMethodInst(arg0: javac.code.Symbol, arg1: javac.code.Type, arg2: javac.code.Type): javac.util.JCDiagnostic$Note;
              DeprecatedFilename(arg0: java.io.File): javac.util.JCDiagnostic$Note;
              DeprecatedFilename(arg0: javax.tools.JavaFileObject): javac.util.JCDiagnostic$Note;
              DeprecatedFilename(arg0: java.nio.file.Path): javac.util.JCDiagnostic$Note;
              DeprecatedFilenameAdditional(arg0: java.io.File): javac.util.JCDiagnostic$Note;
              DeprecatedFilenameAdditional(arg0: javax.tools.JavaFileObject): javac.util.JCDiagnostic$Note;
              DeprecatedFilenameAdditional(arg0: java.nio.file.Path): javac.util.JCDiagnostic$Note;
              LambdaStat(arg0: boolean, arg1: javac.code.Symbol): javac.util.JCDiagnostic$Note;
              MethodRefSearchResultsMulti(arg0: javac.util.JCDiagnostic$Fragment, arg1: string, arg2: int): javac.util.JCDiagnostic$Note;
              MrefStat(arg0: boolean, arg1: java.lang.Void): javac.util.JCDiagnostic$Note;
              MrefStat1(arg0: boolean, arg1: javac.code.Symbol): javac.util.JCDiagnostic$Note;
              MultipleElements(arg0: string, arg1: string, arg2: string): javac.util.JCDiagnostic$Note;
              PreviewFilename(arg0: java.io.File, arg1: javac.code.Source): javac.util.JCDiagnostic$Note;
              PreviewFilename(arg0: javax.tools.JavaFileObject, arg1: javac.code.Source): javac.util.JCDiagnostic$Note;
              PreviewFilename(arg0: java.nio.file.Path, arg1: javac.code.Source): javac.util.JCDiagnostic$Note;
              PreviewFilenameAdditional(arg0: java.io.File, arg1: javac.code.Source): javac.util.JCDiagnostic$Note;
              PreviewFilenameAdditional(arg0: javax.tools.JavaFileObject, arg1: javac.code.Source): javac.util.JCDiagnostic$Note;
              PreviewFilenameAdditional(arg0: java.nio.file.Path, arg1: javac.code.Source): javac.util.JCDiagnostic$Note;
              PreviewPlural(arg0: javac.code.Source): javac.util.JCDiagnostic$Note;
              PreviewPluralAdditional(arg0: javac.code.Source): javac.util.JCDiagnostic$Note;
              ProcMessager(arg0: string): javac.util.JCDiagnostic$Note;
              RemovalFilename(arg0: java.io.File): javac.util.JCDiagnostic$Note;
              RemovalFilename(arg0: javax.tools.JavaFileObject): javac.util.JCDiagnostic$Note;
              RemovalFilename(arg0: java.nio.file.Path): javac.util.JCDiagnostic$Note;
              RemovalFilenameAdditional(arg0: java.io.File): javac.util.JCDiagnostic$Note;
              RemovalFilenameAdditional(arg0: javax.tools.JavaFileObject): javac.util.JCDiagnostic$Note;
              RemovalFilenameAdditional(arg0: java.nio.file.Path): javac.util.JCDiagnostic$Note;
              UncheckedFilename(arg0: java.io.File): javac.util.JCDiagnostic$Note;
              UncheckedFilename(arg0: javax.tools.JavaFileObject): javac.util.JCDiagnostic$Note;
              UncheckedFilename(arg0: java.nio.file.Path): javac.util.JCDiagnostic$Note;
              UncheckedFilenameAdditional(arg0: java.io.File): javac.util.JCDiagnostic$Note;
              UncheckedFilenameAdditional(arg0: javax.tools.JavaFileObject): javac.util.JCDiagnostic$Note;
              UncheckedFilenameAdditional(arg0: java.nio.file.Path): javac.util.JCDiagnostic$Note;
              VerboseL2mDeduplicate(arg0: javac.code.Symbol): javac.util.JCDiagnostic$Note;
              VerboseResolveMulti(arg0: javac.util.Name, arg1: javac.code.Symbol, arg2: int, arg3: string, arg4: java.util.List<javac.code.Type>, arg5: java.util.List<javac.code.Type>): javac.util.JCDiagnostic$Note;
              VerboseResolveMulti(arg0: javac.util.Name, arg1: javac.code.Symbol, arg2: int, arg3: string, arg4: java.util.List<javac.code.Type>, arg5: javac.util.JCDiagnostic): javac.util.JCDiagnostic$Note;
              VerboseResolveMulti(arg0: javac.util.Name, arg1: javac.code.Symbol, arg2: int, arg3: string, arg4: java.util.List<javac.code.Type>, arg5: javac.util.JCDiagnostic$Fragment): javac.util.JCDiagnostic$Note;
              VerboseResolveMulti(arg0: javac.util.Name, arg1: javac.code.Symbol, arg2: int, arg3: string, arg4: javac.util.JCDiagnostic, arg5: java.util.List<javac.code.Type>): javac.util.JCDiagnostic$Note;
              VerboseResolveMulti(arg0: javac.util.Name, arg1: javac.code.Symbol, arg2: int, arg3: string, arg4: javac.util.JCDiagnostic, arg5: javac.util.JCDiagnostic): javac.util.JCDiagnostic$Note;
              VerboseResolveMulti(arg0: javac.util.Name, arg1: javac.code.Symbol, arg2: int, arg3: string, arg4: javac.util.JCDiagnostic, arg5: javac.util.JCDiagnostic$Fragment): javac.util.JCDiagnostic$Note;
              VerboseResolveMulti(arg0: javac.util.Name, arg1: javac.code.Symbol, arg2: int, arg3: string, arg4: javac.util.JCDiagnostic$Fragment, arg5: java.util.List<javac.code.Type>): javac.util.JCDiagnostic$Note;
              VerboseResolveMulti(arg0: javac.util.Name, arg1: javac.code.Symbol, arg2: int, arg3: string, arg4: javac.util.JCDiagnostic$Fragment, arg5: javac.util.JCDiagnostic): javac.util.JCDiagnostic$Note;
              VerboseResolveMulti(arg0: javac.util.Name, arg1: javac.code.Symbol, arg2: int, arg3: string, arg4: javac.util.JCDiagnostic$Fragment, arg5: javac.util.JCDiagnostic$Fragment): javac.util.JCDiagnostic$Note;
              VerboseResolveMulti1(arg0: javac.util.Name, arg1: javac.code.Symbol, arg2: java.lang.Void, arg3: string, arg4: java.util.List<javac.code.Type>, arg5: java.util.List<javac.code.Type>): javac.util.JCDiagnostic$Note;
              VerboseResolveMulti1(arg0: javac.util.Name, arg1: javac.code.Symbol, arg2: java.lang.Void, arg3: string, arg4: java.util.List<javac.code.Type>, arg5: javac.util.JCDiagnostic): javac.util.JCDiagnostic$Note;
              VerboseResolveMulti1(arg0: javac.util.Name, arg1: javac.code.Symbol, arg2: java.lang.Void, arg3: string, arg4: java.util.List<javac.code.Type>, arg5: javac.util.JCDiagnostic$Fragment): javac.util.JCDiagnostic$Note;
              VerboseResolveMulti1(arg0: javac.util.Name, arg1: javac.code.Symbol, arg2: java.lang.Void, arg3: string, arg4: javac.util.JCDiagnostic, arg5: java.util.List<javac.code.Type>): javac.util.JCDiagnostic$Note;
              VerboseResolveMulti1(arg0: javac.util.Name, arg1: javac.code.Symbol, arg2: java.lang.Void, arg3: string, arg4: javac.util.JCDiagnostic, arg5: javac.util.JCDiagnostic): javac.util.JCDiagnostic$Note;
              VerboseResolveMulti1(arg0: javac.util.Name, arg1: javac.code.Symbol, arg2: java.lang.Void, arg3: string, arg4: javac.util.JCDiagnostic, arg5: javac.util.JCDiagnostic$Fragment): javac.util.JCDiagnostic$Note;
              VerboseResolveMulti1(arg0: javac.util.Name, arg1: javac.code.Symbol, arg2: java.lang.Void, arg3: string, arg4: javac.util.JCDiagnostic$Fragment, arg5: java.util.List<javac.code.Type>): javac.util.JCDiagnostic$Note;
              VerboseResolveMulti1(arg0: javac.util.Name, arg1: javac.code.Symbol, arg2: java.lang.Void, arg3: string, arg4: javac.util.JCDiagnostic$Fragment, arg5: javac.util.JCDiagnostic): javac.util.JCDiagnostic$Note;
              VerboseResolveMulti1(arg0: javac.util.Name, arg1: javac.code.Symbol, arg2: java.lang.Void, arg3: string, arg4: javac.util.JCDiagnostic$Fragment, arg5: javac.util.JCDiagnostic$Fragment): javac.util.JCDiagnostic$Note;
              readonly CompressedDiags: javac.util.JCDiagnostic$Note;
              readonly DeprecatedPlural: javac.util.JCDiagnostic$Note;
              readonly DeprecatedPluralAdditional: javac.util.JCDiagnostic$Note;
              readonly DeprecatedRecompile: javac.util.JCDiagnostic$Note;
              readonly ImplicitAnnotationProcessing: javac.util.JCDiagnostic$Note;
              readonly Note: javac.util.JCDiagnostic$Note;
              readonly PreviewRecompile: javac.util.JCDiagnostic$Note;
              readonly RemovalPlural: javac.util.JCDiagnostic$Note;
              readonly RemovalPluralAdditional: javac.util.JCDiagnostic$Note;
              readonly RemovalRecompile: javac.util.JCDiagnostic$Note;
              readonly UncheckedPlural: javac.util.JCDiagnostic$Note;
              readonly UncheckedPluralAdditional: javac.util.JCDiagnostic$Note;
              readonly UncheckedRecompile: javac.util.JCDiagnostic$Note;
              new(): CompilerProperties$Notes;
            }
            let CompilerProperties$Notes: _CompilerProperties$Notes$$static;
            interface _CompilerProperties$Notes {
            }
            interface CompilerProperties$Notes extends CombineTypes<[_CompilerProperties$Notes, java.lang.Object]> {}
            interface _CompilerProperties$Warnings$$static extends ClassLike {
              AccessToMemberFromSerializableElement(arg0: javac.code.Symbol): javac.util.JCDiagnostic$Warning;
              AccessToMemberFromSerializableLambda(arg0: javac.code.Symbol): javac.util.JCDiagnostic$Warning;
              AnnotationMethodNotFound(arg0: javac.code.Type, arg1: javac.util.Name): javac.util.JCDiagnostic$Warning;
              AnnotationMethodNotFoundReason(arg0: javac.code.Type, arg1: javac.util.Name, arg2: javac.util.JCDiagnostic): javac.util.JCDiagnostic$Warning;
              AnnotationMethodNotFoundReason(arg0: javac.code.Type, arg1: javac.util.Name, arg2: javac.util.JCDiagnostic$Fragment): javac.util.JCDiagnostic$Warning;
              AuxiliaryClassAccessedFromOutsideOfItsSourceFile(arg0: javac.code.Symbol, arg1: java.io.File): javac.util.JCDiagnostic$Warning;
              AuxiliaryClassAccessedFromOutsideOfItsSourceFile(arg0: javac.code.Symbol, arg1: javax.tools.JavaFileObject): javac.util.JCDiagnostic$Warning;
              AuxiliaryClassAccessedFromOutsideOfItsSourceFile(arg0: javac.code.Symbol, arg1: java.nio.file.Path): javac.util.JCDiagnostic$Warning;
              AuxiliaryClassAccessedFromOutsideOfItsSourceFile(arg0: javac.code.Type, arg1: java.io.File): javac.util.JCDiagnostic$Warning;
              AuxiliaryClassAccessedFromOutsideOfItsSourceFile(arg0: javac.code.Type, arg1: javax.tools.JavaFileObject): javac.util.JCDiagnostic$Warning;
              AuxiliaryClassAccessedFromOutsideOfItsSourceFile(arg0: javac.code.Type, arg1: java.nio.file.Path): javac.util.JCDiagnostic$Warning;
              BadNameForOption(arg0: javac.main.Option, arg1: string): javac.util.JCDiagnostic$Warning;
              BigMajorVersion(arg0: java.io.File, arg1: int, arg2: int): javac.util.JCDiagnostic$Warning;
              BigMajorVersion(arg0: javax.tools.JavaFileObject, arg1: int, arg2: int): javac.util.JCDiagnostic$Warning;
              BigMajorVersion(arg0: java.nio.file.Path, arg1: int, arg2: int): javac.util.JCDiagnostic$Warning;
              ConstantSVUID(arg0: javac.code.Symbol): javac.util.JCDiagnostic$Warning;
              DeclaredUsingPreview(arg0: javac.code.Kinds$KindName, arg1: javac.code.Symbol): javac.util.JCDiagnostic$Warning;
              DeprecatedAnnotationHasNoEffect(arg0: javac.code.Kinds$KindName): javac.util.JCDiagnostic$Warning;
              DirPathElementNotDirectory(arg0: java.io.File): javac.util.JCDiagnostic$Warning;
              DirPathElementNotDirectory(arg0: javax.tools.JavaFileObject): javac.util.JCDiagnostic$Warning;
              DirPathElementNotDirectory(arg0: java.nio.file.Path): javac.util.JCDiagnostic$Warning;
              DirPathElementNotFound(arg0: java.nio.file.Path): javac.util.JCDiagnostic$Warning;
              FileFromFuture(arg0: java.io.File): javac.util.JCDiagnostic$Warning;
              FileFromFuture(arg0: javax.tools.JavaFileObject): javac.util.JCDiagnostic$Warning;
              FileFromFuture(arg0: java.nio.file.Path): javac.util.JCDiagnostic$Warning;
              ForwardRef(arg0: javac.code.Symbol): javac.util.JCDiagnostic$Warning;
              FutureAttr(arg0: javac.util.Name, arg1: int, arg2: int, arg3: int, arg4: int): javac.util.JCDiagnostic$Warning;
              HasBeenDeprecated(arg0: javac.code.Symbol, arg1: javac.code.Symbol): javac.util.JCDiagnostic$Warning;
              HasBeenDeprecatedForRemoval(arg0: javac.code.Symbol, arg1: javac.code.Symbol): javac.util.JCDiagnostic$Warning;
              HasBeenDeprecatedForRemovalModule(arg0: javac.code.Symbol): javac.util.JCDiagnostic$Warning;
              HasBeenDeprecatedModule(arg0: javac.code.Symbol): javac.util.JCDiagnostic$Warning;
              IllegalRefToRestrictedType(arg0: javac.util.Name): javac.util.JCDiagnostic$Warning;
              ImproperSVUID(arg0: javac.code.Symbol): javac.util.JCDiagnostic$Warning;
              IncubatingModules(arg0: string): javac.util.JCDiagnostic$Warning;
              IneffectualSerialFieldEnum(arg0: string): javac.util.JCDiagnostic$Warning;
              IneffectualSerialMethodEnum(arg0: string): javac.util.JCDiagnostic$Warning;
              IneffectualSerialMethodExternalizable(arg0: javac.util.Name): javac.util.JCDiagnostic$Warning;
              IneffectualSerialMethodRecord(arg0: string): javac.util.JCDiagnostic$Warning;
              InexactNonVarargsCall(arg0: javac.code.Type, arg1: javac.code.Type): javac.util.JCDiagnostic$Warning;
              InvalidArchiveFile(arg0: java.nio.file.Path): javac.util.JCDiagnostic$Warning;
              InvalidPath(arg0: string): javac.util.JCDiagnostic$Warning;
              InvalidUtf8InClassfile(arg0: java.io.File, arg1: javac.util.JCDiagnostic$Fragment): javac.util.JCDiagnostic$Warning;
              InvalidUtf8InClassfile(arg0: javax.tools.JavaFileObject, arg1: javac.util.JCDiagnostic$Fragment): javac.util.JCDiagnostic$Warning;
              InvalidUtf8InClassfile(arg0: java.nio.file.Path, arg1: javac.util.JCDiagnostic$Fragment): javac.util.JCDiagnostic$Warning;
              IsPreview(arg0: javac.code.Symbol): javac.util.JCDiagnostic$Warning;
              IsPreviewReflective(arg0: javac.code.Symbol): javac.util.JCDiagnostic$Warning;
              LeaksNotAccessible(arg0: javac.code.Kinds$KindName, arg1: javac.code.Symbol, arg2: javac.code.Symbol): javac.util.JCDiagnostic$Warning;
              LeaksNotAccessibleNotRequiredTransitive(arg0: javac.code.Kinds$KindName, arg1: javac.code.Symbol, arg2: javac.code.Symbol): javac.util.JCDiagnostic$Warning;
              LeaksNotAccessibleUnexported(arg0: javac.code.Kinds$KindName, arg1: javac.code.Symbol, arg2: javac.code.Symbol): javac.util.JCDiagnostic$Warning;
              LeaksNotAccessibleUnexportedQualified(arg0: javac.code.Kinds$KindName, arg1: javac.code.Symbol, arg2: javac.code.Symbol): javac.util.JCDiagnostic$Warning;
              LintOption(arg0: javac.main.Option): javac.util.JCDiagnostic$Warning;
              LocnUnknownFileOnModulePath(arg0: java.nio.file.Path): javac.util.JCDiagnostic$Warning;
              LongSVUID(arg0: javac.code.Symbol): javac.util.JCDiagnostic$Warning;
              MissingExplicitCtor(arg0: javac.code.Symbol, arg1: javac.code.Symbol, arg2: javac.code.Symbol): javac.util.JCDiagnostic$Warning;
              MissingSVUID(arg0: javac.code.Symbol): javac.util.JCDiagnostic$Warning;
              ModuleForOptionNotFound(arg0: javac.main.Option, arg1: javac.code.Symbol): javac.util.JCDiagnostic$Warning;
              ModuleNotFound(arg0: javac.code.Symbol): javac.util.JCDiagnostic$Warning;
              NonSerializableInstanceFieldArray(arg0: javac.code.Type): javac.util.JCDiagnostic$Warning;
              OptionObsoleteSource(arg0: string): javac.util.JCDiagnostic$Warning;
              OptionObsoleteTarget(arg0: javac.jvm.Target): javac.util.JCDiagnostic$Warning;
              OutdirIsInExplodedModule(arg0: java.nio.file.Path): javac.util.JCDiagnostic$Warning;
              OutputFileClash(arg0: java.nio.file.Path): javac.util.JCDiagnostic$Warning;
              OverrideBridge(arg0: javac.util.JCDiagnostic): javac.util.JCDiagnostic$Warning;
              OverrideBridge(arg0: javac.util.JCDiagnostic$Fragment): javac.util.JCDiagnostic$Warning;
              OverrideEqualsButNotHashcode(arg0: javac.code.Symbol): javac.util.JCDiagnostic$Warning;
              OverrideUncheckedRet(arg0: javac.util.JCDiagnostic, arg1: javac.code.Type, arg2: javac.code.Type): javac.util.JCDiagnostic$Warning;
              OverrideUncheckedRet(arg0: javac.util.JCDiagnostic$Fragment, arg1: javac.code.Type, arg2: javac.code.Type): javac.util.JCDiagnostic$Warning;
              OverrideUncheckedThrown(arg0: javac.util.JCDiagnostic, arg1: javac.code.Type): javac.util.JCDiagnostic$Warning;
              OverrideUncheckedThrown(arg0: javac.util.JCDiagnostic$Fragment, arg1: javac.code.Type): javac.util.JCDiagnostic$Warning;
              OverrideVarargsExtra(arg0: javac.util.JCDiagnostic): javac.util.JCDiagnostic$Warning;
              OverrideVarargsExtra(arg0: javac.util.JCDiagnostic$Fragment): javac.util.JCDiagnostic$Warning;
              OverrideVarargsMissing(arg0: javac.util.JCDiagnostic): javac.util.JCDiagnostic$Warning;
              OverrideVarargsMissing(arg0: javac.util.JCDiagnostic$Fragment): javac.util.JCDiagnostic$Warning;
              PackageEmptyOrNotFound(arg0: javac.code.Symbol): javac.util.JCDiagnostic$Warning;
              PathElementNotFound(arg0: java.nio.file.Path): javac.util.JCDiagnostic$Warning;
              PkgInfoAlreadySeen(arg0: javac.code.Symbol): javac.util.JCDiagnostic$Warning;
              PoorChoiceForModuleName(arg0: javac.util.Name): javac.util.JCDiagnostic$Warning;
              PositionOverflow(arg0: int): javac.util.JCDiagnostic$Warning;
              PossibleLossOfPrecision(arg0: javac.code.Type, arg1: javac.code.Type): javac.util.JCDiagnostic$Warning;
              PotentiallyAmbiguousOverload(arg0: javac.code.Symbol, arg1: javac.code.Symbol, arg2: javac.code.Symbol, arg3: javac.code.Symbol): javac.util.JCDiagnostic$Warning;
              PreviewFeatureUse(arg0: javac.util.JCDiagnostic): javac.util.JCDiagnostic$Warning;
              PreviewFeatureUse(arg0: javac.util.JCDiagnostic$Fragment): javac.util.JCDiagnostic$Warning;
              PreviewFeatureUseClassfile(arg0: javax.tools.JavaFileObject, arg1: string): javac.util.JCDiagnostic$Warning;
              PreviewFeatureUsePlural(arg0: javac.util.JCDiagnostic): javac.util.JCDiagnostic$Warning;
              PreviewFeatureUsePlural(arg0: javac.util.JCDiagnostic$Fragment): javac.util.JCDiagnostic$Warning;
              ProbFoundReq(arg0: javac.util.JCDiagnostic, arg1: javac.code.Type, arg2: javac.code.Type): javac.util.JCDiagnostic$Warning;
              ProbFoundReq(arg0: javac.util.JCDiagnostic$Fragment, arg1: javac.code.Type, arg2: javac.code.Type): javac.util.JCDiagnostic$Warning;
              ProcAnnotationsWithoutProcessors(arg0: java.util.Set<string>): javac.util.JCDiagnostic$Warning;
              ProcDuplicateOptionName(arg0: string, arg1: string): javac.util.JCDiagnostic$Warning;
              ProcDuplicateSupportedAnnotation(arg0: string, arg1: string): javac.util.JCDiagnostic$Warning;
              ProcFileCreateLastRound(arg0: string): javac.util.JCDiagnostic$Warning;
              ProcFileReopening(arg0: string): javac.util.JCDiagnostic$Warning;
              ProcIllegalFileName(arg0: string): javac.util.JCDiagnostic$Warning;
              ProcMalformedSupportedString(arg0: string, arg1: string): javac.util.JCDiagnostic$Warning;
              ProcMessager(arg0: string): javac.util.JCDiagnostic$Warning;
              ProcPackageDoesNotExist(arg0: string): javac.util.JCDiagnostic$Warning;
              ProcProcessorIncompatibleSourceVersion(arg0: javax.lang.model.SourceVersion, arg1: string, arg2: string): javac.util.JCDiagnostic$Warning;
              ProcRedundantTypesWithWildcard(arg0: string): javac.util.JCDiagnostic$Warning;
              ProcSuspiciousClassName(arg0: string, arg1: string): javac.util.JCDiagnostic$Warning;
              ProcTypeAlreadyExists(arg0: string): javac.util.JCDiagnostic$Warning;
              ProcTypeRecreate(arg0: string): javac.util.JCDiagnostic$Warning;
              ProcUnclosedTypeFiles(arg0: java.util.Set<string>): javac.util.JCDiagnostic$Warning;
              ProcUnmatchedProcessorOptions(arg0: string): javac.util.JCDiagnostic$Warning;
              ProfileTargetConflict(arg0: javac.jvm.Profile, arg1: javac.jvm.Target): javac.util.JCDiagnostic$Warning;
              RawClassUse(arg0: javac.code.Type, arg1: javac.code.Type): javac.util.JCDiagnostic$Warning;
              RedundantCast(arg0: javac.code.Type): javac.util.JCDiagnostic$Warning;
              RestrictedTypeNotAllowed(arg0: javac.util.Name, arg1: javac.code.Source): javac.util.JCDiagnostic$Warning;
              RestrictedTypeNotAllowedPreview(arg0: javac.util.Name, arg1: javac.code.Source): javac.util.JCDiagnostic$Warning;
              SelfRef(arg0: javac.code.Symbol): javac.util.JCDiagnostic$Warning;
              SerialConcreteInstanceMethod(arg0: javac.util.Name): javac.util.JCDiagnostic$Warning;
              SerialMethodNoArgs(arg0: javac.util.Name): javac.util.JCDiagnostic$Warning;
              SerialMethodNotPrivate(arg0: javac.util.Name): javac.util.JCDiagnostic$Warning;
              SerialMethodOneArg(arg0: javac.util.Name, arg1: int): javac.util.JCDiagnostic$Warning;
              SerialMethodParameterType(arg0: javac.util.Name, arg1: javac.code.Type, arg2: javac.code.Type): javac.util.JCDiagnostic$Warning;
              SerialMethodStatic(arg0: javac.util.Name): javac.util.JCDiagnostic$Warning;
              SerialMethodUnexpectedException(arg0: javac.util.Name, arg1: javac.code.Type): javac.util.JCDiagnostic$Warning;
              SerialMethodUnexpectedReturnType(arg0: javac.util.Name, arg1: javac.code.Type, arg2: javac.code.Type): javac.util.JCDiagnostic$Warning;
              SerializableMissingAccessNoArgCtor(arg0: javac.util.Name): javac.util.JCDiagnostic$Warning;
              ServiceProvidedButNotExportedOrUsed(arg0: javac.code.Symbol): javac.util.JCDiagnostic$Warning;
              SourceNoBootclasspath(arg0: string): javac.util.JCDiagnostic$Warning;
              SourceNoSystemModulesPath(arg0: string): javac.util.JCDiagnostic$Warning;
              SourceTargetConflict(arg0: string, arg1: javac.jvm.Target): javac.util.JCDiagnostic$Warning;
              StaticNotQualifiedByType(arg0: javac.code.Kinds$KindName, arg1: javac.code.Symbol): javac.util.JCDiagnostic$Warning;
              StaticNotQualifiedByType2(arg0: javac.code.Kinds$KindName): javac.util.JCDiagnostic$Warning;
              SunProprietary(arg0: javac.code.Symbol): javac.util.JCDiagnostic$Warning;
              TargetDefaultSourceConflict(arg0: string, arg1: javac.jvm.Target): javac.util.JCDiagnostic$Warning;
              TryResourceNotReferenced(arg0: javac.code.Symbol): javac.util.JCDiagnostic$Warning;
              TryResourceThrowsInterruptedExc(arg0: javac.code.Type): javac.util.JCDiagnostic$Warning;
              UncheckedAssignToVar(arg0: javac.code.Symbol, arg1: javac.code.Type): javac.util.JCDiagnostic$Warning;
              UncheckedCallMbrOfRawType(arg0: javac.code.Symbol, arg1: javac.code.Type): javac.util.JCDiagnostic$Warning;
              UncheckedGenericArrayCreation(arg0: javac.code.Type): javac.util.JCDiagnostic$Warning;
              UncheckedMethInvocationApplied(arg0: javac.code.Kinds$KindName, arg1: javac.util.Name, arg2: any, arg3: any, arg4: javac.code.Kinds$KindName, arg5: javac.code.Symbol): javac.util.JCDiagnostic$Warning;
              UncheckedVarargsNonReifiableType(arg0: javac.code.Type): javac.util.JCDiagnostic$Warning;
              UnexpectedArchiveFile(arg0: java.nio.file.Path): javac.util.JCDiagnostic$Warning;
              UnknownEnumConstant(arg0: javax.tools.JavaFileObject, arg1: javac.code.Symbol, arg2: javac.util.Name): javac.util.JCDiagnostic$Warning;
              UnknownEnumConstantReason(arg0: javax.tools.JavaFileObject, arg1: javac.code.Symbol, arg2: javac.util.Name, arg3: javac.util.JCDiagnostic): javac.util.JCDiagnostic$Warning;
              UnknownEnumConstantReason(arg0: javax.tools.JavaFileObject, arg1: javac.code.Symbol, arg2: javac.util.Name, arg3: javac.util.JCDiagnostic$Fragment): javac.util.JCDiagnostic$Warning;
              UnreachableCatch(arg0: java.util.List<javac.code.Type>): javac.util.JCDiagnostic$Warning;
              UnreachableCatch1(arg0: java.util.List<javac.code.Type>): javac.util.JCDiagnostic$Warning;
              VarargsRedundantTrustmeAnno(arg0: javac.code.Symbol, arg1: javac.util.JCDiagnostic): javac.util.JCDiagnostic$Warning;
              VarargsRedundantTrustmeAnno(arg0: javac.code.Symbol, arg1: javac.util.JCDiagnostic$Fragment): javac.util.JCDiagnostic$Warning;
              VarargsUnsafeUseVarargsParam(arg0: javac.code.Symbol): javac.util.JCDiagnostic$Warning;
              readonly AddopensIgnored: javac.util.JCDiagnostic$Warning;
              readonly AttemptToSynchronizeOnInstanceOfValueBasedClass: javac.util.JCDiagnostic$Warning;
              readonly DefaultIneffective: javac.util.JCDiagnostic$Warning;
              readonly DiamondRedundantArgs: javac.util.JCDiagnostic$Warning;
              readonly DivZero: javac.util.JCDiagnostic$Warning;
              readonly DoclintNotAvailable: javac.util.JCDiagnostic$Warning;
              readonly EmptyIf: javac.util.JCDiagnostic$Warning;
              readonly ExternalizableMissingPublicNoArgCtor: javac.util.JCDiagnostic$Warning;
              readonly ExtraneousSemicolon: javac.util.JCDiagnostic$Warning;
              readonly FinallyCannotComplete: javac.util.JCDiagnostic$Warning;
              readonly IllegalCharForEncoding: javac.util.JCDiagnostic$Warning;
              readonly ImproperSPF: javac.util.JCDiagnostic$Warning;
              readonly InconsistentWhiteSpaceIndentation: javac.util.JCDiagnostic$Warning;
              readonly IneffectualSerialFieldExternalizable: javac.util.JCDiagnostic$Warning;
              readonly IneffectualSerialFieldInterface: javac.util.JCDiagnostic$Warning;
              readonly IneffectualSerialFieldRecord: javac.util.JCDiagnostic$Warning;
              readonly InvalidYield: javac.util.JCDiagnostic$Warning;
              readonly LocalRedundantType: javac.util.JCDiagnostic$Warning;
              readonly MethodRedundantTypeargs: javac.util.JCDiagnostic$Warning;
              readonly MissingDeprecatedAnnotation: javac.util.JCDiagnostic$Warning;
              readonly NonPrivateMethodWeakerAccess: javac.util.JCDiagnostic$Warning;
              readonly NonSerializableInstanceField: javac.util.JCDiagnostic$Warning;
              readonly OSFArraySPF: javac.util.JCDiagnostic$Warning;
              readonly OptionObsoleteSuppression: javac.util.JCDiagnostic$Warning;
              readonly PossibleFallThroughIntoCase: javac.util.JCDiagnostic$Warning;
              readonly PossibleThisEscape: javac.util.JCDiagnostic$Warning;
              readonly PossibleThisEscapeLocation: javac.util.JCDiagnostic$Warning;
              readonly PotentialLambdaFound: javac.util.JCDiagnostic$Warning;
              readonly ProcProcOnlyRequestedNoProcs: javac.util.JCDiagnostic$Warning;
              readonly ProcUseImplicit: javac.util.JCDiagnostic$Warning;
              readonly ProcUseProcOrImplicit: javac.util.JCDiagnostic$Warning;
              readonly RequiresAutomatic: javac.util.JCDiagnostic$Warning;
              readonly RequiresTransitiveAutomatic: javac.util.JCDiagnostic$Warning;
              readonly SPFNullInit: javac.util.JCDiagnostic$Warning;
              readonly Strictfp: javac.util.JCDiagnostic$Warning;
              readonly TrailingWhiteSpaceWillBeRemoved: javac.util.JCDiagnostic$Warning;
              readonly TryExplicitCloseCall: javac.util.JCDiagnostic$Warning;
              readonly UncheckedAssign: javac.util.JCDiagnostic$Warning;
              readonly UncheckedCastToType: javac.util.JCDiagnostic$Warning;
              readonly UnderscoreAsIdentifier: javac.util.JCDiagnostic$Warning;
              readonly Warning: javac.util.JCDiagnostic$Warning;
              new(): CompilerProperties$Warnings;
            }
            let CompilerProperties$Warnings: _CompilerProperties$Warnings$$static;
            interface _CompilerProperties$Warnings {
            }
            interface CompilerProperties$Warnings extends CombineTypes<[_CompilerProperties$Warnings, java.lang.Object]> {}
            interface _LauncherProperties$$static extends ClassLike {
              new(): LauncherProperties;
            }
            let LauncherProperties: _LauncherProperties$$static;
            interface _LauncherProperties {
            }
            interface LauncherProperties extends CombineTypes<[_LauncherProperties, java.lang.Object]> {}
            interface _LauncherProperties$Errors$$static extends ClassLike {
              CantAccessConstructor(arg0: string): javac.util.JCDiagnostic$Error;
              CantAccessMainMethod(arg0: string): javac.util.JCDiagnostic$Error;
              CantFindClass(arg0: string): javac.util.JCDiagnostic$Error;
              CantFindConstructor(arg0: string): javac.util.JCDiagnostic$Error;
              CantFindMainMethod(arg0: string): javac.util.JCDiagnostic$Error;
              CantReadFile(arg0: java.nio.file.Path, arg1: any): javac.util.JCDiagnostic$Error;
              FileNotFound(arg0: java.nio.file.Path): javac.util.JCDiagnostic$Error;
              InvalidFilename(arg0: string): javac.util.JCDiagnostic$Error;
              InvalidValueForSource(arg0: string): javac.util.JCDiagnostic$Error;
              NoValueForOption(arg0: string): javac.util.JCDiagnostic$Error;
              readonly CompilationFailed: javac.util.JCDiagnostic$Error;
              readonly EnablePreviewRequiresSource: javac.util.JCDiagnostic$Error;
              readonly MainNotPublicStatic: javac.util.JCDiagnostic$Error;
              readonly MainNotVoid: javac.util.JCDiagnostic$Error;
              readonly NoArgs: javac.util.JCDiagnostic$Error;
              readonly NoClass: javac.util.JCDiagnostic$Error;
              readonly SecurityManager: javac.util.JCDiagnostic$Error;
              new(): LauncherProperties$Errors;
            }
            let LauncherProperties$Errors: _LauncherProperties$Errors$$static;
            interface _LauncherProperties$Errors {
            }
            interface LauncherProperties$Errors extends CombineTypes<[_LauncherProperties$Errors, java.lang.Object]> {}
            interface _compiler$$static extends ClassLike {
              new(): compiler;
            }
            let compiler: _compiler$$static;
            interface _compiler {
              _getContents(): any[][];
            }
            interface compiler extends CombineTypes<[_compiler, java.util.ListResourceBundle]> {}
            interface _compiler_de$$static extends ClassLike {
              new(): compiler_de;
            }
            let compiler_de: _compiler_de$$static;
            interface _compiler_de {
              _getContents(): any[][];
            }
            interface compiler_de extends CombineTypes<[_compiler_de, java.util.ListResourceBundle]> {}
            interface _compiler_ja$$static extends ClassLike {
              new(): compiler_ja;
            }
            let compiler_ja: _compiler_ja$$static;
            interface _compiler_ja {
              _getContents(): any[][];
            }
            interface compiler_ja extends CombineTypes<[_compiler_ja, java.util.ListResourceBundle]> {}
            interface _compiler_zh_CN$$static extends ClassLike {
              new(): compiler_zh_CN;
            }
            let compiler_zh_CN: _compiler_zh_CN$$static;
            interface _compiler_zh_CN {
              _getContents(): any[][];
            }
            interface compiler_zh_CN extends CombineTypes<[_compiler_zh_CN, java.util.ListResourceBundle]> {}
            interface _ct$$static extends ClassLike {
              new(): ct;
            }
            let ct: _ct$$static;
            interface _ct {
              _getContents(): any[][];
            }
            interface ct extends CombineTypes<[_ct, java.util.ListResourceBundle]> {}
            interface _javac$$static extends ClassLike {
              new(): javac;
            }
            let javac: _javac$$static;
            interface _javac {
              _getContents(): any[][];
            }
            interface javac extends CombineTypes<[_javac, java.util.ListResourceBundle]> {}
            interface _javac_de$$static extends ClassLike {
              new(): javac_de;
            }
            let javac_de: _javac_de$$static;
            interface _javac_de {
              _getContents(): any[][];
            }
            interface javac_de extends CombineTypes<[_javac_de, java.util.ListResourceBundle]> {}
            interface _javac_ja$$static extends ClassLike {
              new(): javac_ja;
            }
            let javac_ja: _javac_ja$$static;
            interface _javac_ja {
              _getContents(): any[][];
            }
            interface javac_ja extends CombineTypes<[_javac_ja, java.util.ListResourceBundle]> {}
            interface _javac_zh_CN$$static extends ClassLike {
              new(): javac_zh_CN;
            }
            let javac_zh_CN: _javac_zh_CN$$static;
            interface _javac_zh_CN {
              _getContents(): any[][];
            }
            interface javac_zh_CN extends CombineTypes<[_javac_zh_CN, java.util.ListResourceBundle]> {}
            interface _launcher$$static extends ClassLike {
              new(): launcher;
            }
            let launcher: _launcher$$static;
            interface _launcher {
              _getContents(): any[][];
            }
            interface launcher extends CombineTypes<[_launcher, java.util.ListResourceBundle]> {}
            interface _launcher_de$$static extends ClassLike {
              new(): launcher_de;
            }
            let launcher_de: _launcher_de$$static;
            interface _launcher_de {
              _getContents(): any[][];
            }
            interface launcher_de extends CombineTypes<[_launcher_de, java.util.ListResourceBundle]> {}
            interface _launcher_ja$$static extends ClassLike {
              new(): launcher_ja;
            }
            let launcher_ja: _launcher_ja$$static;
            interface _launcher_ja {
              _getContents(): any[][];
            }
            interface launcher_ja extends CombineTypes<[_launcher_ja, java.util.ListResourceBundle]> {}
            interface _launcher_zh_CN$$static extends ClassLike {
              new(): launcher_zh_CN;
            }
            let launcher_zh_CN: _launcher_zh_CN$$static;
            interface _launcher_zh_CN {
              _getContents(): any[][];
            }
            interface launcher_zh_CN extends CombineTypes<[_launcher_zh_CN, java.util.ListResourceBundle]> {}
            interface _legacy$$static extends ClassLike {
              new(): legacy;
            }
            let legacy: _legacy$$static;
            interface _legacy {
              _getContents(): any[][];
            }
            interface legacy extends CombineTypes<[_legacy, java.util.ListResourceBundle]> {}
            interface _version$$static extends ClassLike {
              new(): version;
            }
            let version: _version$$static;
            interface _version {
              _getContents(): any[][];
            }
            interface version extends CombineTypes<[_version, java.util.ListResourceBundle]> {}
          }
          module tree {
            interface _DCTree$$static extends ClassLike {
              createDiagnosticPosition(comment: javac.parser.Tokens$Comment, start: int, pref: int, end: int): javac.util.JCDiagnostic$DiagnosticPosition;
              isBlank(list: java.util.List<DCTree>): boolean;
              new(): DCTree;
            }
            let DCTree: _DCTree$$static;
            interface _DCTree {
              getEndPosition(): int;
              _getLastChild(): DCTree;
              getPreferredPosition(): int;
              getStartPosition(): int;
              isBlank(): boolean;
              pos(dc: DCTree$DCDocComment): javac.util.JCDiagnostic$DiagnosticPosition;
              toString(): string;
              pos: int;
            }
            interface DCTree extends CombineTypes<[_DCTree, com.sun.source.doctree.DocTree, java.lang.Object]> {}
            interface _DCTree$DCAttribute$$static extends ClassLike {
              _new(name: javax.lang.model.element.Name, vkind: sun.source.doctree.AttributeTree$ValueKind, value: java.util.List<DCTree>): DCTree$DCAttribute;
            }
            let DCTree$DCAttribute: _DCTree$DCAttribute$$static;
            interface _DCTree$DCAttribute {
              accept<R, D>(v: sun.source.doctree.DocTreeVisitor<R,D>, d: D): R;
              getKind(): sun.source.doctree.DocTree$Kind;
              getName(): javax.lang.model.element.Name;
              getValue(): java.util.List<DCTree>;
              getValueKind(): sun.source.doctree.AttributeTree$ValueKind;
              readonly name: javax.lang.model.element.Name;
              readonly value: java.util.List<DCTree>;
              readonly vkind: sun.source.doctree.AttributeTree$ValueKind;
            }
            interface DCTree$DCAttribute extends CombineTypes<[_DCTree$DCAttribute, com.sun.tools.javac.tree.DCTree, com.sun.source.doctree.AttributeTree]> {}
            interface _DCTree$DCAuthor$$static extends ClassLike {
              _new(name: java.util.List<DCTree>): DCTree$DCAuthor;
            }
            let DCTree$DCAuthor: _DCTree$DCAuthor$$static;
            interface _DCTree$DCAuthor {
              accept<R, D>(v: sun.source.doctree.DocTreeVisitor<R,D>, d: D): R;
              getKind(): sun.source.doctree.DocTree$Kind;
              getName(): java.util.List<sun.source.doctree.DocTree>;
              readonly name: java.util.List<DCTree>;
            }
            interface DCTree$DCAuthor extends CombineTypes<[_DCTree$DCAuthor, com.sun.tools.javac.tree.DCTree$DCBlockTag, com.sun.source.doctree.AuthorTree]> {}
            interface _DCTree$DCBlockTag$$static extends ClassLike {
              new(): DCTree$DCBlockTag;
            }
            let DCTree$DCBlockTag: _DCTree$DCBlockTag$$static;
            interface _DCTree$DCBlockTag {
              getTagName(): string;
            }
            interface DCTree$DCBlockTag extends CombineTypes<[_DCTree$DCBlockTag, com.sun.tools.javac.tree.DCTree, com.sun.source.doctree.BlockTagTree]> {}
            interface _DCTree$DCComment$$static extends ClassLike {
              _new(body: string): DCTree$DCComment;
            }
            let DCTree$DCComment: _DCTree$DCComment$$static;
            interface _DCTree$DCComment {
              accept<R, D>(v: sun.source.doctree.DocTreeVisitor<R,D>, d: D): R;
              getBody(): string;
              getKind(): sun.source.doctree.DocTree$Kind;
              readonly body: string;
            }
            interface DCTree$DCComment extends CombineTypes<[_DCTree$DCComment, com.sun.source.doctree.CommentTree, com.sun.tools.javac.tree.DCTree]> {}
            interface _DCTree$DCDeprecated$$static extends ClassLike {
              _new(body: java.util.List<DCTree>): DCTree$DCDeprecated;
            }
            let DCTree$DCDeprecated: _DCTree$DCDeprecated$$static;
            interface _DCTree$DCDeprecated {
              accept<R, D>(v: sun.source.doctree.DocTreeVisitor<R,D>, d: D): R;
              getBody(): java.util.List<sun.source.doctree.DocTree>;
              getKind(): sun.source.doctree.DocTree$Kind;
              readonly body: java.util.List<DCTree>;
            }
            interface DCTree$DCDeprecated extends CombineTypes<[_DCTree$DCDeprecated, com.sun.tools.javac.tree.DCTree$DCBlockTag, com.sun.source.doctree.DeprecatedTree]> {}
            interface _DCTree$DCDocComment$$static extends ClassLike {
              new(comment: javac.parser.Tokens$Comment, fullBody: java.util.List<DCTree>, firstSentence: java.util.List<DCTree>, body: java.util.List<DCTree>, tags: java.util.List<DCTree>, preamble: java.util.List<DCTree>, postamble: java.util.List<DCTree>): DCTree$DCDocComment;
            }
            let DCTree$DCDocComment: _DCTree$DCDocComment$$static;
            interface _DCTree$DCDocComment {
              accept<R, D>(v: sun.source.doctree.DocTreeVisitor<R,D>, d: D): R;
              getBlockTags(): java.util.List<sun.source.doctree.DocTree>;
              getBody(): java.util.List<sun.source.doctree.DocTree>;
              getFirstSentence(): java.util.List<sun.source.doctree.DocTree>;
              getFullBody(): java.util.List<sun.source.doctree.DocTree>;
              getKind(): sun.source.doctree.DocTree$Kind;
              getPostamble(): java.util.List<sun.source.doctree.DocTree>;
              getPreamble(): java.util.List<sun.source.doctree.DocTree>;
              getSourcePosition(index: int): int;
              readonly body: java.util.List<DCTree>;
              readonly comment: javac.parser.Tokens$Comment;
              readonly firstSentence: java.util.List<DCTree>;
              readonly fullBody: java.util.List<DCTree>;
              readonly postamble: java.util.List<DCTree>;
              readonly preamble: java.util.List<DCTree>;
              readonly tags: java.util.List<DCTree>;
            }
            interface DCTree$DCDocComment extends CombineTypes<[_DCTree$DCDocComment, com.sun.source.doctree.DocCommentTree, com.sun.tools.javac.tree.DCTree]> {}
            interface _DCTree$DCDocRoot$$static extends ClassLike {
              new(): DCTree$DCDocRoot;
            }
            let DCTree$DCDocRoot: _DCTree$DCDocRoot$$static;
            interface _DCTree$DCDocRoot {
              accept<R, D>(v: sun.source.doctree.DocTreeVisitor<R,D>, d: D): R;
              getKind(): sun.source.doctree.DocTree$Kind;
            }
            interface DCTree$DCDocRoot extends CombineTypes<[_DCTree$DCDocRoot, sun.source.doctree.DocRootTree, DCTree$DCInlineTag<DCTree$DCDocRoot>]> {}
            interface _DCTree$DCDocType$$static extends ClassLike {
              _new(text: string): DCTree$DCDocType;
            }
            let DCTree$DCDocType: _DCTree$DCDocType$$static;
            interface _DCTree$DCDocType {
              accept<R, D>(v: sun.source.doctree.DocTreeVisitor<R,D>, d: D): R;
              getKind(): sun.source.doctree.DocTree$Kind;
              getText(): string;
              readonly text: string;
            }
            interface DCTree$DCDocType extends CombineTypes<[_DCTree$DCDocType, com.sun.source.doctree.DocTypeTree, com.sun.tools.javac.tree.DCTree]> {}
            interface _DCTree$DCEndElement$$static extends ClassLike {
              _new(name: javax.lang.model.element.Name): DCTree$DCEndElement;
            }
            let DCTree$DCEndElement: _DCTree$DCEndElement$$static;
            interface _DCTree$DCEndElement {
              accept<R, D>(v: sun.source.doctree.DocTreeVisitor<R,D>, d: D): R;
              getKind(): sun.source.doctree.DocTree$Kind;
              getName(): javax.lang.model.element.Name;
              readonly name: javax.lang.model.element.Name;
            }
            interface DCTree$DCEndElement extends CombineTypes<[_DCTree$DCEndElement, sun.source.doctree.EndElementTree, DCTree$DCEndPosTree<DCTree$DCEndElement>]> {}
            interface _DCTree$DCEndPosTree$$static<T> extends ClassLike {
              new(): DCTree$DCEndPosTree<T>;
            }
            let DCTree$DCEndPosTree: _DCTree$DCEndPosTree$$static<T>;
            interface _DCTree$DCEndPosTree<T> {
              getEndPos(): int;
              setEndPos(endPos: int): T;
              _endPos: int;
            }
            interface DCTree$DCEndPosTree<T> extends CombineTypes<[_DCTree$DCEndPosTree<T>, DCTree]> {}
            interface _DCTree$DCEntity$$static extends ClassLike {
              _new(name: javax.lang.model.element.Name): DCTree$DCEntity;
            }
            let DCTree$DCEntity: _DCTree$DCEntity$$static;
            interface _DCTree$DCEntity {
              accept<R, D>(v: sun.source.doctree.DocTreeVisitor<R,D>, d: D): R;
              getKind(): sun.source.doctree.DocTree$Kind;
              getName(): javax.lang.model.element.Name;
              readonly name: javax.lang.model.element.Name;
            }
            interface DCTree$DCEntity extends CombineTypes<[_DCTree$DCEntity, com.sun.source.doctree.EntityTree, com.sun.tools.javac.tree.DCTree]> {}
            interface _DCTree$DCErroneous$$static extends ClassLike {
              _new(body: string, diag: javac.util.JCDiagnostic): DCTree$DCErroneous;
            }
            let DCTree$DCErroneous: _DCTree$DCErroneous$$static;
            interface _DCTree$DCErroneous {
              accept<R, D>(v: sun.source.doctree.DocTreeVisitor<R,D>, d: D): R;
              getBody(): string;
              getDiagnostic(): javax.tools.Diagnostic<javax.tools.JavaFileObject>;
              getEndPosition(): int;
              getKind(): sun.source.doctree.DocTree$Kind;
              getPreferredPosition(): int;
              getStartPosition(): int;
              setPrefPos(prefPos: int): DCTree$DCErroneous;
              readonly body: string;
              readonly diag: javac.util.JCDiagnostic;
              _prefPos: int;
            }
            interface DCTree$DCErroneous extends CombineTypes<[_DCTree$DCErroneous, com.sun.tools.javac.tree.DCTree, com.sun.source.doctree.ErroneousTree]> {}
            interface _DCTree$DCEscape$$static extends ClassLike {
              _new(ch: char): DCTree$DCEscape;
            }
            let DCTree$DCEscape: _DCTree$DCEscape$$static;
            interface _DCTree$DCEscape {
              accept<R, D>(v: sun.source.doctree.DocTreeVisitor<R,D>, d: D): R;
              getBody(): string;
              getKind(): sun.source.doctree.DocTree$Kind;
              readonly ch: char;
            }
            interface DCTree$DCEscape extends CombineTypes<[_DCTree$DCEscape, com.sun.source.doctree.EscapeTree, com.sun.tools.javac.tree.DCTree]> {}
            interface _DCTree$DCHidden$$static extends ClassLike {
              _new(body: java.util.List<DCTree>): DCTree$DCHidden;
            }
            let DCTree$DCHidden: _DCTree$DCHidden$$static;
            interface _DCTree$DCHidden {
              accept<R, D>(v: sun.source.doctree.DocTreeVisitor<R,D>, d: D): R;
              getBody(): java.util.List<sun.source.doctree.DocTree>;
              getKind(): sun.source.doctree.DocTree$Kind;
              readonly body: java.util.List<DCTree>;
            }
            interface DCTree$DCHidden extends CombineTypes<[_DCTree$DCHidden, com.sun.tools.javac.tree.DCTree$DCBlockTag, com.sun.source.doctree.HiddenTree]> {}
            interface _DCTree$DCIdentifier$$static extends ClassLike {
              _new(name: javax.lang.model.element.Name): DCTree$DCIdentifier;
            }
            let DCTree$DCIdentifier: _DCTree$DCIdentifier$$static;
            interface _DCTree$DCIdentifier {
              accept<R, D>(v: sun.source.doctree.DocTreeVisitor<R,D>, d: D): R;
              getKind(): sun.source.doctree.DocTree$Kind;
              getName(): javax.lang.model.element.Name;
              readonly name: javax.lang.model.element.Name;
            }
            interface DCTree$DCIdentifier extends CombineTypes<[_DCTree$DCIdentifier, com.sun.tools.javac.tree.DCTree, com.sun.source.doctree.IdentifierTree]> {}
            interface _DCTree$DCIndex$$static extends ClassLike {
              _new(term: DCTree, description: java.util.List<DCTree>): DCTree$DCIndex;
            }
            let DCTree$DCIndex: _DCTree$DCIndex$$static;
            interface _DCTree$DCIndex {
              accept<R, D>(v: sun.source.doctree.DocTreeVisitor<R,D>, d: D): R;
              getDescription(): java.util.List<sun.source.doctree.DocTree>;
              getKind(): sun.source.doctree.DocTree$Kind;
              getSearchTerm(): sun.source.doctree.DocTree;
              readonly description: java.util.List<DCTree>;
              readonly term: DCTree;
            }
            interface DCTree$DCIndex extends CombineTypes<[_DCTree$DCIndex, sun.source.doctree.IndexTree, DCTree$DCInlineTag<DCTree$DCIndex>]> {}
            interface _DCTree$DCInheritDoc$$static extends ClassLike {
              new(): DCTree$DCInheritDoc;
            }
            let DCTree$DCInheritDoc: _DCTree$DCInheritDoc$$static;
            interface _DCTree$DCInheritDoc {
              accept<R, D>(v: sun.source.doctree.DocTreeVisitor<R,D>, d: D): R;
              getKind(): sun.source.doctree.DocTree$Kind;
            }
            interface DCTree$DCInheritDoc extends CombineTypes<[_DCTree$DCInheritDoc, sun.source.doctree.InheritDocTree, DCTree$DCInlineTag<DCTree$DCInheritDoc>]> {}
            interface _DCTree$DCInlineTag$$static<T> extends ClassLike {
              new(): DCTree$DCInlineTag<T>;
            }
            let DCTree$DCInlineTag: _DCTree$DCInlineTag$$static<T>;
            interface _DCTree$DCInlineTag<T> {
              getTagName(): string;
            }
            interface DCTree$DCInlineTag<T> extends CombineTypes<[_DCTree$DCInlineTag<T>, DCTree$DCEndPosTree<T>, sun.source.doctree.InlineTagTree]> {}
            interface _DCTree$DCLink$$static extends ClassLike {
              _new(kind: sun.source.doctree.DocTree$Kind, ref: DCTree$DCReference, label: java.util.List<DCTree>): DCTree$DCLink;
            }
            let DCTree$DCLink: _DCTree$DCLink$$static;
            interface _DCTree$DCLink {
              accept<R, D>(v: sun.source.doctree.DocTreeVisitor<R,D>, d: D): R;
              getKind(): sun.source.doctree.DocTree$Kind;
              getLabel(): java.util.List<sun.source.doctree.DocTree>;
              getReference(): sun.source.doctree.ReferenceTree;
              readonly kind: sun.source.doctree.DocTree$Kind;
              readonly label: java.util.List<DCTree>;
              readonly ref: DCTree$DCReference;
            }
            interface DCTree$DCLink extends CombineTypes<[_DCTree$DCLink, sun.source.doctree.LinkTree, DCTree$DCInlineTag<DCTree$DCLink>]> {}
            interface _DCTree$DCLiteral$$static extends ClassLike {
              _new(kind: sun.source.doctree.DocTree$Kind, body: DCTree$DCText): DCTree$DCLiteral;
            }
            let DCTree$DCLiteral: _DCTree$DCLiteral$$static;
            interface _DCTree$DCLiteral {
              accept<R, D>(v: sun.source.doctree.DocTreeVisitor<R,D>, d: D): R;
              getBody(): DCTree$DCText;
              getBody(): sun.source.doctree.TextTree;
              getKind(): sun.source.doctree.DocTree$Kind;
              readonly body: DCTree$DCText;
              readonly kind: sun.source.doctree.DocTree$Kind;
            }
            interface DCTree$DCLiteral extends CombineTypes<[_DCTree$DCLiteral, DCTree$DCInlineTag<DCTree$DCLiteral>, sun.source.doctree.LiteralTree]> {}
            interface _DCTree$DCParam$$static extends ClassLike {
              _new(isTypeParameter: boolean, name: DCTree$DCIdentifier, description: java.util.List<DCTree>): DCTree$DCParam;
            }
            let DCTree$DCParam: _DCTree$DCParam$$static;
            interface _DCTree$DCParam {
              accept<R, D>(v: sun.source.doctree.DocTreeVisitor<R,D>, d: D): R;
              getDescription(): java.util.List<sun.source.doctree.DocTree>;
              getKind(): sun.source.doctree.DocTree$Kind;
              getName(): sun.source.doctree.IdentifierTree;
              isTypeParameter(): boolean;
              readonly description: java.util.List<DCTree>;
              readonly isTypeParameter: boolean;
              readonly name: DCTree$DCIdentifier;
            }
            interface DCTree$DCParam extends CombineTypes<[_DCTree$DCParam, com.sun.tools.javac.tree.DCTree$DCBlockTag, com.sun.source.doctree.ParamTree]> {}
            interface _DCTree$DCProvides$$static extends ClassLike {
              _new(serviceType: DCTree$DCReference, description: java.util.List<DCTree>): DCTree$DCProvides;
            }
            let DCTree$DCProvides: _DCTree$DCProvides$$static;
            interface _DCTree$DCProvides {
              accept<R, D>(v: sun.source.doctree.DocTreeVisitor<R,D>, d: D): R;
              getDescription(): java.util.List<sun.source.doctree.DocTree>;
              getKind(): sun.source.doctree.DocTree$Kind;
              getServiceType(): sun.source.doctree.ReferenceTree;
              readonly description: java.util.List<DCTree>;
              readonly serviceType: DCTree$DCReference;
            }
            interface DCTree$DCProvides extends CombineTypes<[_DCTree$DCProvides, com.sun.tools.javac.tree.DCTree$DCBlockTag, com.sun.source.doctree.ProvidesTree]> {}
            interface _DCTree$DCReference$$static extends ClassLike {
              _new(signature: string, moduleName: JCTree$JCExpression, qualExpr: JCTree, member: javax.lang.model.element.Name, paramTypes: java.util.List<JCTree>): DCTree$DCReference;
            }
            let DCTree$DCReference: _DCTree$DCReference$$static;
            interface _DCTree$DCReference {
              accept<R, D>(v: sun.source.doctree.DocTreeVisitor<R,D>, d: D): R;
              getKind(): sun.source.doctree.DocTree$Kind;
              getSignature(): string;
              readonly memberName: javax.lang.model.element.Name;
              readonly moduleName: JCTree$JCExpression;
              readonly paramTypes: java.util.List<JCTree>;
              readonly qualifierExpression: JCTree;
              readonly signature: string;
            }
            interface DCTree$DCReference extends CombineTypes<[_DCTree$DCReference, sun.source.doctree.ReferenceTree, DCTree$DCEndPosTree<DCTree$DCReference>]> {}
            interface _DCTree$DCReturn$$static extends ClassLike {
              _new(inline: boolean, description: java.util.List<DCTree>): DCTree$DCReturn;
            }
            let DCTree$DCReturn: _DCTree$DCReturn$$static;
            interface _DCTree$DCReturn {
              accept<R, D>(v: sun.source.doctree.DocTreeVisitor<R,D>, d: D): R;
              getDescription(): java.util.List<sun.source.doctree.DocTree>;
              getKind(): sun.source.doctree.DocTree$Kind;
              getTagName(): string;
              isInline(): boolean;
              readonly description: java.util.List<DCTree>;
              readonly inline: boolean;
            }
            interface DCTree$DCReturn extends CombineTypes<[_DCTree$DCReturn, sun.source.doctree.ReturnTree, DCTree$DCEndPosTree<DCTree$DCReturn>]> {}
            interface _DCTree$DCSee$$static extends ClassLike {
              _new(reference: java.util.List<DCTree>): DCTree$DCSee;
            }
            let DCTree$DCSee: _DCTree$DCSee$$static;
            interface _DCTree$DCSee {
              accept<R, D>(v: sun.source.doctree.DocTreeVisitor<R,D>, d: D): R;
              getKind(): sun.source.doctree.DocTree$Kind;
              getReference(): java.util.List<sun.source.doctree.DocTree>;
              readonly reference: java.util.List<DCTree>;
            }
            interface DCTree$DCSee extends CombineTypes<[_DCTree$DCSee, com.sun.tools.javac.tree.DCTree$DCBlockTag, com.sun.source.doctree.SeeTree]> {}
            interface _DCTree$DCSerial$$static extends ClassLike {
              _new(description: java.util.List<DCTree>): DCTree$DCSerial;
            }
            let DCTree$DCSerial: _DCTree$DCSerial$$static;
            interface _DCTree$DCSerial {
              accept<R, D>(v: sun.source.doctree.DocTreeVisitor<R,D>, d: D): R;
              getDescription(): java.util.List<sun.source.doctree.DocTree>;
              getKind(): sun.source.doctree.DocTree$Kind;
              readonly description: java.util.List<DCTree>;
            }
            interface DCTree$DCSerial extends CombineTypes<[_DCTree$DCSerial, com.sun.tools.javac.tree.DCTree$DCBlockTag, com.sun.source.doctree.SerialTree]> {}
            interface _DCTree$DCSerialData$$static extends ClassLike {
              _new(description: java.util.List<DCTree>): DCTree$DCSerialData;
            }
            let DCTree$DCSerialData: _DCTree$DCSerialData$$static;
            interface _DCTree$DCSerialData {
              accept<R, D>(v: sun.source.doctree.DocTreeVisitor<R,D>, d: D): R;
              getDescription(): java.util.List<sun.source.doctree.DocTree>;
              getKind(): sun.source.doctree.DocTree$Kind;
              readonly description: java.util.List<DCTree>;
            }
            interface DCTree$DCSerialData extends CombineTypes<[_DCTree$DCSerialData, com.sun.tools.javac.tree.DCTree$DCBlockTag, com.sun.source.doctree.SerialDataTree]> {}
            interface _DCTree$DCSerialField$$static extends ClassLike {
              _new(name: DCTree$DCIdentifier, type: DCTree$DCReference, description: java.util.List<DCTree>): DCTree$DCSerialField;
            }
            let DCTree$DCSerialField: _DCTree$DCSerialField$$static;
            interface _DCTree$DCSerialField {
              accept<R, D>(v: sun.source.doctree.DocTreeVisitor<R,D>, d: D): R;
              getDescription(): java.util.List<sun.source.doctree.DocTree>;
              getKind(): sun.source.doctree.DocTree$Kind;
              getName(): sun.source.doctree.IdentifierTree;
              getType(): sun.source.doctree.ReferenceTree;
              readonly description: java.util.List<DCTree>;
              readonly name: DCTree$DCIdentifier;
              readonly type: DCTree$DCReference;
            }
            interface DCTree$DCSerialField extends CombineTypes<[_DCTree$DCSerialField, com.sun.tools.javac.tree.DCTree$DCBlockTag, com.sun.source.doctree.SerialFieldTree]> {}
            interface _DCTree$DCSince$$static extends ClassLike {
              _new(body: java.util.List<DCTree>): DCTree$DCSince;
            }
            let DCTree$DCSince: _DCTree$DCSince$$static;
            interface _DCTree$DCSince {
              accept<R, D>(v: sun.source.doctree.DocTreeVisitor<R,D>, d: D): R;
              getBody(): java.util.List<sun.source.doctree.DocTree>;
              getKind(): sun.source.doctree.DocTree$Kind;
              readonly body: java.util.List<DCTree>;
            }
            interface DCTree$DCSince extends CombineTypes<[_DCTree$DCSince, com.sun.tools.javac.tree.DCTree$DCBlockTag, com.sun.source.doctree.SinceTree]> {}
            interface _DCTree$DCSnippet$$static extends ClassLike {
              new(attributes: java.util.List<DCTree>, body: DCTree$DCText): DCTree$DCSnippet;
            }
            let DCTree$DCSnippet: _DCTree$DCSnippet$$static;
            interface _DCTree$DCSnippet {
              accept<R, D>(v: sun.source.doctree.DocTreeVisitor<R,D>, d: D): R;
              getAttributes(): java.util.List<sun.source.doctree.DocTree>;
              getBody(): sun.source.doctree.TextTree;
              getKind(): sun.source.doctree.DocTree$Kind;
              readonly attributes: java.util.List<sun.source.doctree.DocTree>;
              readonly body: DCTree$DCText;
            }
            interface DCTree$DCSnippet extends CombineTypes<[_DCTree$DCSnippet, DCTree$DCInlineTag<DCTree$DCSnippet>, sun.source.doctree.SnippetTree]> {}
            interface _DCTree$DCSpec$$static extends ClassLike {
              _new(uri: DCTree$DCText, title: java.util.List<DCTree>): DCTree$DCSpec;
            }
            let DCTree$DCSpec: _DCTree$DCSpec$$static;
            interface _DCTree$DCSpec {
              accept<R, D>(v: sun.source.doctree.DocTreeVisitor<R,D>, d: D): R;
              getKind(): sun.source.doctree.DocTree$Kind;
              getTagName(): string;
              getTitle(): java.util.List<sun.source.doctree.DocTree>;
              getURL(): sun.source.doctree.TextTree;
              readonly title: java.util.List<DCTree>;
              readonly uri: DCTree$DCText;
            }
            interface DCTree$DCSpec extends CombineTypes<[_DCTree$DCSpec, com.sun.tools.javac.tree.DCTree$DCBlockTag, com.sun.source.doctree.SpecTree]> {}
            interface _DCTree$DCStartElement$$static extends ClassLike {
              _new(name: javax.lang.model.element.Name, attrs: java.util.List<DCTree>, selfClosing: boolean): DCTree$DCStartElement;
            }
            let DCTree$DCStartElement: _DCTree$DCStartElement$$static;
            interface _DCTree$DCStartElement {
              accept<R, D>(v: sun.source.doctree.DocTreeVisitor<R,D>, d: D): R;
              getAttributes(): java.util.List<sun.source.doctree.DocTree>;
              getKind(): sun.source.doctree.DocTree$Kind;
              getName(): javax.lang.model.element.Name;
              isSelfClosing(): boolean;
              readonly attrs: java.util.List<DCTree>;
              readonly name: javax.lang.model.element.Name;
              readonly selfClosing: boolean;
            }
            interface DCTree$DCStartElement extends CombineTypes<[_DCTree$DCStartElement, DCTree$DCEndPosTree<DCTree$DCStartElement>, sun.source.doctree.StartElementTree]> {}
            interface _DCTree$DCSummary$$static extends ClassLike {
              _new(summary: java.util.List<DCTree>): DCTree$DCSummary;
            }
            let DCTree$DCSummary: _DCTree$DCSummary$$static;
            interface _DCTree$DCSummary {
              accept<R, D>(v: sun.source.doctree.DocTreeVisitor<R,D>, d: D): R;
              getKind(): sun.source.doctree.DocTree$Kind;
              getSummary(): java.util.List<sun.source.doctree.DocTree>;
              readonly summary: java.util.List<DCTree>;
            }
            interface DCTree$DCSummary extends CombineTypes<[_DCTree$DCSummary, DCTree$DCInlineTag<DCTree$DCSummary>, sun.source.doctree.SummaryTree]> {}
            interface _DCTree$DCSystemProperty$$static extends ClassLike {
              _new(propertyName: javax.lang.model.element.Name): DCTree$DCSystemProperty;
            }
            let DCTree$DCSystemProperty: _DCTree$DCSystemProperty$$static;
            interface _DCTree$DCSystemProperty {
              accept<R, D>(v: sun.source.doctree.DocTreeVisitor<R,D>, d: D): R;
              getKind(): sun.source.doctree.DocTree$Kind;
              getPropertyName(): javax.lang.model.element.Name;
              readonly propertyName: javax.lang.model.element.Name;
            }
            interface DCTree$DCSystemProperty extends CombineTypes<[_DCTree$DCSystemProperty, sun.source.doctree.SystemPropertyTree, DCTree$DCInlineTag<DCTree$DCSystemProperty>]> {}
            interface _DCTree$DCText$$static extends ClassLike {
              _new(text: string): DCTree$DCText;
            }
            let DCTree$DCText: _DCTree$DCText$$static;
            interface _DCTree$DCText {
              accept<R, D>(v: sun.source.doctree.DocTreeVisitor<R,D>, d: D): R;
              getBody(): string;
              getKind(): sun.source.doctree.DocTree$Kind;
              isBlank(): boolean;
              readonly text: string;
            }
            interface DCTree$DCText extends CombineTypes<[_DCTree$DCText, com.sun.tools.javac.tree.DCTree, com.sun.source.doctree.TextTree]> {}
            interface _DCTree$DCThrows$$static extends ClassLike {
              _new(kind: sun.source.doctree.DocTree$Kind, name: DCTree$DCReference, description: java.util.List<DCTree>): DCTree$DCThrows;
            }
            let DCTree$DCThrows: _DCTree$DCThrows$$static;
            interface _DCTree$DCThrows {
              accept<R, D>(v: sun.source.doctree.DocTreeVisitor<R,D>, d: D): R;
              getDescription(): java.util.List<sun.source.doctree.DocTree>;
              getExceptionName(): sun.source.doctree.ReferenceTree;
              getKind(): sun.source.doctree.DocTree$Kind;
              readonly description: java.util.List<DCTree>;
              readonly kind: sun.source.doctree.DocTree$Kind;
              readonly name: DCTree$DCReference;
            }
            interface DCTree$DCThrows extends CombineTypes<[_DCTree$DCThrows, com.sun.tools.javac.tree.DCTree$DCBlockTag, com.sun.source.doctree.ThrowsTree]> {}
            interface _DCTree$DCUnknownBlockTag$$static extends ClassLike {
              _new(name: javax.lang.model.element.Name, content: java.util.List<DCTree>): DCTree$DCUnknownBlockTag;
            }
            let DCTree$DCUnknownBlockTag: _DCTree$DCUnknownBlockTag$$static;
            interface _DCTree$DCUnknownBlockTag {
              accept<R, D>(v: sun.source.doctree.DocTreeVisitor<R,D>, d: D): R;
              getContent(): java.util.List<sun.source.doctree.DocTree>;
              getKind(): sun.source.doctree.DocTree$Kind;
              getTagName(): string;
              readonly content: java.util.List<DCTree>;
              readonly name: javax.lang.model.element.Name;
            }
            interface DCTree$DCUnknownBlockTag extends CombineTypes<[_DCTree$DCUnknownBlockTag, com.sun.tools.javac.tree.DCTree$DCBlockTag, com.sun.source.doctree.UnknownBlockTagTree]> {}
            interface _DCTree$DCUnknownInlineTag$$static extends ClassLike {
              _new(name: javax.lang.model.element.Name, content: java.util.List<DCTree>): DCTree$DCUnknownInlineTag;
            }
            let DCTree$DCUnknownInlineTag: _DCTree$DCUnknownInlineTag$$static;
            interface _DCTree$DCUnknownInlineTag {
              accept<R, D>(v: sun.source.doctree.DocTreeVisitor<R,D>, d: D): R;
              getContent(): java.util.List<sun.source.doctree.DocTree>;
              getKind(): sun.source.doctree.DocTree$Kind;
              getTagName(): string;
              readonly content: java.util.List<DCTree>;
              readonly name: javax.lang.model.element.Name;
            }
            interface DCTree$DCUnknownInlineTag extends CombineTypes<[_DCTree$DCUnknownInlineTag, DCTree$DCInlineTag<DCTree$DCUnknownInlineTag>, sun.source.doctree.UnknownInlineTagTree]> {}
            interface _DCTree$DCUses$$static extends ClassLike {
              _new(serviceType: DCTree$DCReference, description: java.util.List<DCTree>): DCTree$DCUses;
            }
            let DCTree$DCUses: _DCTree$DCUses$$static;
            interface _DCTree$DCUses {
              accept<R, D>(v: sun.source.doctree.DocTreeVisitor<R,D>, d: D): R;
              getDescription(): java.util.List<sun.source.doctree.DocTree>;
              getKind(): sun.source.doctree.DocTree$Kind;
              getServiceType(): sun.source.doctree.ReferenceTree;
              readonly description: java.util.List<DCTree>;
              readonly serviceType: DCTree$DCReference;
            }
            interface DCTree$DCUses extends CombineTypes<[_DCTree$DCUses, com.sun.source.doctree.UsesTree, com.sun.tools.javac.tree.DCTree$DCBlockTag]> {}
            interface _DCTree$DCValue$$static extends ClassLike {
              _new(format: DCTree$DCText, ref: DCTree$DCReference): DCTree$DCValue;
            }
            let DCTree$DCValue: _DCTree$DCValue$$static;
            interface _DCTree$DCValue {
              accept<R, D>(v: sun.source.doctree.DocTreeVisitor<R,D>, d: D): R;
              getFormat(): sun.source.doctree.TextTree;
              getKind(): sun.source.doctree.DocTree$Kind;
              getReference(): sun.source.doctree.ReferenceTree;
              readonly format: DCTree$DCText;
              readonly ref: DCTree$DCReference;
            }
            interface DCTree$DCValue extends CombineTypes<[_DCTree$DCValue, sun.source.doctree.ValueTree, DCTree$DCInlineTag<DCTree$DCValue>]> {}
            interface _DCTree$DCVersion$$static extends ClassLike {
              _new(body: java.util.List<DCTree>): DCTree$DCVersion;
            }
            let DCTree$DCVersion: _DCTree$DCVersion$$static;
            interface _DCTree$DCVersion {
              accept<R, D>(v: sun.source.doctree.DocTreeVisitor<R,D>, d: D): R;
              getBody(): java.util.List<sun.source.doctree.DocTree>;
              getKind(): sun.source.doctree.DocTree$Kind;
              readonly body: java.util.List<DCTree>;
            }
            interface DCTree$DCVersion extends CombineTypes<[_DCTree$DCVersion, com.sun.tools.javac.tree.DCTree$DCBlockTag, com.sun.source.doctree.VersionTree]> {}
            interface _DocCommentTable$$static extends ClassLike {
            }
            let DocCommentTable: _DocCommentTable$$static;
            interface _DocCommentTable {
              getComment(a0: JCTree): javac.parser.Tokens$Comment;
              getCommentText(a0: JCTree): string;
              getCommentTree(a0: JCTree): DCTree$DCDocComment;
              hasComment(a0: JCTree): boolean;
              putComment(a0: JCTree, a1: javac.parser.Tokens$Comment): void;
            }
            interface DocCommentTable extends CombineTypes<[_DocCommentTable, java.lang.Object]> {}
            interface _DocPretty$$static extends ClassLike {
              new(out: java.io.Writer): DocPretty;
            }
            let DocPretty: _DocPretty$$static;
            interface _DocPretty {
              print(tree: sun.source.doctree.DocTree): void;
              _print(s: any): void;
              _print(c: char): void;
              print(list: java.util.List<sun.source.doctree.DocTree>): void;
              _print(list: java.util.List<sun.source.doctree.DocTree>, sep: char): void;
              _printTagName(node: sun.source.doctree.DocTree): void;
              _println(): void;
              visitAttribute(node: sun.source.doctree.AttributeTree, p: java.lang.Void): java.lang.Void;
              visitAttribute(a0: sun.source.doctree.AttributeTree, a1: any): any;
              visitAuthor(node: sun.source.doctree.AuthorTree, p: java.lang.Void): java.lang.Void;
              visitAuthor(a0: sun.source.doctree.AuthorTree, a1: any): any;
              visitComment(node: sun.source.doctree.CommentTree, p: java.lang.Void): java.lang.Void;
              visitComment(a0: sun.source.doctree.CommentTree, a1: any): any;
              visitDeprecated(node: sun.source.doctree.DeprecatedTree, p: java.lang.Void): java.lang.Void;
              visitDeprecated(a0: sun.source.doctree.DeprecatedTree, a1: any): any;
              visitDocComment(node: sun.source.doctree.DocCommentTree, p: java.lang.Void): java.lang.Void;
              visitDocComment(a0: sun.source.doctree.DocCommentTree, a1: any): any;
              visitDocRoot(node: sun.source.doctree.DocRootTree, p: java.lang.Void): java.lang.Void;
              visitDocRoot(a0: sun.source.doctree.DocRootTree, a1: any): any;
              visitDocType(node: sun.source.doctree.DocTypeTree, p: java.lang.Void): java.lang.Void;
              visitDocType(a0: sun.source.doctree.DocTypeTree, a1: any): any;
              visitEndElement(node: sun.source.doctree.EndElementTree, p: java.lang.Void): java.lang.Void;
              visitEndElement(a0: sun.source.doctree.EndElementTree, a1: any): any;
              visitEntity(node: sun.source.doctree.EntityTree, p: java.lang.Void): java.lang.Void;
              visitEntity(a0: sun.source.doctree.EntityTree, a1: any): any;
              visitErroneous(node: sun.source.doctree.ErroneousTree, p: java.lang.Void): java.lang.Void;
              visitErroneous(a0: sun.source.doctree.ErroneousTree, a1: any): any;
              visitEscape(node: sun.source.doctree.EscapeTree, p: java.lang.Void): java.lang.Void;
              visitEscape(a0: sun.source.doctree.EscapeTree, a1: any): any;
              visitHidden(node: sun.source.doctree.HiddenTree, p: java.lang.Void): java.lang.Void;
              visitHidden(a0: sun.source.doctree.HiddenTree, a1: any): any;
              visitIdentifier(node: sun.source.doctree.IdentifierTree, p: java.lang.Void): java.lang.Void;
              visitIdentifier(a0: sun.source.doctree.IdentifierTree, a1: any): any;
              visitIndex(node: sun.source.doctree.IndexTree, p: java.lang.Void): java.lang.Void;
              visitIndex(a0: sun.source.doctree.IndexTree, a1: any): any;
              visitInheritDoc(node: sun.source.doctree.InheritDocTree, p: java.lang.Void): java.lang.Void;
              visitInheritDoc(a0: sun.source.doctree.InheritDocTree, a1: any): any;
              visitLink(node: sun.source.doctree.LinkTree, p: java.lang.Void): java.lang.Void;
              visitLink(a0: sun.source.doctree.LinkTree, a1: any): any;
              visitLiteral(node: sun.source.doctree.LiteralTree, p: java.lang.Void): java.lang.Void;
              visitLiteral(a0: sun.source.doctree.LiteralTree, a1: any): any;
              visitOther(node: sun.source.doctree.DocTree, p: java.lang.Void): java.lang.Void;
              visitOther(a0: sun.source.doctree.DocTree, a1: any): any;
              visitParam(node: sun.source.doctree.ParamTree, p: java.lang.Void): java.lang.Void;
              visitParam(a0: sun.source.doctree.ParamTree, a1: any): any;
              visitProvides(node: sun.source.doctree.ProvidesTree, p: java.lang.Void): java.lang.Void;
              visitProvides(a0: sun.source.doctree.ProvidesTree, a1: any): any;
              visitReference(node: sun.source.doctree.ReferenceTree, p: java.lang.Void): java.lang.Void;
              visitReference(a0: sun.source.doctree.ReferenceTree, a1: any): any;
              visitReturn(node: sun.source.doctree.ReturnTree, p: java.lang.Void): java.lang.Void;
              visitReturn(a0: sun.source.doctree.ReturnTree, a1: any): any;
              visitSee(node: sun.source.doctree.SeeTree, p: java.lang.Void): java.lang.Void;
              visitSee(a0: sun.source.doctree.SeeTree, a1: any): any;
              visitSerial(node: sun.source.doctree.SerialTree, p: java.lang.Void): java.lang.Void;
              visitSerial(a0: sun.source.doctree.SerialTree, a1: any): any;
              visitSerialData(node: sun.source.doctree.SerialDataTree, p: java.lang.Void): java.lang.Void;
              visitSerialData(a0: sun.source.doctree.SerialDataTree, a1: any): any;
              visitSerialField(node: sun.source.doctree.SerialFieldTree, p: java.lang.Void): java.lang.Void;
              visitSerialField(a0: sun.source.doctree.SerialFieldTree, a1: any): any;
              visitSince(node: sun.source.doctree.SinceTree, p: java.lang.Void): java.lang.Void;
              visitSince(a0: sun.source.doctree.SinceTree, a1: any): any;
              visitSnippet(node: sun.source.doctree.SnippetTree, p: java.lang.Void): java.lang.Void;
              visitSnippet(a0: sun.source.doctree.SnippetTree, a1: any): any;
              visitSpec(node: sun.source.doctree.SpecTree, p: java.lang.Void): java.lang.Void;
              visitSpec(a0: sun.source.doctree.SpecTree, a1: any): any;
              visitStartElement(node: sun.source.doctree.StartElementTree, p: java.lang.Void): java.lang.Void;
              visitStartElement(a0: sun.source.doctree.StartElementTree, a1: any): any;
              visitSummary(node: sun.source.doctree.SummaryTree, p: java.lang.Void): java.lang.Void;
              visitSummary(a0: sun.source.doctree.SummaryTree, a1: any): any;
              visitSystemProperty(node: sun.source.doctree.SystemPropertyTree, p: java.lang.Void): java.lang.Void;
              visitSystemProperty(a0: sun.source.doctree.SystemPropertyTree, a1: any): any;
              visitText(node: sun.source.doctree.TextTree, p: java.lang.Void): java.lang.Void;
              visitText(a0: sun.source.doctree.TextTree, a1: any): any;
              visitThrows(node: sun.source.doctree.ThrowsTree, p: java.lang.Void): java.lang.Void;
              visitThrows(a0: sun.source.doctree.ThrowsTree, a1: any): any;
              visitUnknownBlockTag(node: sun.source.doctree.UnknownBlockTagTree, p: java.lang.Void): java.lang.Void;
              visitUnknownBlockTag(a0: sun.source.doctree.UnknownBlockTagTree, a1: any): any;
              visitUnknownInlineTag(node: sun.source.doctree.UnknownInlineTagTree, p: java.lang.Void): java.lang.Void;
              visitUnknownInlineTag(a0: sun.source.doctree.UnknownInlineTagTree, a1: any): any;
              visitUses(node: sun.source.doctree.UsesTree, p: java.lang.Void): java.lang.Void;
              visitUses(a0: sun.source.doctree.UsesTree, a1: any): any;
              visitValue(node: sun.source.doctree.ValueTree, p: java.lang.Void): java.lang.Void;
              visitValue(a0: sun.source.doctree.ValueTree, a1: any): any;
              visitVersion(node: sun.source.doctree.VersionTree, p: java.lang.Void): java.lang.Void;
              visitVersion(a0: sun.source.doctree.VersionTree, a1: any): any;
              _lineSep: string;
              _out: java.io.Writer;
            }
            interface DocPretty extends CombineTypes<[_DocPretty, java.lang.Object, sun.source.doctree.DocTreeVisitor<java.lang.Void,java.lang.Void>]> {}
            interface _DocTreeMaker$$static extends ClassLike {
              _cast(list: java.util.List<sun.source.doctree.DocTree>): java.util.List<DCTree>;
              instance(context: javac.util.Context): DocTreeMaker;
              _treeMakerKey: javac.util.Context$Key<DocTreeMaker>;
              _new(context: javac.util.Context): DocTreeMaker;
            }
            let DocTreeMaker: _DocTreeMaker$$static;
            interface _DocTreeMaker {
              at(pos: int): DocTreeMaker;
              at(a0: int): sun.source.util.DocTreeFactory;
              getFirstSentence(list: java.util.List<sun.source.doctree.DocTree>): java.util.List<sun.source.doctree.DocTree>;
              newAttributeTree(name: javax.lang.model.element.Name, vkind: sun.source.doctree.AttributeTree$ValueKind, value: java.util.List<sun.source.doctree.DocTree>): DCTree$DCAttribute;
              newAttributeTree(a0: javax.lang.model.element.Name, a1: sun.source.doctree.AttributeTree$ValueKind, a2: java.util.List): sun.source.doctree.AttributeTree;
              newAuthorTree(name: java.util.List<sun.source.doctree.DocTree>): DCTree$DCAuthor;
              newAuthorTree(a0: java.util.List): sun.source.doctree.AuthorTree;
              newCodeTree(text: sun.source.doctree.TextTree): DCTree$DCLiteral;
              newCodeTree(a0: sun.source.doctree.TextTree): sun.source.doctree.LiteralTree;
              newCommentTree(text: string): DCTree$DCComment;
              newCommentTree(a0: string): sun.source.doctree.CommentTree;
              newDeprecatedTree(text: java.util.List<sun.source.doctree.DocTree>): DCTree$DCDeprecated;
              newDeprecatedTree(a0: java.util.List): sun.source.doctree.DeprecatedTree;
              newDocCommentTree(fullBody: java.util.List<sun.source.doctree.DocTree>, tags: java.util.List<sun.source.doctree.DocTree>): DCTree$DCDocComment;
              newDocCommentTree(comment: javac.parser.Tokens$Comment, fullBody: java.util.List<sun.source.doctree.DocTree>, tags: java.util.List<sun.source.doctree.DocTree>, preamble: java.util.List<sun.source.doctree.DocTree>, postamble: java.util.List<sun.source.doctree.DocTree>): DCTree$DCDocComment;
              newDocCommentTree(fullBody: java.util.List<sun.source.doctree.DocTree>, tags: java.util.List<sun.source.doctree.DocTree>, preamble: java.util.List<sun.source.doctree.DocTree>, postamble: java.util.List<sun.source.doctree.DocTree>): DCTree$DCDocComment;
              newDocCommentTree(a0: java.util.List, a1: java.util.List, a2: java.util.List, a3: java.util.List): sun.source.doctree.DocCommentTree;
              newDocCommentTree(a0: java.util.List, a1: java.util.List): sun.source.doctree.DocCommentTree;
              newDocRootTree(): DCTree$DCDocRoot;
              newDocRootTree(): sun.source.doctree.DocRootTree;
              newDocTypeTree(text: string): DCTree$DCDocType;
              newDocTypeTree(a0: string): sun.source.doctree.DocTypeTree;
              newEndElementTree(name: javax.lang.model.element.Name): DCTree$DCEndElement;
              newEndElementTree(a0: javax.lang.model.element.Name): sun.source.doctree.EndElementTree;
              newEntityTree(name: javax.lang.model.element.Name): DCTree$DCEntity;
              newEntityTree(a0: javax.lang.model.element.Name): sun.source.doctree.EntityTree;
              newErroneousTree(text: string, diag: javax.tools.Diagnostic<javax.tools.JavaFileObject>): DCTree$DCErroneous;
              newErroneousTree(a0: string, a1: javax.tools.Diagnostic): sun.source.doctree.ErroneousTree;
              newEscapeTree(ch: char): DCTree$DCEscape;
              newEscapeTree(a0: char): sun.source.doctree.EscapeTree;
              newExceptionTree(name: sun.source.doctree.ReferenceTree, description: java.util.List<sun.source.doctree.DocTree>): DCTree$DCThrows;
              newExceptionTree(a0: sun.source.doctree.ReferenceTree, a1: java.util.List): sun.source.doctree.ThrowsTree;
              newHiddenTree(text: java.util.List<sun.source.doctree.DocTree>): DCTree$DCHidden;
              newHiddenTree(a0: java.util.List): sun.source.doctree.HiddenTree;
              newIdentifierTree(name: javax.lang.model.element.Name): DCTree$DCIdentifier;
              newIdentifierTree(a0: javax.lang.model.element.Name): sun.source.doctree.IdentifierTree;
              newIndexTree(term: sun.source.doctree.DocTree, description: java.util.List<sun.source.doctree.DocTree>): DCTree$DCIndex;
              newIndexTree(a0: sun.source.doctree.DocTree, a1: java.util.List): sun.source.doctree.IndexTree;
              newInheritDocTree(): DCTree$DCInheritDoc;
              newInheritDocTree(): sun.source.doctree.InheritDocTree;
              newLinkPlainTree(ref: sun.source.doctree.ReferenceTree, label: java.util.List<sun.source.doctree.DocTree>): DCTree$DCLink;
              newLinkPlainTree(a0: sun.source.doctree.ReferenceTree, a1: java.util.List): sun.source.doctree.LinkTree;
              newLinkTree(ref: sun.source.doctree.ReferenceTree, label: java.util.List<sun.source.doctree.DocTree>): DCTree$DCLink;
              newLinkTree(a0: sun.source.doctree.ReferenceTree, a1: java.util.List): sun.source.doctree.LinkTree;
              newLiteralTree(text: sun.source.doctree.TextTree): DCTree$DCLiteral;
              newLiteralTree(a0: sun.source.doctree.TextTree): sun.source.doctree.LiteralTree;
              newParamTree(isTypeParameter: boolean, name: sun.source.doctree.IdentifierTree, description: java.util.List<sun.source.doctree.DocTree>): DCTree$DCParam;
              newParamTree(a0: boolean, a1: sun.source.doctree.IdentifierTree, a2: java.util.List): sun.source.doctree.ParamTree;
              newProvidesTree(name: sun.source.doctree.ReferenceTree, description: java.util.List<sun.source.doctree.DocTree>): DCTree$DCProvides;
              newProvidesTree(a0: sun.source.doctree.ReferenceTree, a1: java.util.List): sun.source.doctree.ProvidesTree;
              newReferenceTree(signature: string): DCTree$DCReference;
              newReferenceTree(signature: string, ref: javac.parser.ReferenceParser$Reference): DCTree$DCReference;
              newReferenceTree(a0: string): sun.source.doctree.ReferenceTree;
              newReturnTree(description: java.util.List<sun.source.doctree.DocTree>): DCTree$DCReturn;
              newReturnTree(isInline: boolean, description: java.util.List<sun.source.doctree.DocTree>): DCTree$DCReturn;
              newReturnTree(a0: boolean, a1: java.util.List): sun.source.doctree.ReturnTree;
              newReturnTree(a0: java.util.List): sun.source.doctree.ReturnTree;
              newSeeTree(reference: java.util.List<sun.source.doctree.DocTree>): DCTree$DCSee;
              newSeeTree(a0: java.util.List): sun.source.doctree.SeeTree;
              newSerialDataTree(description: java.util.List<sun.source.doctree.DocTree>): DCTree$DCSerialData;
              newSerialDataTree(a0: java.util.List): sun.source.doctree.SerialDataTree;
              newSerialFieldTree(name: sun.source.doctree.IdentifierTree, type: sun.source.doctree.ReferenceTree, description: java.util.List<sun.source.doctree.DocTree>): DCTree$DCSerialField;
              newSerialFieldTree(a0: sun.source.doctree.IdentifierTree, a1: sun.source.doctree.ReferenceTree, a2: java.util.List): sun.source.doctree.SerialFieldTree;
              newSerialTree(description: java.util.List<sun.source.doctree.DocTree>): DCTree$DCSerial;
              newSerialTree(a0: java.util.List): sun.source.doctree.SerialTree;
              newSinceTree(text: java.util.List<sun.source.doctree.DocTree>): DCTree$DCSince;
              newSinceTree(a0: java.util.List): sun.source.doctree.SinceTree;
              newSnippetTree(attributes: java.util.List<sun.source.doctree.DocTree>, text: sun.source.doctree.TextTree): DCTree$DCSnippet;
              newSnippetTree(a0: java.util.List, a1: sun.source.doctree.TextTree): sun.source.doctree.SnippetTree;
              newSpecTree(url: sun.source.doctree.TextTree, title: java.util.List<sun.source.doctree.DocTree>): DCTree$DCSpec;
              newSpecTree(a0: sun.source.doctree.TextTree, a1: java.util.List): sun.source.doctree.SpecTree;
              newStartElementTree(name: javax.lang.model.element.Name, attrs: java.util.List<sun.source.doctree.DocTree>, selfClosing: boolean): DCTree$DCStartElement;
              newStartElementTree(a0: javax.lang.model.element.Name, a1: java.util.List, a2: boolean): sun.source.doctree.StartElementTree;
              newSummaryTree(text: java.util.List<sun.source.doctree.DocTree>): DCTree$DCSummary;
              newSummaryTree(a0: java.util.List): sun.source.doctree.SummaryTree;
              newSystemPropertyTree(propertyName: javax.lang.model.element.Name): DCTree$DCSystemProperty;
              newSystemPropertyTree(a0: javax.lang.model.element.Name): sun.source.doctree.SystemPropertyTree;
              newTextTree(text: string): DCTree$DCText;
              newTextTree(a0: string): sun.source.doctree.TextTree;
              newThrowsTree(name: sun.source.doctree.ReferenceTree, description: java.util.List<sun.source.doctree.DocTree>): DCTree$DCThrows;
              newThrowsTree(a0: sun.source.doctree.ReferenceTree, a1: java.util.List): sun.source.doctree.ThrowsTree;
              newUnknownBlockTagTree(name: javax.lang.model.element.Name, content: java.util.List<sun.source.doctree.DocTree>): DCTree$DCUnknownBlockTag;
              newUnknownBlockTagTree(a0: javax.lang.model.element.Name, a1: java.util.List): sun.source.doctree.UnknownBlockTagTree;
              newUnknownInlineTagTree(name: javax.lang.model.element.Name, content: java.util.List<sun.source.doctree.DocTree>): DCTree$DCUnknownInlineTag;
              newUnknownInlineTagTree(a0: javax.lang.model.element.Name, a1: java.util.List): sun.source.doctree.UnknownInlineTagTree;
              newUsesTree(name: sun.source.doctree.ReferenceTree, description: java.util.List<sun.source.doctree.DocTree>): DCTree$DCUses;
              newUsesTree(a0: sun.source.doctree.ReferenceTree, a1: java.util.List): sun.source.doctree.UsesTree;
              newValueTree(ref: sun.source.doctree.ReferenceTree): DCTree$DCValue;
              newValueTree(format: sun.source.doctree.TextTree, ref: sun.source.doctree.ReferenceTree): DCTree$DCValue;
              newValueTree(a0: sun.source.doctree.TextTree, a1: sun.source.doctree.ReferenceTree): sun.source.doctree.ValueTree;
              newValueTree(a0: sun.source.doctree.ReferenceTree): sun.source.doctree.ValueTree;
              newVersionTree(text: java.util.List<sun.source.doctree.DocTree>): DCTree$DCVersion;
              newVersionTree(a0: java.util.List): sun.source.doctree.VersionTree;
              _splitBody(list: java.util.List<sun.source.doctree.DocTree>): javac.util.Pair<java.util.List<DCTree>,java.util.List<DCTree>>;
              _breaker: DocTreeMaker$SentenceBreaker;
              pos: int;
              _referenceParser: javac.parser.ReferenceParser;
              _trees: javac.api.JavacTrees;
            }
            interface DocTreeMaker extends CombineTypes<[_DocTreeMaker, com.sun.source.util.DocTreeFactory, java.lang.Object]> {}
            interface _DocTreeMaker$SentenceBreaker$$static extends ClassLike {
              _sentenceBreakTags: java.util.Set<string>;
              _new(m: DocTreeMaker): DocTreeMaker$SentenceBreaker;
            }
            let DocTreeMaker$SentenceBreaker: _DocTreeMaker$SentenceBreaker$$static;
            interface _DocTreeMaker$SentenceBreaker {
              _defaultSentenceBreak(s: string): int;
              _getSentenceBreak(s: string, nextTree: DCTree): int;
              _isSentenceBreak(dt: DCTree, isFirstDocTree: boolean): boolean;
              _isSentenceBreak(tagName: javax.lang.model.element.Name): boolean;
              _skipWhiteSpace(s: string, start: int): int;
              _splitBody(list: java.util.List<sun.source.doctree.DocTree>): javac.util.Pair<java.util.List<DCTree>,java.util.List<DCTree>>;
              _m: DocTreeMaker;
            }
            interface DocTreeMaker$SentenceBreaker extends CombineTypes<[_DocTreeMaker$SentenceBreaker, java.lang.Object]> {}
            interface _EndPosTable$$static extends ClassLike {
            }
            let EndPosTable: _EndPosTable$$static;
            interface _EndPosTable {
              getEndPos(a0: JCTree): int;
              replaceTree(a0: JCTree, a1: JCTree): int;
              storeEnd(a0: JCTree, a1: int): void;
            }
            interface EndPosTable extends CombineTypes<[_EndPosTable, java.lang.Object]> {}
            interface _JCTree$$static extends ClassLike {
              new(): JCTree;
            }
            let JCTree: _JCTree$$static;
            interface _JCTree {
              accept(a0: JCTree$Visitor): void;
              accept<R, D>(a0: sun.source.tree.TreeVisitor<R,D>, a1: D): R;
              clone(): any;
              getEndPosition(endPosTable: EndPosTable): int;
              getPreferredPosition(): int;
              getStartPosition(): int;
              getTag(): JCTree$Tag;
              getTree(): JCTree;
              hasTag(tag: JCTree$Tag): boolean;
              pos(): javac.util.JCDiagnostic$DiagnosticPosition;
              setPos(pos: int): JCTree;
              setType(type: javac.code.Type): JCTree;
              toString(): string;
              pos: int;
              type: javac.code.Type;
            }
            interface JCTree extends CombineTypes<[_JCTree, java.lang.Cloneable, com.sun.tools.javac.util.JCDiagnostic$DiagnosticPosition, java.lang.Object, com.sun.source.tree.Tree]> {}
            interface _JCTree$Factory$$static extends ClassLike {
            }
            let JCTree$Factory: _JCTree$Factory$$static;
            interface _JCTree$Factory {
              Annotation(a0: JCTree, a1: javac.util.List<JCTree$JCExpression>): JCTree$JCAnnotation;
              Apply(a0: javac.util.List<JCTree$JCExpression>, a1: JCTree$JCExpression, a2: javac.util.List<JCTree$JCExpression>): JCTree$JCMethodInvocation;
              Assert(a0: JCTree$JCExpression, a1: JCTree$JCExpression): JCTree$JCAssert;
              Assign(a0: JCTree$JCExpression, a1: JCTree$JCExpression): JCTree$JCAssign;
              Assignop(a0: JCTree$Tag, a1: JCTree, a2: JCTree): JCTree$JCAssignOp;
              Binary(a0: JCTree$Tag, a1: JCTree$JCExpression, a2: JCTree$JCExpression): JCTree$JCBinary;
              BindingPattern(a0: JCTree$JCVariableDecl): JCTree$JCBindingPattern;
              Block(a0: long, a1: javac.util.List<JCTree$JCStatement>): JCTree$JCBlock;
              Break(a0: javac.util.Name): JCTree$JCBreak;
              Case(a0: sun.source.tree.CaseTree$CaseKind, a1: javac.util.List<JCTree$JCCaseLabel>, a2: JCTree$JCExpression, a3: javac.util.List<JCTree$JCStatement>, a4: JCTree): JCTree$JCCase;
              Catch(a0: JCTree$JCVariableDecl, a1: JCTree$JCBlock): JCTree$JCCatch;
              ClassDef(a0: JCTree$JCModifiers, a1: javac.util.Name, a2: javac.util.List<JCTree$JCTypeParameter>, a3: JCTree$JCExpression, a4: javac.util.List<JCTree$JCExpression>, a5: javac.util.List<JCTree>): JCTree$JCClassDecl;
              Conditional(a0: JCTree$JCExpression, a1: JCTree$JCExpression, a2: JCTree$JCExpression): JCTree$JCConditional;
              Continue(a0: javac.util.Name): JCTree$JCContinue;
              DoLoop(a0: JCTree$JCStatement, a1: JCTree$JCExpression): JCTree$JCDoWhileLoop;
              Erroneous(a0: javac.util.List<JCTree>): JCTree$JCErroneous;
              Exec(a0: JCTree$JCExpression): JCTree$JCExpressionStatement;
              Exports(a0: JCTree$JCExpression, a1: javac.util.List<JCTree$JCExpression>): JCTree$JCExports;
              ForLoop(a0: javac.util.List<JCTree$JCStatement>, a1: JCTree$JCExpression, a2: javac.util.List<JCTree$JCExpressionStatement>, a3: JCTree$JCStatement): JCTree$JCForLoop;
              ForeachLoop(a0: JCTree$JCVariableDecl, a1: JCTree$JCExpression, a2: JCTree$JCStatement): JCTree$JCEnhancedForLoop;
              Ident(a0: javac.util.Name): JCTree$JCIdent;
              If(a0: JCTree$JCExpression, a1: JCTree$JCStatement, a2: JCTree$JCStatement): JCTree$JCIf;
              Import(a0: JCTree$JCFieldAccess, a1: boolean): JCTree$JCImport;
              Indexed(a0: JCTree$JCExpression, a1: JCTree$JCExpression): JCTree$JCArrayAccess;
              Labelled(a0: javac.util.Name, a1: JCTree$JCStatement): JCTree$JCLabeledStatement;
              LetExpr(a0: javac.util.List<JCTree$JCStatement>, a1: JCTree$JCExpression): JCTree$LetExpr;
              Literal(a0: javac.code.TypeTag, a1: any): JCTree$JCLiteral;
              MethodDef(a0: JCTree$JCModifiers, a1: javac.util.Name, a2: JCTree$JCExpression, a3: javac.util.List<JCTree$JCTypeParameter>, a4: JCTree$JCVariableDecl, a5: javac.util.List<JCTree$JCVariableDecl>, a6: javac.util.List<JCTree$JCExpression>, a7: JCTree$JCBlock, a8: JCTree$JCExpression): JCTree$JCMethodDecl;
              Modifiers(a0: long, a1: javac.util.List<JCTree$JCAnnotation>): JCTree$JCModifiers;
              ModuleDef(a0: JCTree$JCModifiers, a1: sun.source.tree.ModuleTree$ModuleKind, a2: JCTree$JCExpression, a3: javac.util.List<JCTree$JCDirective>): JCTree$JCModuleDecl;
              NewArray(a0: JCTree$JCExpression, a1: javac.util.List<JCTree$JCExpression>, a2: javac.util.List<JCTree$JCExpression>): JCTree$JCNewArray;
              NewClass(a0: JCTree$JCExpression, a1: javac.util.List<JCTree$JCExpression>, a2: JCTree$JCExpression, a3: javac.util.List<JCTree$JCExpression>, a4: JCTree$JCClassDecl): JCTree$JCNewClass;
              Opens(a0: JCTree$JCExpression, a1: javac.util.List<JCTree$JCExpression>): JCTree$JCOpens;
              PackageDecl(a0: javac.util.List<JCTree$JCAnnotation>, a1: JCTree$JCExpression): JCTree$JCPackageDecl;
              Parens(a0: JCTree$JCExpression): JCTree$JCParens;
              Provides(a0: JCTree$JCExpression, a1: javac.util.List<JCTree$JCExpression>): JCTree$JCProvides;
              Requires(a0: boolean, a1: boolean, a2: JCTree$JCExpression): JCTree$JCRequires;
              Return(a0: JCTree$JCExpression): JCTree$JCReturn;
              Select(a0: JCTree$JCExpression, a1: javac.util.Name): JCTree$JCFieldAccess;
              Skip(): JCTree$JCSkip;
              StringTemplate(a0: JCTree$JCExpression, a1: javac.util.List<string>, a2: javac.util.List<JCTree$JCExpression>): JCTree$JCStringTemplate;
              Switch(a0: JCTree$JCExpression, a1: javac.util.List<JCTree$JCCase>): JCTree$JCSwitch;
              SwitchExpression(a0: JCTree$JCExpression, a1: javac.util.List<JCTree$JCCase>): JCTree$JCSwitchExpression;
              Synchronized(a0: JCTree$JCExpression, a1: JCTree$JCBlock): JCTree$JCSynchronized;
              Throw(a0: JCTree$JCExpression): JCTree$JCThrow;
              TopLevel(a0: javac.util.List<JCTree>): JCTree$JCCompilationUnit;
              Try(a0: JCTree$JCBlock, a1: javac.util.List<JCTree$JCCatch>, a2: JCTree$JCBlock): JCTree$JCTry;
              Try(a0: javac.util.List<JCTree>, a1: JCTree$JCBlock, a2: javac.util.List<JCTree$JCCatch>, a3: JCTree$JCBlock): JCTree$JCTry;
              TypeApply(a0: JCTree$JCExpression, a1: javac.util.List<JCTree$JCExpression>): JCTree$JCTypeApply;
              TypeArray(a0: JCTree$JCExpression): JCTree$JCArrayTypeTree;
              TypeBoundKind(a0: javac.code.BoundKind): JCTree$TypeBoundKind;
              TypeCast(a0: JCTree, a1: JCTree$JCExpression): JCTree$JCTypeCast;
              TypeIdent(a0: javac.code.TypeTag): JCTree$JCPrimitiveTypeTree;
              TypeParameter(a0: javac.util.Name, a1: javac.util.List<JCTree$JCExpression>): JCTree$JCTypeParameter;
              TypeTest(a0: JCTree$JCExpression, a1: JCTree): JCTree$JCInstanceOf;
              Unary(a0: JCTree$Tag, a1: JCTree$JCExpression): JCTree$JCUnary;
              Uses(a0: JCTree$JCExpression): JCTree$JCUses;
              VarDef(a0: JCTree$JCModifiers, a1: javac.util.Name, a2: JCTree$JCExpression, a3: JCTree$JCExpression): JCTree$JCVariableDecl;
              WhileLoop(a0: JCTree$JCExpression, a1: JCTree$JCStatement): JCTree$JCWhileLoop;
              Wildcard(a0: JCTree$TypeBoundKind, a1: JCTree): JCTree$JCWildcard;
              Yield(a0: JCTree$JCExpression): JCTree$JCYield;
            }
            interface JCTree$Factory extends CombineTypes<[_JCTree$Factory, java.lang.Object]> {}
            interface _JCTree$JCAnnotatedType$$static extends ClassLike {
              _new(annotations: javac.util.List<JCTree$JCAnnotation>, underlyingType: JCTree$JCExpression): JCTree$JCAnnotatedType;
            }
            let JCTree$JCAnnotatedType: _JCTree$JCAnnotatedType$$static;
            interface _JCTree$JCAnnotatedType {
              accept(v: JCTree$Visitor): void;
              accept<R, D>(v: sun.source.tree.TreeVisitor<R,D>, d: D): R;
              getAnnotations(): javac.util.List<JCTree$JCAnnotation>;
              getAnnotations(): java.util.List;
              getKind(): sun.source.tree.Tree$Kind;
              getTag(): JCTree$Tag;
              getUnderlyingType(): JCTree$JCExpression;
              getUnderlyingType(): sun.source.tree.ExpressionTree;
              annotations: javac.util.List<JCTree$JCAnnotation>;
              underlyingType: JCTree$JCExpression;
            }
            interface JCTree$JCAnnotatedType extends CombineTypes<[_JCTree$JCAnnotatedType, com.sun.tools.javac.tree.JCTree$JCExpression, com.sun.source.tree.AnnotatedTypeTree]> {}
            interface _JCTree$JCAnnotation$$static extends ClassLike {
              _new(tag: JCTree$Tag, annotationType: JCTree, args: javac.util.List<JCTree$JCExpression>): JCTree$JCAnnotation;
            }
            let JCTree$JCAnnotation: _JCTree$JCAnnotation$$static;
            interface _JCTree$JCAnnotation {
              accept(v: JCTree$Visitor): void;
              accept<R, D>(v: sun.source.tree.TreeVisitor<R,D>, d: D): R;
              getAnnotationType(): JCTree;
              getAnnotationType(): sun.source.tree.Tree;
              getArguments(): javac.util.List<JCTree$JCExpression>;
              getArguments(): java.util.List;
              getKind(): sun.source.tree.Tree$Kind;
              getTag(): JCTree$Tag;
              annotationType: JCTree;
              args: javac.util.List<JCTree$JCExpression>;
              attribute: javac.code.Attribute$Compound;
              _tag: JCTree$Tag;
            }
            interface JCTree$JCAnnotation extends CombineTypes<[_JCTree$JCAnnotation, com.sun.source.tree.AnnotationTree, com.sun.tools.javac.tree.JCTree$JCExpression]> {}
            interface _JCTree$JCAnyPattern$$static extends ClassLike {
              _new(): JCTree$JCAnyPattern;
            }
            let JCTree$JCAnyPattern: _JCTree$JCAnyPattern$$static;
            interface _JCTree$JCAnyPattern {
              accept(v: JCTree$Visitor): void;
              accept<R, D>(v: sun.source.tree.TreeVisitor<R,D>, d: D): R;
              getKind(): sun.source.tree.Tree$Kind;
              getTag(): JCTree$Tag;
            }
            interface JCTree$JCAnyPattern extends CombineTypes<[_JCTree$JCAnyPattern, com.sun.tools.javac.tree.JCTree$JCPattern, com.sun.source.tree.AnyPatternTree]> {}
            interface _JCTree$JCArrayAccess$$static extends ClassLike {
              _new(indexed: JCTree$JCExpression, index: JCTree$JCExpression): JCTree$JCArrayAccess;
            }
            let JCTree$JCArrayAccess: _JCTree$JCArrayAccess$$static;
            interface _JCTree$JCArrayAccess {
              accept(v: JCTree$Visitor): void;
              accept<R, D>(v: sun.source.tree.TreeVisitor<R,D>, d: D): R;
              getExpression(): JCTree$JCExpression;
              getExpression(): sun.source.tree.ExpressionTree;
              getIndex(): JCTree$JCExpression;
              getIndex(): sun.source.tree.ExpressionTree;
              getKind(): sun.source.tree.Tree$Kind;
              getTag(): JCTree$Tag;
              index: JCTree$JCExpression;
              indexed: JCTree$JCExpression;
            }
            interface JCTree$JCArrayAccess extends CombineTypes<[_JCTree$JCArrayAccess, com.sun.source.tree.ArrayAccessTree, com.sun.tools.javac.tree.JCTree$JCExpression]> {}
            interface _JCTree$JCArrayTypeTree$$static extends ClassLike {
              _new(elemtype: JCTree$JCExpression): JCTree$JCArrayTypeTree;
            }
            let JCTree$JCArrayTypeTree: _JCTree$JCArrayTypeTree$$static;
            interface _JCTree$JCArrayTypeTree {
              accept(v: JCTree$Visitor): void;
              accept<R, D>(v: sun.source.tree.TreeVisitor<R,D>, d: D): R;
              getKind(): sun.source.tree.Tree$Kind;
              getTag(): JCTree$Tag;
              getType(): JCTree;
              getType(): sun.source.tree.Tree;
              elemtype: JCTree$JCExpression;
            }
            interface JCTree$JCArrayTypeTree extends CombineTypes<[_JCTree$JCArrayTypeTree, com.sun.source.tree.ArrayTypeTree, com.sun.tools.javac.tree.JCTree$JCExpression]> {}
            interface _JCTree$JCAssert$$static extends ClassLike {
              _new(cond: JCTree$JCExpression, detail: JCTree$JCExpression): JCTree$JCAssert;
            }
            let JCTree$JCAssert: _JCTree$JCAssert$$static;
            interface _JCTree$JCAssert {
              accept(v: JCTree$Visitor): void;
              accept<R, D>(v: sun.source.tree.TreeVisitor<R,D>, d: D): R;
              getCondition(): JCTree$JCExpression;
              getCondition(): sun.source.tree.ExpressionTree;
              getDetail(): JCTree$JCExpression;
              getDetail(): sun.source.tree.ExpressionTree;
              getKind(): sun.source.tree.Tree$Kind;
              getTag(): JCTree$Tag;
              cond: JCTree$JCExpression;
              detail: JCTree$JCExpression;
            }
            interface JCTree$JCAssert extends CombineTypes<[_JCTree$JCAssert, com.sun.source.tree.AssertTree, com.sun.tools.javac.tree.JCTree$JCStatement]> {}
            interface _JCTree$JCAssign$$static extends ClassLike {
              _new(lhs: JCTree$JCExpression, rhs: JCTree$JCExpression): JCTree$JCAssign;
            }
            let JCTree$JCAssign: _JCTree$JCAssign$$static;
            interface _JCTree$JCAssign {
              accept(v: JCTree$Visitor): void;
              accept<R, D>(v: sun.source.tree.TreeVisitor<R,D>, d: D): R;
              getExpression(): JCTree$JCExpression;
              getExpression(): sun.source.tree.ExpressionTree;
              getKind(): sun.source.tree.Tree$Kind;
              getTag(): JCTree$Tag;
              getVariable(): JCTree$JCExpression;
              getVariable(): sun.source.tree.ExpressionTree;
              lhs: JCTree$JCExpression;
              rhs: JCTree$JCExpression;
            }
            interface JCTree$JCAssign extends CombineTypes<[_JCTree$JCAssign, com.sun.source.tree.AssignmentTree, com.sun.tools.javac.tree.JCTree$JCExpression]> {}
            interface _JCTree$JCAssignOp$$static extends ClassLike {
              _new(opcode: JCTree$Tag, lhs: JCTree, rhs: JCTree, operator: javac.code.Symbol$OperatorSymbol): JCTree$JCAssignOp;
            }
            let JCTree$JCAssignOp: _JCTree$JCAssignOp$$static;
            interface _JCTree$JCAssignOp {
              accept(v: JCTree$Visitor): void;
              accept<R, D>(v: sun.source.tree.TreeVisitor<R,D>, d: D): R;
              getExpression(): JCTree$JCExpression;
              getExpression(): sun.source.tree.ExpressionTree;
              getKind(): sun.source.tree.Tree$Kind;
              getOperand(pos: JCTree$JCOperatorExpression$OperandPos): JCTree$JCExpression;
              getVariable(): JCTree$JCExpression;
              getVariable(): sun.source.tree.ExpressionTree;
              lhs: JCTree$JCExpression;
              rhs: JCTree$JCExpression;
            }
            interface JCTree$JCAssignOp extends CombineTypes<[_JCTree$JCAssignOp, com.sun.source.tree.CompoundAssignmentTree, com.sun.tools.javac.tree.JCTree$JCOperatorExpression]> {}
            interface _JCTree$JCBinary$$static extends ClassLike {
              _new(opcode: JCTree$Tag, lhs: JCTree$JCExpression, rhs: JCTree$JCExpression, operator: javac.code.Symbol$OperatorSymbol): JCTree$JCBinary;
            }
            let JCTree$JCBinary: _JCTree$JCBinary$$static;
            interface _JCTree$JCBinary {
              accept(v: JCTree$Visitor): void;
              accept<R, D>(v: sun.source.tree.TreeVisitor<R,D>, d: D): R;
              getKind(): sun.source.tree.Tree$Kind;
              getLeftOperand(): JCTree$JCExpression;
              getLeftOperand(): sun.source.tree.ExpressionTree;
              getOperand(pos: JCTree$JCOperatorExpression$OperandPos): JCTree$JCExpression;
              getRightOperand(): JCTree$JCExpression;
              getRightOperand(): sun.source.tree.ExpressionTree;
              lhs: JCTree$JCExpression;
              rhs: JCTree$JCExpression;
            }
            interface JCTree$JCBinary extends CombineTypes<[_JCTree$JCBinary, com.sun.source.tree.BinaryTree, com.sun.tools.javac.tree.JCTree$JCOperatorExpression]> {}
            interface _JCTree$JCBindingPattern$$static extends ClassLike {
              _new(_var: JCTree$JCVariableDecl): JCTree$JCBindingPattern;
            }
            let JCTree$JCBindingPattern: _JCTree$JCBindingPattern$$static;
            interface _JCTree$JCBindingPattern {
              accept(v: JCTree$Visitor): void;
              accept<R, D>(v: sun.source.tree.TreeVisitor<R,D>, d: D): R;
              getKind(): sun.source.tree.Tree$Kind;
              getTag(): JCTree$Tag;
              getVariable(): sun.source.tree.VariableTree;
              var: JCTree$JCVariableDecl;
            }
            interface JCTree$JCBindingPattern extends CombineTypes<[_JCTree$JCBindingPattern, com.sun.source.tree.BindingPatternTree, com.sun.tools.javac.tree.JCTree$JCPattern]> {}
            interface _JCTree$JCBlock$$static extends ClassLike {
              _new(flags: long, a1: javac.util.List<JCTree$JCStatement>): JCTree$JCBlock;
            }
            let JCTree$JCBlock: _JCTree$JCBlock$$static;
            interface _JCTree$JCBlock {
              accept(v: JCTree$Visitor): void;
              accept<R, D>(v: sun.source.tree.TreeVisitor<R,D>, d: D): R;
              getKind(): sun.source.tree.Tree$Kind;
              getStatements(): javac.util.List<JCTree$JCStatement>;
              getStatements(): java.util.List;
              getTag(): JCTree$Tag;
              isStatic(): boolean;
              endpos: int;
              flags: long;
              patternMatchingCatch: JCTree$JCBlock$PatternMatchingCatch;
              stats: javac.util.List<JCTree$JCStatement>;
            }
            interface JCTree$JCBlock extends CombineTypes<[_JCTree$JCBlock, com.sun.source.tree.BlockTree, com.sun.tools.javac.tree.JCTree$JCStatement]> {}
            interface _JCTree$JCBlock$PatternMatchingCatch$$static extends ClassLike {
              new(handler: JCTree$JCCatch, calls2Handle: java.util.Set<JCTree$JCMethodInvocation>): JCTree$JCBlock$PatternMatchingCatch;
            }
            let JCTree$JCBlock$PatternMatchingCatch: _JCTree$JCBlock$PatternMatchingCatch$$static;
            interface _JCTree$JCBlock$PatternMatchingCatch {
              calls2Handle(): java.util.Set<JCTree$JCMethodInvocation>;
              equals(o: any): boolean;
              handler(): JCTree$JCCatch;
              hashCode(): int;
              toString(): string;
            }
            interface JCTree$JCBlock$PatternMatchingCatch extends CombineTypes<[_JCTree$JCBlock$PatternMatchingCatch, java.lang.Record]> {}
            interface _JCTree$JCBreak$$static extends ClassLike {
              _new(label: javac.util.Name, target: JCTree): JCTree$JCBreak;
            }
            let JCTree$JCBreak: _JCTree$JCBreak$$static;
            interface _JCTree$JCBreak {
              accept(v: JCTree$Visitor): void;
              accept<R, D>(v: sun.source.tree.TreeVisitor<R,D>, d: D): R;
              getKind(): sun.source.tree.Tree$Kind;
              getLabel(): javac.util.Name;
              getLabel(): javax.lang.model.element.Name;
              getTag(): JCTree$Tag;
              isValueBreak(): boolean;
              label: javac.util.Name;
              target: JCTree;
            }
            interface JCTree$JCBreak extends CombineTypes<[_JCTree$JCBreak, com.sun.source.tree.BreakTree, com.sun.tools.javac.tree.JCTree$JCStatement]> {}
            interface _JCTree$JCCase$$static extends ClassLike {
              readonly RULE: sun.source.tree.CaseTree$CaseKind;
              readonly STATEMENT: sun.source.tree.CaseTree$CaseKind;
              _new(caseKind: sun.source.tree.CaseTree$CaseKind, labels: javac.util.List<JCTree$JCCaseLabel>, guard: JCTree$JCExpression, stats: javac.util.List<JCTree$JCStatement>, body: JCTree): JCTree$JCCase;
            }
            let JCTree$JCCase: _JCTree$JCCase$$static;
            interface _JCTree$JCCase {
              accept(v: JCTree$Visitor): void;
              accept<R, D>(v: sun.source.tree.TreeVisitor<R,D>, d: D): R;
              getBody(): JCTree;
              getBody(): sun.source.tree.Tree;
              getCaseKind(): sun.source.tree.CaseTree$CaseKind;
              getExpression(): JCTree$JCExpression;
              getExpression(): sun.source.tree.ExpressionTree;
              getExpressions(): javac.util.List<JCTree$JCExpression>;
              getExpressions(): java.util.List;
              getGuard(): JCTree$JCExpression;
              getGuard(): sun.source.tree.ExpressionTree;
              getKind(): sun.source.tree.Tree$Kind;
              getLabels(): javac.util.List<JCTree$JCCaseLabel>;
              getLabels(): java.util.List;
              getStatements(): javac.util.List<JCTree$JCStatement>;
              getStatements(): java.util.List;
              getTag(): JCTree$Tag;
              body: JCTree;
              readonly caseKind: sun.source.tree.CaseTree$CaseKind;
              completesNormally: boolean;
              guard: JCTree$JCExpression;
              labels: javac.util.List<JCTree$JCCaseLabel>;
              stats: javac.util.List<JCTree$JCStatement>;
            }
            interface JCTree$JCCase extends CombineTypes<[_JCTree$JCCase, com.sun.tools.javac.tree.JCTree$JCStatement, com.sun.source.tree.CaseTree]> {}
            interface _JCTree$JCCaseLabel$$static extends ClassLike {
              new(): JCTree$JCCaseLabel;
            }
            let JCTree$JCCaseLabel: _JCTree$JCCaseLabel$$static;
            interface _JCTree$JCCaseLabel {
            }
            interface JCTree$JCCaseLabel extends CombineTypes<[_JCTree$JCCaseLabel, com.sun.source.tree.CaseLabelTree, com.sun.tools.javac.tree.JCTree]> {}
            interface _JCTree$JCCatch$$static extends ClassLike {
              _new(param: JCTree$JCVariableDecl, body: JCTree$JCBlock): JCTree$JCCatch;
            }
            let JCTree$JCCatch: _JCTree$JCCatch$$static;
            interface _JCTree$JCCatch {
              accept(v: JCTree$Visitor): void;
              accept<R, D>(v: sun.source.tree.TreeVisitor<R,D>, d: D): R;
              getBlock(): JCTree$JCBlock;
              getBlock(): sun.source.tree.BlockTree;
              getKind(): sun.source.tree.Tree$Kind;
              getParameter(): JCTree$JCVariableDecl;
              getParameter(): sun.source.tree.VariableTree;
              getTag(): JCTree$Tag;
              body: JCTree$JCBlock;
              param: JCTree$JCVariableDecl;
            }
            interface JCTree$JCCatch extends CombineTypes<[_JCTree$JCCatch, com.sun.source.tree.CatchTree, com.sun.tools.javac.tree.JCTree]> {}
            interface _JCTree$JCClassDecl$$static extends ClassLike {
              _new(mods: JCTree$JCModifiers, name: javac.util.Name, typarams: javac.util.List<JCTree$JCTypeParameter>, extending: JCTree$JCExpression, implementing: javac.util.List<JCTree$JCExpression>, permitting: javac.util.List<JCTree$JCExpression>, defs: javac.util.List<JCTree>, sym: javac.code.Symbol$ClassSymbol): JCTree$JCClassDecl;
            }
            let JCTree$JCClassDecl: _JCTree$JCClassDecl$$static;
            interface _JCTree$JCClassDecl {
              accept(v: JCTree$Visitor): void;
              accept<R, D>(v: sun.source.tree.TreeVisitor<R,D>, d: D): R;
              getExtendsClause(): JCTree$JCExpression;
              getExtendsClause(): sun.source.tree.Tree;
              getImplementsClause(): javac.util.List<JCTree$JCExpression>;
              getImplementsClause(): java.util.List;
              getKind(): sun.source.tree.Tree$Kind;
              getMembers(): javac.util.List<JCTree>;
              getMembers(): java.util.List;
              getModifiers(): JCTree$JCModifiers;
              getModifiers(): sun.source.tree.ModifiersTree;
              getPermitsClause(): javac.util.List<JCTree$JCExpression>;
              getPermitsClause(): java.util.List;
              getSimpleName(): javac.util.Name;
              getSimpleName(): javax.lang.model.element.Name;
              getTag(): JCTree$Tag;
              getTypeParameters(): javac.util.List<JCTree$JCTypeParameter>;
              getTypeParameters(): java.util.List;
              defs: javac.util.List<JCTree>;
              extending: JCTree$JCExpression;
              implementing: javac.util.List<JCTree$JCExpression>;
              mods: JCTree$JCModifiers;
              name: javac.util.Name;
              permitting: javac.util.List<JCTree$JCExpression>;
              sym: javac.code.Symbol$ClassSymbol;
              typarams: javac.util.List<JCTree$JCTypeParameter>;
            }
            interface JCTree$JCClassDecl extends CombineTypes<[_JCTree$JCClassDecl, com.sun.tools.javac.tree.JCTree$JCStatement, com.sun.source.tree.ClassTree]> {}
            interface _JCTree$JCCompilationUnit$$static extends ClassLike {
              _new(defs: javac.util.List<JCTree>): JCTree$JCCompilationUnit;
            }
            let JCTree$JCCompilationUnit: _JCTree$JCCompilationUnit$$static;
            interface _JCTree$JCCompilationUnit {
              accept(v: JCTree$Visitor): void;
              accept<R, D>(v: sun.source.tree.TreeVisitor<R,D>, d: D): R;
              getImports(): javac.util.List<JCTree$JCImport>;
              getImports(): java.util.List;
              getKind(): sun.source.tree.Tree$Kind;
              getLineMap(): javac.util.Position$LineMap;
              getLineMap(): sun.source.tree.LineMap;
              getModule(): JCTree$JCModuleDecl;
              getModule(): sun.source.tree.ModuleTree;
              getModuleDecl(): JCTree$JCModuleDecl;
              getPackage(): JCTree$JCPackageDecl;
              getPackage(): sun.source.tree.PackageTree;
              getPackageAnnotations(): javac.util.List<JCTree$JCAnnotation>;
              getPackageAnnotations(): java.util.List;
              getPackageName(): sun.source.tree.ExpressionTree;
              getSourceFile(): javax.tools.JavaFileObject;
              getTag(): JCTree$Tag;
              getTypeDecls(): javac.util.List<JCTree>;
              getTypeDecls(): java.util.List;
              defs: javac.util.List<JCTree>;
              docComments: DocCommentTable;
              endPositions: EndPosTable;
              lineMap: javac.util.Position$LineMap;
              locn: javax.tools.JavaFileManager$Location;
              modle: javac.code.Symbol$ModuleSymbol;
              namedImportScope: javac.code.Scope$NamedImportScope;
              packge: javac.code.Symbol$PackageSymbol;
              sourcefile: javax.tools.JavaFileObject;
              starImportScope: javac.code.Scope$StarImportScope;
              toplevelScope: javac.code.Scope$WriteableScope;
            }
            interface JCTree$JCCompilationUnit extends CombineTypes<[_JCTree$JCCompilationUnit, com.sun.tools.javac.tree.JCTree, com.sun.source.tree.CompilationUnitTree]> {}
            interface _JCTree$JCConditional$$static extends ClassLike {
              _new(cond: JCTree$JCExpression, truepart: JCTree$JCExpression, falsepart: JCTree$JCExpression): JCTree$JCConditional;
            }
            let JCTree$JCConditional: _JCTree$JCConditional$$static;
            interface _JCTree$JCConditional {
              accept(v: JCTree$Visitor): void;
              accept<R, D>(v: sun.source.tree.TreeVisitor<R,D>, d: D): R;
              getCondition(): JCTree$JCExpression;
              getCondition(): sun.source.tree.ExpressionTree;
              getFalseExpression(): JCTree$JCExpression;
              getFalseExpression(): sun.source.tree.ExpressionTree;
              getKind(): sun.source.tree.Tree$Kind;
              getTag(): JCTree$Tag;
              getTrueExpression(): JCTree$JCExpression;
              getTrueExpression(): sun.source.tree.ExpressionTree;
              cond: JCTree$JCExpression;
              falsepart: JCTree$JCExpression;
              truepart: JCTree$JCExpression;
            }
            interface JCTree$JCConditional extends CombineTypes<[_JCTree$JCConditional, com.sun.source.tree.ConditionalExpressionTree, com.sun.tools.javac.tree.JCTree$JCPolyExpression]> {}
            interface _JCTree$JCConstantCaseLabel$$static extends ClassLike {
              _new(expr: JCTree$JCExpression): JCTree$JCConstantCaseLabel;
            }
            let JCTree$JCConstantCaseLabel: _JCTree$JCConstantCaseLabel$$static;
            interface _JCTree$JCConstantCaseLabel {
              accept(v: JCTree$Visitor): void;
              accept<R, D>(v: sun.source.tree.TreeVisitor<R,D>, d: D): R;
              getConstantExpression(): JCTree$JCExpression;
              getConstantExpression(): sun.source.tree.ExpressionTree;
              getKind(): sun.source.tree.Tree$Kind;
              getTag(): JCTree$Tag;
              expr: JCTree$JCExpression;
            }
            interface JCTree$JCConstantCaseLabel extends CombineTypes<[_JCTree$JCConstantCaseLabel, com.sun.tools.javac.tree.JCTree$JCCaseLabel, com.sun.source.tree.ConstantCaseLabelTree]> {}
            interface _JCTree$JCContinue$$static extends ClassLike {
              _new(label: javac.util.Name, target: JCTree): JCTree$JCContinue;
            }
            let JCTree$JCContinue: _JCTree$JCContinue$$static;
            interface _JCTree$JCContinue {
              accept(v: JCTree$Visitor): void;
              accept<R, D>(v: sun.source.tree.TreeVisitor<R,D>, d: D): R;
              getKind(): sun.source.tree.Tree$Kind;
              getLabel(): javac.util.Name;
              getLabel(): javax.lang.model.element.Name;
              getTag(): JCTree$Tag;
              label: javac.util.Name;
              target: JCTree;
            }
            interface JCTree$JCContinue extends CombineTypes<[_JCTree$JCContinue, com.sun.source.tree.ContinueTree, com.sun.tools.javac.tree.JCTree$JCStatement]> {}
            interface _JCTree$JCDefaultCaseLabel$$static extends ClassLike {
              _new(): JCTree$JCDefaultCaseLabel;
            }
            let JCTree$JCDefaultCaseLabel: _JCTree$JCDefaultCaseLabel$$static;
            interface _JCTree$JCDefaultCaseLabel {
              accept(v: JCTree$Visitor): void;
              accept<R, D>(v: sun.source.tree.TreeVisitor<R,D>, d: D): R;
              getKind(): sun.source.tree.Tree$Kind;
              getTag(): JCTree$Tag;
            }
            interface JCTree$JCDefaultCaseLabel extends CombineTypes<[_JCTree$JCDefaultCaseLabel, com.sun.source.tree.DefaultCaseLabelTree, com.sun.tools.javac.tree.JCTree$JCCaseLabel]> {}
            interface _JCTree$JCDirective$$static extends ClassLike {
              new(): JCTree$JCDirective;
            }
            let JCTree$JCDirective: _JCTree$JCDirective$$static;
            interface _JCTree$JCDirective {
            }
            interface JCTree$JCDirective extends CombineTypes<[_JCTree$JCDirective, com.sun.source.tree.DirectiveTree, com.sun.tools.javac.tree.JCTree]> {}
            interface _JCTree$JCDoWhileLoop$$static extends ClassLike {
              _new(body: JCTree$JCStatement, cond: JCTree$JCExpression): JCTree$JCDoWhileLoop;
            }
            let JCTree$JCDoWhileLoop: _JCTree$JCDoWhileLoop$$static;
            interface _JCTree$JCDoWhileLoop {
              accept(v: JCTree$Visitor): void;
              accept<R, D>(v: sun.source.tree.TreeVisitor<R,D>, d: D): R;
              getCondition(): JCTree$JCExpression;
              getCondition(): sun.source.tree.ExpressionTree;
              getKind(): sun.source.tree.Tree$Kind;
              getStatement(): JCTree$JCStatement;
              getStatement(): sun.source.tree.StatementTree;
              getTag(): JCTree$Tag;
              body: JCTree$JCStatement;
              cond: JCTree$JCExpression;
            }
            interface JCTree$JCDoWhileLoop extends CombineTypes<[_JCTree$JCDoWhileLoop, com.sun.source.tree.DoWhileLoopTree, com.sun.tools.javac.tree.JCTree$JCStatement]> {}
            interface _JCTree$JCEnhancedForLoop$$static extends ClassLike {
              _new(_var: JCTree$JCVariableDecl, expr: JCTree$JCExpression, body: JCTree$JCStatement): JCTree$JCEnhancedForLoop;
            }
            let JCTree$JCEnhancedForLoop: _JCTree$JCEnhancedForLoop$$static;
            interface _JCTree$JCEnhancedForLoop {
              accept(v: JCTree$Visitor): void;
              accept<R, D>(v: sun.source.tree.TreeVisitor<R,D>, d: D): R;
              getExpression(): JCTree$JCExpression;
              getExpression(): sun.source.tree.ExpressionTree;
              getKind(): sun.source.tree.Tree$Kind;
              getStatement(): JCTree$JCStatement;
              getStatement(): sun.source.tree.StatementTree;
              getTag(): JCTree$Tag;
              getVariable(): JCTree$JCVariableDecl;
              getVariable(): sun.source.tree.VariableTree;
              body: JCTree$JCStatement;
              expr: JCTree$JCExpression;
              var: JCTree$JCVariableDecl;
            }
            interface JCTree$JCEnhancedForLoop extends CombineTypes<[_JCTree$JCEnhancedForLoop, com.sun.tools.javac.tree.JCTree$JCStatement, com.sun.source.tree.EnhancedForLoopTree]> {}
            interface _JCTree$JCErroneous$$static extends ClassLike {
              _new(errs: javac.util.List<JCTree>): JCTree$JCErroneous;
            }
            let JCTree$JCErroneous: _JCTree$JCErroneous$$static;
            interface _JCTree$JCErroneous {
              accept(v: JCTree$Visitor): void;
              accept<R, D>(v: sun.source.tree.TreeVisitor<R,D>, d: D): R;
              getErrorTrees(): javac.util.List<JCTree>;
              getErrorTrees(): java.util.List;
              getKind(): sun.source.tree.Tree$Kind;
              getTag(): JCTree$Tag;
              errs: javac.util.List<JCTree>;
            }
            interface JCTree$JCErroneous extends CombineTypes<[_JCTree$JCErroneous, com.sun.source.tree.ErroneousTree, com.sun.tools.javac.tree.JCTree$JCExpression]> {}
            interface _JCTree$JCExports$$static extends ClassLike {
              _new(qualId: JCTree$JCExpression, moduleNames: javac.util.List<JCTree$JCExpression>): JCTree$JCExports;
            }
            let JCTree$JCExports: _JCTree$JCExports$$static;
            interface _JCTree$JCExports {
              accept(v: JCTree$Visitor): void;
              accept<R, D>(v: sun.source.tree.TreeVisitor<R,D>, d: D): R;
              getKind(): sun.source.tree.Tree$Kind;
              getModuleNames(): javac.util.List<JCTree$JCExpression>;
              getModuleNames(): java.util.List;
              getPackageName(): JCTree$JCExpression;
              getPackageName(): sun.source.tree.ExpressionTree;
              getTag(): JCTree$Tag;
              directive: javac.code.Directive$ExportsDirective;
              moduleNames: javac.util.List<JCTree$JCExpression>;
              qualid: JCTree$JCExpression;
            }
            interface JCTree$JCExports extends CombineTypes<[_JCTree$JCExports, com.sun.tools.javac.tree.JCTree$JCDirective, com.sun.source.tree.ExportsTree]> {}
            interface _JCTree$JCExpression$$static extends ClassLike {
              new(): JCTree$JCExpression;
            }
            let JCTree$JCExpression: _JCTree$JCExpression$$static;
            interface _JCTree$JCExpression {
              isPoly(): boolean;
              isStandalone(): boolean;
              setPos(pos: int): JCTree$JCExpression;
              setPos(a0: int): JCTree;
              setType(type: javac.code.Type): JCTree$JCExpression;
              setType(a0: javac.code.Type): JCTree;
            }
            interface JCTree$JCExpression extends CombineTypes<[_JCTree$JCExpression, com.sun.source.tree.ExpressionTree, com.sun.tools.javac.tree.JCTree]> {}
            interface _JCTree$JCExpressionStatement$$static extends ClassLike {
              _new(expr: JCTree$JCExpression): JCTree$JCExpressionStatement;
            }
            let JCTree$JCExpressionStatement: _JCTree$JCExpressionStatement$$static;
            interface _JCTree$JCExpressionStatement {
              accept(v: JCTree$Visitor): void;
              accept<R, D>(v: sun.source.tree.TreeVisitor<R,D>, d: D): R;
              getExpression(): JCTree$JCExpression;
              getExpression(): sun.source.tree.ExpressionTree;
              getKind(): sun.source.tree.Tree$Kind;
              getTag(): JCTree$Tag;
              toString(): string;
              expr: JCTree$JCExpression;
            }
            interface JCTree$JCExpressionStatement extends CombineTypes<[_JCTree$JCExpressionStatement, com.sun.tools.javac.tree.JCTree$JCStatement, com.sun.source.tree.ExpressionStatementTree]> {}
            interface _JCTree$JCFieldAccess$$static extends ClassLike {
              _new(selected: JCTree$JCExpression, name: javac.util.Name, sym: javac.code.Symbol): JCTree$JCFieldAccess;
            }
            let JCTree$JCFieldAccess: _JCTree$JCFieldAccess$$static;
            interface _JCTree$JCFieldAccess {
              accept(v: JCTree$Visitor): void;
              accept<R, D>(v: sun.source.tree.TreeVisitor<R,D>, d: D): R;
              getExpression(): JCTree$JCExpression;
              getExpression(): sun.source.tree.ExpressionTree;
              getIdentifier(): javac.util.Name;
              getIdentifier(): javax.lang.model.element.Name;
              getKind(): sun.source.tree.Tree$Kind;
              getTag(): JCTree$Tag;
              name: javac.util.Name;
              selected: JCTree$JCExpression;
              sym: javac.code.Symbol;
            }
            interface JCTree$JCFieldAccess extends CombineTypes<[_JCTree$JCFieldAccess, com.sun.tools.javac.tree.JCTree$JCExpression, com.sun.source.tree.MemberSelectTree]> {}
            interface _JCTree$JCForLoop$$static extends ClassLike {
              _new(init: javac.util.List<JCTree$JCStatement>, cond: JCTree$JCExpression, update: javac.util.List<JCTree$JCExpressionStatement>, body: JCTree$JCStatement): JCTree$JCForLoop;
            }
            let JCTree$JCForLoop: _JCTree$JCForLoop$$static;
            interface _JCTree$JCForLoop {
              accept(v: JCTree$Visitor): void;
              accept<R, D>(v: sun.source.tree.TreeVisitor<R,D>, d: D): R;
              getCondition(): JCTree$JCExpression;
              getCondition(): sun.source.tree.ExpressionTree;
              getInitializer(): javac.util.List<JCTree$JCStatement>;
              getInitializer(): java.util.List;
              getKind(): sun.source.tree.Tree$Kind;
              getStatement(): JCTree$JCStatement;
              getStatement(): sun.source.tree.StatementTree;
              getTag(): JCTree$Tag;
              getUpdate(): javac.util.List<JCTree$JCExpressionStatement>;
              getUpdate(): java.util.List;
              body: JCTree$JCStatement;
              cond: JCTree$JCExpression;
              init: javac.util.List<JCTree$JCStatement>;
              step: javac.util.List<JCTree$JCExpressionStatement>;
            }
            interface JCTree$JCForLoop extends CombineTypes<[_JCTree$JCForLoop, com.sun.tools.javac.tree.JCTree$JCStatement, com.sun.source.tree.ForLoopTree]> {}
            interface _JCTree$JCFunctionalExpression$$static extends ClassLike {
              new(): JCTree$JCFunctionalExpression;
            }
            let JCTree$JCFunctionalExpression: _JCTree$JCFunctionalExpression$$static;
            interface _JCTree$JCFunctionalExpression {
              getDescriptorType(types: javac.code.Types): javac.code.Type;
              target: javac.code.Type;
            }
            interface JCTree$JCFunctionalExpression extends CombineTypes<[_JCTree$JCFunctionalExpression, com.sun.tools.javac.tree.JCTree$JCPolyExpression]> {}
            interface _JCTree$JCIdent$$static extends ClassLike {
              _new(name: javac.util.Name, sym: javac.code.Symbol): JCTree$JCIdent;
            }
            let JCTree$JCIdent: _JCTree$JCIdent$$static;
            interface _JCTree$JCIdent {
              accept(v: JCTree$Visitor): void;
              accept<R, D>(v: sun.source.tree.TreeVisitor<R,D>, d: D): R;
              getKind(): sun.source.tree.Tree$Kind;
              getName(): javac.util.Name;
              getName(): javax.lang.model.element.Name;
              getTag(): JCTree$Tag;
              name: javac.util.Name;
              sym: javac.code.Symbol;
            }
            interface JCTree$JCIdent extends CombineTypes<[_JCTree$JCIdent, com.sun.tools.javac.tree.JCTree$JCExpression, com.sun.source.tree.IdentifierTree]> {}
            interface _JCTree$JCIf$$static extends ClassLike {
              _new(cond: JCTree$JCExpression, thenpart: JCTree$JCStatement, elsepart: JCTree$JCStatement): JCTree$JCIf;
            }
            let JCTree$JCIf: _JCTree$JCIf$$static;
            interface _JCTree$JCIf {
              accept(v: JCTree$Visitor): void;
              accept<R, D>(v: sun.source.tree.TreeVisitor<R,D>, d: D): R;
              getCondition(): JCTree$JCExpression;
              getCondition(): sun.source.tree.ExpressionTree;
              getElseStatement(): JCTree$JCStatement;
              getElseStatement(): sun.source.tree.StatementTree;
              getKind(): sun.source.tree.Tree$Kind;
              getTag(): JCTree$Tag;
              getThenStatement(): JCTree$JCStatement;
              getThenStatement(): sun.source.tree.StatementTree;
              cond: JCTree$JCExpression;
              elsepart: JCTree$JCStatement;
              thenpart: JCTree$JCStatement;
            }
            interface JCTree$JCIf extends CombineTypes<[_JCTree$JCIf, com.sun.source.tree.IfTree, com.sun.tools.javac.tree.JCTree$JCStatement]> {}
            interface _JCTree$JCImport$$static extends ClassLike {
              _new(qualid: JCTree$JCFieldAccess, importStatic: boolean): JCTree$JCImport;
            }
            let JCTree$JCImport: _JCTree$JCImport$$static;
            interface _JCTree$JCImport {
              accept(v: JCTree$Visitor): void;
              accept<R, D>(v: sun.source.tree.TreeVisitor<R,D>, d: D): R;
              getKind(): sun.source.tree.Tree$Kind;
              getQualifiedIdentifier(): JCTree$JCFieldAccess;
              getQualifiedIdentifier(): sun.source.tree.Tree;
              getTag(): JCTree$Tag;
              isStatic(): boolean;
              importScope: javac.code.Scope;
              qualid: JCTree$JCFieldAccess;
              staticImport: boolean;
            }
            interface JCTree$JCImport extends CombineTypes<[_JCTree$JCImport, com.sun.tools.javac.tree.JCTree, com.sun.source.tree.ImportTree]> {}
            interface _JCTree$JCInstanceOf$$static extends ClassLike {
              _new(expr: JCTree$JCExpression, pattern: JCTree): JCTree$JCInstanceOf;
            }
            let JCTree$JCInstanceOf: _JCTree$JCInstanceOf$$static;
            interface _JCTree$JCInstanceOf {
              accept(v: JCTree$Visitor): void;
              accept<R, D>(v: sun.source.tree.TreeVisitor<R,D>, d: D): R;
              getExpression(): JCTree$JCExpression;
              getExpression(): sun.source.tree.ExpressionTree;
              getKind(): sun.source.tree.Tree$Kind;
              getPattern(): JCTree$JCPattern;
              getPattern(): sun.source.tree.PatternTree;
              getTag(): JCTree$Tag;
              getType(): JCTree;
              getType(): sun.source.tree.Tree;
              allowNull: boolean;
              expr: JCTree$JCExpression;
              pattern: JCTree;
            }
            interface JCTree$JCInstanceOf extends CombineTypes<[_JCTree$JCInstanceOf, com.sun.tools.javac.tree.JCTree$JCExpression, com.sun.source.tree.InstanceOfTree]> {}
            interface _JCTree$JCLabeledStatement$$static extends ClassLike {
              _new(label: javac.util.Name, body: JCTree$JCStatement): JCTree$JCLabeledStatement;
            }
            let JCTree$JCLabeledStatement: _JCTree$JCLabeledStatement$$static;
            interface _JCTree$JCLabeledStatement {
              accept(v: JCTree$Visitor): void;
              accept<R, D>(v: sun.source.tree.TreeVisitor<R,D>, d: D): R;
              getKind(): sun.source.tree.Tree$Kind;
              getLabel(): javac.util.Name;
              getLabel(): javax.lang.model.element.Name;
              getStatement(): JCTree$JCStatement;
              getStatement(): sun.source.tree.StatementTree;
              getTag(): JCTree$Tag;
              body: JCTree$JCStatement;
              label: javac.util.Name;
            }
            interface JCTree$JCLabeledStatement extends CombineTypes<[_JCTree$JCLabeledStatement, com.sun.source.tree.LabeledStatementTree, com.sun.tools.javac.tree.JCTree$JCStatement]> {}
            interface _JCTree$JCLambda$$static extends ClassLike {
              new(params: javac.util.List<JCTree$JCVariableDecl>, body: JCTree): JCTree$JCLambda;
            }
            let JCTree$JCLambda: _JCTree$JCLambda$$static;
            interface _JCTree$JCLambda {
              accept(v: JCTree$Visitor): void;
              accept<R, D>(v: sun.source.tree.TreeVisitor<R,D>, d: D): R;
              getBody(): JCTree;
              getBody(): sun.source.tree.Tree;
              getBodyKind(): sun.source.tree.LambdaExpressionTree$BodyKind;
              getKind(): sun.source.tree.Tree$Kind;
              getParameters(): java.util.List<sun.source.tree.VariableTree>;
              getTag(): JCTree$Tag;
              setType(type: javac.code.Type): JCTree$JCLambda;
              setType(a0: javac.code.Type): JCTree$JCExpression;
              setType(a0: javac.code.Type): JCTree;
              body: JCTree;
              canCompleteNormally: boolean;
              paramKind: JCTree$JCLambda$ParameterKind;
              params: javac.util.List<JCTree$JCVariableDecl>;
            }
            interface JCTree$JCLambda extends CombineTypes<[_JCTree$JCLambda, com.sun.tools.javac.tree.JCTree$JCFunctionalExpression, com.sun.source.tree.LambdaExpressionTree]> {}
            interface _JCTree$JCLambda$ParameterKind$$static extends ClassLike {
              valueOf(name: string): JCTree$JCLambda$ParameterKind;
              values(): JCTree$JCLambda$ParameterKind[];
              readonly EXPLICIT: JCTree$JCLambda$ParameterKind;
              readonly IMPLICIT: JCTree$JCLambda$ParameterKind;
            }
            let JCTree$JCLambda$ParameterKind: _JCTree$JCLambda$ParameterKind$$static;
            interface _JCTree$JCLambda$ParameterKind {
            }
            interface JCTree$JCLambda$ParameterKind extends CombineTypes<[_JCTree$JCLambda$ParameterKind]> {}
            interface _JCTree$JCLiteral$$static extends ClassLike {
              _new(typetag: javac.code.TypeTag, value: any): JCTree$JCLiteral;
            }
            let JCTree$JCLiteral: _JCTree$JCLiteral$$static;
            interface _JCTree$JCLiteral {
              accept(v: JCTree$Visitor): void;
              accept<R, D>(v: sun.source.tree.TreeVisitor<R,D>, d: D): R;
              getKind(): sun.source.tree.Tree$Kind;
              getTag(): JCTree$Tag;
              getValue(): any;
              setType(type: javac.code.Type): JCTree$JCLiteral;
              setType(a0: javac.code.Type): JCTree$JCExpression;
              setType(a0: javac.code.Type): JCTree;
              typetag: javac.code.TypeTag;
              value: any;
            }
            interface JCTree$JCLiteral extends CombineTypes<[_JCTree$JCLiteral, com.sun.source.tree.LiteralTree, com.sun.tools.javac.tree.JCTree$JCExpression]> {}
            interface _JCTree$JCMemberReference$$static extends ClassLike {
              new(mode: sun.source.tree.MemberReferenceTree$ReferenceMode, name: javac.util.Name, expr: JCTree$JCExpression, typeargs: javac.util.List<JCTree$JCExpression>): JCTree$JCMemberReference;
            }
            let JCTree$JCMemberReference: _JCTree$JCMemberReference$$static;
            interface _JCTree$JCMemberReference {
              accept(v: JCTree$Visitor): void;
              accept<R, D>(v: sun.source.tree.TreeVisitor<R,D>, d: D): R;
              getKind(): sun.source.tree.Tree$Kind;
              getMode(): sun.source.tree.MemberReferenceTree$ReferenceMode;
              getName(): javac.util.Name;
              getName(): javax.lang.model.element.Name;
              getOverloadKind(): JCTree$JCMemberReference$OverloadKind;
              getQualifierExpression(): JCTree$JCExpression;
              getQualifierExpression(): sun.source.tree.ExpressionTree;
              getTag(): JCTree$Tag;
              getTypeArguments(): javac.util.List<JCTree$JCExpression>;
              getTypeArguments(): java.util.List;
              hasKind(kind: JCTree$JCMemberReference$ReferenceKind): boolean;
              setOverloadKind(overloadKind: JCTree$JCMemberReference$OverloadKind): void;
              expr: JCTree$JCExpression;
              kind: JCTree$JCMemberReference$ReferenceKind;
              mode: sun.source.tree.MemberReferenceTree$ReferenceMode;
              name: javac.util.Name;
              _overloadKind: JCTree$JCMemberReference$OverloadKind;
              ownerAccessible: boolean;
              refPolyKind: JCTree$JCPolyExpression$PolyKind;
              referentType: javac.code.Type;
              sym: javac.code.Symbol;
              typeargs: javac.util.List<JCTree$JCExpression>;
              varargsElement: javac.code.Type;
            }
            interface JCTree$JCMemberReference extends CombineTypes<[_JCTree$JCMemberReference, com.sun.tools.javac.tree.JCTree$JCFunctionalExpression, com.sun.source.tree.MemberReferenceTree]> {}
            interface _JCTree$JCMemberReference$OverloadKind$$static extends ClassLike {
              valueOf(name: string): JCTree$JCMemberReference$OverloadKind;
              values(): JCTree$JCMemberReference$OverloadKind[];
              readonly ERROR: JCTree$JCMemberReference$OverloadKind;
              readonly OVERLOADED: JCTree$JCMemberReference$OverloadKind;
              readonly UNOVERLOADED: JCTree$JCMemberReference$OverloadKind;
            }
            let JCTree$JCMemberReference$OverloadKind: _JCTree$JCMemberReference$OverloadKind$$static;
            interface _JCTree$JCMemberReference$OverloadKind {
            }
            interface JCTree$JCMemberReference$OverloadKind extends CombineTypes<[_JCTree$JCMemberReference$OverloadKind]> {}
            interface _JCTree$JCMemberReference$ReferenceKind$$static extends ClassLike {
              valueOf(name: string): JCTree$JCMemberReference$ReferenceKind;
              values(): JCTree$JCMemberReference$ReferenceKind[];
              readonly ARRAY_CTOR: JCTree$JCMemberReference$ReferenceKind;
              readonly BOUND: JCTree$JCMemberReference$ReferenceKind;
              readonly IMPLICIT_INNER: JCTree$JCMemberReference$ReferenceKind;
              readonly STATIC: JCTree$JCMemberReference$ReferenceKind;
              readonly SUPER: JCTree$JCMemberReference$ReferenceKind;
              readonly TOPLEVEL: JCTree$JCMemberReference$ReferenceKind;
              readonly UNBOUND: JCTree$JCMemberReference$ReferenceKind;
            }
            let JCTree$JCMemberReference$ReferenceKind: _JCTree$JCMemberReference$ReferenceKind$$static;
            interface _JCTree$JCMemberReference$ReferenceKind {
              isUnbound(): boolean;
              _mode: sun.source.tree.MemberReferenceTree$ReferenceMode;
              _unbound: boolean;
            }
            interface JCTree$JCMemberReference$ReferenceKind extends CombineTypes<[_JCTree$JCMemberReference$ReferenceKind]> {}
            interface _JCTree$JCMethodDecl$$static extends ClassLike {
              _new(mods: JCTree$JCModifiers, name: javac.util.Name, restype: JCTree$JCExpression, typarams: javac.util.List<JCTree$JCTypeParameter>, recvparam: JCTree$JCVariableDecl, params: javac.util.List<JCTree$JCVariableDecl>, thrown: javac.util.List<JCTree$JCExpression>, body: JCTree$JCBlock, defaultValue: JCTree$JCExpression, sym: javac.code.Symbol$MethodSymbol): JCTree$JCMethodDecl;
            }
            let JCTree$JCMethodDecl: _JCTree$JCMethodDecl$$static;
            interface _JCTree$JCMethodDecl {
              accept(v: JCTree$Visitor): void;
              accept<R, D>(v: sun.source.tree.TreeVisitor<R,D>, d: D): R;
              getBody(): JCTree$JCBlock;
              getBody(): sun.source.tree.BlockTree;
              getDefaultValue(): JCTree;
              getDefaultValue(): sun.source.tree.Tree;
              getKind(): sun.source.tree.Tree$Kind;
              getModifiers(): JCTree$JCModifiers;
              getModifiers(): sun.source.tree.ModifiersTree;
              getName(): javac.util.Name;
              getName(): javax.lang.model.element.Name;
              getParameters(): javac.util.List<JCTree$JCVariableDecl>;
              getParameters(): java.util.List;
              getReceiverParameter(): JCTree$JCVariableDecl;
              getReceiverParameter(): sun.source.tree.VariableTree;
              getReturnType(): JCTree;
              getReturnType(): sun.source.tree.Tree;
              getTag(): JCTree$Tag;
              getThrows(): javac.util.List<JCTree$JCExpression>;
              getThrows(): java.util.List;
              getTypeParameters(): javac.util.List<JCTree$JCTypeParameter>;
              getTypeParameters(): java.util.List;
              body: JCTree$JCBlock;
              completesNormally: boolean;
              defaultValue: JCTree$JCExpression;
              mods: JCTree$JCModifiers;
              name: javac.util.Name;
              params: javac.util.List<JCTree$JCVariableDecl>;
              recvparam: JCTree$JCVariableDecl;
              restype: JCTree$JCExpression;
              sym: javac.code.Symbol$MethodSymbol;
              thrown: javac.util.List<JCTree$JCExpression>;
              typarams: javac.util.List<JCTree$JCTypeParameter>;
            }
            interface JCTree$JCMethodDecl extends CombineTypes<[_JCTree$JCMethodDecl, com.sun.source.tree.MethodTree, com.sun.tools.javac.tree.JCTree]> {}
            interface _JCTree$JCMethodInvocation$$static extends ClassLike {
              _new(typeargs: javac.util.List<JCTree$JCExpression>, meth: JCTree$JCExpression, args: javac.util.List<JCTree$JCExpression>): JCTree$JCMethodInvocation;
            }
            let JCTree$JCMethodInvocation: _JCTree$JCMethodInvocation$$static;
            interface _JCTree$JCMethodInvocation {
              accept(v: JCTree$Visitor): void;
              accept<R, D>(v: sun.source.tree.TreeVisitor<R,D>, d: D): R;
              getArguments(): javac.util.List<JCTree$JCExpression>;
              getArguments(): java.util.List;
              getKind(): sun.source.tree.Tree$Kind;
              getMethodSelect(): JCTree$JCExpression;
              getMethodSelect(): sun.source.tree.ExpressionTree;
              getTag(): JCTree$Tag;
              getTypeArguments(): javac.util.List<JCTree$JCExpression>;
              getTypeArguments(): java.util.List;
              setType(type: javac.code.Type): JCTree$JCMethodInvocation;
              setType(a0: javac.code.Type): JCTree$JCExpression;
              setType(a0: javac.code.Type): JCTree;
              args: javac.util.List<JCTree$JCExpression>;
              meth: JCTree$JCExpression;
              typeargs: javac.util.List<JCTree$JCExpression>;
              varargsElement: javac.code.Type;
            }
            interface JCTree$JCMethodInvocation extends CombineTypes<[_JCTree$JCMethodInvocation, com.sun.source.tree.MethodInvocationTree, com.sun.tools.javac.tree.JCTree$JCPolyExpression]> {}
            interface _JCTree$JCModifiers$$static extends ClassLike {
              _new(flags: long, a1: javac.util.List<JCTree$JCAnnotation>): JCTree$JCModifiers;
            }
            let JCTree$JCModifiers: _JCTree$JCModifiers$$static;
            interface _JCTree$JCModifiers {
              accept(v: JCTree$Visitor): void;
              accept<R, D>(v: sun.source.tree.TreeVisitor<R,D>, d: D): R;
              getAnnotations(): javac.util.List<JCTree$JCAnnotation>;
              getAnnotations(): java.util.List;
              getFlags(): java.util.Set<javax.lang.model.element.Modifier>;
              getKind(): sun.source.tree.Tree$Kind;
              getTag(): JCTree$Tag;
              annotations: javac.util.List<JCTree$JCAnnotation>;
              flags: long;
            }
            interface JCTree$JCModifiers extends CombineTypes<[_JCTree$JCModifiers, com.sun.source.tree.ModifiersTree, com.sun.tools.javac.tree.JCTree]> {}
            interface _JCTree$JCModuleDecl$$static extends ClassLike {
              _new(mods: JCTree$JCModifiers, kind: sun.source.tree.ModuleTree$ModuleKind, qualId: JCTree$JCExpression, directives: javac.util.List<JCTree$JCDirective>): JCTree$JCModuleDecl;
            }
            let JCTree$JCModuleDecl: _JCTree$JCModuleDecl$$static;
            interface _JCTree$JCModuleDecl {
              accept(v: JCTree$Visitor): void;
              accept<R, D>(v: sun.source.tree.TreeVisitor<R,D>, d: D): R;
              getAnnotations(): javac.util.List<sun.source.tree.AnnotationTree>;
              getAnnotations(): java.util.List;
              getDirectives(): javac.util.List<JCTree$JCDirective>;
              getDirectives(): java.util.List;
              getKind(): sun.source.tree.Tree$Kind;
              getModuleType(): sun.source.tree.ModuleTree$ModuleKind;
              getName(): JCTree$JCExpression;
              getName(): sun.source.tree.ExpressionTree;
              getTag(): JCTree$Tag;
              directives: javac.util.List<JCTree$JCDirective>;
              _kind: sun.source.tree.ModuleTree$ModuleKind;
              mods: JCTree$JCModifiers;
              qualId: JCTree$JCExpression;
              sym: javac.code.Symbol$ModuleSymbol;
              type: javac.code.Type$ModuleType;
            }
            interface JCTree$JCModuleDecl extends CombineTypes<[_JCTree$JCModuleDecl, com.sun.tools.javac.tree.JCTree, com.sun.source.tree.ModuleTree]> {}
            interface _JCTree$JCNewArray$$static extends ClassLike {
              _new(elemtype: JCTree$JCExpression, dims: javac.util.List<JCTree$JCExpression>, elems: javac.util.List<JCTree$JCExpression>): JCTree$JCNewArray;
            }
            let JCTree$JCNewArray: _JCTree$JCNewArray$$static;
            interface _JCTree$JCNewArray {
              accept(v: JCTree$Visitor): void;
              accept<R, D>(v: sun.source.tree.TreeVisitor<R,D>, d: D): R;
              getAnnotations(): javac.util.List<JCTree$JCAnnotation>;
              getAnnotations(): java.util.List;
              getDimAnnotations(): javac.util.List<javac.util.List<JCTree$JCAnnotation>>;
              getDimAnnotations(): java.util.List;
              getDimensions(): javac.util.List<JCTree$JCExpression>;
              getDimensions(): java.util.List;
              getInitializers(): javac.util.List<JCTree$JCExpression>;
              getInitializers(): java.util.List;
              getKind(): sun.source.tree.Tree$Kind;
              getTag(): JCTree$Tag;
              getType(): JCTree$JCExpression;
              getType(): sun.source.tree.Tree;
              annotations: javac.util.List<JCTree$JCAnnotation>;
              dimAnnotations: javac.util.List<javac.util.List<JCTree$JCAnnotation>>;
              dims: javac.util.List<JCTree$JCExpression>;
              elems: javac.util.List<JCTree$JCExpression>;
              elemtype: JCTree$JCExpression;
            }
            interface JCTree$JCNewArray extends CombineTypes<[_JCTree$JCNewArray, com.sun.tools.javac.tree.JCTree$JCExpression, com.sun.source.tree.NewArrayTree]> {}
            interface _JCTree$JCNewClass$$static extends ClassLike {
              _new(encl: JCTree$JCExpression, typeargs: javac.util.List<JCTree$JCExpression>, clazz: JCTree$JCExpression, args: javac.util.List<JCTree$JCExpression>, def: JCTree$JCClassDecl): JCTree$JCNewClass;
            }
            let JCTree$JCNewClass: _JCTree$JCNewClass$$static;
            interface _JCTree$JCNewClass {
              accept(v: JCTree$Visitor): void;
              accept<R, D>(v: sun.source.tree.TreeVisitor<R,D>, d: D): R;
              classDeclRemoved(): boolean;
              getArguments(): javac.util.List<JCTree$JCExpression>;
              getArguments(): java.util.List;
              getClassBody(): JCTree$JCClassDecl;
              getClassBody(): sun.source.tree.ClassTree;
              getEnclosingExpression(): JCTree$JCExpression;
              getEnclosingExpression(): sun.source.tree.ExpressionTree;
              getIdentifier(): JCTree$JCExpression;
              getIdentifier(): sun.source.tree.ExpressionTree;
              getKind(): sun.source.tree.Tree$Kind;
              getTag(): JCTree$Tag;
              getTypeArguments(): javac.util.List<JCTree$JCExpression>;
              getTypeArguments(): java.util.List;
              /** @renamed-from constructor */_constructor: javac.code.Symbol;
              args: javac.util.List<JCTree$JCExpression>;
              clazz: JCTree$JCExpression;
              constructorType: javac.code.Type;
              def: JCTree$JCClassDecl;
              encl: JCTree$JCExpression;
              typeargs: javac.util.List<JCTree$JCExpression>;
              varargsElement: javac.code.Type;
              /** @renamed-to _constructor */constructor: javac.code.Symbol;
            }
            interface JCTree$JCNewClass extends CombineTypes<[_JCTree$JCNewClass, com.sun.tools.javac.tree.JCTree$JCPolyExpression, com.sun.source.tree.NewClassTree]> {}
            interface _JCTree$JCOpens$$static extends ClassLike {
              _new(qualId: JCTree$JCExpression, moduleNames: javac.util.List<JCTree$JCExpression>): JCTree$JCOpens;
            }
            let JCTree$JCOpens: _JCTree$JCOpens$$static;
            interface _JCTree$JCOpens {
              accept(v: JCTree$Visitor): void;
              accept<R, D>(v: sun.source.tree.TreeVisitor<R,D>, d: D): R;
              getKind(): sun.source.tree.Tree$Kind;
              getModuleNames(): javac.util.List<JCTree$JCExpression>;
              getModuleNames(): java.util.List;
              getPackageName(): JCTree$JCExpression;
              getPackageName(): sun.source.tree.ExpressionTree;
              getTag(): JCTree$Tag;
              directive: javac.code.Directive$OpensDirective;
              moduleNames: javac.util.List<JCTree$JCExpression>;
              qualid: JCTree$JCExpression;
            }
            interface JCTree$JCOpens extends CombineTypes<[_JCTree$JCOpens, com.sun.tools.javac.tree.JCTree$JCDirective, com.sun.source.tree.OpensTree]> {}
            interface _JCTree$JCOperatorExpression$$static extends ClassLike {
              new(): JCTree$JCOperatorExpression;
            }
            let JCTree$JCOperatorExpression: _JCTree$JCOperatorExpression$$static;
            interface _JCTree$JCOperatorExpression {
              getOperand(a0: JCTree$JCOperatorExpression$OperandPos): JCTree$JCExpression;
(a0: JCTree$JCOperatorExpression$OperandPos): JCTree$JCExpression;
              getOperator(): javac.code.Symbol$OperatorSymbol;
              getTag(): JCTree$Tag;
              _opcode: JCTree$Tag;
              operator: javac.code.Symbol$OperatorSymbol;
            }
            interface JCTree$JCOperatorExpression extends CombineTypes<[_JCTree$JCOperatorExpression, com.sun.tools.javac.tree.JCTree$JCExpression]> {}
            interface _JCTree$JCOperatorExpression$OperandPos$$static extends ClassLike {
              valueOf(name: string): JCTree$JCOperatorExpression$OperandPos;
              values(): JCTree$JCOperatorExpression$OperandPos[];
              readonly LEFT: JCTree$JCOperatorExpression$OperandPos;
              readonly RIGHT: JCTree$JCOperatorExpression$OperandPos;
            }
            let JCTree$JCOperatorExpression$OperandPos: _JCTree$JCOperatorExpression$OperandPos$$static;
            interface _JCTree$JCOperatorExpression$OperandPos {
            }
            interface JCTree$JCOperatorExpression$OperandPos extends CombineTypes<[_JCTree$JCOperatorExpression$OperandPos]> {}
            interface _JCTree$JCPackageDecl$$static extends ClassLike {
              new(annotations: javac.util.List<JCTree$JCAnnotation>, pid: JCTree$JCExpression): JCTree$JCPackageDecl;
            }
            let JCTree$JCPackageDecl: _JCTree$JCPackageDecl$$static;
            interface _JCTree$JCPackageDecl {
              accept(v: JCTree$Visitor): void;
              accept<R, D>(v: sun.source.tree.TreeVisitor<R,D>, d: D): R;
              getAnnotations(): javac.util.List<JCTree$JCAnnotation>;
              getAnnotations(): java.util.List;
              getKind(): sun.source.tree.Tree$Kind;
              getPackageName(): JCTree$JCExpression;
              getPackageName(): sun.source.tree.ExpressionTree;
              getTag(): JCTree$Tag;
              annotations: javac.util.List<JCTree$JCAnnotation>;
              packge: javac.code.Symbol$PackageSymbol;
              pid: JCTree$JCExpression;
            }
            interface JCTree$JCPackageDecl extends CombineTypes<[_JCTree$JCPackageDecl, com.sun.tools.javac.tree.JCTree, com.sun.source.tree.PackageTree]> {}
            interface _JCTree$JCParens$$static extends ClassLike {
              _new(expr: JCTree$JCExpression): JCTree$JCParens;
            }
            let JCTree$JCParens: _JCTree$JCParens$$static;
            interface _JCTree$JCParens {
              accept(v: JCTree$Visitor): void;
              accept<R, D>(v: sun.source.tree.TreeVisitor<R,D>, d: D): R;
              getExpression(): JCTree$JCExpression;
              getExpression(): sun.source.tree.ExpressionTree;
              getKind(): sun.source.tree.Tree$Kind;
              getTag(): JCTree$Tag;
              expr: JCTree$JCExpression;
            }
            interface JCTree$JCParens extends CombineTypes<[_JCTree$JCParens, com.sun.tools.javac.tree.JCTree$JCExpression, com.sun.source.tree.ParenthesizedTree]> {}
            interface _JCTree$JCPattern$$static extends ClassLike {
              new(): JCTree$JCPattern;
            }
            let JCTree$JCPattern: _JCTree$JCPattern$$static;
            interface _JCTree$JCPattern {
            }
            interface JCTree$JCPattern extends CombineTypes<[_JCTree$JCPattern, com.sun.source.tree.PatternTree, com.sun.tools.javac.tree.JCTree]> {}
            interface _JCTree$JCPatternCaseLabel$$static extends ClassLike {
              _new(pat: JCTree$JCPattern): JCTree$JCPatternCaseLabel;
            }
            let JCTree$JCPatternCaseLabel: _JCTree$JCPatternCaseLabel$$static;
            interface _JCTree$JCPatternCaseLabel {
              accept(v: JCTree$Visitor): void;
              accept<R, D>(v: sun.source.tree.TreeVisitor<R,D>, d: D): R;
              getKind(): sun.source.tree.Tree$Kind;
              getPattern(): JCTree$JCPattern;
              getPattern(): sun.source.tree.PatternTree;
              getTag(): JCTree$Tag;
              pat: JCTree$JCPattern;
              syntheticGuard: JCTree$JCExpression;
            }
            interface JCTree$JCPatternCaseLabel extends CombineTypes<[_JCTree$JCPatternCaseLabel, com.sun.source.tree.PatternCaseLabelTree, com.sun.tools.javac.tree.JCTree$JCCaseLabel]> {}
            interface _JCTree$JCPolyExpression$$static extends ClassLike {
              new(): JCTree$JCPolyExpression;
            }
            let JCTree$JCPolyExpression: _JCTree$JCPolyExpression$$static;
            interface _JCTree$JCPolyExpression {
              isPoly(): boolean;
              isStandalone(): boolean;
              polyKind: JCTree$JCPolyExpression$PolyKind;
            }
            interface JCTree$JCPolyExpression extends CombineTypes<[_JCTree$JCPolyExpression, com.sun.tools.javac.tree.JCTree$JCExpression]> {}
            interface _JCTree$JCPolyExpression$PolyKind$$static extends ClassLike {
              valueOf(name: string): JCTree$JCPolyExpression$PolyKind;
              values(): JCTree$JCPolyExpression$PolyKind[];
              readonly POLY: JCTree$JCPolyExpression$PolyKind;
              readonly STANDALONE: JCTree$JCPolyExpression$PolyKind;
            }
            let JCTree$JCPolyExpression$PolyKind: _JCTree$JCPolyExpression$PolyKind$$static;
            interface _JCTree$JCPolyExpression$PolyKind {
            }
            interface JCTree$JCPolyExpression$PolyKind extends CombineTypes<[_JCTree$JCPolyExpression$PolyKind]> {}
            interface _JCTree$JCPrimitiveTypeTree$$static extends ClassLike {
              _new(typetag: javac.code.TypeTag): JCTree$JCPrimitiveTypeTree;
            }
            let JCTree$JCPrimitiveTypeTree: _JCTree$JCPrimitiveTypeTree$$static;
            interface _JCTree$JCPrimitiveTypeTree {
              accept(v: JCTree$Visitor): void;
              accept<R, D>(v: sun.source.tree.TreeVisitor<R,D>, d: D): R;
              getKind(): sun.source.tree.Tree$Kind;
              getPrimitiveTypeKind(): javax.lang.model.type.TypeKind;
              getTag(): JCTree$Tag;
              typetag: javac.code.TypeTag;
            }
            interface JCTree$JCPrimitiveTypeTree extends CombineTypes<[_JCTree$JCPrimitiveTypeTree, com.sun.tools.javac.tree.JCTree$JCExpression, com.sun.source.tree.PrimitiveTypeTree]> {}
            interface _JCTree$JCProvides$$static extends ClassLike {
              _new(serviceName: JCTree$JCExpression, implNames: javac.util.List<JCTree$JCExpression>): JCTree$JCProvides;
            }
            let JCTree$JCProvides: _JCTree$JCProvides$$static;
            interface _JCTree$JCProvides {
              accept(v: JCTree$Visitor): void;
              accept<R, D>(v: sun.source.tree.TreeVisitor<R,D>, d: D): R;
              getImplementationNames(): javac.util.List<JCTree$JCExpression>;
              getImplementationNames(): java.util.List;
              getKind(): sun.source.tree.Tree$Kind;
              getServiceName(): JCTree$JCExpression;
              getServiceName(): sun.source.tree.ExpressionTree;
              getTag(): JCTree$Tag;
              implNames: javac.util.List<JCTree$JCExpression>;
              serviceName: JCTree$JCExpression;
            }
            interface JCTree$JCProvides extends CombineTypes<[_JCTree$JCProvides, com.sun.tools.javac.tree.JCTree$JCDirective, com.sun.source.tree.ProvidesTree]> {}
            interface _JCTree$JCRecordPattern$$static extends ClassLike {
              _new(deconstructor: JCTree$JCExpression, nested: javac.util.List<JCTree$JCPattern>): JCTree$JCRecordPattern;
            }
            let JCTree$JCRecordPattern: _JCTree$JCRecordPattern$$static;
            interface _JCTree$JCRecordPattern {
              accept(v: JCTree$Visitor): void;
              accept<R, D>(v: sun.source.tree.TreeVisitor<R,D>, d: D): R;
              getBinding(): javac.util.Name;
              getDeconstructor(): sun.source.tree.ExpressionTree;
              getKind(): sun.source.tree.Tree$Kind;
              getNestedPatterns(): javac.util.List<JCTree$JCPattern>;
              getNestedPatterns(): java.util.List;
              getTag(): JCTree$Tag;
              deconstructor: JCTree$JCExpression;
              fullComponentTypes: javac.util.List<javac.code.Type>;
              nested: javac.util.List<JCTree$JCPattern>;
              record: javac.code.Symbol$ClassSymbol;
            }
            interface JCTree$JCRecordPattern extends CombineTypes<[_JCTree$JCRecordPattern, com.sun.tools.javac.tree.JCTree$JCPattern, com.sun.source.tree.DeconstructionPatternTree]> {}
            interface _JCTree$JCRequires$$static extends ClassLike {
              _new(isTransitive: boolean, isStaticPhase: boolean, moduleName: JCTree$JCExpression): JCTree$JCRequires;
            }
            let JCTree$JCRequires: _JCTree$JCRequires$$static;
            interface _JCTree$JCRequires {
              accept(v: JCTree$Visitor): void;
              accept<R, D>(v: sun.source.tree.TreeVisitor<R,D>, d: D): R;
              getKind(): sun.source.tree.Tree$Kind;
              getModuleName(): JCTree$JCExpression;
              getModuleName(): sun.source.tree.ExpressionTree;
              getTag(): JCTree$Tag;
              isStatic(): boolean;
              isTransitive(): boolean;
              directive: javac.code.Directive$RequiresDirective;
              isStaticPhase: boolean;
              isTransitive: boolean;
              moduleName: JCTree$JCExpression;
            }
            interface JCTree$JCRequires extends CombineTypes<[_JCTree$JCRequires, com.sun.tools.javac.tree.JCTree$JCDirective, com.sun.source.tree.RequiresTree]> {}
            interface _JCTree$JCReturn$$static extends ClassLike {
              _new(expr: JCTree$JCExpression): JCTree$JCReturn;
            }
            let JCTree$JCReturn: _JCTree$JCReturn$$static;
            interface _JCTree$JCReturn {
              accept(v: JCTree$Visitor): void;
              accept<R, D>(v: sun.source.tree.TreeVisitor<R,D>, d: D): R;
              getExpression(): JCTree$JCExpression;
              getExpression(): sun.source.tree.ExpressionTree;
              getKind(): sun.source.tree.Tree$Kind;
              getTag(): JCTree$Tag;
              expr: JCTree$JCExpression;
            }
            interface JCTree$JCReturn extends CombineTypes<[_JCTree$JCReturn, com.sun.source.tree.ReturnTree, com.sun.tools.javac.tree.JCTree$JCStatement]> {}
            interface _JCTree$JCSkip$$static extends ClassLike {
              _new(): JCTree$JCSkip;
            }
            let JCTree$JCSkip: _JCTree$JCSkip$$static;
            interface _JCTree$JCSkip {
              accept(v: JCTree$Visitor): void;
              accept<R, D>(v: sun.source.tree.TreeVisitor<R,D>, d: D): R;
              getKind(): sun.source.tree.Tree$Kind;
              getTag(): JCTree$Tag;
            }
            interface JCTree$JCSkip extends CombineTypes<[_JCTree$JCSkip, com.sun.source.tree.EmptyStatementTree, com.sun.tools.javac.tree.JCTree$JCStatement]> {}
            interface _JCTree$JCStatement$$static extends ClassLike {
              new(): JCTree$JCStatement;
            }
            let JCTree$JCStatement: _JCTree$JCStatement$$static;
            interface _JCTree$JCStatement {
              setPos(pos: int): JCTree$JCStatement;
              setPos(a0: int): JCTree;
              setType(type: javac.code.Type): JCTree$JCStatement;
              setType(a0: javac.code.Type): JCTree;
            }
            interface JCTree$JCStatement extends CombineTypes<[_JCTree$JCStatement, com.sun.source.tree.StatementTree, com.sun.tools.javac.tree.JCTree]> {}
            interface _JCTree$JCStringTemplate$$static extends ClassLike {
              _new(processor: JCTree$JCExpression, fragments: javac.util.List<string>, expressions: javac.util.List<JCTree$JCExpression>): JCTree$JCStringTemplate;
            }
            let JCTree$JCStringTemplate: _JCTree$JCStringTemplate$$static;
            interface _JCTree$JCStringTemplate {
              accept(v: JCTree$Visitor): void;
              accept<R, D>(v: sun.source.tree.TreeVisitor<R,D>, d: D): R;
              getExpressions(): javac.util.List<sun.source.tree.ExpressionTree>;
              getExpressions(): java.util.List;
              getFragments(): javac.util.List<string>;
              getFragments(): java.util.List;
              getKind(): sun.source.tree.Tree$Kind;
              getProcessor(): sun.source.tree.ExpressionTree;
              getTag(): JCTree$Tag;
              expressions: javac.util.List<JCTree$JCExpression>;
              fragments: javac.util.List<string>;
              processor: JCTree$JCExpression;
            }
            interface JCTree$JCStringTemplate extends CombineTypes<[_JCTree$JCStringTemplate, com.sun.tools.javac.tree.JCTree$JCExpression, com.sun.source.tree.StringTemplateTree]> {}
            interface _JCTree$JCSwitch$$static extends ClassLike {
              _new(selector: JCTree$JCExpression, cases: javac.util.List<JCTree$JCCase>): JCTree$JCSwitch;
            }
            let JCTree$JCSwitch: _JCTree$JCSwitch$$static;
            interface _JCTree$JCSwitch {
              accept(v: JCTree$Visitor): void;
              accept<R, D>(v: sun.source.tree.TreeVisitor<R,D>, d: D): R;
              getCases(): javac.util.List<JCTree$JCCase>;
              getCases(): java.util.List;
              getExpression(): JCTree$JCExpression;
              getExpression(): sun.source.tree.ExpressionTree;
              getKind(): sun.source.tree.Tree$Kind;
              getTag(): JCTree$Tag;
              cases: javac.util.List<JCTree$JCCase>;
              endpos: int;
              hasUnconditionalPattern: boolean;
              isExhaustive: boolean;
              patternSwitch: boolean;
              selector: JCTree$JCExpression;
              wasEnumSelector: boolean;
            }
            interface JCTree$JCSwitch extends CombineTypes<[_JCTree$JCSwitch, com.sun.tools.javac.tree.JCTree$JCStatement, com.sun.source.tree.SwitchTree]> {}
            interface _JCTree$JCSwitchExpression$$static extends ClassLike {
              _new(selector: JCTree$JCExpression, cases: javac.util.List<JCTree$JCCase>): JCTree$JCSwitchExpression;
            }
            let JCTree$JCSwitchExpression: _JCTree$JCSwitchExpression$$static;
            interface _JCTree$JCSwitchExpression {
              accept(v: JCTree$Visitor): void;
              accept<R, D>(v: sun.source.tree.TreeVisitor<R,D>, d: D): R;
              getCases(): javac.util.List<JCTree$JCCase>;
              getCases(): java.util.List;
              getExpression(): JCTree$JCExpression;
              getExpression(): sun.source.tree.ExpressionTree;
              getKind(): sun.source.tree.Tree$Kind;
              getTag(): JCTree$Tag;
              cases: javac.util.List<JCTree$JCCase>;
              endpos: int;
              hasUnconditionalPattern: boolean;
              isExhaustive: boolean;
              patternSwitch: boolean;
              selector: JCTree$JCExpression;
              wasEnumSelector: boolean;
            }
            interface JCTree$JCSwitchExpression extends CombineTypes<[_JCTree$JCSwitchExpression, com.sun.source.tree.SwitchExpressionTree, com.sun.tools.javac.tree.JCTree$JCPolyExpression]> {}
            interface _JCTree$JCSynchronized$$static extends ClassLike {
              _new(lock: JCTree$JCExpression, body: JCTree$JCBlock): JCTree$JCSynchronized;
            }
            let JCTree$JCSynchronized: _JCTree$JCSynchronized$$static;
            interface _JCTree$JCSynchronized {
              accept(v: JCTree$Visitor): void;
              accept<R, D>(v: sun.source.tree.TreeVisitor<R,D>, d: D): R;
              getBlock(): JCTree$JCBlock;
              getBlock(): sun.source.tree.BlockTree;
              getExpression(): JCTree$JCExpression;
              getExpression(): sun.source.tree.ExpressionTree;
              getKind(): sun.source.tree.Tree$Kind;
              getTag(): JCTree$Tag;
              body: JCTree$JCBlock;
              lock: JCTree$JCExpression;
            }
            interface JCTree$JCSynchronized extends CombineTypes<[_JCTree$JCSynchronized, com.sun.source.tree.SynchronizedTree, com.sun.tools.javac.tree.JCTree$JCStatement]> {}
            interface _JCTree$JCThrow$$static extends ClassLike {
              _new(expr: JCTree$JCExpression): JCTree$JCThrow;
            }
            let JCTree$JCThrow: _JCTree$JCThrow$$static;
            interface _JCTree$JCThrow {
              accept(v: JCTree$Visitor): void;
              accept<R, D>(v: sun.source.tree.TreeVisitor<R,D>, d: D): R;
              getExpression(): JCTree$JCExpression;
              getExpression(): sun.source.tree.ExpressionTree;
              getKind(): sun.source.tree.Tree$Kind;
              getTag(): JCTree$Tag;
              expr: JCTree$JCExpression;
            }
            interface JCTree$JCThrow extends CombineTypes<[_JCTree$JCThrow, com.sun.source.tree.ThrowTree, com.sun.tools.javac.tree.JCTree$JCStatement]> {}
            interface _JCTree$JCTry$$static extends ClassLike {
              _new(resources: javac.util.List<JCTree>, body: JCTree$JCBlock, catchers: javac.util.List<JCTree$JCCatch>, finalizer: JCTree$JCBlock): JCTree$JCTry;
            }
            let JCTree$JCTry: _JCTree$JCTry$$static;
            interface _JCTree$JCTry {
              accept(v: JCTree$Visitor): void;
              accept<R, D>(v: sun.source.tree.TreeVisitor<R,D>, d: D): R;
              getBlock(): JCTree$JCBlock;
              getBlock(): sun.source.tree.BlockTree;
              getCatches(): javac.util.List<JCTree$JCCatch>;
              getCatches(): java.util.List;
              getFinallyBlock(): JCTree$JCBlock;
              getFinallyBlock(): sun.source.tree.BlockTree;
              getKind(): sun.source.tree.Tree$Kind;
              getResources(): javac.util.List<JCTree>;
              getResources(): java.util.List;
              getTag(): JCTree$Tag;
              body: JCTree$JCBlock;
              catchers: javac.util.List<JCTree$JCCatch>;
              finalizer: JCTree$JCBlock;
              finallyCanCompleteNormally: boolean;
              resources: javac.util.List<JCTree>;
            }
            interface JCTree$JCTry extends CombineTypes<[_JCTree$JCTry, com.sun.source.tree.TryTree, com.sun.tools.javac.tree.JCTree$JCStatement]> {}
            interface _JCTree$JCTypeApply$$static extends ClassLike {
              _new(clazz: JCTree$JCExpression, arguments: javac.util.List<JCTree$JCExpression>): JCTree$JCTypeApply;
            }
            let JCTree$JCTypeApply: _JCTree$JCTypeApply$$static;
            interface _JCTree$JCTypeApply {
              accept(v: JCTree$Visitor): void;
              accept<R, D>(v: sun.source.tree.TreeVisitor<R,D>, d: D): R;
              getKind(): sun.source.tree.Tree$Kind;
              getTag(): JCTree$Tag;
              getType(): JCTree;
              getType(): sun.source.tree.Tree;
              getTypeArguments(): javac.util.List<JCTree$JCExpression>;
              getTypeArguments(): java.util.List;
              arguments: javac.util.List<JCTree$JCExpression>;
              clazz: JCTree$JCExpression;
            }
            interface JCTree$JCTypeApply extends CombineTypes<[_JCTree$JCTypeApply, com.sun.source.tree.ParameterizedTypeTree, com.sun.tools.javac.tree.JCTree$JCExpression]> {}
            interface _JCTree$JCTypeCast$$static extends ClassLike {
              _new(clazz: JCTree, expr: JCTree$JCExpression): JCTree$JCTypeCast;
            }
            let JCTree$JCTypeCast: _JCTree$JCTypeCast$$static;
            interface _JCTree$JCTypeCast {
              accept(v: JCTree$Visitor): void;
              accept<R, D>(v: sun.source.tree.TreeVisitor<R,D>, d: D): R;
              getExpression(): JCTree$JCExpression;
              getExpression(): sun.source.tree.ExpressionTree;
              getKind(): sun.source.tree.Tree$Kind;
              getTag(): JCTree$Tag;
              getType(): JCTree;
              getType(): sun.source.tree.Tree;
              clazz: JCTree;
              expr: JCTree$JCExpression;
            }
            interface JCTree$JCTypeCast extends CombineTypes<[_JCTree$JCTypeCast, com.sun.source.tree.TypeCastTree, com.sun.tools.javac.tree.JCTree$JCExpression]> {}
            interface _JCTree$JCTypeIntersection$$static extends ClassLike {
              _new(bounds: javac.util.List<JCTree$JCExpression>): JCTree$JCTypeIntersection;
            }
            let JCTree$JCTypeIntersection: _JCTree$JCTypeIntersection$$static;
            interface _JCTree$JCTypeIntersection {
              accept(v: JCTree$Visitor): void;
              accept<R, D>(v: sun.source.tree.TreeVisitor<R,D>, d: D): R;
              getBounds(): javac.util.List<JCTree$JCExpression>;
              getBounds(): java.util.List;
              getKind(): sun.source.tree.Tree$Kind;
              getTag(): JCTree$Tag;
              bounds: javac.util.List<JCTree$JCExpression>;
            }
            interface JCTree$JCTypeIntersection extends CombineTypes<[_JCTree$JCTypeIntersection, com.sun.tools.javac.tree.JCTree$JCExpression, com.sun.source.tree.IntersectionTypeTree]> {}
            interface _JCTree$JCTypeParameter$$static extends ClassLike {
              _new(name: javac.util.Name, bounds: javac.util.List<JCTree$JCExpression>, annotations: javac.util.List<JCTree$JCAnnotation>): JCTree$JCTypeParameter;
            }
            let JCTree$JCTypeParameter: _JCTree$JCTypeParameter$$static;
            interface _JCTree$JCTypeParameter {
              accept(v: JCTree$Visitor): void;
              accept<R, D>(v: sun.source.tree.TreeVisitor<R,D>, d: D): R;
              getAnnotations(): javac.util.List<JCTree$JCAnnotation>;
              getAnnotations(): java.util.List;
              getBounds(): javac.util.List<JCTree$JCExpression>;
              getBounds(): java.util.List;
              getKind(): sun.source.tree.Tree$Kind;
              getName(): javac.util.Name;
              getName(): javax.lang.model.element.Name;
              getTag(): JCTree$Tag;
              annotations: javac.util.List<JCTree$JCAnnotation>;
              bounds: javac.util.List<JCTree$JCExpression>;
              name: javac.util.Name;
            }
            interface JCTree$JCTypeParameter extends CombineTypes<[_JCTree$JCTypeParameter, com.sun.tools.javac.tree.JCTree, com.sun.source.tree.TypeParameterTree]> {}
            interface _JCTree$JCTypeUnion$$static extends ClassLike {
              _new(components: javac.util.List<JCTree$JCExpression>): JCTree$JCTypeUnion;
            }
            let JCTree$JCTypeUnion: _JCTree$JCTypeUnion$$static;
            interface _JCTree$JCTypeUnion {
              accept(v: JCTree$Visitor): void;
              accept<R, D>(v: sun.source.tree.TreeVisitor<R,D>, d: D): R;
              getKind(): sun.source.tree.Tree$Kind;
              getTag(): JCTree$Tag;
              getTypeAlternatives(): javac.util.List<JCTree$JCExpression>;
              getTypeAlternatives(): java.util.List;
              alternatives: javac.util.List<JCTree$JCExpression>;
            }
            interface JCTree$JCTypeUnion extends CombineTypes<[_JCTree$JCTypeUnion, com.sun.tools.javac.tree.JCTree$JCExpression, com.sun.source.tree.UnionTypeTree]> {}
            interface _JCTree$JCUnary$$static extends ClassLike {
              _new(opcode: JCTree$Tag, arg: JCTree$JCExpression): JCTree$JCUnary;
            }
            let JCTree$JCUnary: _JCTree$JCUnary$$static;
            interface _JCTree$JCUnary {
              accept(v: JCTree$Visitor): void;
              accept<R, D>(v: sun.source.tree.TreeVisitor<R,D>, d: D): R;
              getExpression(): JCTree$JCExpression;
              getExpression(): sun.source.tree.ExpressionTree;
              getKind(): sun.source.tree.Tree$Kind;
              getOperand(pos: JCTree$JCOperatorExpression$OperandPos): JCTree$JCExpression;
              setTag(tag: JCTree$Tag): void;
              arg: JCTree$JCExpression;
            }
            interface JCTree$JCUnary extends CombineTypes<[_JCTree$JCUnary, com.sun.source.tree.UnaryTree, com.sun.tools.javac.tree.JCTree$JCOperatorExpression]> {}
            interface _JCTree$JCUses$$static extends ClassLike {
              _new(qualId: JCTree$JCExpression): JCTree$JCUses;
            }
            let JCTree$JCUses: _JCTree$JCUses$$static;
            interface _JCTree$JCUses {
              accept(v: JCTree$Visitor): void;
              accept<R, D>(v: sun.source.tree.TreeVisitor<R,D>, d: D): R;
              getKind(): sun.source.tree.Tree$Kind;
              getServiceName(): JCTree$JCExpression;
              getServiceName(): sun.source.tree.ExpressionTree;
              getTag(): JCTree$Tag;
              qualid: JCTree$JCExpression;
            }
            interface JCTree$JCUses extends CombineTypes<[_JCTree$JCUses, com.sun.tools.javac.tree.JCTree$JCDirective, com.sun.source.tree.UsesTree]> {}
            interface _JCTree$JCVariableDecl$$static extends ClassLike {
              _new(mods: JCTree$JCModifiers, name: javac.util.Name, vartype: JCTree$JCExpression, init: JCTree$JCExpression, sym: javac.code.Symbol$VarSymbol): JCTree$JCVariableDecl;
              _new(mods: JCTree$JCModifiers, name: javac.util.Name, vartype: JCTree$JCExpression, init: JCTree$JCExpression, sym: javac.code.Symbol$VarSymbol, declaredUsingVar: boolean): JCTree$JCVariableDecl;
              _new(mods: JCTree$JCModifiers, nameexpr: JCTree$JCExpression, vartype: JCTree$JCExpression): JCTree$JCVariableDecl;
            }
            let JCTree$JCVariableDecl: _JCTree$JCVariableDecl$$static;
            interface _JCTree$JCVariableDecl {
              accept(v: JCTree$Visitor): void;
              accept<R, D>(v: sun.source.tree.TreeVisitor<R,D>, d: D): R;
              declaredUsingVar(): boolean;
              getInitializer(): JCTree$JCExpression;
              getInitializer(): sun.source.tree.ExpressionTree;
              getKind(): sun.source.tree.Tree$Kind;
              getModifiers(): JCTree$JCModifiers;
              getModifiers(): sun.source.tree.ModifiersTree;
              getName(): javac.util.Name;
              getName(): javax.lang.model.element.Name;
              getNameExpression(): JCTree$JCExpression;
              getNameExpression(): sun.source.tree.ExpressionTree;
              getTag(): JCTree$Tag;
              getType(): JCTree;
              getType(): sun.source.tree.Tree;
              isImplicitlyTyped(): boolean;
              _declaredUsingVar: boolean;
              init: JCTree$JCExpression;
              mods: JCTree$JCModifiers;
              name: javac.util.Name;
              nameexpr: JCTree$JCExpression;
              startPos: int;
              sym: javac.code.Symbol$VarSymbol;
              vartype: JCTree$JCExpression;
            }
            interface JCTree$JCVariableDecl extends CombineTypes<[_JCTree$JCVariableDecl, com.sun.tools.javac.tree.JCTree$JCStatement, com.sun.source.tree.VariableTree]> {}
            interface _JCTree$JCWhileLoop$$static extends ClassLike {
              _new(cond: JCTree$JCExpression, body: JCTree$JCStatement): JCTree$JCWhileLoop;
            }
            let JCTree$JCWhileLoop: _JCTree$JCWhileLoop$$static;
            interface _JCTree$JCWhileLoop {
              accept(v: JCTree$Visitor): void;
              accept<R, D>(v: sun.source.tree.TreeVisitor<R,D>, d: D): R;
              getCondition(): JCTree$JCExpression;
              getCondition(): sun.source.tree.ExpressionTree;
              getKind(): sun.source.tree.Tree$Kind;
              getStatement(): JCTree$JCStatement;
              getStatement(): sun.source.tree.StatementTree;
              getTag(): JCTree$Tag;
              body: JCTree$JCStatement;
              cond: JCTree$JCExpression;
            }
            interface JCTree$JCWhileLoop extends CombineTypes<[_JCTree$JCWhileLoop, com.sun.tools.javac.tree.JCTree$JCStatement, com.sun.source.tree.WhileLoopTree]> {}
            interface _JCTree$JCWildcard$$static extends ClassLike {
              _new(kind: JCTree$TypeBoundKind, inner: JCTree): JCTree$JCWildcard;
            }
            let JCTree$JCWildcard: _JCTree$JCWildcard$$static;
            interface _JCTree$JCWildcard {
              accept(v: JCTree$Visitor): void;
              accept<R, D>(v: sun.source.tree.TreeVisitor<R,D>, d: D): R;
              getBound(): JCTree;
              getBound(): sun.source.tree.Tree;
              getKind(): sun.source.tree.Tree$Kind;
              getTag(): JCTree$Tag;
              inner: JCTree;
              kind: JCTree$TypeBoundKind;
            }
            interface JCTree$JCWildcard extends CombineTypes<[_JCTree$JCWildcard, com.sun.tools.javac.tree.JCTree$JCExpression, com.sun.source.tree.WildcardTree]> {}
            interface _JCTree$JCYield$$static extends ClassLike {
              _new(value: JCTree$JCExpression, target: JCTree): JCTree$JCYield;
            }
            let JCTree$JCYield: _JCTree$JCYield$$static;
            interface _JCTree$JCYield {
              accept(v: JCTree$Visitor): void;
              accept<R, D>(v: sun.source.tree.TreeVisitor<R,D>, d: D): R;
              getKind(): sun.source.tree.Tree$Kind;
              getTag(): JCTree$Tag;
              getValue(): JCTree$JCExpression;
              getValue(): sun.source.tree.ExpressionTree;
              target: JCTree;
              value: JCTree$JCExpression;
            }
            interface JCTree$JCYield extends CombineTypes<[_JCTree$JCYield, com.sun.source.tree.YieldTree, com.sun.tools.javac.tree.JCTree$JCStatement]> {}
            interface _JCTree$LetExpr$$static extends ClassLike {
              _new(defs: javac.util.List<JCTree$JCStatement>, expr: JCTree$JCExpression): JCTree$LetExpr;
            }
            let JCTree$LetExpr: _JCTree$LetExpr$$static;
            interface _JCTree$LetExpr {
              accept(v: JCTree$Visitor): void;
              accept<R, D>(v: sun.source.tree.TreeVisitor<R,D>, d: D): R;
              getKind(): sun.source.tree.Tree$Kind;
              getTag(): JCTree$Tag;
              defs: javac.util.List<JCTree$JCStatement>;
              expr: JCTree$JCExpression;
              needsCond: boolean;
            }
            interface JCTree$LetExpr extends CombineTypes<[_JCTree$LetExpr, com.sun.tools.javac.tree.JCTree$JCExpression]> {}
            interface _JCTree$Tag$$static extends ClassLike {
              getNumberOfOperators(): int;
              valueOf(name: string): JCTree$Tag;
              values(): JCTree$Tag[];
              readonly AND: JCTree$Tag;
              readonly ANNOTATED_TYPE: JCTree$Tag;
              readonly ANNOTATION: JCTree$Tag;
              readonly ANYPATTERN: JCTree$Tag;
              readonly APPLY: JCTree$Tag;
              readonly ASSERT: JCTree$Tag;
              readonly ASSIGN: JCTree$Tag;
              readonly BINDINGPATTERN: JCTree$Tag;
              readonly BITAND: JCTree$Tag;
              readonly BITAND_ASG: JCTree$Tag;
              readonly BITOR: JCTree$Tag;
              readonly BITOR_ASG: JCTree$Tag;
              readonly BITXOR: JCTree$Tag;
              readonly BITXOR_ASG: JCTree$Tag;
              readonly BLOCK: JCTree$Tag;
              readonly BREAK: JCTree$Tag;
              readonly CASE: JCTree$Tag;
              readonly CATCH: JCTree$Tag;
              readonly CLASSDEF: JCTree$Tag;
              readonly COMPL: JCTree$Tag;
              readonly CONDEXPR: JCTree$Tag;
              readonly CONSTANTCASELABEL: JCTree$Tag;
              readonly CONTINUE: JCTree$Tag;
              readonly DEFAULTCASELABEL: JCTree$Tag;
              readonly DIV: JCTree$Tag;
              readonly DIV_ASG: JCTree$Tag;
              readonly DOLOOP: JCTree$Tag;
              readonly EQ: JCTree$Tag;
              readonly ERRONEOUS: JCTree$Tag;
              readonly EXEC: JCTree$Tag;
              readonly EXPORTS: JCTree$Tag;
              readonly FOREACHLOOP: JCTree$Tag;
              readonly FORLOOP: JCTree$Tag;
              readonly GE: JCTree$Tag;
              readonly GT: JCTree$Tag;
              readonly IDENT: JCTree$Tag;
              readonly IF: JCTree$Tag;
              readonly IMPORT: JCTree$Tag;
              readonly INDEXED: JCTree$Tag;
              readonly LABELLED: JCTree$Tag;
              readonly LAMBDA: JCTree$Tag;
              readonly LE: JCTree$Tag;
              readonly LETEXPR: JCTree$Tag;
              readonly LITERAL: JCTree$Tag;
              readonly LT: JCTree$Tag;
              readonly METHODDEF: JCTree$Tag;
              readonly MINUS: JCTree$Tag;
              readonly MINUS_ASG: JCTree$Tag;
              readonly MOD: JCTree$Tag;
              readonly MODIFIERS: JCTree$Tag;
              readonly MODULEDEF: JCTree$Tag;
              readonly MOD_ASG: JCTree$Tag;
              readonly MUL: JCTree$Tag;
              readonly MUL_ASG: JCTree$Tag;
              readonly NE: JCTree$Tag;
              readonly NEG: JCTree$Tag;
              readonly NEWARRAY: JCTree$Tag;
              readonly NEWCLASS: JCTree$Tag;
              readonly NOT: JCTree$Tag;
              readonly NO_TAG: JCTree$Tag;
              readonly NULLCHK: JCTree$Tag;
              readonly OPENS: JCTree$Tag;
              readonly OR: JCTree$Tag;
              readonly PACKAGEDEF: JCTree$Tag;
              readonly PARENS: JCTree$Tag;
              readonly PATTERNCASELABEL: JCTree$Tag;
              readonly PLUS: JCTree$Tag;
              readonly PLUS_ASG: JCTree$Tag;
              readonly POS: JCTree$Tag;
              readonly POSTDEC: JCTree$Tag;
              readonly POSTINC: JCTree$Tag;
              readonly PREDEC: JCTree$Tag;
              readonly PREINC: JCTree$Tag;
              readonly PROVIDES: JCTree$Tag;
              readonly RECORDPATTERN: JCTree$Tag;
              readonly REFERENCE: JCTree$Tag;
              readonly REQUIRES: JCTree$Tag;
              readonly RETURN: JCTree$Tag;
              readonly SELECT: JCTree$Tag;
              readonly SKIP: JCTree$Tag;
              readonly SL: JCTree$Tag;
              readonly SL_ASG: JCTree$Tag;
              readonly SR: JCTree$Tag;
              readonly SR_ASG: JCTree$Tag;
              readonly STRING_TEMPLATE: JCTree$Tag;
              readonly SWITCH: JCTree$Tag;
              readonly SWITCH_EXPRESSION: JCTree$Tag;
              readonly SYNCHRONIZED: JCTree$Tag;
              readonly THROW: JCTree$Tag;
              readonly TOPLEVEL: JCTree$Tag;
              readonly TRY: JCTree$Tag;
              readonly TYPEAPPLY: JCTree$Tag;
              readonly TYPEARRAY: JCTree$Tag;
              readonly TYPEBOUNDKIND: JCTree$Tag;
              readonly TYPECAST: JCTree$Tag;
              readonly TYPEIDENT: JCTree$Tag;
              readonly TYPEINTERSECTION: JCTree$Tag;
              readonly TYPEPARAMETER: JCTree$Tag;
              readonly TYPETEST: JCTree$Tag;
              readonly TYPEUNION: JCTree$Tag;
              readonly TYPE_ANNOTATION: JCTree$Tag;
              readonly USES: JCTree$Tag;
              readonly USR: JCTree$Tag;
              readonly USR_ASG: JCTree$Tag;
              readonly VARDEF: JCTree$Tag;
              readonly WHILELOOP: JCTree$Tag;
              readonly WILDCARD: JCTree$Tag;
              readonly YIELD: JCTree$Tag;
              _numberOfOperators: int;
            }
            let JCTree$Tag: _JCTree$Tag$$static;
            interface _JCTree$Tag {
              isAssignop(): boolean;
              isIncOrDecUnaryOp(): boolean;
              isPostUnaryOp(): boolean;
              noAssignOp(): JCTree$Tag;
              operatorIndex(): int;
              _noAssignTag: JCTree$Tag;
            }
            interface JCTree$Tag extends CombineTypes<[_JCTree$Tag]> {}
            interface _JCTree$TypeBoundKind$$static extends ClassLike {
              _new(kind: javac.code.BoundKind): JCTree$TypeBoundKind;
            }
            let JCTree$TypeBoundKind: _JCTree$TypeBoundKind$$static;
            interface _JCTree$TypeBoundKind {
              accept(v: JCTree$Visitor): void;
              accept<R, D>(v: sun.source.tree.TreeVisitor<R,D>, d: D): R;
              getKind(): sun.source.tree.Tree$Kind;
              getTag(): JCTree$Tag;
              kind: javac.code.BoundKind;
            }
            interface JCTree$TypeBoundKind extends CombineTypes<[_JCTree$TypeBoundKind, com.sun.tools.javac.tree.JCTree]> {}
            interface _JCTree$Visitor$$static extends ClassLike {
              new(): JCTree$Visitor;
            }
            let JCTree$Visitor: _JCTree$Visitor$$static;
            interface _JCTree$Visitor {
              visitAnnotatedType(that: JCTree$JCAnnotatedType): void;
              visitAnnotation(that: JCTree$JCAnnotation): void;
              visitAnyPattern(that: JCTree$JCAnyPattern): void;
              visitApply(that: JCTree$JCMethodInvocation): void;
              visitAssert(that: JCTree$JCAssert): void;
              visitAssign(that: JCTree$JCAssign): void;
              visitAssignop(that: JCTree$JCAssignOp): void;
              visitBinary(that: JCTree$JCBinary): void;
              visitBindingPattern(that: JCTree$JCBindingPattern): void;
              visitBlock(that: JCTree$JCBlock): void;
              visitBreak(that: JCTree$JCBreak): void;
              visitCase(that: JCTree$JCCase): void;
              visitCatch(that: JCTree$JCCatch): void;
              visitClassDef(that: JCTree$JCClassDecl): void;
              visitConditional(that: JCTree$JCConditional): void;
              visitConstantCaseLabel(that: JCTree$JCConstantCaseLabel): void;
              visitContinue(that: JCTree$JCContinue): void;
              visitDefaultCaseLabel(that: JCTree$JCDefaultCaseLabel): void;
              visitDoLoop(that: JCTree$JCDoWhileLoop): void;
              visitErroneous(that: JCTree$JCErroneous): void;
              visitExec(that: JCTree$JCExpressionStatement): void;
              visitExports(that: JCTree$JCExports): void;
              visitForLoop(that: JCTree$JCForLoop): void;
              visitForeachLoop(that: JCTree$JCEnhancedForLoop): void;
              visitIdent(that: JCTree$JCIdent): void;
              visitIf(that: JCTree$JCIf): void;
              visitImport(that: JCTree$JCImport): void;
              visitIndexed(that: JCTree$JCArrayAccess): void;
              visitLabelled(that: JCTree$JCLabeledStatement): void;
              visitLambda(that: JCTree$JCLambda): void;
              visitLetExpr(that: JCTree$LetExpr): void;
              visitLiteral(that: JCTree$JCLiteral): void;
              visitMethodDef(that: JCTree$JCMethodDecl): void;
              visitModifiers(that: JCTree$JCModifiers): void;
              visitModuleDef(that: JCTree$JCModuleDecl): void;
              visitNewArray(that: JCTree$JCNewArray): void;
              visitNewClass(that: JCTree$JCNewClass): void;
              visitOpens(that: JCTree$JCOpens): void;
              visitPackageDef(that: JCTree$JCPackageDecl): void;
              visitParens(that: JCTree$JCParens): void;
              visitPatternCaseLabel(that: JCTree$JCPatternCaseLabel): void;
              visitProvides(that: JCTree$JCProvides): void;
              visitRecordPattern(that: JCTree$JCRecordPattern): void;
              visitReference(that: JCTree$JCMemberReference): void;
              visitRequires(that: JCTree$JCRequires): void;
              visitReturn(that: JCTree$JCReturn): void;
              visitSelect(that: JCTree$JCFieldAccess): void;
              visitSkip(that: JCTree$JCSkip): void;
              visitStringTemplate(that: JCTree$JCStringTemplate): void;
              visitSwitch(that: JCTree$JCSwitch): void;
              visitSwitchExpression(that: JCTree$JCSwitchExpression): void;
              visitSynchronized(that: JCTree$JCSynchronized): void;
              visitThrow(that: JCTree$JCThrow): void;
              visitTopLevel(that: JCTree$JCCompilationUnit): void;
              visitTree(that: JCTree): void;
              visitTry(that: JCTree$JCTry): void;
              visitTypeApply(that: JCTree$JCTypeApply): void;
              visitTypeArray(that: JCTree$JCArrayTypeTree): void;
              visitTypeBoundKind(that: JCTree$TypeBoundKind): void;
              visitTypeCast(that: JCTree$JCTypeCast): void;
              visitTypeIdent(that: JCTree$JCPrimitiveTypeTree): void;
              visitTypeIntersection(that: JCTree$JCTypeIntersection): void;
              visitTypeParameter(that: JCTree$JCTypeParameter): void;
              visitTypeTest(that: JCTree$JCInstanceOf): void;
              visitTypeUnion(that: JCTree$JCTypeUnion): void;
              visitUnary(that: JCTree$JCUnary): void;
              visitUses(that: JCTree$JCUses): void;
              visitVarDef(that: JCTree$JCVariableDecl): void;
              visitWhileLoop(that: JCTree$JCWhileLoop): void;
              visitWildcard(that: JCTree$JCWildcard): void;
              visitYield(that: JCTree$JCYield): void;
            }
            interface JCTree$Visitor extends CombineTypes<[_JCTree$Visitor, java.lang.Object]> {}
            interface _Pretty$$static extends ClassLike {
              _lineEndPos(s: string, start: int): int;
              toSimpleString(tree: JCTree): string;
              toSimpleString(tree: JCTree, maxLength: int): string;
              _PREFERRED_LENGTH: int;
              _trimSequence: string;
              new(out: java.io.Writer, sourceOutput: boolean): Pretty;
            }
            let Pretty: _Pretty$$static;
            interface _Pretty {
              _align(): void;
              _close(contextPrec: int, ownPrec: int): void;
              _indent(): void;
              _isEnumerator(t: JCTree): boolean;
              _isUsed(t: javac.code.Symbol, cdef: JCTree): boolean;
              _open(contextPrec: int, ownPrec: int): void;
              operatorName(tag: JCTree$Tag): string;
              print(s: any): void;
              _print(c: char): void;
              printAnnotations(trees: javac.util.List<JCTree$JCAnnotation>): void;
              _printBaseElementType(tree: JCTree): void;
              printBlock(stats: javac.util.List<JCTree>): void;
              _printBrackets(tree: JCTree): void;
              printDocComment(tree: JCTree): void;
              printEnumBody(stats: javac.util.List<JCTree>): void;
              printExpr(tree: JCTree, prec: int): void;
              printExpr(tree: JCTree): void;
              printExprs<T>(trees: javac.util.List<T>, sep: string): void;
              printExprs<T>(trees: javac.util.List<T>): void;
              printFlags(flags: long): void;
              printPattern(tree: JCTree): void;
              printStat(tree: JCTree): void;
              printStats(trees: javac.util.List<JCTree>): void;
              printTypeAnnotations(trees: javac.util.List<JCTree$JCAnnotation>): void;
              printTypeParameters(trees: javac.util.List<JCTree$JCTypeParameter>): void;
              printUnit(tree: JCTree$JCCompilationUnit, cdef: JCTree$JCClassDecl): void;
              println(): void;
              _undent(): void;
              visitAnnotatedType(tree: JCTree$JCAnnotatedType): void;
              visitAnnotation(tree: JCTree$JCAnnotation): void;
              visitAnyPattern(patt: JCTree$JCAnyPattern): void;
              visitApply(tree: JCTree$JCMethodInvocation): void;
              visitAssert(tree: JCTree$JCAssert): void;
              visitAssign(tree: JCTree$JCAssign): void;
              visitAssignop(tree: JCTree$JCAssignOp): void;
              visitBinary(tree: JCTree$JCBinary): void;
              visitBindingPattern(patt: JCTree$JCBindingPattern): void;
              visitBlock(tree: JCTree$JCBlock): void;
              visitBreak(tree: JCTree$JCBreak): void;
              visitCase(tree: JCTree$JCCase): void;
              visitCatch(tree: JCTree$JCCatch): void;
              visitClassDef(tree: JCTree$JCClassDecl): void;
              visitConditional(tree: JCTree$JCConditional): void;
              visitConstantCaseLabel(tree: JCTree$JCConstantCaseLabel): void;
              visitContinue(tree: JCTree$JCContinue): void;
              visitDefaultCaseLabel(that: JCTree$JCDefaultCaseLabel): void;
              visitDoLoop(tree: JCTree$JCDoWhileLoop): void;
              visitErroneous(tree: JCTree$JCErroneous): void;
              visitExec(tree: JCTree$JCExpressionStatement): void;
              visitExports(tree: JCTree$JCExports): void;
              visitForLoop(tree: JCTree$JCForLoop): void;
              visitForeachLoop(tree: JCTree$JCEnhancedForLoop): void;
              visitIdent(tree: JCTree$JCIdent): void;
              visitIf(tree: JCTree$JCIf): void;
              visitImport(tree: JCTree$JCImport): void;
              visitIndexed(tree: JCTree$JCArrayAccess): void;
              visitLabelled(tree: JCTree$JCLabeledStatement): void;
              visitLambda(tree: JCTree$JCLambda): void;
              visitLetExpr(tree: JCTree$LetExpr): void;
              visitLiteral(tree: JCTree$JCLiteral): void;
              visitMethodDef(tree: JCTree$JCMethodDecl): void;
              visitModifiers(mods: JCTree$JCModifiers): void;
              visitModuleDef(tree: JCTree$JCModuleDecl): void;
              visitNewArray(tree: JCTree$JCNewArray): void;
              visitNewClass(tree: JCTree$JCNewClass): void;
              visitOpens(tree: JCTree$JCOpens): void;
              visitPackageDef(tree: JCTree$JCPackageDecl): void;
              visitParens(tree: JCTree$JCParens): void;
              visitPatternCaseLabel(tree: JCTree$JCPatternCaseLabel): void;
              visitProvides(tree: JCTree$JCProvides): void;
              visitRecordPattern(tree: JCTree$JCRecordPattern): void;
              visitReference(tree: JCTree$JCMemberReference): void;
              visitRequires(tree: JCTree$JCRequires): void;
              visitReturn(tree: JCTree$JCReturn): void;
              visitSelect(tree: JCTree$JCFieldAccess): void;
              visitSkip(tree: JCTree$JCSkip): void;
              visitStringTemplate(tree: JCTree$JCStringTemplate): void;
              visitSwitch(tree: JCTree$JCSwitch): void;
              visitSwitchExpression(tree: JCTree$JCSwitchExpression): void;
              visitSynchronized(tree: JCTree$JCSynchronized): void;
              visitThrow(tree: JCTree$JCThrow): void;
              visitTopLevel(tree: JCTree$JCCompilationUnit): void;
              visitTree(tree: JCTree): void;
              visitTry(tree: JCTree$JCTry): void;
              visitTypeApply(tree: JCTree$JCTypeApply): void;
              visitTypeArray(tree: JCTree$JCArrayTypeTree): void;
              visitTypeBoundKind(tree: JCTree$TypeBoundKind): void;
              visitTypeCast(tree: JCTree$JCTypeCast): void;
              visitTypeIdent(tree: JCTree$JCPrimitiveTypeTree): void;
              visitTypeIntersection(tree: JCTree$JCTypeIntersection): void;
              visitTypeParameter(tree: JCTree$JCTypeParameter): void;
              visitTypeTest(tree: JCTree$JCInstanceOf): void;
              visitTypeUnion(tree: JCTree$JCTypeUnion): void;
              visitUnary(tree: JCTree$JCUnary): void;
              visitUses(tree: JCTree$JCUses): void;
              visitVarDef(tree: JCTree$JCVariableDecl): void;
              visitWhileLoop(tree: JCTree$JCWhileLoop): void;
              visitWildcard(tree: JCTree$JCWildcard): void;
              visitYield(tree: JCTree$JCYield): void;
              _docComments: DocCommentTable;
              _enclClassName: javac.util.Name;
              _lineSep: string;
              _lmargin: int;
              _out: java.io.Writer;
              _prec: int;
              _sourceOutput: boolean;
              width: int;
            }
            interface Pretty extends CombineTypes<[_Pretty, com.sun.tools.javac.tree.JCTree$Visitor]> {}
            interface _TreeCopier$$static<P> extends ClassLike {
              new(M: TreeMaker): TreeCopier<P>;
            }
            let TreeCopier: _TreeCopier$$static<P>;
            interface _TreeCopier<P> {
              copy<T>(tree: T): T;
              copy<T>(tree: T, p: P): T;
              copy<T>(trees: javac.util.List<T>): javac.util.List<T>;
              copy<T>(trees: javac.util.List<T>, p: P): javac.util.List<T>;
              visitAnnotatedType(node: sun.source.tree.AnnotatedTypeTree, p: P): JCTree;
              visitAnnotatedType(a0: sun.source.tree.AnnotatedTypeTree, a1: any): any;
              visitAnnotation(node: sun.source.tree.AnnotationTree, p: P): JCTree;
              visitAnnotation(a0: sun.source.tree.AnnotationTree, a1: any): any;
              visitAnyPattern(node: sun.source.tree.AnyPatternTree, p: P): JCTree;
              visitAnyPattern(a0: sun.source.tree.AnyPatternTree, a1: any): any;
              visitArrayAccess(node: sun.source.tree.ArrayAccessTree, p: P): JCTree;
              visitArrayAccess(a0: sun.source.tree.ArrayAccessTree, a1: any): any;
              visitArrayType(node: sun.source.tree.ArrayTypeTree, p: P): JCTree;
              visitArrayType(a0: sun.source.tree.ArrayTypeTree, a1: any): any;
              visitAssert(node: sun.source.tree.AssertTree, p: P): JCTree;
              visitAssert(a0: sun.source.tree.AssertTree, a1: any): any;
              visitAssignment(node: sun.source.tree.AssignmentTree, p: P): JCTree;
              visitAssignment(a0: sun.source.tree.AssignmentTree, a1: any): any;
              visitBinary(node: sun.source.tree.BinaryTree, p: P): JCTree;
              visitBinary(a0: sun.source.tree.BinaryTree, a1: any): any;
              visitBindingPattern(node: sun.source.tree.BindingPatternTree, p: P): JCTree;
              visitBindingPattern(a0: sun.source.tree.BindingPatternTree, a1: any): any;
              visitBlock(node: sun.source.tree.BlockTree, p: P): JCTree;
              visitBlock(a0: sun.source.tree.BlockTree, a1: any): any;
              visitBreak(node: sun.source.tree.BreakTree, p: P): JCTree;
              visitBreak(a0: sun.source.tree.BreakTree, a1: any): any;
              visitCase(node: sun.source.tree.CaseTree, p: P): JCTree;
              visitCase(a0: sun.source.tree.CaseTree, a1: any): any;
              visitCatch(node: sun.source.tree.CatchTree, p: P): JCTree;
              visitCatch(a0: sun.source.tree.CatchTree, a1: any): any;
              visitClass(node: sun.source.tree.ClassTree, p: P): JCTree;
              visitClass(a0: sun.source.tree.ClassTree, a1: any): any;
              visitCompilationUnit(node: sun.source.tree.CompilationUnitTree, p: P): JCTree;
              visitCompilationUnit(a0: sun.source.tree.CompilationUnitTree, a1: any): any;
              visitCompoundAssignment(node: sun.source.tree.CompoundAssignmentTree, p: P): JCTree;
              visitCompoundAssignment(a0: sun.source.tree.CompoundAssignmentTree, a1: any): any;
              visitConditionalExpression(node: sun.source.tree.ConditionalExpressionTree, p: P): JCTree;
              visitConditionalExpression(a0: sun.source.tree.ConditionalExpressionTree, a1: any): any;
              visitConstantCaseLabel(node: sun.source.tree.ConstantCaseLabelTree, p: P): JCTree;
              visitConstantCaseLabel(a0: sun.source.tree.ConstantCaseLabelTree, a1: any): any;
              visitContinue(node: sun.source.tree.ContinueTree, p: P): JCTree;
              visitContinue(a0: sun.source.tree.ContinueTree, a1: any): any;
              visitDeconstructionPattern(node: sun.source.tree.DeconstructionPatternTree, p: P): JCTree;
              visitDeconstructionPattern(a0: sun.source.tree.DeconstructionPatternTree, a1: any): any;
              visitDefaultCaseLabel(node: sun.source.tree.DefaultCaseLabelTree, p: P): JCTree;
              visitDefaultCaseLabel(a0: sun.source.tree.DefaultCaseLabelTree, a1: any): any;
              visitDoWhileLoop(node: sun.source.tree.DoWhileLoopTree, p: P): JCTree;
              visitDoWhileLoop(a0: sun.source.tree.DoWhileLoopTree, a1: any): any;
              visitEmptyStatement(node: sun.source.tree.EmptyStatementTree, p: P): JCTree;
              visitEmptyStatement(a0: sun.source.tree.EmptyStatementTree, a1: any): any;
              visitEnhancedForLoop(node: sun.source.tree.EnhancedForLoopTree, p: P): JCTree;
              visitEnhancedForLoop(a0: sun.source.tree.EnhancedForLoopTree, a1: any): any;
              visitErroneous(node: sun.source.tree.ErroneousTree, p: P): JCTree;
              visitErroneous(a0: sun.source.tree.ErroneousTree, a1: any): any;
              visitExports(node: sun.source.tree.ExportsTree, p: P): JCTree$JCExports;
              visitExports(a0: sun.source.tree.ExportsTree, a1: any): any;
              visitExpressionStatement(node: sun.source.tree.ExpressionStatementTree, p: P): JCTree;
              visitExpressionStatement(a0: sun.source.tree.ExpressionStatementTree, a1: any): any;
              visitForLoop(node: sun.source.tree.ForLoopTree, p: P): JCTree;
              visitForLoop(a0: sun.source.tree.ForLoopTree, a1: any): any;
              visitIdentifier(node: sun.source.tree.IdentifierTree, p: P): JCTree;
              visitIdentifier(a0: sun.source.tree.IdentifierTree, a1: any): any;
              visitIf(node: sun.source.tree.IfTree, p: P): JCTree;
              visitIf(a0: sun.source.tree.IfTree, a1: any): any;
              visitImport(node: sun.source.tree.ImportTree, p: P): JCTree;
              visitImport(a0: sun.source.tree.ImportTree, a1: any): any;
              visitInstanceOf(node: sun.source.tree.InstanceOfTree, p: P): JCTree;
              visitInstanceOf(a0: sun.source.tree.InstanceOfTree, a1: any): any;
              visitIntersectionType(node: sun.source.tree.IntersectionTypeTree, p: P): JCTree;
              visitIntersectionType(a0: sun.source.tree.IntersectionTypeTree, a1: any): any;
              visitLabeledStatement(node: sun.source.tree.LabeledStatementTree, p: P): JCTree;
              visitLabeledStatement(a0: sun.source.tree.LabeledStatementTree, a1: any): any;
              visitLambdaExpression(node: sun.source.tree.LambdaExpressionTree, p: P): JCTree;
              visitLambdaExpression(a0: sun.source.tree.LambdaExpressionTree, a1: any): any;
              visitLiteral(node: sun.source.tree.LiteralTree, p: P): JCTree;
              visitLiteral(a0: sun.source.tree.LiteralTree, a1: any): any;
              visitMemberReference(node: sun.source.tree.MemberReferenceTree, p: P): JCTree;
              visitMemberReference(a0: sun.source.tree.MemberReferenceTree, a1: any): any;
              visitMemberSelect(node: sun.source.tree.MemberSelectTree, p: P): JCTree;
              visitMemberSelect(a0: sun.source.tree.MemberSelectTree, a1: any): any;
              visitMethod(node: sun.source.tree.MethodTree, p: P): JCTree;
              visitMethod(a0: sun.source.tree.MethodTree, a1: any): any;
              visitMethodInvocation(node: sun.source.tree.MethodInvocationTree, p: P): JCTree;
              visitMethodInvocation(a0: sun.source.tree.MethodInvocationTree, a1: any): any;
              visitModifiers(node: sun.source.tree.ModifiersTree, p: P): JCTree;
              visitModifiers(a0: sun.source.tree.ModifiersTree, a1: any): any;
              visitModule(node: sun.source.tree.ModuleTree, p: P): JCTree;
              visitModule(a0: sun.source.tree.ModuleTree, a1: any): any;
              visitNewArray(node: sun.source.tree.NewArrayTree, p: P): JCTree;
              visitNewArray(a0: sun.source.tree.NewArrayTree, a1: any): any;
              visitNewClass(node: sun.source.tree.NewClassTree, p: P): JCTree;
              visitNewClass(a0: sun.source.tree.NewClassTree, a1: any): any;
              visitOpens(node: sun.source.tree.OpensTree, p: P): JCTree$JCOpens;
              visitOpens(a0: sun.source.tree.OpensTree, a1: any): any;
              visitOther(node: sun.source.tree.Tree, p: P): JCTree;
              visitOther(a0: sun.source.tree.Tree, a1: any): any;
              visitPackage(node: sun.source.tree.PackageTree, p: P): JCTree;
              visitPackage(a0: sun.source.tree.PackageTree, a1: any): any;
              visitParameterizedType(node: sun.source.tree.ParameterizedTypeTree, p: P): JCTree;
              visitParameterizedType(a0: sun.source.tree.ParameterizedTypeTree, a1: any): any;
              visitParenthesized(node: sun.source.tree.ParenthesizedTree, p: P): JCTree;
              visitParenthesized(a0: sun.source.tree.ParenthesizedTree, a1: any): any;
              visitPatternCaseLabel(node: sun.source.tree.PatternCaseLabelTree, p: P): JCTree;
              visitPatternCaseLabel(a0: sun.source.tree.PatternCaseLabelTree, a1: any): any;
              visitPrimitiveType(node: sun.source.tree.PrimitiveTypeTree, p: P): JCTree;
              visitPrimitiveType(a0: sun.source.tree.PrimitiveTypeTree, a1: any): any;
              visitProvides(node: sun.source.tree.ProvidesTree, p: P): JCTree$JCProvides;
              visitProvides(a0: sun.source.tree.ProvidesTree, a1: any): any;
              visitRequires(node: sun.source.tree.RequiresTree, p: P): JCTree$JCRequires;
              visitRequires(a0: sun.source.tree.RequiresTree, a1: any): any;
              visitReturn(node: sun.source.tree.ReturnTree, p: P): JCTree;
              visitReturn(a0: sun.source.tree.ReturnTree, a1: any): any;
              visitStringTemplate(node: sun.source.tree.StringTemplateTree, p: P): JCTree;
              visitStringTemplate(a0: sun.source.tree.StringTemplateTree, a1: any): any;
              visitSwitch(node: sun.source.tree.SwitchTree, p: P): JCTree;
              visitSwitch(a0: sun.source.tree.SwitchTree, a1: any): any;
              visitSwitchExpression(node: sun.source.tree.SwitchExpressionTree, p: P): JCTree;
              visitSwitchExpression(a0: sun.source.tree.SwitchExpressionTree, a1: any): any;
              visitSynchronized(node: sun.source.tree.SynchronizedTree, p: P): JCTree;
              visitSynchronized(a0: sun.source.tree.SynchronizedTree, a1: any): any;
              visitThrow(node: sun.source.tree.ThrowTree, p: P): JCTree;
              visitThrow(a0: sun.source.tree.ThrowTree, a1: any): any;
              visitTry(node: sun.source.tree.TryTree, p: P): JCTree;
              visitTry(a0: sun.source.tree.TryTree, a1: any): any;
              visitTypeCast(node: sun.source.tree.TypeCastTree, p: P): JCTree;
              visitTypeCast(a0: sun.source.tree.TypeCastTree, a1: any): any;
              visitTypeParameter(node: sun.source.tree.TypeParameterTree, p: P): JCTree;
              visitTypeParameter(a0: sun.source.tree.TypeParameterTree, a1: any): any;
              visitUnary(node: sun.source.tree.UnaryTree, p: P): JCTree;
              visitUnary(a0: sun.source.tree.UnaryTree, a1: any): any;
              visitUnionType(node: sun.source.tree.UnionTypeTree, p: P): JCTree;
              visitUnionType(a0: sun.source.tree.UnionTypeTree, a1: any): any;
              visitUses(node: sun.source.tree.UsesTree, p: P): JCTree$JCUses;
              visitUses(a0: sun.source.tree.UsesTree, a1: any): any;
              visitVariable(node: sun.source.tree.VariableTree, p: P): JCTree;
              visitVariable(a0: sun.source.tree.VariableTree, a1: any): any;
              visitWhileLoop(node: sun.source.tree.WhileLoopTree, p: P): JCTree;
              visitWhileLoop(a0: sun.source.tree.WhileLoopTree, a1: any): any;
              visitWildcard(node: sun.source.tree.WildcardTree, p: P): JCTree;
              visitWildcard(a0: sun.source.tree.WildcardTree, a1: any): any;
              visitYield(node: sun.source.tree.YieldTree, p: P): JCTree;
              visitYield(a0: sun.source.tree.YieldTree, a1: any): any;
              _M: TreeMaker;
            }
            interface TreeCopier<P> extends CombineTypes<[_TreeCopier<P>, sun.source.tree.TreeVisitor<JCTree,P>, java.lang.Object]> {}
            interface _TreeInfo$$static extends ClassLike {
              args(t: JCTree): javac.util.List<JCTree$JCExpression>;
              calledMethodName(tree: JCTree): javac.util.Name;
              containsTypeAnnotation(e: JCTree): boolean;
              declarationFor(sym: javac.code.Symbol, tree: JCTree): JCTree;
              diagEndPos(tree: JCTree): javac.util.JCDiagnostic$DiagnosticPosition;
              diagnosticPositionFor(sym: javac.code.Symbol, tree: JCTree): javac.util.JCDiagnostic$DiagnosticPosition;
              diagnosticPositionFor(sym: javac.code.Symbol, tree: JCTree, returnNullIfNotFound: boolean): javac.util.JCDiagnostic$DiagnosticPosition;
              diagnosticPositionFor(sym: javac.code.Symbol, tree: JCTree, returnNullIfNotFound: boolean, filter: java.util.function.Predicate<JCTree>): javac.util.JCDiagnostic$DiagnosticPosition;
              diagnosticPositionFor(sym: javac.code.Symbol, trees: javac.util.List<JCTree>): javac.util.JCDiagnostic$DiagnosticPosition;
              endPos(tree: JCTree): int;
              expectedExhaustive(tree: JCTree$JCSwitch): boolean;
              finalizerPos(tree: JCTree, posKind: TreeInfo$PosKind): int;
              firstConstructorCall(tree: JCTree): JCTree$JCMethodInvocation;
              firstFlag(flags: long): long;
              firstStatPos(tree: JCTree): int;
              flagNames(flags: long): string;
              flags(tree: JCTree): long;
              fullName(tree: JCTree): javac.util.Name;
              getCommentText(env: javac.comp.Env<any>, tree: JCTree): string;
              getCommentTree(env: javac.comp.Env<any>, tree: JCTree): DCTree$DCDocComment;
              getConstructorInvocationName(trees: javac.util.List<JCTree>, names: javac.util.Names): javac.util.Name;
              getEndPos(tree: JCTree, endPosTable: EndPosTable): int;
              getModifiers(tree: JCTree): JCTree$JCModifiers;
              getModule(t: JCTree$JCCompilationUnit): JCTree$JCModuleDecl;
              getStartPos(tree: JCTree): int;
              hasConstructors(trees: javac.util.List<JCTree>): boolean;
              innermostType(type: JCTree, skipAnnos: boolean): JCTree;
              isBooleanWithValue(guard: JCTree$JCExpression, value: int): boolean;
              isCanonicalConstructor(tree: JCTree): boolean;
              isCompactConstructor(tree: JCTree): boolean;
              isConstructor(tree: JCTree): boolean;
              isDeclaration(node: JCTree): boolean;
              isDiamond(tree: JCTree): boolean;
              isEnumInit(tree: JCTree): boolean;
              isErrorEnumSwitch(selector: JCTree$JCExpression, cases: javac.util.List<JCTree$JCCase>): boolean;
              isExpressionStatement(tree: JCTree$JCExpression): boolean;
              isIdentOrThisDotIdent(tree: JCTree): boolean;
              isInAnnotation(env: javac.comp.Env<any>, tree: JCTree): boolean;
              isInitialConstructor(tree: JCTree): boolean;
              isModuleInfo(tree: JCTree$JCCompilationUnit): boolean;
              isMultiCatch(catchClause: JCTree$JCCatch): boolean;
              isNull(tree: JCTree): boolean;
              isNullCaseLabel(label: JCTree$JCCaseLabel): boolean;
              isPackageInfo(tree: JCTree$JCCompilationUnit): boolean;
              isReceiverParam(tree: JCTree): boolean;
              isSelfCall(tree: JCTree): boolean;
              isStatement(tree: JCTree): boolean;
              isStaticSelector(base: JCTree, names: javac.util.Names): boolean;
              _isStaticSym(tree: JCTree): boolean;
              isSuperCall(tree: JCTree): boolean;
              isSyntheticInit(stat: JCTree): boolean;
              isThisQualifier(tree: JCTree): boolean;
              name(tree: JCTree): javac.util.Name;
              nonstaticSelect(tree: JCTree): boolean;
              opPrec(op: JCTree$Tag): int;
              positionFor(sym: javac.code.Symbol, tree: JCTree): int;
              primaryPatternType(pat: JCTree): javac.code.Type;
              primaryPatternTypeTree(pat: JCTree): JCTree;
              recordFieldTypes(tree: JCTree$JCClassDecl): javac.util.List<javac.code.Type>;
              recordFields(tree: JCTree$JCClassDecl): javac.util.List<JCTree$JCVariableDecl>;
              referencedStatement(tree: JCTree$JCLabeledStatement): JCTree;
              setPolyKind(tree: JCTree, pkind: JCTree$JCPolyExpression$PolyKind): void;
              setSymbol(tree: JCTree, sym: javac.code.Symbol): void;
              setVarargsElement(tree: JCTree, varargsElement: javac.code.Type): void;
              skipParens(tree: JCTree$JCExpression): JCTree$JCExpression;
              skipParens(tree: JCTree): JCTree;
              symbol(tree: JCTree): javac.code.Symbol;
              symbolFor(node: JCTree): javac.code.Symbol;
              _symbolForImpl(node: JCTree): javac.code.Symbol;
              _tagToKind(tag: JCTree$Tag): sun.source.tree.Tree$Kind;
              typeIn(tree: JCTree$JCExpression): JCTree$JCExpression;
              types(trees: javac.util.List<JCTree>): javac.util.List<javac.code.Type>;
              unguardedCase(cse: JCTree$JCCase): boolean;
              readonly addPrec: int;
              readonly andPrec: int;
              readonly assignPrec: int;
              readonly assignopPrec: int;
              readonly bitandPrec: int;
              readonly bitorPrec: int;
              readonly bitxorPrec: int;
              readonly condPrec: int;
              readonly eqPrec: int;
              readonly mulPrec: int;
              readonly noPrec: int;
              readonly notExpression: int;
              readonly orPrec: int;
              readonly ordPrec: int;
              readonly postfixPrec: int;
              readonly precCount: int;
              readonly prefixPrec: int;
              readonly shiftPrec: int;
              new(): TreeInfo;
            }
            let TreeInfo: _TreeInfo$$static;
            interface _TreeInfo {
            }
            interface TreeInfo extends CombineTypes<[_TreeInfo, java.lang.Object]> {}
            interface _TreeInfo$DeclScanner$$static extends ClassLike {
              _new(sym: javac.code.Symbol): TreeInfo$DeclScanner;
              _new(sym: javac.code.Symbol, filter: java.util.function.Predicate<JCTree>): TreeInfo$DeclScanner;
            }
            let TreeInfo$DeclScanner: _TreeInfo$DeclScanner$$static;
            interface _TreeInfo$DeclScanner {
              _checkMatch(that: JCTree, thatSym: javac.code.Symbol): boolean;
              scan(tree: JCTree): void;
              visitClassDef(that: JCTree$JCClassDecl): void;
              visitMethodDef(that: JCTree$JCMethodDecl): void;
              visitModuleDef(that: JCTree$JCModuleDecl): void;
              visitPackageDef(that: JCTree$JCPackageDecl): void;
              visitTopLevel(that: JCTree$JCCompilationUnit): void;
              visitTypeParameter(that: JCTree$JCTypeParameter): void;
              visitVarDef(that: JCTree$JCVariableDecl): void;
              _filter: java.util.function.Predicate<JCTree>;
              _result: JCTree;
              _sym: javac.code.Symbol;
            }
            interface TreeInfo$DeclScanner extends CombineTypes<[_TreeInfo$DeclScanner, com.sun.tools.javac.tree.TreeScanner]> {}
            interface _TreeInfo$PosKind$$static extends ClassLike {
              valueOf(name: string): TreeInfo$PosKind;
              values(): TreeInfo$PosKind[];
              readonly END_POS: TreeInfo$PosKind;
              readonly FIRST_STAT_POS: TreeInfo$PosKind;
              readonly START_POS: TreeInfo$PosKind;
            }
            let TreeInfo$PosKind: _TreeInfo$PosKind$$static;
            interface _TreeInfo$PosKind {
              _toPos(tree: JCTree): int;
              _posFunc: java.util.function.ToIntFunction<JCTree>;
            }
            interface TreeInfo$PosKind extends CombineTypes<[_TreeInfo$PosKind]> {}
            interface _TreeInfo$TypeAnnotationFinder$$static extends ClassLike {
            }
            let TreeInfo$TypeAnnotationFinder: _TreeInfo$TypeAnnotationFinder$$static;
            interface _TreeInfo$TypeAnnotationFinder {
              scan(tree: JCTree): void;
              visitAnnotation(tree: JCTree$JCAnnotation): void;
              foundTypeAnno: boolean;
            }
            interface TreeInfo$TypeAnnotationFinder extends CombineTypes<[_TreeInfo$TypeAnnotationFinder, com.sun.tools.javac.tree.TreeScanner]> {}
            interface _TreeMaker$$static extends ClassLike {
              instance(context: javac.util.Context): TreeMaker;
              _treeMakerKey: javac.util.Context$Key<TreeMaker>;
              _new(context: javac.util.Context): TreeMaker;
              _new(toplevel: JCTree$JCCompilationUnit, names: javac.util.Names, types: javac.code.Types, syms: javac.code.Symtab): TreeMaker;
            }
            let TreeMaker: _TreeMaker$$static;
            interface _TreeMaker {
              AnnotatedType(annotations: javac.util.List<JCTree$JCAnnotation>, underlyingType: JCTree$JCExpression): JCTree$JCAnnotatedType;
              Annotation(annotationType: JCTree, args: javac.util.List<JCTree$JCExpression>): JCTree$JCAnnotation;
              Annotation(a: javac.code.Attribute): JCTree$JCAnnotation;
              Annotations(attributes: javac.util.List<javac.code.Attribute$Compound>): javac.util.List<JCTree$JCAnnotation>;
              AnonymousClassDef(mods: JCTree$JCModifiers, defs: javac.util.List<JCTree>): JCTree$JCClassDecl;
              AnyPattern(): JCTree$JCAnyPattern;
              App(meth: JCTree$JCExpression, args: javac.util.List<JCTree$JCExpression>): JCTree$JCMethodInvocation;
              App(meth: JCTree$JCExpression): JCTree$JCMethodInvocation;
              Apply(typeargs: javac.util.List<JCTree$JCExpression>, fn: JCTree$JCExpression, args: javac.util.List<JCTree$JCExpression>): JCTree$JCMethodInvocation;
              Assert(cond: JCTree$JCExpression, detail: JCTree$JCExpression): JCTree$JCAssert;
              Assign(lhs: JCTree$JCExpression, rhs: JCTree$JCExpression): JCTree$JCAssign;
              Assignment(v: javac.code.Symbol, rhs: JCTree$JCExpression): JCTree$JCStatement;
              Assignop(opcode: JCTree$Tag, lhs: JCTree, rhs: JCTree): JCTree$JCAssignOp;
              Binary(opcode: JCTree$Tag, lhs: JCTree$JCExpression, rhs: JCTree$JCExpression): JCTree$JCBinary;
              BindingPattern(_var: JCTree$JCVariableDecl): JCTree$JCBindingPattern;
              Block(flags: long, a1: javac.util.List<JCTree$JCStatement>): JCTree$JCBlock;
              Break(label: javac.util.Name): JCTree$JCBreak;
              Call(apply: JCTree$JCExpression): JCTree$JCStatement;
              Case(caseKind: sun.source.tree.CaseTree$CaseKind, labels: javac.util.List<JCTree$JCCaseLabel>, guard: JCTree$JCExpression, stats: javac.util.List<JCTree$JCStatement>, body: JCTree): JCTree$JCCase;
              Catch(param: JCTree$JCVariableDecl, body: JCTree$JCBlock): JCTree$JCCatch;
              ClassDef(mods: JCTree$JCModifiers, name: javac.util.Name, typarams: javac.util.List<JCTree$JCTypeParameter>, extending: JCTree$JCExpression, implementing: javac.util.List<JCTree$JCExpression>, defs: javac.util.List<JCTree>): JCTree$JCClassDecl;
              ClassDef(mods: JCTree$JCModifiers, name: javac.util.Name, typarams: javac.util.List<JCTree$JCTypeParameter>, extending: JCTree$JCExpression, implementing: javac.util.List<JCTree$JCExpression>, permitting: javac.util.List<JCTree$JCExpression>, defs: javac.util.List<JCTree>): JCTree$JCClassDecl;
              ClassLiteral(clazz: javac.code.Symbol$ClassSymbol): JCTree$JCExpression;
              ClassLiteral(t: javac.code.Type): JCTree$JCExpression;
              Conditional(cond: JCTree$JCExpression, thenpart: JCTree$JCExpression, elsepart: JCTree$JCExpression): JCTree$JCConditional;
              ConstantCaseLabel(expr: JCTree$JCExpression): JCTree$JCConstantCaseLabel;
              Continue(label: javac.util.Name): JCTree$JCContinue;
              Create(ctor: javac.code.Symbol, args: javac.util.List<JCTree$JCExpression>): JCTree$JCExpression;
              DefaultCaseLabel(): JCTree$JCDefaultCaseLabel;
              DoLoop(body: JCTree$JCStatement, cond: JCTree$JCExpression): JCTree$JCDoWhileLoop;
              Erroneous(): JCTree$JCErroneous;
              Erroneous(errs: javac.util.List<JCTree>): JCTree$JCErroneous;
              Exec(expr: JCTree$JCExpression): JCTree$JCExpressionStatement;
              Exports(qualId: JCTree$JCExpression, moduleNames: javac.util.List<JCTree$JCExpression>): JCTree$JCExports;
              ForLoop(init: javac.util.List<JCTree$JCStatement>, cond: JCTree$JCExpression, step: javac.util.List<JCTree$JCExpressionStatement>, body: JCTree$JCStatement): JCTree$JCForLoop;
              ForeachLoop(_var: JCTree$JCVariableDecl, expr: JCTree$JCExpression, body: JCTree$JCStatement): JCTree$JCEnhancedForLoop;
              Ident(name: javac.util.Name): JCTree$JCIdent;
              Ident(sym: javac.code.Symbol): JCTree$JCIdent;
              Ident(param: JCTree$JCVariableDecl): JCTree$JCExpression;
              Idents(params: javac.util.List<JCTree$JCVariableDecl>): javac.util.List<JCTree$JCExpression>;
              If(cond: JCTree$JCExpression, thenpart: JCTree$JCStatement, elsepart: JCTree$JCStatement): JCTree$JCIf;
              Import(qualid: JCTree$JCFieldAccess, importStatic: boolean): JCTree$JCImport;
              Indexed(indexed: JCTree$JCExpression, index: JCTree$JCExpression): JCTree$JCArrayAccess;
              Indexed(v: javac.code.Symbol, index: JCTree$JCExpression): JCTree$JCArrayAccess;
              Labelled(label: javac.util.Name, body: JCTree$JCStatement): JCTree$JCLabeledStatement;
              Lambda(params: javac.util.List<JCTree$JCVariableDecl>, body: JCTree): JCTree$JCLambda;
              LetExpr(defs: javac.util.List<JCTree$JCStatement>, expr: JCTree$JCExpression): JCTree$LetExpr;
              LetExpr(def: JCTree$JCVariableDecl, expr: JCTree$JCExpression): JCTree$LetExpr;
              Literal(tag: javac.code.TypeTag, value: any): JCTree$JCLiteral;
              Literal(value: any): JCTree$JCLiteral;
              MethodDef(mods: JCTree$JCModifiers, name: javac.util.Name, restype: JCTree$JCExpression, typarams: javac.util.List<JCTree$JCTypeParameter>, params: javac.util.List<JCTree$JCVariableDecl>, thrown: javac.util.List<JCTree$JCExpression>, body: JCTree$JCBlock, defaultValue: JCTree$JCExpression): JCTree$JCMethodDecl;
              MethodDef(mods: JCTree$JCModifiers, name: javac.util.Name, restype: JCTree$JCExpression, typarams: javac.util.List<JCTree$JCTypeParameter>, recvparam: JCTree$JCVariableDecl, params: javac.util.List<JCTree$JCVariableDecl>, thrown: javac.util.List<JCTree$JCExpression>, body: JCTree$JCBlock, defaultValue: JCTree$JCExpression): JCTree$JCMethodDecl;
              MethodDef(m: javac.code.Symbol$MethodSymbol, body: JCTree$JCBlock): JCTree$JCMethodDecl;
              MethodDef(m: javac.code.Symbol$MethodSymbol, mtype: javac.code.Type, body: JCTree$JCBlock): JCTree$JCMethodDecl;
              Modifiers(flags: long, a1: javac.util.List<JCTree$JCAnnotation>): JCTree$JCModifiers;
              Modifiers(flags: long): JCTree$JCModifiers;
              ModuleDef(mods: JCTree$JCModifiers, kind: sun.source.tree.ModuleTree$ModuleKind, qualid: JCTree$JCExpression, directives: javac.util.List<JCTree$JCDirective>): JCTree$JCModuleDecl;
              NewArray(elemtype: JCTree$JCExpression, dims: javac.util.List<JCTree$JCExpression>, elems: javac.util.List<JCTree$JCExpression>): JCTree$JCNewArray;
              NewClass(encl: JCTree$JCExpression, typeargs: javac.util.List<JCTree$JCExpression>, clazz: JCTree$JCExpression, args: javac.util.List<JCTree$JCExpression>, def: JCTree$JCClassDecl): JCTree$JCNewClass;
              Opens(qualId: JCTree$JCExpression, moduleNames: javac.util.List<JCTree$JCExpression>): JCTree$JCOpens;
              PackageDecl(annotations: javac.util.List<JCTree$JCAnnotation>, pid: JCTree$JCExpression): JCTree$JCPackageDecl;
              Param(name: javac.util.Name, argtype: javac.code.Type, owner: javac.code.Symbol): JCTree$JCVariableDecl;
              Params(mth: javac.code.Symbol$MethodSymbol): javac.util.List<JCTree$JCVariableDecl>;
              Params(mth: javac.code.Symbol$MethodSymbol, argtypes: javac.util.List<javac.code.Type>): javac.util.List<JCTree$JCVariableDecl>;
              Parens(expr: JCTree$JCExpression): JCTree$JCParens;
              PatternCaseLabel(pat: JCTree$JCPattern): JCTree$JCPatternCaseLabel;
              Provides(serviceName: JCTree$JCExpression, implNames: javac.util.List<JCTree$JCExpression>): JCTree$JCProvides;
              QualIdent(sym: javac.code.Symbol): JCTree$JCExpression;
              QualThis(t: javac.code.Type): JCTree$JCExpression;
              ReceiverVarDef(mods: JCTree$JCModifiers, name: JCTree$JCExpression, vartype: JCTree$JCExpression): JCTree$JCVariableDecl;
              RecordPattern(deconstructor: JCTree$JCExpression, nested: javac.util.List<JCTree$JCPattern>): JCTree$JCRecordPattern;
              Reference(mode: sun.source.tree.MemberReferenceTree$ReferenceMode, name: javac.util.Name, expr: JCTree$JCExpression, typeargs: javac.util.List<JCTree$JCExpression>): JCTree$JCMemberReference;
              Requires(isTransitive: boolean, isStaticPhase: boolean, qualId: JCTree$JCExpression): JCTree$JCRequires;
              Return(expr: JCTree$JCExpression): JCTree$JCReturn;
              Select(selected: JCTree$JCExpression, selector: javac.util.Name): JCTree$JCFieldAccess;
              Select(base: JCTree$JCExpression, sym: javac.code.Symbol): JCTree$JCFieldAccess;
              Skip(): JCTree$JCSkip;
              SpeculativeNewClass(encl: JCTree$JCExpression, typeargs: javac.util.List<JCTree$JCExpression>, clazz: JCTree$JCExpression, args: javac.util.List<JCTree$JCExpression>, def: JCTree$JCClassDecl, classDefRemoved: boolean): JCTree$JCNewClass;
              StringTemplate(processor: JCTree$JCExpression, fragments: javac.util.List<string>, expressions: javac.util.List<JCTree$JCExpression>): JCTree$JCStringTemplate;
              Super(t: javac.code.Type, owner: javac.code.Symbol$TypeSymbol): JCTree$JCIdent;
              Switch(selector: JCTree$JCExpression, cases: javac.util.List<JCTree$JCCase>): JCTree$JCSwitch;
              SwitchExpression(selector: JCTree$JCExpression, cases: javac.util.List<JCTree$JCCase>): JCTree$JCSwitchExpression;
              Synchronized(lock: JCTree$JCExpression, body: JCTree$JCBlock): JCTree$JCSynchronized;
              This(t: javac.code.Type): JCTree$JCExpression;
              Throw(expr: JCTree$JCExpression): JCTree$JCThrow;
              TopLevel(defs: javac.util.List<JCTree>): JCTree$JCCompilationUnit;
              Try(body: JCTree$JCBlock, catchers: javac.util.List<JCTree$JCCatch>, finalizer: JCTree$JCBlock): JCTree$JCTry;
              Try(resources: javac.util.List<JCTree>, body: JCTree$JCBlock, catchers: javac.util.List<JCTree$JCCatch>, finalizer: JCTree$JCBlock): JCTree$JCTry;
              Type(t: javac.code.Type): JCTree$JCExpression;
              TypeAnnotation(annotationType: JCTree, args: javac.util.List<JCTree$JCExpression>): JCTree$JCAnnotation;
              TypeAnnotation(a: javac.code.Attribute): JCTree$JCAnnotation;
              TypeApply(clazz: JCTree$JCExpression, arguments: javac.util.List<JCTree$JCExpression>): JCTree$JCTypeApply;
              TypeArray(elemtype: JCTree$JCExpression): JCTree$JCArrayTypeTree;
              TypeBoundKind(kind: javac.code.BoundKind): JCTree$TypeBoundKind;
              TypeCast(clazz: JCTree, expr: JCTree$JCExpression): JCTree$JCTypeCast;
              TypeCast(type: javac.code.Type, expr: JCTree$JCExpression): JCTree$JCTypeCast;
              TypeIdent(typetag: javac.code.TypeTag): JCTree$JCPrimitiveTypeTree;
              TypeIntersection(components: javac.util.List<JCTree$JCExpression>): JCTree$JCTypeIntersection;
              TypeParam(name: javac.util.Name, tvar: javac.code.Type$TypeVar): JCTree$JCTypeParameter;
              TypeParameter(name: javac.util.Name, bounds: javac.util.List<JCTree$JCExpression>): JCTree$JCTypeParameter;
              TypeParameter(name: javac.util.Name, bounds: javac.util.List<JCTree$JCExpression>, annos: javac.util.List<JCTree$JCAnnotation>): JCTree$JCTypeParameter;
              TypeParams(typarams: javac.util.List<javac.code.Type>): javac.util.List<JCTree$JCTypeParameter>;
              TypeTest(expr: JCTree$JCExpression, clazz: JCTree): JCTree$JCInstanceOf;
              TypeUnion(components: javac.util.List<JCTree$JCExpression>): JCTree$JCTypeUnion;
              Types(ts: javac.util.List<javac.code.Type>): javac.util.List<JCTree$JCExpression>;
              Unary(opcode: JCTree$Tag, arg: JCTree$JCExpression): JCTree$JCUnary;
              Uses(qualId: JCTree$JCExpression): JCTree$JCUses;
              VarDef(mods: JCTree$JCModifiers, name: javac.util.Name, vartype: JCTree$JCExpression, init: JCTree$JCExpression): JCTree$JCVariableDecl;
              VarDef(mods: JCTree$JCModifiers, name: javac.util.Name, vartype: JCTree$JCExpression, init: JCTree$JCExpression, declaredUsingVar: boolean): JCTree$JCVariableDecl;
              VarDef(v: javac.code.Symbol$VarSymbol, init: JCTree$JCExpression): JCTree$JCVariableDecl;
              WhileLoop(cond: JCTree$JCExpression, body: JCTree$JCStatement): JCTree$JCWhileLoop;
              Wildcard(kind: JCTree$TypeBoundKind, type: JCTree): JCTree$JCWildcard;
              Yield(value: JCTree$JCExpression): JCTree$JCYield;
              at(pos: int): TreeMaker;
              at(pos: javac.util.JCDiagnostic$DiagnosticPosition): TreeMaker;
              forToplevel(toplevel: JCTree$JCCompilationUnit): TreeMaker;
              _isUnqualifiable(sym: javac.code.Symbol): boolean;
              paramName(i: int): javac.util.Name;
              typaramName(i: int): javac.util.Name;
              _annotationBuilder: TreeMaker$AnnotationBuilder;
              _names: javac.util.Names;
              pos: int;
              _syms: javac.code.Symtab;
              toplevel: JCTree$JCCompilationUnit;
              _types: javac.code.Types;
            }
            interface TreeMaker extends CombineTypes<[_TreeMaker, com.sun.tools.javac.tree.JCTree$Factory, java.lang.Object]> {}
            interface _TreeMaker$AnnotationBuilder$$static extends ClassLike {
              _new(this$0: TreeMaker): TreeMaker$AnnotationBuilder;
            }
            let TreeMaker$AnnotationBuilder: _TreeMaker$AnnotationBuilder$$static;
            interface _TreeMaker$AnnotationBuilder {
              _translate(a: javac.code.Attribute): JCTree$JCExpression;
              _translate(a: javac.code.Attribute$Compound): JCTree$JCAnnotation;
              _translate(a: javac.code.Attribute$TypeCompound): JCTree$JCAnnotation;
              visitArray(array: javac.code.Attribute$Array): void;
              visitClass(clazz: javac.code.Attribute$Class): void;
              visitCompound(compound: javac.code.Attribute$Compound): void;
              visitCompoundInternal(compound: javac.code.Attribute$Compound): JCTree$JCAnnotation;
              visitConstant(v: javac.code.Attribute$Constant): void;
              visitEnum(e: javac.code.Attribute$Enum): void;
              visitError(e: javac.code.Attribute$Error): void;
              visitTypeCompoundInternal(compound: javac.code.Attribute$TypeCompound): JCTree$JCAnnotation;
              _result: JCTree$JCExpression;
              _this$0: TreeMaker;
            }
            interface TreeMaker$AnnotationBuilder extends CombineTypes<[_TreeMaker$AnnotationBuilder, com.sun.tools.javac.code.Attribute$Visitor, java.lang.Object]> {}
            interface _TreeScanner$$static extends ClassLike {
              new(): TreeScanner;
            }
            let TreeScanner: _TreeScanner$$static;
            interface _TreeScanner {
              scan(tree: JCTree): void;
              scan(trees: javac.util.List<JCTree>): void;
              visitAnnotatedType(tree: JCTree$JCAnnotatedType): void;
              visitAnnotation(tree: JCTree$JCAnnotation): void;
              visitAnyPattern(that: JCTree$JCAnyPattern): void;
              visitApply(tree: JCTree$JCMethodInvocation): void;
              visitAssert(tree: JCTree$JCAssert): void;
              visitAssign(tree: JCTree$JCAssign): void;
              visitAssignop(tree: JCTree$JCAssignOp): void;
              visitBinary(tree: JCTree$JCBinary): void;
              visitBindingPattern(tree: JCTree$JCBindingPattern): void;
              visitBlock(tree: JCTree$JCBlock): void;
              visitBreak(tree: JCTree$JCBreak): void;
              visitCase(tree: JCTree$JCCase): void;
              visitCatch(tree: JCTree$JCCatch): void;
              visitClassDef(tree: JCTree$JCClassDecl): void;
              visitConditional(tree: JCTree$JCConditional): void;
              visitConstantCaseLabel(tree: JCTree$JCConstantCaseLabel): void;
              visitContinue(tree: JCTree$JCContinue): void;
              visitDefaultCaseLabel(tree: JCTree$JCDefaultCaseLabel): void;
              visitDoLoop(tree: JCTree$JCDoWhileLoop): void;
              visitErroneous(tree: JCTree$JCErroneous): void;
              visitExec(tree: JCTree$JCExpressionStatement): void;
              visitExports(tree: JCTree$JCExports): void;
              visitForLoop(tree: JCTree$JCForLoop): void;
              visitForeachLoop(tree: JCTree$JCEnhancedForLoop): void;
              visitIdent(tree: JCTree$JCIdent): void;
              visitIf(tree: JCTree$JCIf): void;
              visitImport(tree: JCTree$JCImport): void;
              visitIndexed(tree: JCTree$JCArrayAccess): void;
              visitLabelled(tree: JCTree$JCLabeledStatement): void;
              visitLambda(tree: JCTree$JCLambda): void;
              visitLetExpr(tree: JCTree$LetExpr): void;
              visitLiteral(tree: JCTree$JCLiteral): void;
              visitMethodDef(tree: JCTree$JCMethodDecl): void;
              visitModifiers(tree: JCTree$JCModifiers): void;
              visitModuleDef(tree: JCTree$JCModuleDecl): void;
              visitNewArray(tree: JCTree$JCNewArray): void;
              visitNewClass(tree: JCTree$JCNewClass): void;
              visitOpens(tree: JCTree$JCOpens): void;
              visitPackageDef(tree: JCTree$JCPackageDecl): void;
              visitParens(tree: JCTree$JCParens): void;
              visitPatternCaseLabel(tree: JCTree$JCPatternCaseLabel): void;
              visitProvides(tree: JCTree$JCProvides): void;
              visitRecordPattern(that: JCTree$JCRecordPattern): void;
              visitReference(tree: JCTree$JCMemberReference): void;
              visitRequires(tree: JCTree$JCRequires): void;
              visitReturn(tree: JCTree$JCReturn): void;
              visitSelect(tree: JCTree$JCFieldAccess): void;
              visitSkip(tree: JCTree$JCSkip): void;
              visitStringTemplate(tree: JCTree$JCStringTemplate): void;
              visitSwitch(tree: JCTree$JCSwitch): void;
              visitSwitchExpression(tree: JCTree$JCSwitchExpression): void;
              visitSynchronized(tree: JCTree$JCSynchronized): void;
              visitThrow(tree: JCTree$JCThrow): void;
              visitTopLevel(tree: JCTree$JCCompilationUnit): void;
              visitTree(tree: JCTree): void;
              visitTry(tree: JCTree$JCTry): void;
              visitTypeApply(tree: JCTree$JCTypeApply): void;
              visitTypeArray(tree: JCTree$JCArrayTypeTree): void;
              visitTypeBoundKind(that: JCTree$TypeBoundKind): void;
              visitTypeCast(tree: JCTree$JCTypeCast): void;
              visitTypeIdent(tree: JCTree$JCPrimitiveTypeTree): void;
              visitTypeIntersection(tree: JCTree$JCTypeIntersection): void;
              visitTypeParameter(tree: JCTree$JCTypeParameter): void;
              visitTypeTest(tree: JCTree$JCInstanceOf): void;
              visitTypeUnion(tree: JCTree$JCTypeUnion): void;
              visitUnary(tree: JCTree$JCUnary): void;
              visitUses(tree: JCTree$JCUses): void;
              visitVarDef(tree: JCTree$JCVariableDecl): void;
              visitWhileLoop(tree: JCTree$JCWhileLoop): void;
              visitWildcard(tree: JCTree$JCWildcard): void;
              visitYield(tree: JCTree$JCYield): void;
            }
            interface TreeScanner extends CombineTypes<[_TreeScanner, com.sun.tools.javac.tree.JCTree$Visitor]> {}
            interface _TreeTranslator$$static extends ClassLike {
              new(): TreeTranslator;
            }
            let TreeTranslator: _TreeTranslator$$static;
            interface _TreeTranslator {
              translate<T>(tree: T): T;
              translate<T>(trees: javac.util.List<T>): javac.util.List<T>;
              translateAnnotations(trees: javac.util.List<JCTree$JCAnnotation>): javac.util.List<JCTree$JCAnnotation>;
              translateCases(trees: javac.util.List<JCTree$JCCase>): javac.util.List<JCTree$JCCase>;
              translateCatchers(trees: javac.util.List<JCTree$JCCatch>): javac.util.List<JCTree$JCCatch>;
              translateTypeParams(trees: javac.util.List<JCTree$JCTypeParameter>): javac.util.List<JCTree$JCTypeParameter>;
              translateVarDefs(trees: javac.util.List<JCTree$JCVariableDecl>): javac.util.List<JCTree$JCVariableDecl>;
              visitAnnotatedType(tree: JCTree$JCAnnotatedType): void;
              visitAnnotation(tree: JCTree$JCAnnotation): void;
              visitAnyPattern(tree: JCTree$JCAnyPattern): void;
              visitApply(tree: JCTree$JCMethodInvocation): void;
              visitAssert(tree: JCTree$JCAssert): void;
              visitAssign(tree: JCTree$JCAssign): void;
              visitAssignop(tree: JCTree$JCAssignOp): void;
              visitBinary(tree: JCTree$JCBinary): void;
              visitBindingPattern(tree: JCTree$JCBindingPattern): void;
              visitBlock(tree: JCTree$JCBlock): void;
              visitBreak(tree: JCTree$JCBreak): void;
              visitCase(tree: JCTree$JCCase): void;
              visitCatch(tree: JCTree$JCCatch): void;
              visitClassDef(tree: JCTree$JCClassDecl): void;
              visitConditional(tree: JCTree$JCConditional): void;
              visitConstantCaseLabel(tree: JCTree$JCConstantCaseLabel): void;
              visitContinue(tree: JCTree$JCContinue): void;
              visitDefaultCaseLabel(tree: JCTree$JCDefaultCaseLabel): void;
              visitDoLoop(tree: JCTree$JCDoWhileLoop): void;
              visitErroneous(tree: JCTree$JCErroneous): void;
              visitExec(tree: JCTree$JCExpressionStatement): void;
              visitForLoop(tree: JCTree$JCForLoop): void;
              visitForeachLoop(tree: JCTree$JCEnhancedForLoop): void;
              visitIdent(tree: JCTree$JCIdent): void;
              visitIf(tree: JCTree$JCIf): void;
              visitImport(tree: JCTree$JCImport): void;
              visitIndexed(tree: JCTree$JCArrayAccess): void;
              visitLabelled(tree: JCTree$JCLabeledStatement): void;
              visitLambda(tree: JCTree$JCLambda): void;
              visitLetExpr(tree: JCTree$LetExpr): void;
              visitLiteral(tree: JCTree$JCLiteral): void;
              visitMethodDef(tree: JCTree$JCMethodDecl): void;
              visitModifiers(tree: JCTree$JCModifiers): void;
              visitNewArray(tree: JCTree$JCNewArray): void;
              visitNewClass(tree: JCTree$JCNewClass): void;
              visitPackageDef(tree: JCTree$JCPackageDecl): void;
              visitParens(tree: JCTree$JCParens): void;
              visitPatternCaseLabel(tree: JCTree$JCPatternCaseLabel): void;
              visitRecordPattern(tree: JCTree$JCRecordPattern): void;
              visitReference(tree: JCTree$JCMemberReference): void;
              visitReturn(tree: JCTree$JCReturn): void;
              visitSelect(tree: JCTree$JCFieldAccess): void;
              visitSkip(tree: JCTree$JCSkip): void;
              visitStringTemplate(tree: JCTree$JCStringTemplate): void;
              visitSwitch(tree: JCTree$JCSwitch): void;
              visitSwitchExpression(tree: JCTree$JCSwitchExpression): void;
              visitSynchronized(tree: JCTree$JCSynchronized): void;
              visitThrow(tree: JCTree$JCThrow): void;
              visitTopLevel(tree: JCTree$JCCompilationUnit): void;
              visitTree(tree: JCTree): void;
              visitTry(tree: JCTree$JCTry): void;
              visitTypeApply(tree: JCTree$JCTypeApply): void;
              visitTypeArray(tree: JCTree$JCArrayTypeTree): void;
              visitTypeBoundKind(tree: JCTree$TypeBoundKind): void;
              visitTypeCast(tree: JCTree$JCTypeCast): void;
              visitTypeIdent(tree: JCTree$JCPrimitiveTypeTree): void;
              visitTypeIntersection(tree: JCTree$JCTypeIntersection): void;
              visitTypeParameter(tree: JCTree$JCTypeParameter): void;
              visitTypeTest(tree: JCTree$JCInstanceOf): void;
              visitTypeUnion(tree: JCTree$JCTypeUnion): void;
              visitUnary(tree: JCTree$JCUnary): void;
              visitVarDef(tree: JCTree$JCVariableDecl): void;
              visitWhileLoop(tree: JCTree$JCWhileLoop): void;
              visitWildcard(tree: JCTree$JCWildcard): void;
              visitYield(tree: JCTree$JCYield): void;
              _result: JCTree;
            }
            interface TreeTranslator extends CombineTypes<[_TreeTranslator, com.sun.tools.javac.tree.JCTree$Visitor]> {}
          }
          module util {
            interface _Abort$$static extends ClassLike {
              _serialVersionUID: long;
              new(cause: java.lang.Throwable): Abort;
              new(): Abort;
            }
            let Abort: _Abort$$static;
            interface _Abort {
            }
            interface Abort extends CombineTypes<[_Abort, java.lang.Error]> {}
            interface _AbstractDiagnosticFormatter$$static extends ClassLike {
              _new(messages: JavacMessages, config: AbstractDiagnosticFormatter$SimpleConfiguration): AbstractDiagnosticFormatter;
            }
            let AbstractDiagnosticFormatter: _AbstractDiagnosticFormatter$$static;
            interface _AbstractDiagnosticFormatter {
              displaySource(d: JCDiagnostic): boolean;
              displaySource(a0: javax.tools.Diagnostic): boolean;
              _expr2String(tree: javac.tree.JCTree$JCExpression): string;
              format(d: JCDiagnostic, locale: java.util.Locale): string;
              format(a0: javax.tools.Diagnostic, a1: java.util.Locale): string;
              _formatArgument(d: JCDiagnostic, arg: any, l: java.util.Locale): string;
              _formatArguments(d: JCDiagnostic, l: java.util.Locale): java.util.Collection<string>;
              _formatDiagnostic(a0: JCDiagnostic, a1: java.util.Locale): string;
(a0: JCDiagnostic, a1: java.util.Locale): string;
              _formatIterable(d: JCDiagnostic, it: java.lang.Iterable<any>, l: java.util.Locale): string;
              formatKind(d: JCDiagnostic, l: java.util.Locale): string;
              formatKind(a0: javax.tools.Diagnostic, a1: java.util.Locale): string;
              _formatLintCategory(d: JCDiagnostic, l: java.util.Locale): string;
              formatPosition(d: JCDiagnostic, pk: javac.api.DiagnosticFormatter$PositionKind, l: java.util.Locale): string;
              formatPosition(a0: javax.tools.Diagnostic, a1: javac.api.DiagnosticFormatter$PositionKind, a2: java.util.Locale): string;
              formatSource(d: JCDiagnostic, fullname: boolean, l: java.util.Locale): string;
              formatSource(a0: javax.tools.Diagnostic, a1: boolean, a2: java.util.Locale): string;
              _formatSourceLine(d: JCDiagnostic, nSpaces: int): string;
              _formatSubdiagnostic(parent: JCDiagnostic, sub: JCDiagnostic, l: java.util.Locale): string;
              _formatSubdiagnostics(d: JCDiagnostic, l: java.util.Locale): List<string>;
              getConfiguration(): AbstractDiagnosticFormatter$SimpleConfiguration;
              getConfiguration(): javac.api.DiagnosticFormatter$Configuration;
              _getPosition(d: JCDiagnostic, pk: javac.api.DiagnosticFormatter$PositionKind): long;
              getPrinter(): javac.code.Printer;
              _indent(s: string, nSpaces: int): string;
              _indentString(nSpaces: int): string;
              isRaw(): boolean;
              _localize(l: java.util.Locale, key: string, args: any[]): string;
              _localize(l: java.util.Locale, key: string, ...args: any[]): string;
              setPrinter(printer: javac.code.Printer): void;
              _allCaptured: List<javac.code.Type>;
              _config: AbstractDiagnosticFormatter$SimpleConfiguration;
              _depth: int;
              _messages: JavacMessages;
              _printer: javac.code.Printer;
            }
            interface AbstractDiagnosticFormatter extends CombineTypes<[_AbstractDiagnosticFormatter, javac.api.DiagnosticFormatter<JCDiagnostic>, java.lang.Object]> {}
            interface _AbstractDiagnosticFormatter$SimpleConfiguration$$static extends ClassLike {
              new(parts: java.util.Set<javac.api.DiagnosticFormatter$Configuration$DiagnosticPart>): AbstractDiagnosticFormatter$SimpleConfiguration;
              new(options: Options, parts: java.util.Set<javac.api.DiagnosticFormatter$Configuration$DiagnosticPart>): AbstractDiagnosticFormatter$SimpleConfiguration;
            }
            let AbstractDiagnosticFormatter$SimpleConfiguration: _AbstractDiagnosticFormatter$SimpleConfiguration$$static;
            interface _AbstractDiagnosticFormatter$SimpleConfiguration {
              getMultilineLimit(limit: javac.api.DiagnosticFormatter$Configuration$MultilineLimit): int;
              getVisible(): java.util.EnumSet<javac.api.DiagnosticFormatter$Configuration$DiagnosticPart>;
              getVisible(): java.util.Set;
              isCaretEnabled(): boolean;
              setCaretEnabled(caretEnabled: boolean): void;
              setMultilineLimit(limit: javac.api.DiagnosticFormatter$Configuration$MultilineLimit, value: int): void;
              setVisible(diagParts: java.util.Set<javac.api.DiagnosticFormatter$Configuration$DiagnosticPart>): void;
              setVisiblePart(diagParts: javac.api.DiagnosticFormatter$Configuration$DiagnosticPart, enabled: boolean): void;
              _caretEnabled: boolean;
              _multilineLimits: java.util.Map<javac.api.DiagnosticFormatter$Configuration$MultilineLimit,int>;
              _visibleParts: java.util.EnumSet<javac.api.DiagnosticFormatter$Configuration$DiagnosticPart>;
            }
            interface AbstractDiagnosticFormatter$SimpleConfiguration extends CombineTypes<[_AbstractDiagnosticFormatter$SimpleConfiguration, com.sun.tools.javac.api.DiagnosticFormatter$Configuration, java.lang.Object]> {}
            interface _AbstractLog$$static extends ClassLike {
              _new(diags: JCDiagnostic$Factory): AbstractLog;
            }
            let AbstractLog: _AbstractLog$$static;
            interface _AbstractLog {
              currentSource(): DiagnosticSource;
              _directError(a0: string, a1: any[]): void;
              _directError(a0: string, ...a1: any[]): void;
              error(key: string, args: any[]): void;
              error(key: string, ...args: any[]): void;
              error(errorKey: JCDiagnostic$Error): void;
              error(pos: JCDiagnostic$DiagnosticPosition, errorKey: JCDiagnostic$Error): void;
              error(flag: JCDiagnostic$DiagnosticFlag, pos: JCDiagnostic$DiagnosticPosition, errorKey: JCDiagnostic$Error): void;
              error(pos: int, key: string, args: any[]): void;
              error(pos: int, key: string, ...args: any[]): void;
              error(pos: int, errorKey: JCDiagnostic$Error): void;
              error(flag: JCDiagnostic$DiagnosticFlag, pos: int, errorKey: JCDiagnostic$Error): void;
              _getSource(file: javax.tools.JavaFileObject): DiagnosticSource;
              mandatoryNote(file: javax.tools.JavaFileObject, noteKey: JCDiagnostic$Note): void;
              mandatoryWarning(pos: JCDiagnostic$DiagnosticPosition, warningKey: JCDiagnostic$Warning): void;
              mandatoryWarning(lc: javac.code.Lint$LintCategory, pos: JCDiagnostic$DiagnosticPosition, warningKey: JCDiagnostic$Warning): void;
              note(noteKey: JCDiagnostic$Note): void;
              note(pos: JCDiagnostic$DiagnosticPosition, noteKey: JCDiagnostic$Note): void;
              note(pos: int, noteKey: JCDiagnostic$Note): void;
              note(file: javax.tools.JavaFileObject, noteKey: JCDiagnostic$Note): void;
              _report(a0: JCDiagnostic): void;
              useSource(file: javax.tools.JavaFileObject): javax.tools.JavaFileObject;
              warning(warningKey: JCDiagnostic$Warning): void;
              warning(lc: javac.code.Lint$LintCategory, warningKey: JCDiagnostic$Warning): void;
              warning(pos: JCDiagnostic$DiagnosticPosition, warningKey: JCDiagnostic$Warning): void;
              warning(lc: javac.code.Lint$LintCategory, pos: JCDiagnostic$DiagnosticPosition, warningKey: JCDiagnostic$Warning): void;
              warning(pos: int, warningKey: JCDiagnostic$Warning): void;
              _wrap(pos: int): JCDiagnostic$DiagnosticPosition;
              readonly diags: JCDiagnostic$Factory;
              _source: DiagnosticSource;
              _sourceMap: java.util.Map<javax.tools.JavaFileObject,DiagnosticSource>;
            }
            interface AbstractLog extends CombineTypes<[_AbstractLog, java.lang.Object]> {}
            interface _ArrayUtils$$static extends ClassLike {
              _calculateNewLength(currentLength: int, maxIndex: int): int;
              ensureCapacity<T>(array: T[], maxIndex: int): T[];
              ensureCapacity(array: byte[], maxIndex: int): byte[];
              ensureCapacity(array: char[], maxIndex: int): char[];
              ensureCapacity(array: int[], maxIndex: int): int[];
              new(): ArrayUtils;
            }
            let ArrayUtils: _ArrayUtils$$static;
            interface _ArrayUtils {
            }
            interface ArrayUtils extends CombineTypes<[_ArrayUtils, java.lang.Object]> {}
            interface _Assert$$static extends ClassLike {
              check(cond: boolean): void;
              check(cond: boolean, value: int): void;
              check(cond: boolean, value: long): void;
              check(cond: boolean, value: any): void;
              check(cond: boolean, msg: string): void;
              check(cond: boolean, msg: java.util.function.Supplier<string>): void;
              checkNonNull<T>(t: T): T;
              checkNonNull<T>(t: T, msg: string): T;
              checkNonNull<T>(t: T, msg: java.util.function.Supplier<string>): T;
              checkNull(o: any): void;
              checkNull(o: any, value: any): void;
              checkNull(o: any, msg: string): void;
              checkNull(o: any, msg: java.util.function.Supplier<string>): void;
              error(): java.lang.Error;
              error(msg: string): java.lang.Error;
            }
            let Assert: _Assert$$static;
            interface _Assert {
            }
            interface Assert extends CombineTypes<[_Assert, java.lang.Object]> {}
            interface _BasicDiagnosticFormatter$$static extends ClassLike {
              new(options: Options, msgs: JavacMessages): BasicDiagnosticFormatter;
              new(msgs: JavacMessages): BasicDiagnosticFormatter;
            }
            let BasicDiagnosticFormatter: _BasicDiagnosticFormatter$$static;
            interface _BasicDiagnosticFormatter {
              _addSourceLineIfNeeded(d: JCDiagnostic, msg: string): string;
              formatDiagnostic(d: JCDiagnostic, l: java.util.Locale): string;
              formatMessage(d: JCDiagnostic, l: java.util.Locale): string;
              formatMessage(a0: javax.tools.Diagnostic, a1: java.util.Locale): string;
              _formatMeta(c: char, d: JCDiagnostic, l: java.util.Locale): string;
              getConfiguration(): BasicDiagnosticFormatter$BasicConfiguration;
              getConfiguration(): AbstractDiagnosticFormatter$SimpleConfiguration;
              getConfiguration(): javac.api.DiagnosticFormatter$Configuration;
              _selectFormat(d: JCDiagnostic): string;
            }
            interface BasicDiagnosticFormatter extends CombineTypes<[_BasicDiagnosticFormatter, com.sun.tools.javac.util.AbstractDiagnosticFormatter]> {}
            interface _BasicDiagnosticFormatter$BasicConfiguration$$static extends ClassLike {
              new(options: Options): BasicDiagnosticFormatter$BasicConfiguration;
              new(): BasicDiagnosticFormatter$BasicConfiguration;
            }
            let BasicDiagnosticFormatter$BasicConfiguration: _BasicDiagnosticFormatter$BasicConfiguration$$static;
            interface _BasicDiagnosticFormatter$BasicConfiguration {
              getFormat(kind: BasicDiagnosticFormatter$BasicConfiguration$BasicFormatKind): string;
              getIndentation(diagPart: javac.api.DiagnosticFormatter$Configuration$DiagnosticPart): int;
              getSourcePosition(): BasicDiagnosticFormatter$BasicConfiguration$SourcePosition;
              _initFormat(): void;
              _initFormats(pos: string, nopos: string, clazz: string): void;
              _initFormats(fmt: string): void;
              _initIndentation(): void;
              _initOldFormat(): void;
              setFormat(kind: BasicDiagnosticFormatter$BasicConfiguration$BasicFormatKind, s: string): void;
              setIndentation(diagPart: javac.api.DiagnosticFormatter$Configuration$DiagnosticPart, nSpaces: int): void;
              setSourcePosition(sourcePos: BasicDiagnosticFormatter$BasicConfiguration$SourcePosition): void;
              _availableFormats: java.util.Map<BasicDiagnosticFormatter$BasicConfiguration$BasicFormatKind,string>;
              _indentationLevels: java.util.Map<javac.api.DiagnosticFormatter$Configuration$DiagnosticPart,int>;
              _sourcePosition: BasicDiagnosticFormatter$BasicConfiguration$SourcePosition;
            }
            interface BasicDiagnosticFormatter$BasicConfiguration extends CombineTypes<[_BasicDiagnosticFormatter$BasicConfiguration, com.sun.tools.javac.util.AbstractDiagnosticFormatter$SimpleConfiguration]> {}
            interface _BasicDiagnosticFormatter$BasicConfiguration$BasicFormatKind$$static extends ClassLike {
              valueOf(name: string): BasicDiagnosticFormatter$BasicConfiguration$BasicFormatKind;
              values(): BasicDiagnosticFormatter$BasicConfiguration$BasicFormatKind[];
              readonly DEFAULT_CLASS_FORMAT: BasicDiagnosticFormatter$BasicConfiguration$BasicFormatKind;
              readonly DEFAULT_NO_POS_FORMAT: BasicDiagnosticFormatter$BasicConfiguration$BasicFormatKind;
              readonly DEFAULT_POS_FORMAT: BasicDiagnosticFormatter$BasicConfiguration$BasicFormatKind;
            }
            let BasicDiagnosticFormatter$BasicConfiguration$BasicFormatKind: _BasicDiagnosticFormatter$BasicConfiguration$BasicFormatKind$$static;
            interface _BasicDiagnosticFormatter$BasicConfiguration$BasicFormatKind {
            }
            interface BasicDiagnosticFormatter$BasicConfiguration$BasicFormatKind extends CombineTypes<[_BasicDiagnosticFormatter$BasicConfiguration$BasicFormatKind]> {}
            interface _BasicDiagnosticFormatter$BasicConfiguration$SourcePosition$$static extends ClassLike {
              valueOf(name: string): BasicDiagnosticFormatter$BasicConfiguration$SourcePosition;
              values(): BasicDiagnosticFormatter$BasicConfiguration$SourcePosition[];
              readonly AFTER_SUMMARY: BasicDiagnosticFormatter$BasicConfiguration$SourcePosition;
              readonly BOTTOM: BasicDiagnosticFormatter$BasicConfiguration$SourcePosition;
            }
            let BasicDiagnosticFormatter$BasicConfiguration$SourcePosition: _BasicDiagnosticFormatter$BasicConfiguration$SourcePosition$$static;
            interface _BasicDiagnosticFormatter$BasicConfiguration$SourcePosition {
            }
            interface BasicDiagnosticFormatter$BasicConfiguration$SourcePosition extends CombineTypes<[_BasicDiagnosticFormatter$BasicConfiguration$SourcePosition]> {}
            interface _Bits$$static extends ClassLike {
              _trailingZeroBits(x: int): int;
              _unassignedBits: int[];
              _wordlen: int;
              _wordmask: int;
              _wordshift: int;
              new(): Bits;
              new(someBits: Bits): Bits;
              new(reset: boolean): Bits;
              _new(bits: int[], initState: Bits$BitsState): Bits;
            }
            let Bits: _Bits$$static;
            interface _Bits {
              andSet(xs: Bits): Bits;
              assign(someBits: Bits): Bits;
              clear(): void;
              diffSet(xs: Bits): Bits;
              dup(): Bits;
              _dupBits(): int[];
              excl(x: int): void;
              excludeFrom(start: int): void;
              incl(x: int): void;
              inclRange(start: int, limit: int): void;
              _internalAndSet(xs: Bits): void;
              _internalReset(): void;
              isMember(x: int): boolean;
              isReset(): boolean;
              nextBit(x: int): int;
              orSet(xs: Bits): Bits;
              reset(): void;
              _sizeTo(len: int): void;
              toString(): string;
              xorSet(xs: Bits): Bits;
              bits: int[];
              _currentState: Bits$BitsState;
            }
            interface Bits extends CombineTypes<[_Bits, java.lang.Object]> {}
            interface _Bits$BitsState$$static extends ClassLike {
              _getState(someBits: int[], reset: boolean): Bits$BitsState;
              valueOf(name: string): Bits$BitsState;
              values(): Bits$BitsState[];
              readonly NORMAL: Bits$BitsState;
              readonly UNINIT: Bits$BitsState;
              readonly UNKNOWN: Bits$BitsState;
            }
            let Bits$BitsState: _Bits$BitsState$$static;
            interface _Bits$BitsState {
            }
            interface Bits$BitsState extends CombineTypes<[_Bits$BitsState]> {}
            interface _ByteBuffer$$static extends ClassLike {
              new(): ByteBuffer;
              new(initialSize: int): ByteBuffer;
              new(elems: byte[]): ByteBuffer;
            }
            let ByteBuffer: _ByteBuffer$$static;
            interface _ByteBuffer {
              appendByte(b: int): void;
              appendBytes(bs: byte[], start: int, len: int): void;
              appendBytes(bs: byte[]): void;
              appendChar(x: int): void;
              appendDouble(x: double): void;
              appendFloat(x: float): void;
              appendInt(x: int): void;
              appendLong(x: long): void;
              appendName(name: Name): void;
              appendStream(input: java.io.InputStream): void;
              asByteBuffer(): java.nio.ByteBuffer;
              getByte(bp: int): byte;
              getChar(bp: int): char;
              getDouble(bp: int): double;
              getFloat(bp: int): float;
              getInt(bp: int): int;
              getLong(bp: int): long;
              reset(): void;
              toName(names: Names): Name;
              verifyRange(off: int, len: int): void;
              elems: byte[];
              length: int;
            }
            interface ByteBuffer extends CombineTypes<[_ByteBuffer, java.lang.Object]> {}
            interface _ByteBuffer$UnderflowException$$static extends ClassLike {
              _serialVersionUID: long;
              new(length: int): ByteBuffer$UnderflowException;
            }
            let ByteBuffer$UnderflowException: _ByteBuffer$UnderflowException$$static;
            interface _ByteBuffer$UnderflowException {
              getLength(): int;
              _length: int;
            }
            interface ByteBuffer$UnderflowException extends CombineTypes<[_ByteBuffer$UnderflowException, java.lang.Exception]> {}
            interface _ClientCodeException$$static extends ClassLike {
              _serialVersionUID: long;
              new(cause: java.lang.Throwable): ClientCodeException;
            }
            let ClientCodeException: _ClientCodeException$$static;
            interface _ClientCodeException {
            }
            interface ClientCodeException extends CombineTypes<[_ClientCodeException, java.lang.RuntimeException]> {}
            interface _Constants$$static extends ClassLike {
              decode(value: any, type: javac.code.Type): any;
              format(value: any, type: javac.code.Type): string;
              format(value: any): string;
              _formatByte(b: byte): string;
              _formatChar(c: char): string;
              _formatDouble(d: double): string;
              _formatFloat(f: float): string;
              _formatLong(lng: long): string;
              _formatShort(s: short): string;
              _formatString(s: string): string;
              new(): Constants;
            }
            let Constants: _Constants$$static;
            interface _Constants {
            }
            interface Constants extends CombineTypes<[_Constants, java.lang.Object]> {}
            interface _Context$$static extends ClassLike {
              _checkState(t: java.util.Map<any,any>): void;
              _uncheckedCast<T>(o: any): T;
              new(): Context;
            }
            let Context: _Context$$static;
            interface _Context {
              dump(): void;
              get<T>(key: Context$Key<T>): T;
              get<T>(clazz: java.lang.Class<T>): T;
              _key<T>(clss: java.lang.Class<T>): Context$Key<T>;
              put<T>(key: Context$Key<T>, fac: Context$Factory<T>): void;
              put<T>(key: Context$Key<T>, data: T): void;
              put<T>(clazz: java.lang.Class<T>, data: T): void;
              put<T>(clazz: java.lang.Class<T>, fac: Context$Factory<T>): void;
              _ft: java.util.Map<Context$Key<any>,Context$Factory<any>>;
              _ht: java.util.Map<Context$Key<any>,any>;
              _kt: java.util.Map<java.lang.Class<any>,Context$Key<any>>;
            }
            interface Context extends CombineTypes<[_Context, java.lang.Object]> {}
            interface _Context$Factory$$static<T> extends ClassLike {
            }
            let Context$Factory: _Context$Factory$$static<T>;
            interface _Context$Factory<T> {
              make(a0: Context): T;
(a0: Context): T;
            }
            interface Context$Factory<T> extends CombineTypes<[_Context$Factory<T>, java.lang.Object]> {}
            interface _Context$Key$$static<T> extends ClassLike {
              new(): Context$Key<T>;
            }
            let Context$Key: _Context$Key$$static<T>;
            interface _Context$Key<T> {
            }
            interface Context$Key<T> extends CombineTypes<[_Context$Key<T>, java.lang.Object]> {}
            interface _Convert$$static extends ClassLike {
              chars2utf(src: char[], sindex: int, dst: byte[], dindex: int, len: int): int;
              chars2utf(src: char[], sindex: int, len: int): byte[];
              chars2utf(src: char[]): byte[];
              classCandidates(name: Name): List<Name>;
              enclosingCandidates(name: Name): List<Name>;
              escapeUnicode(s: string): string;
              _isPrintableAscii(ch: char): boolean;
              packagePart(classname: Name): Name;
              packagePart(classname: string): string;
              quote(s: string): string;
              quote(ch: char): string;
              shortName(name: Name): Name;
              shortName(name: string): string;
              string2int(s: string, radix: int): int;
              string2long(s: string, radix: int): long;
              string2utf(s: string): byte[];
              utf2chars(src: byte[], soff: int, dst: char[], doff: int, len: int, validation: Convert$Validation): int;
              utf2chars(src: byte[], sindex: int, len: int, validation: Convert$Validation): char[];
              utf2string(src: byte[], sindex: int, len: int, validation: Convert$Validation): string;
              utfValidate(buf: byte[], off: int, len: int, validation: Convert$Validation): void;
              new(): Convert;
            }
            let Convert: _Convert$$static;
            interface _Convert {
            }
            interface Convert extends CombineTypes<[_Convert, java.lang.Object]> {}
            interface _Convert$Validation$$static extends ClassLike {
              valueOf(name: string): Convert$Validation;
              values(): Convert$Validation[];
              readonly NONE: Convert$Validation;
              readonly PREJDK14: Convert$Validation;
              readonly STRICT: Convert$Validation;
            }
            let Convert$Validation: _Convert$Validation$$static;
            interface _Convert$Validation {
              allowAnything(): boolean;
              allowLongEncoding(): boolean;
              allowSingleByteNul(): boolean;
              _allowAnything: boolean;
              _allowLongEncoding: boolean;
              _allowSingleByteNul: boolean;
            }
            interface Convert$Validation extends CombineTypes<[_Convert$Validation]> {}
            interface _DefinedBy$$static extends ClassLike {
            }
            let DefinedBy: _DefinedBy$$static;
            interface _DefinedBy {
              value(): DefinedBy$Api;
(): DefinedBy$Api;
            }
            interface DefinedBy extends CombineTypes<[_DefinedBy, java.lang.annotation.Annotation, java.lang.Object]> {}
            interface _DefinedBy$Api$$static extends ClassLike {
              valueOf(name: string): DefinedBy$Api;
              values(): DefinedBy$Api[];
              readonly ANNOTATION_PROCESSING: DefinedBy$Api;
              readonly COMPILER: DefinedBy$Api;
              readonly COMPILER_TREE: DefinedBy$Api;
              readonly LANGUAGE_MODEL: DefinedBy$Api;
            }
            let DefinedBy$Api: _DefinedBy$Api$$static;
            interface _DefinedBy$Api {
              readonly packageRoot: string;
            }
            interface DefinedBy$Api extends CombineTypes<[_DefinedBy$Api]> {}
            interface _Dependencies$$static extends ClassLike {
              instance(context: Context): Dependencies;
              _dependenciesKey: Context$Key<Dependencies>;
              _new(context: Context): Dependencies;
            }
            let Dependencies: _Dependencies$$static;
            interface _Dependencies {
              pop(): void;
              push(a0: javac.code.Symbol$ClassSymbol, a1: Dependencies$CompletionCause): void;
            }
            interface Dependencies extends CombineTypes<[_Dependencies, java.lang.Object]> {}
            interface _Dependencies$CompletionCause$$static extends ClassLike {
              valueOf(name: string): Dependencies$CompletionCause;
              values(): Dependencies$CompletionCause[];
              readonly CLASS_READER: Dependencies$CompletionCause;
              readonly HEADER_PHASE: Dependencies$CompletionCause;
              readonly HIERARCHY_PHASE: Dependencies$CompletionCause;
              readonly IMPORTS_PHASE: Dependencies$CompletionCause;
              readonly MEMBERS_PHASE: Dependencies$CompletionCause;
              readonly MEMBER_ENTER: Dependencies$CompletionCause;
              readonly OTHER: Dependencies$CompletionCause;
              readonly PERMITS_PHASE: Dependencies$CompletionCause;
              readonly RECORD_PHASE: Dependencies$CompletionCause;
            }
            let Dependencies$CompletionCause: _Dependencies$CompletionCause$$static;
            interface _Dependencies$CompletionCause {
            }
            interface Dependencies$CompletionCause extends CombineTypes<[_Dependencies$CompletionCause, GraphUtils$DependencyKind]> {}
            interface _Dependencies$DummyDependencies$$static extends ClassLike {
            }
            let Dependencies$DummyDependencies: _Dependencies$DummyDependencies$$static;
            interface _Dependencies$DummyDependencies {
              pop(): void;
              push(s: javac.code.Symbol$ClassSymbol, phase: Dependencies$CompletionCause): void;
            }
            interface Dependencies$DummyDependencies extends CombineTypes<[_Dependencies$DummyDependencies, com.sun.tools.javac.util.Dependencies]> {}
            interface _Dependencies$GraphDependencies$$static extends ClassLike {
              preRegister(context: Context): void;
              _new(context: Context): Dependencies$GraphDependencies;
            }
            let Dependencies$GraphDependencies: _Dependencies$GraphDependencies$$static;
            interface _Dependencies$GraphDependencies {
              close(): void;
              complete(sym: javac.code.Symbol): void;
              getNodes(): java.util.Collection<Dependencies$GraphDependencies$Node>;
              isTerminal(): boolean;
              pop(): void;
              push(s: javac.code.Symbol$ClassSymbol, phase: Dependencies$CompletionCause): void;
              _push(newNode: Dependencies$GraphDependencies$Node, cc: Dependencies$CompletionCause): Dependencies$GraphDependencies$Node;
              _dependenciesFile: string;
              _dependenciesModes: java.util.EnumSet<Dependencies$GraphDependencies$DependenciesMode>;
              _dependencyNodeMap: java.util.Map<javac.code.Symbol$ClassSymbol,Dependencies$GraphDependencies$Node>;
              _nodeStack: java.util.Stack<Dependencies$GraphDependencies$Node>;
            }
            interface Dependencies$GraphDependencies extends CombineTypes<[_Dependencies$GraphDependencies, com.sun.tools.javac.util.Dependencies, java.io.Closeable, com.sun.tools.javac.code.Symbol$Completer]> {}
            interface _Dependencies$GraphDependencies$CompletionNode$$static extends ClassLike {
              _new(sym: javac.code.Symbol$ClassSymbol): Dependencies$GraphDependencies$CompletionNode;
            }
            let Dependencies$GraphDependencies$CompletionNode: _Dependencies$GraphDependencies$CompletionNode$$static;
            interface _Dependencies$GraphDependencies$CompletionNode {
              getClassSymbol(): javac.code.Symbol$ClassSymbol;
              nodeAttributes(): java.util.Properties;
              _ck: Dependencies$GraphDependencies$CompletionNode$Kind;
            }
            interface Dependencies$GraphDependencies$CompletionNode extends CombineTypes<[_Dependencies$GraphDependencies$CompletionNode, com.sun.tools.javac.util.Dependencies$GraphDependencies$Node]> {}
            interface _Dependencies$GraphDependencies$CompletionNode$Kind$$static extends ClassLike {
              valueOf(name: string): Dependencies$GraphDependencies$CompletionNode$Kind;
              values(): Dependencies$GraphDependencies$CompletionNode$Kind[];
              readonly CLASS: Dependencies$GraphDependencies$CompletionNode$Kind;
              readonly SOURCE: Dependencies$GraphDependencies$CompletionNode$Kind;
            }
            let Dependencies$GraphDependencies$CompletionNode$Kind: _Dependencies$GraphDependencies$CompletionNode$Kind$$static;
            interface _Dependencies$GraphDependencies$CompletionNode$Kind {
              _dotStyle: string;
            }
            interface Dependencies$GraphDependencies$CompletionNode$Kind extends CombineTypes<[_Dependencies$GraphDependencies$CompletionNode$Kind]> {}
            interface _Dependencies$GraphDependencies$DependenciesMode$$static extends ClassLike {
              _getDependenciesModes(modes: string[]): java.util.EnumSet<Dependencies$GraphDependencies$DependenciesMode>;
              valueOf(name: string): Dependencies$GraphDependencies$DependenciesMode;
              values(): Dependencies$GraphDependencies$DependenciesMode[];
              readonly CLASS: Dependencies$GraphDependencies$DependenciesMode;
              readonly REDUNDANT: Dependencies$GraphDependencies$DependenciesMode;
              readonly SOURCE: Dependencies$GraphDependencies$DependenciesMode;
            }
            let Dependencies$GraphDependencies$DependenciesMode: _Dependencies$GraphDependencies$DependenciesMode$$static;
            interface _Dependencies$GraphDependencies$DependenciesMode {
              _opt: string;
            }
            interface Dependencies$GraphDependencies$DependenciesMode extends CombineTypes<[_Dependencies$GraphDependencies$DependenciesMode]> {}
            interface _Dependencies$GraphDependencies$FilterVisitor$$static extends ClassLike {
            }
            let Dependencies$GraphDependencies$FilterVisitor: _Dependencies$GraphDependencies$FilterVisitor$$static;
            interface _Dependencies$GraphDependencies$FilterVisitor {
              visitDependency(dk: GraphUtils$DependencyKind, from: Dependencies$GraphDependencies$Node, to: Dependencies$GraphDependencies$Node, arg: java.lang.Void): void;
              visitDependency(a0: GraphUtils$DependencyKind, a1: GraphUtils$Node, a2: GraphUtils$Node, a3: any): void;
              visitNode(node: Dependencies$GraphDependencies$Node, arg: java.lang.Void): void;
              visitNode(a0: GraphUtils$Node, a1: any): void;
              _ck: Dependencies$GraphDependencies$CompletionNode$Kind;
              _this$0: Dependencies$GraphDependencies;
            }
            interface Dependencies$GraphDependencies$FilterVisitor extends CombineTypes<[_Dependencies$GraphDependencies$FilterVisitor, GraphUtils$NodeVisitor<javac.code.Symbol$ClassSymbol,Dependencies$GraphDependencies$Node,java.lang.Void>]> {}
            interface _Dependencies$GraphDependencies$Node$$static extends ClassLike {
              _new(value: javac.code.Symbol$ClassSymbol): Dependencies$GraphDependencies$Node;
            }
            let Dependencies$GraphDependencies$Node: _Dependencies$GraphDependencies$Node$$static;
            interface _Dependencies$GraphDependencies$Node {
              _addDependency(depKind: GraphUtils$DependencyKind, dep: Dependencies$GraphDependencies$Node): void;
              dependencyAttributes(to: Dependencies$GraphDependencies$Node, dk: GraphUtils$DependencyKind): java.util.Properties;
              dependencyAttributes(a0: GraphUtils$DottableNode, a1: GraphUtils$DependencyKind): java.util.Properties;
              equals(obj: any): boolean;
              getDependenciesByKind(dk: GraphUtils$DependencyKind): java.util.Collection<Dependencies$GraphDependencies$Node>;
              getSupportedDependencyKinds(): GraphUtils$DependencyKind[];
              hashCode(): int;
              nodeAttributes(): java.util.Properties;
              toString(): string;
              _depsByKind: java.util.EnumMap<Dependencies$CompletionCause,java.util.List<Dependencies$GraphDependencies$Node>>;
            }
            interface Dependencies$GraphDependencies$Node extends CombineTypes<[_Dependencies$GraphDependencies$Node, GraphUtils$DottableNode<javac.code.Symbol$ClassSymbol,Dependencies$GraphDependencies$Node>, GraphUtils$AbstractNode<javac.code.Symbol$ClassSymbol,Dependencies$GraphDependencies$Node>]> {}
            interface _Dependencies$GraphDependencies$PruneVisitor$$static extends ClassLike {
            }
            let Dependencies$GraphDependencies$PruneVisitor: _Dependencies$GraphDependencies$PruneVisitor$$static;
            interface _Dependencies$GraphDependencies$PruneVisitor {
              visitDependency(dk: GraphUtils$DependencyKind, from: Dependencies$GraphDependencies$Node, to: Dependencies$GraphDependencies$Node, arg: java.lang.Void): void;
              visitDependency(a0: GraphUtils$DependencyKind, a1: GraphUtils$Node, a2: GraphUtils$Node, a3: any): void;
              visitNode(node: Dependencies$GraphDependencies$Node, arg: java.lang.Void): void;
              visitNode(a0: GraphUtils$Node, a1: any): void;
            }
            interface Dependencies$GraphDependencies$PruneVisitor extends CombineTypes<[_Dependencies$GraphDependencies$PruneVisitor, GraphUtils$NodeVisitor<javac.code.Symbol$ClassSymbol,Dependencies$GraphDependencies$Node,java.lang.Void>]> {}
            interface _DiagnosticSource$$static extends ClassLike {
              readonly NO_SOURCE: DiagnosticSource;
              new(fo: javax.tools.JavaFileObject, log: AbstractLog): DiagnosticSource;
            }
            let DiagnosticSource: _DiagnosticSource$$static;
            interface _DiagnosticSource {
              _findLine(pos: int): boolean;
              getColumnNumber(pos: int, expandTabs: boolean): int;
              getEndPosTable(): javac.tree.EndPosTable;
              getFile(): javax.tools.JavaFileObject;
              getLine(pos: int): string;
              getLineNumber(pos: int): int;
              _initBuf(fileObject: javax.tools.JavaFileObject): char[];
              setEndPosTable(t: javac.tree.EndPosTable): void;
              _buf: char[];
              _bufLen: int;
              _endPosTable: javac.tree.EndPosTable;
              _fileObject: javax.tools.JavaFileObject;
              _line: int;
              _lineStart: int;
              _log: AbstractLog;
              _refBuf: java.lang.ref.SoftReference<char[]>;
            }
            interface DiagnosticSource extends CombineTypes<[_DiagnosticSource, java.lang.Object]> {}
            interface _FatalError$$static extends ClassLike {
              _serialVersionUID: long;
              new(d: JCDiagnostic): FatalError;
              new(d: JCDiagnostic, t: java.lang.Throwable): FatalError;
              new(s: string): FatalError;
            }
            let FatalError: _FatalError$$static;
            interface _FatalError {
            }
            interface FatalError extends CombineTypes<[_FatalError, java.lang.Error]> {}
            interface _ForwardingDiagnosticFormatter$$static<D,F> extends ClassLike {
              new(formatter: F): ForwardingDiagnosticFormatter<D,F>;
            }
            let ForwardingDiagnosticFormatter: _ForwardingDiagnosticFormatter$$static<D,F>;
            interface _ForwardingDiagnosticFormatter<D,F> {
              displaySource(diag: D): boolean;
              format(diag: D, l: java.util.Locale): string;
              formatKind(diag: D, l: java.util.Locale): string;
              formatMessage(diag: D, l: java.util.Locale): string;
              formatPosition(diag: D, pk: javac.api.DiagnosticFormatter$PositionKind, l: java.util.Locale): string;
              formatSource(diag: D, fullname: boolean, l: java.util.Locale): string;
              getConfiguration(): javac.api.DiagnosticFormatter$Configuration;
              getDelegatedFormatter(): F;
              _configuration: ForwardingDiagnosticFormatter$ForwardingConfiguration;
              _formatter: F;
            }
            interface ForwardingDiagnosticFormatter<D,F> extends CombineTypes<[_ForwardingDiagnosticFormatter<D,F>, javac.api.DiagnosticFormatter<D>, java.lang.Object]> {}
            interface _ForwardingDiagnosticFormatter$ForwardingConfiguration$$static extends ClassLike {
              new(configuration: javac.api.DiagnosticFormatter$Configuration): ForwardingDiagnosticFormatter$ForwardingConfiguration;
            }
            let ForwardingDiagnosticFormatter$ForwardingConfiguration: _ForwardingDiagnosticFormatter$ForwardingConfiguration$$static;
            interface _ForwardingDiagnosticFormatter$ForwardingConfiguration {
              getDelegatedConfiguration(): javac.api.DiagnosticFormatter$Configuration;
              getMultilineLimit(limit: javac.api.DiagnosticFormatter$Configuration$MultilineLimit): int;
              getVisible(): java.util.Set<javac.api.DiagnosticFormatter$Configuration$DiagnosticPart>;
              setMultilineLimit(limit: javac.api.DiagnosticFormatter$Configuration$MultilineLimit, value: int): void;
              setVisible(diagParts: java.util.Set<javac.api.DiagnosticFormatter$Configuration$DiagnosticPart>): void;
              _configuration: javac.api.DiagnosticFormatter$Configuration;
            }
            interface ForwardingDiagnosticFormatter$ForwardingConfiguration extends CombineTypes<[_ForwardingDiagnosticFormatter$ForwardingConfiguration, com.sun.tools.javac.api.DiagnosticFormatter$Configuration, java.lang.Object]> {}
            interface _GraphUtils$$static extends ClassLike {
              tarjan<D, N>(nodes: java.lang.Iterable<N>): List<List<N>>;
              toDot<D, N>(nodes: java.util.Collection<N>, name: string, header: string): string;
              new(): GraphUtils;
            }
            let GraphUtils: _GraphUtils$$static;
            interface _GraphUtils {
            }
            interface GraphUtils extends CombineTypes<[_GraphUtils, java.lang.Object]> {}
            interface _GraphUtils$AbstractNode$$static<D,N> extends ClassLike {
              new(data: D): GraphUtils$AbstractNode<D,N>;
            }
            let GraphUtils$AbstractNode: _GraphUtils$AbstractNode$$static<D,N>;
            interface _GraphUtils$AbstractNode<D,N> {
              accept<A>(visitor: GraphUtils$NodeVisitor<D,N,A>, arg: A): void;
              getDependenciesByKind(a0: GraphUtils$DependencyKind): java.util.Collection<N>;
              getSupportedDependencyKinds(): GraphUtils$DependencyKind[];
              toString(): string;
              readonly data: D;
            }
            interface GraphUtils$AbstractNode<D,N> extends CombineTypes<[_GraphUtils$AbstractNode<D,N>, GraphUtils$Node<D,N>, java.lang.Object]> {}
            interface _GraphUtils$DependencyKind$$static extends ClassLike {
            }
            let GraphUtils$DependencyKind: _GraphUtils$DependencyKind$$static;
            interface _GraphUtils$DependencyKind {
            }
            interface GraphUtils$DependencyKind extends CombineTypes<[_GraphUtils$DependencyKind, java.lang.Object]> {}
            interface _GraphUtils$DotVisitor$$static<D,N> extends ClassLike {
              _wrap(s: string): string;
              new(): GraphUtils$DotVisitor<D,N>;
            }
            let GraphUtils$DotVisitor: _GraphUtils$DotVisitor$$static<D,N>;
            interface _GraphUtils$DotVisitor<D,N> {
              _formatProperties(p: java.util.Properties): string;
              visit(a0: java.util.Collection, a1: any): void;
              visitDependency(dk: GraphUtils$DependencyKind, from: N, to: N, buf: GraphUtils$DotVisitor$stringBuilder): void;
              visitDependency(a0: GraphUtils$DependencyKind, a1: GraphUtils$Node, a2: GraphUtils$Node, a3: any): void;
              visitNode(node: N, buf: GraphUtils$DotVisitor$stringBuilder): void;
              visitNode(a0: GraphUtils$Node, a1: any): void;
            }
            interface GraphUtils$DotVisitor<D,N> extends CombineTypes<[_GraphUtils$DotVisitor<D,N>, GraphUtils$NodeVisitor<D,N,util$stringBuilder>]> {}
            interface _GraphUtils$DottableNode$$static<D,N> extends ClassLike {
            }
            let GraphUtils$DottableNode: _GraphUtils$DottableNode$$static<D,N>;
            interface _GraphUtils$DottableNode<D,N> {
              dependencyAttributes(a0: N, a1: GraphUtils$DependencyKind): java.util.Properties;
              nodeAttributes(): java.util.Properties;
            }
            interface GraphUtils$DottableNode<D,N> extends CombineTypes<[_GraphUtils$DottableNode<D,N>, GraphUtils$Node<D,N>, java.lang.Object]> {}
            interface _GraphUtils$Node$$static<D,N> extends ClassLike {
            }
            let GraphUtils$Node: _GraphUtils$Node$$static<D,N>;
            interface _GraphUtils$Node<D,N> {
              accept<A>(a0: GraphUtils$NodeVisitor<D,N,A>, a1: A): void;
<A>(a0: GraphUtils$NodeVisitor<D,N,A>, a1: A): void;
            }
            interface GraphUtils$Node<D,N> extends CombineTypes<[_GraphUtils$Node<D,N>, java.lang.Object]> {}
            interface _GraphUtils$NodeVisitor$$static<D,N,A> extends ClassLike {
              _new(): GraphUtils$NodeVisitor<D,N,A>;
            }
            let GraphUtils$NodeVisitor: _GraphUtils$NodeVisitor$$static<D,N,A>;
            interface _GraphUtils$NodeVisitor<D,N,A> {
              visit(nodes: java.util.Collection<N>, arg: A): void;
              visitDependency(a0: GraphUtils$DependencyKind, a1: N, a2: N, a3: A): void;
              visitNode(a0: N, a1: A): void;
            }
            interface GraphUtils$NodeVisitor<D,N,A> extends CombineTypes<[_GraphUtils$NodeVisitor<D,N,A>, java.lang.Object]> {}
            interface _GraphUtils$Tarjan$$static<D,N> extends ClassLike {
            }
            let GraphUtils$Tarjan: _GraphUtils$Tarjan$$static<D,N>;
            interface _GraphUtils$Tarjan<D,N> {
              _addSCC(v: N): void;
              _findSCC(nodes: java.lang.Iterable<N>): List<List<N>>;
              _findSCC(v: N): void;
              _visitNode(n: N): void;
              _index: int;
              _sccs: ListBuffer<List<N>>;
              _stack: ListBuffer<N>;
            }
            interface GraphUtils$Tarjan<D,N> extends CombineTypes<[_GraphUtils$Tarjan<D,N>, java.lang.Object]> {}
            interface _GraphUtils$TarjanNode$$static<D,N> extends ClassLike {
              new(data: D): GraphUtils$TarjanNode<D,N>;
            }
            let GraphUtils$TarjanNode: _GraphUtils$TarjanNode$$static<D,N>;
            interface _GraphUtils$TarjanNode<D,N> {
              compareTo(o: N): int;
              compareTo(a0: any): int;
              getAllDependencies(): java.lang.Iterable<N>;
(): java.lang.Iterable<N>;
              _active: boolean;
              _index: int;
              _lowlink: int;
            }
            interface GraphUtils$TarjanNode<D,N> extends CombineTypes<[_GraphUtils$TarjanNode<D,N>, java.lang.Comparable<N>, GraphUtils$AbstractNode<D,N>]> {}
            interface _IntHashTable$$static extends ClassLike {
              _DEFAULT_INITIAL_SIZE: int;
              _DELETED: any;
              new(): IntHashTable;
              new(capacity: int): IntHashTable;
            }
            let IntHashTable: _IntHashTable$$static;
            interface _IntHashTable {
              clear(): void;
              get(key: any): int;
              _hash(key: any): int;
              _lookup(key: any): int;
              put(key: any, value: int): int;
              _rehash(): void;
              remove(key: any): int;
              _ints: int[];
              _mask: int;
              _num_bindings: int;
              _objs: any[];
            }
            interface IntHashTable extends CombineTypes<[_IntHashTable, java.lang.Object]> {}
            interface _InvalidUtfException$$static extends ClassLike {
              _serialVersionUID: long;
              new(offset: int): InvalidUtfException;
            }
            let InvalidUtfException: _InvalidUtfException$$static;
            interface _InvalidUtfException {
              getOffset(): int;
              _offset: int;
            }
            interface InvalidUtfException extends CombineTypes<[_InvalidUtfException, java.lang.Exception]> {}
            interface _Iterators$$static extends ClassLike {
              createCompoundIterator<I, O>(inputs: java.lang.Iterable<I>, converter: java.util.function.Function<I,java.util.Iterator<O>>): java.util.Iterator<O>;
              createFilterIterator<E>(input: java.util.Iterator<E>, test: java.util.function.Predicate<E>): java.util.Iterator<E>;
              emptyIterator<T>(): java.util.Iterator<T>;
              _EMPTY: java.util.Iterator<any>;
              new(): Iterators;
            }
            let Iterators: _Iterators$$static;
            interface _Iterators {
            }
            interface Iterators extends CombineTypes<[_Iterators, java.lang.Object]> {}
            interface _Iterators$CompoundIterator$$static<I,O> extends ClassLike {
              new(inputs: java.lang.Iterable<I>, converter: java.util.function.Function<I,java.util.Iterator<O>>): Iterators$CompoundIterator<I,O>;
            }
            let Iterators$CompoundIterator: _Iterators$CompoundIterator$$static<I,O>;
            interface _Iterators$CompoundIterator<I,O> {
              hasNext(): boolean;
              next(): O;
              _converter: java.util.function.Function<I,java.util.Iterator<O>>;
              _currentIterator: java.util.Iterator<O>;
              _inputs: java.util.Iterator<I>;
            }
            interface Iterators$CompoundIterator<I,O> extends CombineTypes<[_Iterators$CompoundIterator<I,O>, java.lang.Object, java.util.Iterator<O>]> {}
            interface _JCDiagnostic$$static extends ClassLike {
              fragment(key: string, args: any[]): JCDiagnostic;
              fragment(key: string, ...args: any[]): JCDiagnostic;
              getFragmentFormatter(): javac.api.DiagnosticFormatter<JCDiagnostic>;
              _fragmentFormatter: javac.api.DiagnosticFormatter<JCDiagnostic>;
              _new(formatter: javac.api.DiagnosticFormatter<JCDiagnostic>, diagnosticInfo: JCDiagnostic$DiagnosticInfo, lc: javac.code.Lint$LintCategory, flags: java.util.Set<JCDiagnostic$DiagnosticFlag>, source: DiagnosticSource, pos: JCDiagnostic$DiagnosticPosition): JCDiagnostic;
              _new(formatter: javac.api.DiagnosticFormatter<JCDiagnostic>, diagnosticInfo: JCDiagnostic$DiagnosticInfo, lc: javac.code.Lint$LintCategory, flags: java.util.Set<JCDiagnostic$DiagnosticFlag>, source: DiagnosticSource, pos: JCDiagnostic$DiagnosticPosition, rewriter: java.util.function.UnaryOperator<JCDiagnostic>): JCDiagnostic;
            }
            let JCDiagnostic: _JCDiagnostic$$static;
            interface _JCDiagnostic {
              getArgs(): any[];
              getCode(): string;
              getColumnNumber(): long;
              getDiagnosticPosition(): JCDiagnostic$DiagnosticPosition;
              getDiagnosticSource(): DiagnosticSource;
              getEndPosition(): long;
              _getIntEndPosition(): int;
              _getIntPosition(): int;
              _getIntStartPosition(): int;
              getKind(): javax.tools.Diagnostic$Kind;
              getLineNumber(): long;
              getLintCategory(): javac.code.Lint$LintCategory;
              getMessage(locale: java.util.Locale): string;
              getPosition(): long;
              getPrefix(): string;
              getPrefix(dt: JCDiagnostic$DiagnosticType): string;
              getSource(): javax.tools.JavaFileObject;
              getSource(): any;
              getStartPosition(): long;
              getSubdiagnostics(): List<JCDiagnostic>;
              getType(): JCDiagnostic$DiagnosticType;
              hasLintCategory(): boolean;
              _hasRewriter(): boolean;
              isFlagSet(flag: JCDiagnostic$DiagnosticFlag): boolean;
              isMandatory(): boolean;
              isMultiline(): boolean;
              _rewrite(): JCDiagnostic;
              setFlag(flag: JCDiagnostic$DiagnosticFlag): void;
              toString(): string;
              _defaultFormatter: javac.api.DiagnosticFormatter<JCDiagnostic>;
              _diagnosticInfo: JCDiagnostic$DiagnosticInfo;
              _flags: java.util.Set<JCDiagnostic$DiagnosticFlag>;
              _lintCategory: javac.code.Lint$LintCategory;
              _position: JCDiagnostic$DiagnosticPosition;
              _rewriter: java.util.function.UnaryOperator<JCDiagnostic>;
              _source: DiagnosticSource;
              _sourcePosition: JCDiagnostic$SourcePosition;
            }
            interface JCDiagnostic extends CombineTypes<[_JCDiagnostic, javax.tools.Diagnostic<javax.tools.JavaFileObject>, java.lang.Object]> {}
            interface _JCDiagnostic$DiagnosticFlag$$static extends ClassLike {
              valueOf(name: string): JCDiagnostic$DiagnosticFlag;
              values(): JCDiagnostic$DiagnosticFlag[];
              readonly API: JCDiagnostic$DiagnosticFlag;
              readonly COMPRESSED: JCDiagnostic$DiagnosticFlag;
              readonly MANDATORY: JCDiagnostic$DiagnosticFlag;
              readonly NON_DEFERRABLE: JCDiagnostic$DiagnosticFlag;
              readonly RECOVERABLE: JCDiagnostic$DiagnosticFlag;
              readonly RESOLVE_ERROR: JCDiagnostic$DiagnosticFlag;
              readonly SOURCE_LEVEL: JCDiagnostic$DiagnosticFlag;
              readonly SYNTAX: JCDiagnostic$DiagnosticFlag;
            }
            let JCDiagnostic$DiagnosticFlag: _JCDiagnostic$DiagnosticFlag$$static;
            interface _JCDiagnostic$DiagnosticFlag {
            }
            interface JCDiagnostic$DiagnosticFlag extends CombineTypes<[_JCDiagnostic$DiagnosticFlag]> {}
            interface _JCDiagnostic$DiagnosticInfo$$static extends ClassLike {
              of(type: JCDiagnostic$DiagnosticType, prefix: string, code: string, args: any[]): JCDiagnostic$DiagnosticInfo;
              of(type: JCDiagnostic$DiagnosticType, prefix: string, code: string, ...args: any[]): JCDiagnostic$DiagnosticInfo;
            }
            let JCDiagnostic$DiagnosticInfo: _JCDiagnostic$DiagnosticInfo$$static;
            interface _JCDiagnostic$DiagnosticInfo {
              getArgs(): any[];
              getCode(): string;
              key(): string;
              setArgs(args: any[]): void;
              _args: any[];
              _code: string;
              _prefix: string;
              _type: JCDiagnostic$DiagnosticType;
            }
            interface JCDiagnostic$DiagnosticInfo extends CombineTypes<[_JCDiagnostic$DiagnosticInfo, java.lang.Object]> {}
            interface _JCDiagnostic$DiagnosticPosition$$static extends ClassLike {
            }
            let JCDiagnostic$DiagnosticPosition: _JCDiagnostic$DiagnosticPosition$$static;
            interface _JCDiagnostic$DiagnosticPosition {
              getEndPosition(a0: javac.tree.EndPosTable): int;
              getPreferredPosition(): int;
              getStartPosition(): int;
              getTree(): javac.tree.JCTree;
            }
            interface JCDiagnostic$DiagnosticPosition extends CombineTypes<[_JCDiagnostic$DiagnosticPosition, java.lang.Object]> {}
            interface _JCDiagnostic$DiagnosticType$$static extends ClassLike {
              valueOf(name: string): JCDiagnostic$DiagnosticType;
              values(): JCDiagnostic$DiagnosticType[];
              readonly ERROR: JCDiagnostic$DiagnosticType;
              readonly FRAGMENT: JCDiagnostic$DiagnosticType;
              readonly NOTE: JCDiagnostic$DiagnosticType;
              readonly WARNING: JCDiagnostic$DiagnosticType;
            }
            let JCDiagnostic$DiagnosticType: _JCDiagnostic$DiagnosticType$$static;
            interface _JCDiagnostic$DiagnosticType {
              _key: string;
            }
            interface JCDiagnostic$DiagnosticType extends CombineTypes<[_JCDiagnostic$DiagnosticType]> {}
            interface _JCDiagnostic$Error$$static extends ClassLike {
              new(prefix: string, key: string, args: any[]): JCDiagnostic$Error;
              new(prefix: string, key: string, ...args: any[]): JCDiagnostic$Error;
            }
            let JCDiagnostic$Error: _JCDiagnostic$Error$$static;
            interface _JCDiagnostic$Error {
            }
            interface JCDiagnostic$Error extends CombineTypes<[_JCDiagnostic$Error, com.sun.tools.javac.util.JCDiagnostic$DiagnosticInfo]> {}
            interface _JCDiagnostic$Factory$$static extends ClassLike {
              instance(context: Context): JCDiagnostic$Factory;
              _diagnosticFactoryKey: Context$Key<JCDiagnostic$Factory>;
              _new(context: Context): JCDiagnostic$Factory;
              new(messages: JavacMessages, prefix: string): JCDiagnostic$Factory;
            }
            let JCDiagnostic$Factory: _JCDiagnostic$Factory$$static;
            interface _JCDiagnostic$Factory {
              create(kind: JCDiagnostic$DiagnosticType, source: DiagnosticSource, pos: JCDiagnostic$DiagnosticPosition, key: string, args: any[]): JCDiagnostic;
              create(kind: JCDiagnostic$DiagnosticType, source: DiagnosticSource, pos: JCDiagnostic$DiagnosticPosition, key: string, ...args: any[]): JCDiagnostic;
              create(kind: JCDiagnostic$DiagnosticType, source: DiagnosticSource, pos: JCDiagnostic$DiagnosticPosition, key: string, rewriter: java.util.function.UnaryOperator<JCDiagnostic>, args: any[]): JCDiagnostic;
              create(kind: JCDiagnostic$DiagnosticType, source: DiagnosticSource, pos: JCDiagnostic$DiagnosticPosition, key: string, rewriter: java.util.function.UnaryOperator<JCDiagnostic>, ...args: any[]): JCDiagnostic;
              create(source: DiagnosticSource, pos: JCDiagnostic$DiagnosticPosition, diagnosticInfo: JCDiagnostic$DiagnosticInfo): JCDiagnostic;
              create(kind: JCDiagnostic$DiagnosticType, lc: javac.code.Lint$LintCategory, flags: java.util.Set<JCDiagnostic$DiagnosticFlag>, source: DiagnosticSource, pos: JCDiagnostic$DiagnosticPosition, key: string, args: any[]): JCDiagnostic;
              create(kind: JCDiagnostic$DiagnosticType, lc: javac.code.Lint$LintCategory, flags: java.util.Set<JCDiagnostic$DiagnosticFlag>, source: DiagnosticSource, pos: JCDiagnostic$DiagnosticPosition, key: string, ...args: any[]): JCDiagnostic;
              create(lc: javac.code.Lint$LintCategory, flags: java.util.Set<JCDiagnostic$DiagnosticFlag>, source: DiagnosticSource, pos: JCDiagnostic$DiagnosticPosition, diagnosticInfo: JCDiagnostic$DiagnosticInfo): JCDiagnostic;
              create(lc: javac.code.Lint$LintCategory, flags: java.util.Set<JCDiagnostic$DiagnosticFlag>, source: DiagnosticSource, pos: JCDiagnostic$DiagnosticPosition, diagnosticInfo: JCDiagnostic$DiagnosticInfo, rewriter: java.util.function.UnaryOperator<JCDiagnostic>): JCDiagnostic;
              error(flag: JCDiagnostic$DiagnosticFlag, source: DiagnosticSource, pos: JCDiagnostic$DiagnosticPosition, key: string, args: any[]): JCDiagnostic;
              error(flag: JCDiagnostic$DiagnosticFlag, source: DiagnosticSource, pos: JCDiagnostic$DiagnosticPosition, key: string, ...args: any[]): JCDiagnostic;
              error(flag: JCDiagnostic$DiagnosticFlag, source: DiagnosticSource, pos: JCDiagnostic$DiagnosticPosition, errorKey: JCDiagnostic$Error): JCDiagnostic;
              errorKey(code: string, args: any[]): JCDiagnostic$Error;
              errorKey(code: string, ...args: any[]): JCDiagnostic$Error;
              fragment(key: string, args: any[]): JCDiagnostic;
              fragment(key: string, ...args: any[]): JCDiagnostic;
              fragment(fragmentKey: JCDiagnostic$Fragment): JCDiagnostic;
              _fragmentKey(code: string, args: any[]): JCDiagnostic$Fragment;
              _fragmentKey(code: string, ...args: any[]): JCDiagnostic$Fragment;
              _initOptions(options: Options): void;
              mandatoryNote(source: DiagnosticSource, key: string, args: any[]): JCDiagnostic;
              mandatoryNote(source: DiagnosticSource, key: string, ...args: any[]): JCDiagnostic;
              mandatoryNote(source: DiagnosticSource, noteKey: JCDiagnostic$Note): JCDiagnostic;
              mandatoryWarning(lc: javac.code.Lint$LintCategory, source: DiagnosticSource, pos: JCDiagnostic$DiagnosticPosition, key: string, args: any[]): JCDiagnostic;
              mandatoryWarning(lc: javac.code.Lint$LintCategory, source: DiagnosticSource, pos: JCDiagnostic$DiagnosticPosition, key: string, ...args: any[]): JCDiagnostic;
              mandatoryWarning(lc: javac.code.Lint$LintCategory, source: DiagnosticSource, pos: JCDiagnostic$DiagnosticPosition, warningKey: JCDiagnostic$Warning): JCDiagnostic;
              _normalize(diagnosticInfo: JCDiagnostic$DiagnosticInfo): JCDiagnostic$DiagnosticInfo;
              note(source: DiagnosticSource, pos: JCDiagnostic$DiagnosticPosition, key: string, args: any[]): JCDiagnostic;
              note(source: DiagnosticSource, pos: JCDiagnostic$DiagnosticPosition, key: string, ...args: any[]): JCDiagnostic;
              note(source: DiagnosticSource, pos: JCDiagnostic$DiagnosticPosition, noteKey: JCDiagnostic$Note): JCDiagnostic;
              noteKey(code: string, args: any[]): JCDiagnostic$Note;
              noteKey(code: string, ...args: any[]): JCDiagnostic$Note;
              warning(lc: javac.code.Lint$LintCategory, source: DiagnosticSource, pos: JCDiagnostic$DiagnosticPosition, key: string, args: any[]): JCDiagnostic;
              warning(lc: javac.code.Lint$LintCategory, source: DiagnosticSource, pos: JCDiagnostic$DiagnosticPosition, key: string, ...args: any[]): JCDiagnostic;
              warning(lc: javac.code.Lint$LintCategory, source: DiagnosticSource, pos: JCDiagnostic$DiagnosticPosition, warningKey: JCDiagnostic$Warning): JCDiagnostic;
              _warningKey(code: string, args: any[]): JCDiagnostic$Warning;
              _warningKey(code: string, ...args: any[]): JCDiagnostic$Warning;
              _defaultErrorFlags: java.util.Set<JCDiagnostic$DiagnosticFlag>;
              _formatter: javac.api.DiagnosticFormatter<JCDiagnostic>;
              _prefix: string;
            }
            interface JCDiagnostic$Factory extends CombineTypes<[_JCDiagnostic$Factory, java.lang.Object]> {}
            interface _JCDiagnostic$Fragment$$static extends ClassLike {
              new(prefix: string, key: string, args: any[]): JCDiagnostic$Fragment;
              new(prefix: string, key: string, ...args: any[]): JCDiagnostic$Fragment;
            }
            let JCDiagnostic$Fragment: _JCDiagnostic$Fragment$$static;
            interface _JCDiagnostic$Fragment {
            }
            interface JCDiagnostic$Fragment extends CombineTypes<[_JCDiagnostic$Fragment, com.sun.tools.javac.util.JCDiagnostic$DiagnosticInfo]> {}
            interface _JCDiagnostic$MultilineDiagnostic$$static extends ClassLike {
              new(other: JCDiagnostic, subdiagnostics: List<JCDiagnostic>): JCDiagnostic$MultilineDiagnostic;
            }
            let JCDiagnostic$MultilineDiagnostic: _JCDiagnostic$MultilineDiagnostic$$static;
            interface _JCDiagnostic$MultilineDiagnostic {
              getSource(): any;
              getSubdiagnostics(): List<JCDiagnostic>;
              isMultiline(): boolean;
              _subdiagnostics: List<JCDiagnostic>;
            }
            interface JCDiagnostic$MultilineDiagnostic extends CombineTypes<[_JCDiagnostic$MultilineDiagnostic, com.sun.tools.javac.util.JCDiagnostic]> {}
            interface _JCDiagnostic$Note$$static extends ClassLike {
              new(prefix: string, key: string, args: any[]): JCDiagnostic$Note;
              new(prefix: string, key: string, ...args: any[]): JCDiagnostic$Note;
            }
            let JCDiagnostic$Note: _JCDiagnostic$Note$$static;
            interface _JCDiagnostic$Note {
            }
            interface JCDiagnostic$Note extends CombineTypes<[_JCDiagnostic$Note, com.sun.tools.javac.util.JCDiagnostic$DiagnosticInfo]> {}
            interface _JCDiagnostic$SimpleDiagnosticPosition$$static extends ClassLike {
              new(pos: int): JCDiagnostic$SimpleDiagnosticPosition;
            }
            let JCDiagnostic$SimpleDiagnosticPosition: _JCDiagnostic$SimpleDiagnosticPosition$$static;
            interface _JCDiagnostic$SimpleDiagnosticPosition {
              getEndPosition(endPosTable: javac.tree.EndPosTable): int;
              getPreferredPosition(): int;
              getStartPosition(): int;
              getTree(): javac.tree.JCTree;
              _pos: int;
            }
            interface JCDiagnostic$SimpleDiagnosticPosition extends CombineTypes<[_JCDiagnostic$SimpleDiagnosticPosition, com.sun.tools.javac.util.JCDiagnostic$DiagnosticPosition, java.lang.Object]> {}
            interface _JCDiagnostic$SourcePosition$$static extends ClassLike {
              _new(this$0: JCDiagnostic): JCDiagnostic$SourcePosition;
            }
            let JCDiagnostic$SourcePosition: _JCDiagnostic$SourcePosition$$static;
            interface _JCDiagnostic$SourcePosition {
              getColumnNumber(): int;
              getLineNumber(): int;
              _column: int;
              _line: int;
            }
            interface JCDiagnostic$SourcePosition extends CombineTypes<[_JCDiagnostic$SourcePosition, java.lang.Object]> {}
            interface _JCDiagnostic$Warning$$static extends ClassLike {
              new(prefix: string, key: string, args: any[]): JCDiagnostic$Warning;
              new(prefix: string, key: string, ...args: any[]): JCDiagnostic$Warning;
            }
            let JCDiagnostic$Warning: _JCDiagnostic$Warning$$static;
            interface _JCDiagnostic$Warning {
            }
            interface JCDiagnostic$Warning extends CombineTypes<[_JCDiagnostic$Warning, com.sun.tools.javac.util.JCDiagnostic$DiagnosticInfo]> {}
            interface _JavacMessages$$static extends ClassLike {
              getDefaultBundle(): java.util.ResourceBundle;
              _getDefaultLocalizedString(key: string, args: any[]): string;
              _getDefaultLocalizedString(key: string, ...args: any[]): string;
              _getDefaultMessages(): JavacMessages;
              _getLocalizedString(bundles: List<java.util.ResourceBundle>, key: string, args: any[]): string;
              _getLocalizedString(bundles: List<java.util.ResourceBundle>, key: string, ...args: any[]): string;
              instance(context: Context): JavacMessages;
              _defaultBundle: java.util.ResourceBundle;
              _defaultBundleName: string;
              _defaultMessages: JavacMessages;
              readonly messagesKey: Context$Key<JavacMessages>;
              new(context: Context): JavacMessages;
              new(bundleName: string): JavacMessages;
              new(bundleName: string, locale: java.util.Locale): JavacMessages;
              new(): JavacMessages;
            }
            let JavacMessages: _JavacMessages$$static;
            interface _JavacMessages {
              add(bundleName: string): void;
              add(ma: JavacMessages$ResourceBundleHelper): void;
              getBundles(locale: java.util.Locale): List<java.util.ResourceBundle>;
              getCurrentLocale(): java.util.Locale;
              _getDiagFactory(): JCDiagnostic$Factory;
              getLocalizedString(key: string, args: any[]): string;
              getLocalizedString(key: string, ...args: any[]): string;
              getLocalizedString(diagInfo: JCDiagnostic$DiagnosticInfo): string;
              getLocalizedString(l: java.util.Locale, key: string, args: any[]): string;
              getLocalizedString(l: java.util.Locale, key: string, ...args: any[]): string;
              getLocalizedString(l: java.util.Locale, diagInfo: JCDiagnostic$DiagnosticInfo): string;
              _getLocalizedString(bundles: List<java.util.ResourceBundle>, diagInfo: JCDiagnostic$DiagnosticInfo): string;
              setCurrentLocale(locale: java.util.Locale): void;
              _bundleCache: java.util.Map<java.util.Locale,java.lang.ref.SoftReference<List<java.util.ResourceBundle>>>;
              _bundleHelpers: List<JavacMessages$ResourceBundleHelper>;
              _context: Context;
              _currentBundles: List<java.util.ResourceBundle>;
              _currentLocale: java.util.Locale;
              _diagFactory: JCDiagnostic$Factory;
              _diagFormatter: javac.api.DiagnosticFormatter<JCDiagnostic>;
            }
            interface JavacMessages extends CombineTypes<[_JavacMessages, java.lang.Object, com.sun.tools.javac.api.Messages]> {}
            interface _JavacMessages$ResourceBundleHelper$$static extends ClassLike {
            }
            let JavacMessages$ResourceBundleHelper: _JavacMessages$ResourceBundleHelper$$static;
            interface _JavacMessages$ResourceBundleHelper {
              getResourceBundle(a0: java.util.Locale): java.util.ResourceBundle;
(a0: java.util.Locale): java.util.ResourceBundle;
            }
            interface JavacMessages$ResourceBundleHelper extends CombineTypes<[_JavacMessages$ResourceBundleHelper, java.lang.Object]> {}
            interface _LayoutCharacters$$static extends ClassLike {
              tabulate(column: int): int;
              readonly CR: byte;
              readonly DetailsInc: int;
              readonly DiagInc: int;
              readonly EOI: byte;
              readonly FF: byte;
              readonly LF: byte;
              readonly TAB: byte;
              readonly TabInc: int;
            }
            let LayoutCharacters: _LayoutCharacters$$static;
            interface _LayoutCharacters {
            }
            interface LayoutCharacters extends CombineTypes<[_LayoutCharacters, java.lang.Object]> {}
            interface _List$$static<A> extends ClassLike {
              collector<Z>(): java.util.stream.Collector<Z,ListBuffer<Z>,List<Z>>;
              convert<T>(klass: java.lang.Class<T>, list: List<any>): List<T>;
              equals(xs: List<any>, ys: List<any>): boolean;
              fill<A>(len: int, init: A): List<A>;
              filter<A>(l: List<A>, elem: A): List<A>;
              from<A>(array: A[]): List<A>;
              from<A>(coll: java.lang.Iterable<A>): List<A>;
              nil<A>(): List<A>;
              of<A>(x1: A): List<A>;
              of<A>(x1: A, x2: A): List<A>;
              of<A>(x1: A, x2: A, x3: A): List<A>;
              of<A>(x1: A, x2: A, x3: A, rest: A[]): List<A>;
              of<A>(x1: A, x2: A, x3: A, ...rest: A[]): List<A>;
              _EMPTY_LIST: List<any>;
              _new(head: A, tail: List<A>): List<A>;
            }
            let List: _List$$static<A>;
            interface _List<A> {
              add(index: int, element: A): void;
              addAll(index: int, c: java.util.Collection<A>): boolean;
              append(x: A): List<A>;
              appendList(x: List<A>): List<A>;
              appendList(x: ListBuffer<A>): List<A>;
              contains(x: any): boolean;
              diff(that: List<A>): List<A>;
              equals(other: any): boolean;
              get(index: int): A;
              hashCode(): int;
              indexOf(o: any): int;
              intersect(that: List<A>): List<A>;
              isEmpty(): boolean;
              iterator(): java.util.Iterator<A>;
              last(): A;
              lastIndexOf(o: any): int;
              length(): int;
              listIterator(): java.util.ListIterator<A>;
              listIterator(index: int): java.util.ListIterator<A>;
              map<Z>(mapper: java.util.function.Function<A,Z>): List<Z>;
              nonEmpty(): boolean;
              prepend(x: A): List<A>;
              prependList(xs: List<A>): List<A>;
              remove(index: int): A;
              reverse(): List<A>;
              set(index: int, element: A): A;
              setTail(tail: List<A>): List<A>;
              size(): int;
              subList(fromIndex: int, toIndex: int): java.util.List<A>;
              take(n: int): List<A>;
              toArray<T>(vec: T[]): T[];
              toArray(): any[];
              toString(sep: string): string;
              toString(): string;
              head: A;
              tail: List<A>;
            }
            interface List<A> extends CombineTypes<[_List<A>, java.util.List<A>, java.util.AbstractCollection<A>]> {}
            interface _ListBuffer$$static<A> extends ClassLike {
              of<T>(x: T): ListBuffer<T>;
              new(): ListBuffer<A>;
            }
            let ListBuffer: _ListBuffer$$static<A>;
            interface _ListBuffer<A> {
              add(a: A): boolean;
              addAll(c: java.util.Collection<A>): boolean;
              append(x: A): ListBuffer<A>;
              appendArray(xs: A[]): ListBuffer<A>;
              appendList(xs: List<A>): ListBuffer<A>;
              appendList(xs: ListBuffer<A>): ListBuffer<A>;
              clear(): void;
              contains(x: any): boolean;
              containsAll(c: java.util.Collection<any>): boolean;
              _copy(): void;
              first(): A;
              isEmpty(): boolean;
              iterator(): java.util.Iterator<A>;
              last(): A;
              length(): int;
              next(): A;
              nonEmpty(): boolean;
              offer(a: A): boolean;
              peek(): A;
              poll(): A;
              prepend(x: A): ListBuffer<A>;
              remove(o: any): boolean;
              removeAll(c: java.util.Collection<any>): boolean;
              retainAll(c: java.util.Collection<any>): boolean;
              size(): int;
              toArray<T>(vec: T[]): T[];
              toArray(): any[];
              toList(): List<A>;
              _count: int;
              _elems: List<A>;
              _last: List<A>;
              _shared: boolean;
            }
            interface ListBuffer<A> extends CombineTypes<[_ListBuffer<A>, java.util.AbstractQueue<A>]> {}
            interface _Log$$static extends ClassLike {
              format(fmt: string, args: any[]): string;
              format(fmt: string, ...args: any[]): string;
              getLocalizedString(key: string, args: any[]): string;
              getLocalizedString(key: string, ...args: any[]): string;
              _initWriters(context: Context): java.util.Map<Log$WriterKind,java.io.PrintWriter>;
              _initWriters(out: java.io.PrintWriter, err: java.io.PrintWriter): java.util.Map<Log$WriterKind,java.io.PrintWriter>;
              instance(context: Context): Log;
              preRegister(context: Context, w: java.io.PrintWriter): void;
              printRawLines(writer: java.io.PrintWriter, msg: string): void;
              readonly errKey: Context$Key<java.io.PrintWriter>;
              readonly logKey: Context$Key<Log>;
              readonly outKey: Context$Key<java.io.PrintWriter>;
              _useRawMessages: boolean;
              _new(context: Context): Log;
              _new(context: Context, writer: java.io.PrintWriter): Log;
              _new(context: Context, out: java.io.PrintWriter, err: java.io.PrintWriter): Log;
            }
            let Log: _Log$$static;
            interface _Log {
              currentSourceFile(): javax.tools.JavaFileObject;
              _directError(key: string, args: any[]): void;
              _directError(key: string, ...args: any[]): void;
              flush(): void;
              flush(kind: Log$WriterKind): void;
              _getCode(d: JCDiagnostic): List<string>;
              _getCodeRecursive(buf: ListBuffer<string>, d: JCDiagnostic): void;
              _getDefaultMaxErrors(): int;
              _getDefaultMaxWarnings(): int;
              getDiagnosticFormatter(): javac.api.DiagnosticFormatter<JCDiagnostic>;
              _getIntOption(options: Options, option: javac.main.Option, defaultValue: int): int;
              getWriter(kind: Log$WriterKind): java.io.PrintWriter;
              _getWriterForDiagnosticType(dt: JCDiagnostic$DiagnosticType): java.io.PrintWriter;
              hasDiagnosticListener(): boolean;
              hasErrorOn(pos: JCDiagnostic$DiagnosticPosition): boolean;
              _initOptions(options: Options): void;
              localize(key: string, args: any[]): string;
              localize(key: string, ...args: any[]): string;
              localize(diagInfo: JCDiagnostic$DiagnosticInfo): string;
              localize(pk: Log$PrefixKind, key: string, args: any[]): string;
              localize(pk: Log$PrefixKind, key: string, ...args: any[]): string;
              popDiagnosticHandler(h: Log$DiagnosticHandler): void;
              _printErrLine(pos: int, writer: java.io.PrintWriter): void;
              printLines(key: string, args: any[]): void;
              printLines(key: string, ...args: any[]): void;
              printLines(diag: JCDiagnostic$DiagnosticInfo): void;
              printLines(pk: Log$PrefixKind, key: string, args: any[]): void;
              printLines(pk: Log$PrefixKind, key: string, ...args: any[]): void;
              printLines(wk: Log$WriterKind, key: string, args: any[]): void;
              printLines(wk: Log$WriterKind, key: string, ...args: any[]): void;
              printLines(wk: Log$WriterKind, pk: Log$PrefixKind, key: string, args: any[]): void;
              printLines(wk: Log$WriterKind, pk: Log$PrefixKind, key: string, ...args: any[]): void;
              printNewline(): void;
              printNewline(wk: Log$WriterKind): void;
              _printRawDiag(pw: java.io.PrintWriter, prefix: string, pos: int, msg: string): void;
              printRawLines(msg: string): void;
              printRawLines(kind: Log$WriterKind, msg: string): void;
              printVerbose(key: string, args: any[]): void;
              printVerbose(key: string, ...args: any[]): void;
              prompt(): void;
              rawError(pos: int, msg: string): void;
              rawWarning(pos: int, msg: string): void;
              report(diagnostic: JCDiagnostic): void;
              setDiagnosticFormatter(diagFormatter: javac.api.DiagnosticFormatter<JCDiagnostic>): void;
              setEndPosTable(name: javax.tools.JavaFileObject, endPosTable: javac.tree.EndPosTable): void;
              setWriter(kind: Log$WriterKind, pw: java.io.PrintWriter): void;
              setWriters(pw: java.io.PrintWriter): void;
              _shouldReport(file: javax.tools.JavaFileObject, pos: int): boolean;
              _shouldReport(d: JCDiagnostic): boolean;
              strictWarning(pos: JCDiagnostic$DiagnosticPosition, key: string, args: any[]): void;
              strictWarning(pos: JCDiagnostic$DiagnosticPosition, key: string, ...args: any[]): void;
              _writeDiagnostic(diag: JCDiagnostic): void;
              _MaxErrors: int;
              _MaxWarnings: int;
              compressedOutput: boolean;
              _diagFormatter: javac.api.DiagnosticFormatter<JCDiagnostic>;
              _diagListener: javax.tools.DiagnosticListener<javax.tools.JavaFileObject>;
              _diagnosticHandler: Log$DiagnosticHandler;
              dumpOnError: boolean;
              emitWarnings: boolean;
              expectDiagKeys: java.util.Set<string>;
              _messages: JavacMessages;
              nerrors: int;
              nsuppressederrors: int;
              nsuppressedwarns: int;
              nwarnings: int;
              promptOnError: boolean;
              _recorded: java.util.Set<Pair<javax.tools.JavaFileObject,int>>;
              _recordedSourceLevelErrors: java.util.Set<Pair<javax.tools.JavaFileObject,List<string>>>;
              suppressNotes: boolean;
              _writers: java.util.Map<Log$WriterKind,java.io.PrintWriter>;
            }
            interface Log extends CombineTypes<[_Log, com.sun.tools.javac.util.AbstractLog]> {}
            interface _Log$DefaultDiagnosticHandler$$static extends ClassLike {
            }
            let Log$DefaultDiagnosticHandler: _Log$DefaultDiagnosticHandler$$static;
            interface _Log$DefaultDiagnosticHandler {
              report(diagnostic: JCDiagnostic): void;
              _this$0: Log;
            }
            interface Log$DefaultDiagnosticHandler extends CombineTypes<[_Log$DefaultDiagnosticHandler, com.sun.tools.javac.util.Log$DiagnosticHandler]> {}
            interface _Log$DeferredDiagnosticHandler$$static extends ClassLike {
              new(log: Log): Log$DeferredDiagnosticHandler;
              new(log: Log, filter: java.util.function.Predicate<JCDiagnostic>): Log$DeferredDiagnosticHandler;
            }
            let Log$DeferredDiagnosticHandler: _Log$DeferredDiagnosticHandler$$static;
            interface _Log$DeferredDiagnosticHandler {
              getDiagnostics(): java.util.Queue<JCDiagnostic>;
              report(diag: JCDiagnostic): void;
              reportDeferredDiagnostics(): void;
              reportDeferredDiagnostics(accepter: java.util.function.Predicate<JCDiagnostic>): void;
              _deferred: java.util.Queue<JCDiagnostic>;
              _filter: java.util.function.Predicate<JCDiagnostic>;
            }
            interface Log$DeferredDiagnosticHandler extends CombineTypes<[_Log$DeferredDiagnosticHandler, com.sun.tools.javac.util.Log$DiagnosticHandler]> {}
            interface _Log$DiagnosticHandler$$static extends ClassLike {
              new(): Log$DiagnosticHandler;
            }
            let Log$DiagnosticHandler: _Log$DiagnosticHandler$$static;
            interface _Log$DiagnosticHandler {
              _install(log: Log): void;
              report(a0: JCDiagnostic): void;
(a0: JCDiagnostic): void;
              _prev: Log$DiagnosticHandler;
            }
            interface Log$DiagnosticHandler extends CombineTypes<[_Log$DiagnosticHandler, java.lang.Object]> {}
            interface _Log$DiscardDiagnosticHandler$$static extends ClassLike {
              new(log: Log): Log$DiscardDiagnosticHandler;
            }
            let Log$DiscardDiagnosticHandler: _Log$DiscardDiagnosticHandler$$static;
            interface _Log$DiscardDiagnosticHandler {
              report(diag: JCDiagnostic): void;
            }
            interface Log$DiscardDiagnosticHandler extends CombineTypes<[_Log$DiscardDiagnosticHandler, com.sun.tools.javac.util.Log$DiagnosticHandler]> {}
            interface _Log$PrefixKind$$static extends ClassLike {
              valueOf(name: string): Log$PrefixKind;
              values(): Log$PrefixKind[];
              readonly COMPILER_MISC: Log$PrefixKind;
              readonly JAVAC: Log$PrefixKind;
            }
            let Log$PrefixKind: _Log$PrefixKind$$static;
            interface _Log$PrefixKind {
              key(k: string): string;
              _value: string;
            }
            interface Log$PrefixKind extends CombineTypes<[_Log$PrefixKind]> {}
            interface _Log$WriterKind$$static extends ClassLike {
              valueOf(name: string): Log$WriterKind;
              values(): Log$WriterKind[];
              readonly ERROR: Log$WriterKind;
              readonly NOTICE: Log$WriterKind;
              readonly STDERR: Log$WriterKind;
              readonly STDOUT: Log$WriterKind;
              readonly WARNING: Log$WriterKind;
            }
            let Log$WriterKind: _Log$WriterKind$$static;
            interface _Log$WriterKind {
            }
            interface Log$WriterKind extends CombineTypes<[_Log$WriterKind]> {}
            interface _MandatoryWarningHandler$$static extends ClassLike {
              new(log: Log, source: javac.code.Source, verbose: boolean, enforceMandatory: boolean, prefix: string, lc: javac.code.Lint$LintCategory): MandatoryWarningHandler;
            }
            let MandatoryWarningHandler: _MandatoryWarningHandler$$static;
            interface _MandatoryWarningHandler {
              clear(): void;
              _logMandatoryNote(file: javax.tools.JavaFileObject, msg: string, args: any[]): void;
              _logMandatoryNote(file: javax.tools.JavaFileObject, msg: string, ...args: any[]): void;
              _logMandatoryWarning(pos: JCDiagnostic$DiagnosticPosition, warnKey: JCDiagnostic$Warning): void;
              report(pos: JCDiagnostic$DiagnosticPosition, warnKey: JCDiagnostic$Warning): void;
              reportDeferredDiagnostic(): void;
              _deferredDiagnosticArg: any;
              _deferredDiagnosticKind: MandatoryWarningHandler$DeferredDiagnosticKind;
              _deferredDiagnosticSource: javax.tools.JavaFileObject;
              _enforceMandatory: boolean;
              _lintCategory: javac.code.Lint$LintCategory;
              _log: Log;
              _prefix: string;
              _source: javac.code.Source;
              _sourcesWithReportedWarnings: java.util.Set<javax.tools.JavaFileObject>;
              _verbose: boolean;
            }
            interface MandatoryWarningHandler extends CombineTypes<[_MandatoryWarningHandler, java.lang.Object]> {}
            interface _MandatoryWarningHandler$DeferredDiagnosticKind$$static extends ClassLike {
              valueOf(name: string): MandatoryWarningHandler$DeferredDiagnosticKind;
              values(): MandatoryWarningHandler$DeferredDiagnosticKind[];
              readonly ADDITIONAL_IN_FILE: MandatoryWarningHandler$DeferredDiagnosticKind;
              readonly ADDITIONAL_IN_FILES: MandatoryWarningHandler$DeferredDiagnosticKind;
              readonly IN_FILE: MandatoryWarningHandler$DeferredDiagnosticKind;
              readonly IN_FILES: MandatoryWarningHandler$DeferredDiagnosticKind;
            }
            let MandatoryWarningHandler$DeferredDiagnosticKind: _MandatoryWarningHandler$DeferredDiagnosticKind$$static;
            interface _MandatoryWarningHandler$DeferredDiagnosticKind {
              _getKey(prefix: string): string;
              _value: string;
            }
            interface MandatoryWarningHandler$DeferredDiagnosticKind extends CombineTypes<[_MandatoryWarningHandler$DeferredDiagnosticKind]> {}
            interface _MatchingUtils$$static extends ClassLike {
              isValidImportString(s: string): boolean;
              validImportStringToPattern(s: string): java.util.regex.Pattern;
              validImportStringToPatternString(s: string): string;
              _allMatches: java.util.regex.Pattern;
              _allMatchesString: string;
              new(): MatchingUtils;
            }
            let MatchingUtils: _MatchingUtils$$static;
            interface _MatchingUtils {
            }
            interface MatchingUtils extends CombineTypes<[_MatchingUtils, java.lang.Object]> {}
            interface _ModuleHelper$$static extends ClassLike {
              addExports(from: java.lang.Module, to: java.lang.Module): void;
              _javacInternalPackages: string[];
              new(): ModuleHelper;
            }
            let ModuleHelper: _ModuleHelper$$static;
            interface _ModuleHelper {
            }
            interface ModuleHelper extends CombineTypes<[_ModuleHelper, java.lang.Object]> {}
            interface _Name$$static extends ClassLike {
              _new(table: Name$Table): Name;
            }
            let Name: _Name$$static;
            interface _Name {
              append(n: Name): Name;
              append(c: char, n: Name): Name;
              charAt(index: int): char;
              compareTo(name: Name): int;
              compareTo(a0: any): int;
              contentEquals(cs: Name$charSequence): boolean;
              getByteArray(): byte[];
              getByteAt(a0: int): byte;
              getByteLength(): int;
              getByteOffset(): int;
              getBytes(cs: byte[], start: int): void;
              getIndex(): int;
              isEmpty(): boolean;
              lastIndexOf(b: byte): int;
              length(): int;
              map<X>(mapper: Name$NameMapper<X>): X;
              poolTag(): int;
              startsWith(prefix: Name): boolean;
              subName(start: int, end: int): Name;
              subSequence(start: int, end: int): Name$charSequence;
              toString(): string;
              toUtf(): byte[];
              readonly table: Name$Table;
            }
            interface Name extends CombineTypes<[_Name, java.lang.Object, java.lang.Comparable<Name>, javax.lang.model.element.Name, javac.jvm.PoolConstant]> {}
            interface _Name$NameMapper$$static<X> extends ClassLike {
            }
            let Name$NameMapper: _Name$NameMapper$$static<X>;
            interface _Name$NameMapper<X> {
              map(a0: byte[], a1: int, a2: int): X;
(a0: byte[], a1: int, a2: int): X;
            }
            interface Name$NameMapper<X> extends CombineTypes<[_Name$NameMapper<X>, java.lang.Object]> {}
            interface _Name$Table$$static extends ClassLike {
              _equals(bytes1: byte[], offset1: int, bytes2: byte[], offset2: int, length: int): boolean;
              _hashValue(bytes: byte[], offset: int, length: int): int;
              _new(names: Names): Name$Table;
            }
            let Name$Table: _Name$Table$$static;
            interface _Name$Table {
              dispose(): void;
              fromChars(a0: char[], a1: int, a2: int): Name;
              fromString(s: string): Name;
              fromUtf(cs: byte[]): Name;
              fromUtf(a0: byte[], a1: int, a2: int, a3: Convert$Validation): Name;
              readonly names: Names;
            }
            interface Name$Table extends CombineTypes<[_Name$Table, java.lang.Object]> {}
            interface _Names$$static extends ClassLike {
              instance(context: Context): Names;
              readonly namesKey: Context$Key<Names>;
              new(context: Context): Names;
            }
            let Names: _Names$$static;
            interface _Names {
              _createTable(options: Options): Name$Table;
              dispose(): void;
              fromChars(cs: char[], start: int, len: int): Name;
              fromString(s: string): Name;
              fromUtf(cs: byte[]): Name;
              fromUtf(cs: byte[], start: int, len: int, validation: Convert$Validation): Name;
              fromUtfLax(cs: byte[], start: int, len: int): Name;
              readonly ANNOTATION_TYPE: Name;
              readonly Annotation: Name;
              readonly AnnotationDefault: Name;
              readonly Array: Name;
              readonly BootstrapMethods: Name;
              readonly Bound: Name;
              readonly Bridge: Name;
              readonly CLASS: Name;
              readonly CONSTRUCTOR: Name;
              readonly CharacterRangeTable: Name;
              readonly Code: Name;
              readonly CompilationID: Name;
              readonly ConstantValue: Name;
              readonly Deprecated: Name;
              readonly EnclosingMethod: Name;
              readonly Enum: Name;
              readonly Exceptions: Name;
              readonly FIELD: Name;
              readonly InnerClasses: Name;
              readonly LOCAL_VARIABLE: Name;
              readonly LineNumberTable: Name;
              readonly LocalVariableTable: Name;
              readonly LocalVariableTypeTable: Name;
              readonly METHOD: Name;
              readonly MODULE: Name;
              readonly Method: Name;
              readonly MethodParameters: Name;
              readonly Module: Name;
              readonly ModuleResolution: Name;
              readonly NestHost: Name;
              readonly NestMembers: Name;
              readonly PACKAGE: Name;
              readonly PARAMETER: Name;
              readonly PermittedSubclasses: Name;
              readonly RAW: Name;
              readonly RECORD_COMPONENT: Name;
              readonly RUNTIME: Name;
              readonly Record: Name;
              readonly RuntimeInvisibleAnnotations: Name;
              readonly RuntimeInvisibleParameterAnnotations: Name;
              readonly RuntimeInvisibleTypeAnnotations: Name;
              readonly RuntimeVisibleAnnotations: Name;
              readonly RuntimeVisibleParameterAnnotations: Name;
              readonly RuntimeVisibleTypeAnnotations: Name;
              readonly SOURCE: Name;
              readonly STR: Name;
              readonly Signature: Name;
              readonly SourceFile: Name;
              readonly SourceID: Name;
              readonly StackMap: Name;
              readonly StackMapTable: Name;
              readonly Synthetic: Name;
              readonly T: Name;
              readonly TYPE: Name;
              readonly TYPE_PARAMETER: Name;
              readonly TYPE_USE: Name;
              readonly Value: Name;
              readonly Varargs: Name;
              readonly _class: Name;
              readonly _name: Name;
              readonly _super: Name;
              readonly _this: Name;
              readonly addSuppressed: Name;
              readonly altMetafactory: Name;
              readonly any: Name;
              readonly append: Name;
              readonly asterisk: Name;
              readonly bootstrap: Name;
              readonly clinit: Name;
              readonly clone: Name;
              readonly close: Name;
              readonly comma: Name;
              readonly deserializeLambda: Name;
              readonly desiredAssertionStatus: Name;
              readonly dollarThis: Name;
              readonly empty: Name;
              readonly enumConstant: Name;
              readonly enumSwitch: Name;
              readonly equals: Name;
              readonly error: Name;
              readonly ex: Name;
              readonly exports: Name;
              readonly finalize: Name;
              readonly forRemoval: Name;
              readonly getClass: Name;
              readonly hasNext: Name;
              readonly hashCode: Name;
              readonly hyphen: Name;
              readonly init: Name;
              readonly invoke: Name;
              readonly iterator: Name;
              readonly java: Name;
              readonly java_base: Name;
              readonly java_io_Serializable: Name;
              readonly java_lang: Name;
              readonly java_lang_Class: Name;
              readonly java_lang_Cloneable: Name;
              readonly java_lang_Enum: Name;
              readonly java_lang_Object: Name;
              readonly jdk_internal_javac: Name;
              readonly jdk_unsupported: Name;
              readonly lambda: Name;
              readonly length: Name;
              readonly main: Name;
              readonly makeConcat: Name;
              readonly makeConcatWithConstants: Name;
              readonly metafactory: Name;
              readonly module: Name;
              readonly module_info: Name;
              readonly newLargeStringTemplate: Name;
              readonly newStringTemplate: Name;
              readonly next: Name;
              readonly non: Name;
              readonly of: Name;
              readonly one: Name;
              readonly open: Name;
              readonly opens: Name;
              readonly ordinal: Name;
              readonly package_info: Name;
              readonly permits: Name;
              readonly process: Name;
              readonly processStringTemplate: Name;
              readonly provider: Name;
              readonly provides: Name;
              readonly readObject: Name;
              readonly readObjectNoData: Name;
              readonly readResolve: Name;
              readonly record: Name;
              readonly reflective: Name;
              readonly requireNonNull: Name;
              readonly requires: Name;
              readonly sealed: Name;
              readonly serialPersistentFields: Name;
              readonly serialVersionUID: Name;
              readonly slash: Name;
              readonly table: Name$Table;
              readonly to: Name;
              readonly toString: Name;
              readonly transitive: Name;
              readonly typeSwitch: Name;
              readonly underscore: Name;
              readonly uses: Name;
              readonly value: Name;
              readonly valueOf: Name;
              readonly values: Name;
              readonly var: Name;
              readonly when: Name;
              readonly with: Name;
              readonly writeObject: Name;
              readonly writeReplace: Name;
              readonly yield: Name;
            }
            interface Names extends CombineTypes<[_Names, java.lang.Object]> {}
            interface _Options$$static extends ClassLike {
              instance(context: Context): Options;
              readonly optionsKey: Context$Key<Options>;
              _serialVersionUID: long;
              _new(context: Context): Options;
            }
            let Options: _Options$$static;
            interface _Options {
              addListener(listener: java.lang.Runnable): void;
              clear(): void;
              get(name: string): string;
              get(option: javac.main.Option): string;
              getBoolean(name: string): boolean;
              getBoolean(name: string, defaultValue: boolean): boolean;
              isLintSet(s: string): boolean;
              isSet(name: string): boolean;
              isSet(option: javac.main.Option): boolean;
              isSet(option: javac.main.Option, value: string): boolean;
              isUnset(name: string): boolean;
              isUnset(option: javac.main.Option): boolean;
              isUnset(option: javac.main.Option, value: string): boolean;
              keySet(): java.util.Set<string>;
              notifyListeners(): void;
              put(name: string, value: string): void;
              put(option: javac.main.Option, value: string): void;
              putAll(options: Options): void;
              remove(name: string): void;
              size(): int;
              _listeners: List<java.lang.Runnable>;
              _values: java.util.LinkedHashMap<string,string>;
            }
            interface Options extends CombineTypes<[_Options, java.lang.Object]> {}
            interface _Pair$$static<A,B> extends ClassLike {
              of<A, B>(a: A, b: B): Pair<A,B>;
              new(fst: A, snd: B): Pair<A,B>;
            }
            let Pair: _Pair$$static<A,B>;
            interface _Pair<A,B> {
              equals(other: any): boolean;
              hashCode(): int;
              toString(): string;
              readonly fst: A;
              readonly snd: B;
            }
            interface Pair<A,B> extends CombineTypes<[_Pair<A,B>, java.lang.Object]> {}
            interface _Position$$static extends ClassLike {
              encodePosition(line: int, col: int): int;
              makeLineMap(src: char[], max: int, expandTabs: boolean): Position$LineMap;
              readonly FIRSTCOLUMN: int;
              readonly FIRSTLINE: int;
              readonly FIRSTPOS: int;
              readonly LINESHIFT: int;
              readonly MAXCOLUMN: int;
              readonly MAXLINE: int;
              readonly MAXPOS: int;
              readonly NOPOS: int;
            }
            let Position: _Position$$static;
            interface _Position {
            }
            interface Position extends CombineTypes<[_Position, java.lang.Object]> {}
            interface _Position$LineMap$$static extends ClassLike {
            }
            let Position$LineMap: _Position$LineMap$$static;
            interface _Position$LineMap {
              getColumnNumber(a0: int): int;
              getLineNumber(a0: int): int;
              getPosition(a0: int, a1: int): int;
              getStartPosition(a0: int): int;
            }
            interface Position$LineMap extends CombineTypes<[_Position$LineMap, java.lang.Object, com.sun.source.tree.LineMap]> {}
            interface _Position$LineMapImpl$$static extends ClassLike {
              _longToInt(longValue: long): int;
              _new(): Position$LineMapImpl;
            }
            let Position$LineMapImpl: _Position$LineMapImpl$$static;
            interface _Position$LineMapImpl {
              _build(src: char[], max: int): void;
              getColumnNumber(pos: int): int;
              getColumnNumber(pos: long): long;
              getLineNumber(pos: int): int;
              getLineNumber(pos: long): long;
              getPosition(line: int, column: int): int;
              getPosition(line: long, a1: long): long;
              getStartPosition(line: int): int;
              getStartPosition(line: long): long;
              _setTabPosition(offset: int): void;
              _lastLine: int;
              _lastPosition: int;
              _startPosition: int[];
            }
            interface Position$LineMapImpl extends CombineTypes<[_Position$LineMapImpl, java.lang.Object, com.sun.tools.javac.util.Position$LineMap]> {}
            interface _Position$LineTabMapImpl$$static extends ClassLike {
              new(max: int): Position$LineTabMapImpl;
            }
            let Position$LineTabMapImpl: _Position$LineTabMapImpl$$static;
            interface _Position$LineTabMapImpl {
              getColumnNumber(pos: int): int;
              getColumnNumber(a0: long): long;
              getLineNumber(a0: long): long;
              getLineNumber(a0: int): int;
              getPosition(line: int, column: int): int;
              getPosition(a0: long, a1: long): long;
              getStartPosition(a0: long): long;
              getStartPosition(a0: int): int;
              _setTabPosition(offset: int): void;
              _tabMap: java.util.BitSet;
            }
            interface Position$LineTabMapImpl extends CombineTypes<[_Position$LineTabMapImpl, com.sun.tools.javac.util.Position$LineMapImpl]> {}
            interface _PropagatedException$$static extends ClassLike {
              _serialVersionUID: long;
              new(cause: java.lang.RuntimeException): PropagatedException;
            }
            let PropagatedException: _PropagatedException$$static;
            interface _PropagatedException {
              getCause(): java.lang.RuntimeException;
              getCause(): java.lang.Throwable;
            }
            interface PropagatedException extends CombineTypes<[_PropagatedException, java.lang.RuntimeException]> {}
            interface _RawDiagnosticFormatter$$static extends ClassLike {
              _CODES_NEEDING_SOURCE_NORMALIZATION: java.util.Set<string>;
              new(options: Options): RawDiagnosticFormatter;
            }
            let RawDiagnosticFormatter: _RawDiagnosticFormatter$$static;
            interface _RawDiagnosticFormatter {
              _formatArgument(diag: JCDiagnostic, arg: any, l: java.util.Locale): string;
              formatDiagnostic(d: JCDiagnostic, l: java.util.Locale): string;
              formatMessage(d: JCDiagnostic, l: java.util.Locale): string;
              formatMessage(a0: javax.tools.Diagnostic, a1: java.util.Locale): string;
              isRaw(): boolean;
              _localize(l: java.util.Locale, key: string, args: any[]): string;
              _localize(l: java.util.Locale, key: string, ...args: any[]): string;
              _rawDiagnosticPosHelper: RawDiagnosticFormatter$RawDiagnosticPosHelper;
            }
            interface RawDiagnosticFormatter extends CombineTypes<[_RawDiagnosticFormatter, com.sun.tools.javac.util.AbstractDiagnosticFormatter]> {}
            interface _RawDiagnosticFormatter$RawDiagnosticPosHelper$$static extends ClassLike {
              _new(diag: JCDiagnostic): RawDiagnosticFormatter$RawDiagnosticPosHelper;
            }
            let RawDiagnosticFormatter$RawDiagnosticPosHelper: _RawDiagnosticFormatter$RawDiagnosticPosHelper$$static;
            interface _RawDiagnosticFormatter$RawDiagnosticPosHelper {
              _getPosition(exp: javac.tree.JCTree$JCExpression): string;
              _diag: JCDiagnostic;
            }
            interface RawDiagnosticFormatter$RawDiagnosticPosHelper extends CombineTypes<[_RawDiagnosticFormatter$RawDiagnosticPosHelper, java.lang.Object]> {}
            interface _RichDiagnosticFormatter$$static extends ClassLike {
              instance(context: Context): RichDiagnosticFormatter;
              _new(context: Context): RichDiagnosticFormatter;
            }
            let RichDiagnosticFormatter: _RichDiagnosticFormatter$$static;
            interface _RichDiagnosticFormatter {
              format(diag: JCDiagnostic, l: java.util.Locale): string;
              format(a0: javax.tools.Diagnostic, a1: java.util.Locale): string;
              formatMessage(diag: JCDiagnostic, l: java.util.Locale): string;
              formatMessage(a0: javax.tools.Diagnostic, a1: java.util.Locale): string;
              getConfiguration(): RichDiagnosticFormatter$RichConfiguration;
              getConfiguration(): javac.api.DiagnosticFormatter$Configuration;
              _getRichPrinter(): RichDiagnosticFormatter$RichPrinter;
              _getWhereClauses(): List<JCDiagnostic>;
              _indexOf(type: javac.code.Type, kind: RichDiagnosticFormatter$WhereClauseKind): int;
              _preprocessArgument(arg: any): void;
              _preprocessDiagnostic(diag: JCDiagnostic): void;
              _preprocessSymbol(s: javac.code.Symbol): void;
              _preprocessType(t: javac.code.Type): void;
              _setRichPrinter(printer: RichDiagnosticFormatter$RichPrinter): void;
              _unique(typevar: javac.code.Type$TypeVar): boolean;
              _diags: JCDiagnostic$Factory;
              _messages: JavacMessages;
              _nameSimplifier: RichDiagnosticFormatter$ClassNameSimplifier;
              _printer: RichDiagnosticFormatter$RichPrinter;
              _symbolPreprocessor: javac.code.Types$DefaultSymbolVisitor<java.lang.Void,java.lang.Void>;
              _syms: javac.code.Symtab;
              _typePreprocessor: javac.code.Types$UnaryVisitor<java.lang.Void>;
              _types: javac.code.Types;
              _whereClauses: java.util.Map<RichDiagnosticFormatter$WhereClauseKind,java.util.Map<javac.code.Type,JCDiagnostic>>;
            }
            interface RichDiagnosticFormatter extends CombineTypes<[_RichDiagnosticFormatter, ForwardingDiagnosticFormatter<JCDiagnostic,AbstractDiagnosticFormatter>]> {}
            interface _RichDiagnosticFormatter$ClassNameSimplifier$$static extends ClassLike {
              _new(this$0: RichDiagnosticFormatter): RichDiagnosticFormatter$ClassNameSimplifier;
            }
            let RichDiagnosticFormatter$ClassNameSimplifier: _RichDiagnosticFormatter$ClassNameSimplifier$$static;
            interface _RichDiagnosticFormatter$ClassNameSimplifier {
              _addUsage(sym: javac.code.Symbol): void;
              simplify(s: javac.code.Symbol): string;
              _nameClashes: java.util.Map<Name,List<javac.code.Symbol>>;
            }
            interface RichDiagnosticFormatter$ClassNameSimplifier extends CombineTypes<[_RichDiagnosticFormatter$ClassNameSimplifier, java.lang.Object]> {}
            interface _RichDiagnosticFormatter$RichConfiguration$$static extends ClassLike {
              new(options: Options, formatter: AbstractDiagnosticFormatter): RichDiagnosticFormatter$RichConfiguration;
            }
            let RichDiagnosticFormatter$RichConfiguration: _RichDiagnosticFormatter$RichConfiguration$$static;
            interface _RichDiagnosticFormatter$RichConfiguration {
              disable(feature: RichDiagnosticFormatter$RichConfiguration$RichFormatterFeature): void;
              enable(feature: RichDiagnosticFormatter$RichConfiguration$RichFormatterFeature): void;
              getAvailableFeatures(): RichDiagnosticFormatter$RichConfiguration$RichFormatterFeature[];
              isEnabled(feature: RichDiagnosticFormatter$RichConfiguration$RichFormatterFeature): boolean;
              _features: java.util.EnumSet<RichDiagnosticFormatter$RichConfiguration$RichFormatterFeature>;
            }
            interface RichDiagnosticFormatter$RichConfiguration extends CombineTypes<[_RichDiagnosticFormatter$RichConfiguration, com.sun.tools.javac.util.ForwardingDiagnosticFormatter$ForwardingConfiguration]> {}
            interface _RichDiagnosticFormatter$RichConfiguration$RichFormatterFeature$$static extends ClassLike {
              valueOf(name: string): RichDiagnosticFormatter$RichConfiguration$RichFormatterFeature;
              values(): RichDiagnosticFormatter$RichConfiguration$RichFormatterFeature[];
              readonly SIMPLE_NAMES: RichDiagnosticFormatter$RichConfiguration$RichFormatterFeature;
              readonly UNIQUE_TYPEVAR_NAMES: RichDiagnosticFormatter$RichConfiguration$RichFormatterFeature;
              readonly WHERE_CLAUSES: RichDiagnosticFormatter$RichConfiguration$RichFormatterFeature;
            }
            let RichDiagnosticFormatter$RichConfiguration$RichFormatterFeature: _RichDiagnosticFormatter$RichConfiguration$RichFormatterFeature$$static;
            interface _RichDiagnosticFormatter$RichConfiguration$RichFormatterFeature {
            }
            interface RichDiagnosticFormatter$RichConfiguration$RichFormatterFeature extends CombineTypes<[_RichDiagnosticFormatter$RichConfiguration$RichFormatterFeature]> {}
            interface _RichDiagnosticFormatter$RichPrinter$$static extends ClassLike {
              _new(this$0: RichDiagnosticFormatter): RichDiagnosticFormatter$RichPrinter;
            }
            let RichDiagnosticFormatter$RichPrinter: _RichDiagnosticFormatter$RichPrinter$$static;
            interface _RichDiagnosticFormatter$RichPrinter {
              capturedVarId(t: javac.code.Type$CapturedType, locale: java.util.Locale): string;
              _className(t: javac.code.Type$ClassType, longform: boolean, locale: java.util.Locale): string;
              localize(locale: java.util.Locale, key: string, args: any[]): string;
              localize(locale: java.util.Locale, key: string, ...args: any[]): string;
              visitCapturedType(t: javac.code.Type$CapturedType, locale: java.util.Locale): string;
              visitCapturedType(a0: javac.code.Type$CapturedType, a1: any): any;
              visitClassSymbol(s: javac.code.Symbol$ClassSymbol, locale: java.util.Locale): string;
              visitClassSymbol(a0: javac.code.Symbol$ClassSymbol, a1: any): any;
              visitClassType(t: javac.code.Type$ClassType, locale: java.util.Locale): string;
              visitClassType(a0: javac.code.Type$ClassType, a1: any): any;
              visitMethodSymbol(s: javac.code.Symbol$MethodSymbol, locale: java.util.Locale): string;
              visitMethodSymbol(a0: javac.code.Symbol$MethodSymbol, a1: any): any;
              visitType(t: javac.code.Type, locale: java.util.Locale): string;
              visitType(a0: javac.code.Type, a1: any): any;
              visitTypeVar(t: javac.code.Type$TypeVar, locale: java.util.Locale): string;
              visitTypeVar(a0: javac.code.Type$TypeVar, a1: any): any;
              _this$0: RichDiagnosticFormatter;
            }
            interface RichDiagnosticFormatter$RichPrinter extends CombineTypes<[_RichDiagnosticFormatter$RichPrinter, com.sun.tools.javac.code.Printer]> {}
            interface _RichDiagnosticFormatter$WhereClauseKind$$static extends ClassLike {
              valueOf(name: string): RichDiagnosticFormatter$WhereClauseKind;
              values(): RichDiagnosticFormatter$WhereClauseKind[];
              readonly CAPTURED: RichDiagnosticFormatter$WhereClauseKind;
              readonly INTERSECTION: RichDiagnosticFormatter$WhereClauseKind;
              readonly TYPEVAR: RichDiagnosticFormatter$WhereClauseKind;
            }
            let RichDiagnosticFormatter$WhereClauseKind: _RichDiagnosticFormatter$WhereClauseKind$$static;
            interface _RichDiagnosticFormatter$WhereClauseKind {
              _key(): string;
              _key: string;
            }
            interface RichDiagnosticFormatter$WhereClauseKind extends CombineTypes<[_RichDiagnosticFormatter$WhereClauseKind]> {}
            interface _SharedNameTable$$static extends ClassLike {
              create(names: Names): SharedNameTable;
              _dispose(t: SharedNameTable): void;
              _freelist: List<java.lang.ref.SoftReference<SharedNameTable>>;
              new(names: Names, hashSize: int, nameSize: int): SharedNameTable;
              new(names: Names): SharedNameTable;
            }
            let SharedNameTable: _SharedNameTable$$static;
            interface _SharedNameTable {
              dispose(): void;
              fromChars(cs: char[], start: int, len: int): Name;
              fromUtf(cs: byte[], start: int, len: int, validation: Convert$Validation): Name;
              bytes: byte[];
              _hashMask: int;
              _hashes: SharedNameTable$NameImpl[];
              _nc: int;
            }
            interface SharedNameTable extends CombineTypes<[_SharedNameTable, com.sun.tools.javac.util.Name$Table]> {}
            interface _SharedNameTable$NameImpl$$static extends ClassLike {
              _new(table: SharedNameTable): SharedNameTable$NameImpl;
            }
            let SharedNameTable$NameImpl: _SharedNameTable$NameImpl$$static;
            interface _SharedNameTable$NameImpl {
              equals(other: any): boolean;
              getByteArray(): byte[];
              getByteAt(i: int): byte;
              getByteLength(): int;
              getByteOffset(): int;
              getIndex(): int;
              hashCode(): int;
              _index: int;
              _length: int;
              _next: SharedNameTable$NameImpl;
            }
            interface SharedNameTable$NameImpl extends CombineTypes<[_SharedNameTable$NameImpl, com.sun.tools.javac.util.Name]> {}
            interface _StringUtils$$static extends ClassLike {
              indexOfIgnoreCase(text: string, str: string): int;
              indexOfIgnoreCase(text: string, str: string, startIndex: int): int;
              toLowerCase(source: string): string;
              toUpperCase(source: string): string;
              new(): StringUtils;
            }
            let StringUtils: _StringUtils$$static;
            interface _StringUtils {
            }
            interface StringUtils extends CombineTypes<[_StringUtils, java.lang.Object]> {}
            interface _UnsharedNameTable$$static extends ClassLike {
              create(names: Names): Name$Table;
              new(names: Names, hashSize: int): UnsharedNameTable;
              new(names: Names): UnsharedNameTable;
            }
            let UnsharedNameTable: _UnsharedNameTable$$static;
            interface _UnsharedNameTable {
              dispose(): void;
              fromChars(cs: char[], start: int, len: int): Name;
              fromUtf(cs: byte[], start: int, len: int, validation: Convert$Validation): Name;
              _fromValidUtf(cs: byte[], start: int, len: int): Name;
              _hashMask: int;
              _hashes: UnsharedNameTable$HashEntry[];
              index: int;
            }
            interface UnsharedNameTable extends CombineTypes<[_UnsharedNameTable, com.sun.tools.javac.util.Name$Table]> {}
            interface _UnsharedNameTable$HashEntry$$static extends ClassLike {
              _new(referent: UnsharedNameTable$NameImpl): UnsharedNameTable$HashEntry;
            }
            let UnsharedNameTable$HashEntry: _UnsharedNameTable$HashEntry$$static;
            interface _UnsharedNameTable$HashEntry {
              _next: UnsharedNameTable$HashEntry;
            }
            interface UnsharedNameTable$HashEntry extends CombineTypes<[_UnsharedNameTable$HashEntry, java.lang.ref.WeakReference<UnsharedNameTable$NameImpl>]> {}
            interface _UnsharedNameTable$NameImpl$$static extends ClassLike {
              _new(table: UnsharedNameTable, bytes: byte[], index: int): UnsharedNameTable$NameImpl;
            }
            let UnsharedNameTable$NameImpl: _UnsharedNameTable$NameImpl$$static;
            interface _UnsharedNameTable$NameImpl {
              getByteArray(): byte[];
              getByteAt(i: int): byte;
              getByteLength(): int;
              getByteOffset(): int;
              getIndex(): int;
              _bytes: byte[];
              _index: int;
            }
            interface UnsharedNameTable$NameImpl extends CombineTypes<[_UnsharedNameTable$NameImpl, com.sun.tools.javac.util.Name]> {}
            interface _Warner$$static extends ClassLike {
              new(pos: JCDiagnostic$DiagnosticPosition): Warner;
              new(): Warner;
            }
            let Warner: _Warner$$static;
            interface _Warner {
              clear(): void;
              hasLint(lint: javac.code.Lint$LintCategory): boolean;
              hasNonSilentLint(lint: javac.code.Lint$LintCategory): boolean;
              hasSilentLint(lint: javac.code.Lint$LintCategory): boolean;
              pos(): JCDiagnostic$DiagnosticPosition;
              silentWarn(lint: javac.code.Lint$LintCategory): void;
              warn(lint: javac.code.Lint$LintCategory): void;
              _nonSilentLintSet: java.util.EnumSet<javac.code.Lint$LintCategory>;
              _pos: JCDiagnostic$DiagnosticPosition;
              _silentLintSet: java.util.EnumSet<javac.code.Lint$LintCategory>;
              _warned: boolean;
            }
            interface Warner extends CombineTypes<[_Warner, java.lang.Object]> {}
          }
          interface _Main$$static extends ClassLike {
            compile(args: string[]): int;
            compile(args: string[], out: java.io.PrintWriter): int;
            main(args: string[]): void;
            new(): Main;
          }
          let Main: _Main$$static;
          interface _Main {
          }
          interface Main extends CombineTypes<[_Main, java.lang.Object]> {}
        }
      }
    }
  }
  module jdk {
    module internal {
      module shellsupport {
        module doc {
          module resources {
            interface _javadocformatter$$static extends ClassLike {
              new(): javadocformatter;
            }
            let javadocformatter: _javadocformatter$$static;
            interface _javadocformatter {
              _getContents(): any[][];
            }
            interface javadocformatter extends CombineTypes<[_javadocformatter, java.util.ListResourceBundle]> {}
          }
          interface _JavadocFormatter$$static extends ClassLike {
            _addNewLineIfNeeded(text: JavadocFormatter$stringBuilder): void;
            _addSpaceIfNeeded(text: JavadocFormatter$stringBuilder): void;
            _countTableColumns(dct: com.sun.source.doctree.DocCommentTree): java.util.Map<com.sun.source.doctree.StartElementTree,int>;
            _getHtmlTag(name: javax.lang.model.element.Name): JavadocFormatter$HtmlTag;
            _indentString(indent: int): string;
            _reflow(text: JavadocFormatter$stringBuilder, from: int, indent: int, limit: int): void;
            _CODE_HIGHLIGHT: string;
            _CODE_RESET: string;
            _CODE_UNDERLINE: string;
            _INDENT: int;
            _MAX_LINE_LENGTH: int;
            _SHORTEST_LINE: int;
            _docSections: java.util.Map<JavadocFormatter$Sections,string>;
            _inlineReturns: string;
            new(lineLimit: int, escapeSequencesSupported: boolean): JavadocFormatter;
          }
          let JavadocFormatter: _JavadocFormatter$$static;
          interface _JavadocFormatter {
            _escape(sequence: string): string;
            formatJavadoc(header: string, javadoc: string): string;
            _escapeSequencesSupported: boolean;
            _lineLimit: int;
          }
          interface JavadocFormatter extends CombineTypes<[_JavadocFormatter, java.lang.Object]> {}
          interface _JavadocFormatter$FormatJavadocScanner$$static extends ClassLike {
            new(a0: JavadocFormatter, result: JavadocFormatter$FormatJavadocScanner$stringBuilder, task: com.sun.source.util.JavacTask): JavadocFormatter$FormatJavadocScanner;
          }
          let JavadocFormatter$FormatJavadocScanner: _JavadocFormatter$FormatJavadocScanner$$static;
          interface _JavadocFormatter$FormatJavadocScanner {
            formatDef(name: JavadocFormatter$FormatJavadocScanner$charSequence, description: java.util.List<com.sun.source.doctree.DocTree>): any;
            _handleEndElement(name: javax.lang.model.element.Name): void;
            _reflowTillNow(): void;
            scan(node: com.sun.source.doctree.DocTree, p: any): any;
            _startSection(current: JavadocFormatter$Sections): void;
            visitDocComment(node: com.sun.source.doctree.DocCommentTree, p: any): any;
            visitEndElement(node: com.sun.source.doctree.EndElementTree, p: any): any;
            visitEntity(node: com.sun.source.doctree.EntityTree, p: any): any;
            visitEscape(node: com.sun.source.doctree.EscapeTree, p: any): any;
            visitLink(node: com.sun.source.doctree.LinkTree, p: any): any;
            visitLiteral(node: com.sun.source.doctree.LiteralTree, p: any): any;
            visitParam(node: com.sun.source.doctree.ParamTree, p: any): any;
            visitReturn(node: com.sun.source.doctree.ReturnTree, p: any): any;
            visitStartElement(node: com.sun.source.doctree.StartElementTree, p: any): any;
            visitText(node: com.sun.source.doctree.TextTree, p: any): any;
            visitThrows(node: com.sun.source.doctree.ThrowsTree, p: any): any;
            _cellsStack: java.util.Stack<java.util.List<int>>;
            _defStack: java.util.Stack<int>;
            _headerStack: java.util.Stack<java.util.List<boolean>>;
            _indent: int;
            _lastNode: com.sun.source.doctree.DocTree;
            _limit: int;
            _listStack: java.util.Stack<int>;
            _pre: boolean;
            _reflownTo: int;
            _result: doc$stringBuilder;
            _tableColumns: java.util.Map<com.sun.source.doctree.StartElementTree,int>;
            _tableStack: java.util.Stack<int>;
            _task: com.sun.source.util.JavacTask;
            _this$0: JavadocFormatter;
            _trees: com.sun.source.util.DocTrees;
          }
          interface JavadocFormatter$FormatJavadocScanner extends CombineTypes<[_JavadocFormatter$FormatJavadocScanner, com.sun.source.util.DocTreeScanner<any,any>]> {}
          interface _JavadocFormatter$HtmlTag$$static extends ClassLike {
            get(tagName: javax.lang.model.element.Name): JavadocFormatter$HtmlTag;
            valueOf(name: string): JavadocFormatter$HtmlTag;
            values(): JavadocFormatter$HtmlTag[];
            readonly BLOCKQUOTE: JavadocFormatter$HtmlTag;
            readonly DD: JavadocFormatter$HtmlTag;
            readonly DL: JavadocFormatter$HtmlTag;
            readonly DT: JavadocFormatter$HtmlTag;
            readonly H1: JavadocFormatter$HtmlTag;
            readonly H2: JavadocFormatter$HtmlTag;
            readonly H3: JavadocFormatter$HtmlTag;
            readonly H4: JavadocFormatter$HtmlTag;
            readonly H5: JavadocFormatter$HtmlTag;
            readonly H6: JavadocFormatter$HtmlTag;
            readonly HTML: JavadocFormatter$HtmlTag;
            readonly IMG: JavadocFormatter$HtmlTag;
            readonly LI: JavadocFormatter$HtmlTag;
            readonly OL: JavadocFormatter$HtmlTag;
            readonly P: JavadocFormatter$HtmlTag;
            readonly PRE: JavadocFormatter$HtmlTag;
            readonly TABLE: JavadocFormatter$HtmlTag;
            readonly TD: JavadocFormatter$HtmlTag;
            readonly TH: JavadocFormatter$HtmlTag;
            readonly TR: JavadocFormatter$HtmlTag;
            readonly UL: JavadocFormatter$HtmlTag;
            _index: java.util.Map<string,JavadocFormatter$HtmlTag>;
          }
          let JavadocFormatter$HtmlTag: _JavadocFormatter$HtmlTag$$static;
          interface _JavadocFormatter$HtmlTag {
          }
          interface JavadocFormatter$HtmlTag extends CombineTypes<[_JavadocFormatter$HtmlTag]> {}
          interface _JavadocFormatter$Sections$$static extends ClassLike {
            valueOf(name: string): JavadocFormatter$Sections;
            values(): JavadocFormatter$Sections[];
            readonly PARAMS: JavadocFormatter$Sections;
            readonly RETURNS: JavadocFormatter$Sections;
            readonly THROWS: JavadocFormatter$Sections;
            readonly TYPE_PARAMS: JavadocFormatter$Sections;
          }
          let JavadocFormatter$Sections: _JavadocFormatter$Sections$$static;
          interface _JavadocFormatter$Sections {
            matches(a0: com.sun.source.doctree.DocTree): boolean;
(a0: com.sun.source.doctree.DocTree): boolean;
          }
          interface JavadocFormatter$Sections extends CombineTypes<[_JavadocFormatter$Sections]> {}
          interface _JavadocHelper$$static extends ClassLike {
            create(mainTask: com.sun.source.util.JavacTask, sourceLocations: java.util.Collection<java.nio.file.Path>): JavadocHelper;
            _compiler: javax.tools.JavaCompiler;
            new(): JavadocHelper;
          }
          let JavadocHelper: _JavadocHelper$$static;
          interface _JavadocHelper {
            close(): void;
            getResolvedDocComment(a0: javax.lang.model.element.Element): string;
            getSourceElement(a0: javax.lang.model.element.Element): javax.lang.model.element.Element;
          }
          interface JavadocHelper extends CombineTypes<[_JavadocHelper, java.lang.Object, java.lang.AutoCloseable]> {}
          interface _JavadocHelper$OnDemandJavadocHelper$$static extends ClassLike {
          }
          let JavadocHelper$OnDemandJavadocHelper: _JavadocHelper$OnDemandJavadocHelper$$static;
          interface _JavadocHelper$OnDemandJavadocHelper {
            close(): void;
            _elementSignature(el: javax.lang.model.element.Element): string;
            _fillElementCache(task: com.sun.source.util.JavacTask, cut: com.sun.source.tree.CompilationUnitTree): void;
            _findSource(moduleName: string, binaryName: string): com.sun.tools.javac.util.Pair<com.sun.source.util.JavacTask,com.sun.source.tree.CompilationUnitTree>;
            getResolvedDocComment(forElement: javax.lang.model.element.Element): string;
            _getResolvedDocComment(task: com.sun.source.util.JavacTask, el: com.sun.source.util.TreePath): string;
            getSourceElement(forElement: javax.lang.model.element.Element): javax.lang.model.element.Element;
            _getSourceElement(origin: com.sun.source.util.JavacTask, el: javax.lang.model.element.Element): com.sun.tools.javac.util.Pair<com.sun.source.util.JavacTask,com.sun.source.util.TreePath>;
            _getThrownException(task: com.sun.source.util.JavacTask, rootOn: com.sun.source.util.TreePath, comment: com.sun.source.doctree.DocCommentTree, tt: com.sun.source.doctree.ThrowsTree): string;
            _interfaces(clazz: javax.lang.model.element.TypeElement): java.util.stream.Stream<javax.lang.model.element.Element>;
            _parseBlockTag(task: com.sun.source.util.JavacTask, blockTag: string): com.sun.source.doctree.DocTree;
            _parseDocComment(task: com.sun.source.util.JavacTask, javadoc: string): com.sun.tools.javac.util.Pair<com.sun.source.doctree.DocCommentTree,int>;
            _superMethodsForInheritDoc(task: com.sun.source.util.JavacTask, method: javax.lang.model.element.ExecutableElement): java.util.stream.Stream<javax.lang.model.element.ExecutableElement>;
            _superTypeForInheritDoc(task: com.sun.source.util.JavacTask, type: javax.lang.model.element.Element): java.util.stream.Stream<javax.lang.model.element.Element>;
            _topLevelType(el: javax.lang.model.element.Element): javax.lang.model.element.TypeElement;
            _baseFileManager: javax.tools.JavaFileManager;
            _fm: javax.tools.StandardJavaFileManager;
            _mainTask: com.sun.source.util.JavacTask;
            _signature2Source: java.util.Map<string,com.sun.tools.javac.util.Pair<com.sun.source.util.JavacTask,com.sun.source.util.TreePath>>;
          }
          interface JavadocHelper$OnDemandJavadocHelper extends CombineTypes<[_JavadocHelper$OnDemandJavadocHelper, jdk.internal.shellsupport.doc.JavadocHelper]> {}
          interface _JavadocHelper$OnDemandJavadocHelper$PatchModuleFileManager$$static extends ClassLike {
            _PATCH_LOCATION: javax.tools.JavaFileManager$Location;
            new(fileManager: javax.tools.JavaFileManager, file: javax.tools.JavaFileObject, moduleName: string): JavadocHelper$OnDemandJavadocHelper$PatchModuleFileManager;
          }
          let JavadocHelper$OnDemandJavadocHelper$PatchModuleFileManager: _JavadocHelper$OnDemandJavadocHelper$PatchModuleFileManager$$static;
          interface _JavadocHelper$OnDemandJavadocHelper$PatchModuleFileManager {
            getLocationForModule(location: javax.tools.JavaFileManager$Location, fo: javax.tools.JavaFileObject): javax.tools.JavaFileManager$Location;
            hasLocation(location: javax.tools.JavaFileManager$Location): boolean;
            inferModuleName(location: javax.tools.JavaFileManager$Location): string;
            _file: javax.tools.JavaFileObject;
            _moduleName: string;
          }
          interface JavadocHelper$OnDemandJavadocHelper$PatchModuleFileManager extends CombineTypes<[_JavadocHelper$OnDemandJavadocHelper$PatchModuleFileManager, javax.tools.ForwardingJavaFileManager<javax.tools.JavaFileManager>]> {}
        }
      }
    }
  }
  module sun {
    module tools {
      module serialver {
        module resources {
          interface _serialver$$static extends ClassLike {
            new(): serialver;
          }
          let serialver: _serialver$$static;
          interface _serialver {
            _getContents(): any[][];
          }
          interface serialver extends CombineTypes<[_serialver, java.util.ListResourceBundle]> {}
          interface _serialver_de$$static extends ClassLike {
            new(): serialver_de;
          }
          let serialver_de: _serialver_de$$static;
          interface _serialver_de {
            _getContents(): any[][];
          }
          interface serialver_de extends CombineTypes<[_serialver_de, java.util.ListResourceBundle]> {}
          interface _serialver_ja$$static extends ClassLike {
            new(): serialver_ja;
          }
          let serialver_ja: _serialver_ja$$static;
          interface _serialver_ja {
            _getContents(): any[][];
          }
          interface serialver_ja extends CombineTypes<[_serialver_ja, java.util.ListResourceBundle]> {}
          interface _serialver_zh_CN$$static extends ClassLike {
            new(): serialver_zh_CN;
          }
          let serialver_zh_CN: _serialver_zh_CN$$static;
          interface _serialver_zh_CN {
            _getContents(): any[][];
          }
          interface serialver_zh_CN extends CombineTypes<[_serialver_zh_CN, java.util.ListResourceBundle]> {}
        }
        interface _Res$$static extends ClassLike {
          _getText(key: string): string;
          _getText(key: string, a1: string): string;
          _getText(key: string, a1: string, a2: string): string;
          _getText(key: string, a1: string, a2: string, a3: string): string;
          _initResource(): void;
          _messageRB: java.util.ResourceBundle;
          _new(): Res;
        }
        let Res: _Res$$static;
        interface _Res {
        }
        interface Res extends CombineTypes<[_Res, java.lang.Object]> {}
        interface _SerialVer$$static extends ClassLike {
          _initializeLoader(cp: string): void;
          main(args: string[]): void;
          _resolveClass(classname: string): string;
          _serialSyntax(classname: string): string;
          usage(): void;
          _loader: java.net.URLClassLoader;
          new(): SerialVer;
        }
        let SerialVer: _SerialVer$$static;
        interface _SerialVer {
        }
        interface SerialVer extends CombineTypes<[_SerialVer, java.lang.Object]> {}
      }
    }
  }
}

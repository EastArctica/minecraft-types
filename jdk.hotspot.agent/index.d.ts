type ClassLike = {
  class: Packages.java.lang.Class<any>;
  [Symbol.hasInstance](v): boolean
 }
type isAny<T> = (T extends never ? true : false) extends false ? false : true;
type CombineTypes<A> = (
  A extends [infer B, ...infer Rest] ?
    isAny<B> extends true ?
      CombineTypes<Rest>
      : CombineTypes<Rest> extends never ? B : B & CombineTypes<Rest>
    : A extends [infer B] ?
      isAny<B> extends true ? never : B
  : never
)
type char   = number & {};
type byte   = number & {};
type short  = number & {};
type int    = number & {};
type long   = number | BigInt;
type float  = number & {};
type double = number & {};
type Function$$JS = Function;
declare module Packages {
  module com {
    module sun {
      module java {
        module swing {
          module action {
            interface _AboutAction$$static extends ClassLike {
              readonly VALUE_COMMAND: string;
              readonly VALUE_LARGE_ICON: string;
              readonly VALUE_LONG_DESCRIPTION: string;
              readonly VALUE_MNEMONIC: int;
              readonly VALUE_NAME: string;
              readonly VALUE_SHORT_DESCRIPTION: string;
              readonly VALUE_SMALL_ICON: string;
              new(): AboutAction;
              new(iconPath: string): AboutAction;
            }
            let AboutAction: _AboutAction$$static;
            interface _AboutAction {
            }
            interface AboutAction extends CombineTypes<[_AboutAction, com.sun.java.swing.action.DelegateAction]> {}
            interface _ActionManager$$static extends ClassLike {
              getIcon(name: string): javax.swing.ImageIcon;
              getInstance(): ActionManager;
              _setInstance(m: ActionManager): void;
              _manager: ActionManager;
              _utilities: ActionUtilities;
              _new(): ActionManager;
            }
            let ActionManager: _ActionManager$$static;
            interface _ActionManager {
              _addAction(cmdname: string, action: javax.swing.Action): void;
              _addActions(): void;
(): void;
              getAction(key: string): javax.swing.Action;
              getDelegateAction(name: string): DelegateAction;
              getStateChangeAction(name: string): StateChangeAction;
              setActionEnabled(name: string, enabled: boolean): void;
              _actions: java.util.HashMap<string,javax.swing.Action>;
            }
            interface ActionManager extends CombineTypes<[_ActionManager, java.lang.Object]> {}
            interface _ActionUtilities$$static extends ClassLike {
              readonly IMAGE_DIR: string;
              _new(): ActionUtilities;
            }
            let ActionUtilities: _ActionUtilities$$static;
            interface _ActionUtilities {
              getIcon(name: string): javax.swing.ImageIcon;
            }
            interface ActionUtilities extends CombineTypes<[_ActionUtilities, java.lang.Object]> {}
            interface _AlignCenterAction$$static extends ClassLike {
              readonly VALUE_ACCELERATOR: javax.swing.KeyStroke;
              readonly VALUE_COMMAND: string;
              readonly VALUE_LARGE_ICON: string;
              readonly VALUE_LONG_DESCRIPTION: string;
              readonly VALUE_MNEMONIC: int;
              readonly VALUE_NAME: string;
              readonly VALUE_SHORT_DESCRIPTION: string;
              readonly VALUE_SMALL_ICON: string;
              new(): AlignCenterAction;
              new(iconPath: string): AlignCenterAction;
            }
            let AlignCenterAction: _AlignCenterAction$$static;
            interface _AlignCenterAction {
            }
            interface AlignCenterAction extends CombineTypes<[_AlignCenterAction, com.sun.java.swing.action.StateChangeAction]> {}
            interface _AlignLeftAction$$static extends ClassLike {
              readonly VALUE_ACCELERATOR: javax.swing.KeyStroke;
              readonly VALUE_COMMAND: string;
              readonly VALUE_LARGE_ICON: string;
              readonly VALUE_LONG_DESCRIPTION: string;
              readonly VALUE_MNEMONIC: int;
              readonly VALUE_NAME: string;
              readonly VALUE_SHORT_DESCRIPTION: string;
              readonly VALUE_SMALL_ICON: string;
              new(): AlignLeftAction;
              new(iconPath: string): AlignLeftAction;
            }
            let AlignLeftAction: _AlignLeftAction$$static;
            interface _AlignLeftAction {
            }
            interface AlignLeftAction extends CombineTypes<[_AlignLeftAction, com.sun.java.swing.action.StateChangeAction]> {}
            interface _AlignRightAction$$static extends ClassLike {
              readonly VALUE_ACCELERATOR: javax.swing.KeyStroke;
              readonly VALUE_COMMAND: string;
              readonly VALUE_LARGE_ICON: string;
              readonly VALUE_LONG_DESCRIPTION: string;
              readonly VALUE_MNEMONIC: int;
              readonly VALUE_NAME: string;
              readonly VALUE_SHORT_DESCRIPTION: string;
              readonly VALUE_SMALL_ICON: string;
              new(): AlignRightAction;
              new(iconPath: string): AlignRightAction;
            }
            let AlignRightAction: _AlignRightAction$$static;
            interface _AlignRightAction {
            }
            interface AlignRightAction extends CombineTypes<[_AlignRightAction, com.sun.java.swing.action.StateChangeAction]> {}
            interface _ApplyAction$$static extends ClassLike {
              readonly VALUE_ACCELERATOR: javax.swing.KeyStroke;
              readonly VALUE_COMMAND: string;
              readonly VALUE_LARGE_ICON: string;
              readonly VALUE_LONG_DESCRIPTION: string;
              readonly VALUE_MNEMONIC: int;
              readonly VALUE_NAME: string;
              readonly VALUE_SHORT_DESCRIPTION: string;
              readonly VALUE_SMALL_ICON: string;
              new(): ApplyAction;
              new(iconPath: string): ApplyAction;
            }
            let ApplyAction: _ApplyAction$$static;
            interface _ApplyAction {
            }
            interface ApplyAction extends CombineTypes<[_ApplyAction, com.sun.java.swing.action.DelegateAction]> {}
            interface _BackAction$$static extends ClassLike {
              readonly VALUE_ACCELERATOR: javax.swing.KeyStroke;
              readonly VALUE_COMMAND: string;
              readonly VALUE_LARGE_ICON: string;
              readonly VALUE_LONG_DESCRIPTION: string;
              readonly VALUE_MNEMONIC: int;
              readonly VALUE_NAME: string;
              readonly VALUE_SHORT_DESCRIPTION: string;
              readonly VALUE_SMALL_ICON: string;
              new(): BackAction;
              new(iconPath: string): BackAction;
            }
            let BackAction: _BackAction$$static;
            interface _BackAction {
            }
            interface BackAction extends CombineTypes<[_BackAction, com.sun.java.swing.action.DelegateAction]> {}
            interface _CancelAction$$static extends ClassLike {
              readonly VALUE_ACCELERATOR: javax.swing.KeyStroke;
              readonly VALUE_COMMAND: string;
              readonly VALUE_LARGE_ICON: string;
              readonly VALUE_LONG_DESCRIPTION: string;
              readonly VALUE_MNEMONIC: int;
              readonly VALUE_NAME: string;
              readonly VALUE_SHORT_DESCRIPTION: string;
              readonly VALUE_SMALL_ICON: string;
              new(): CancelAction;
              new(iconPath: string): CancelAction;
            }
            let CancelAction: _CancelAction$$static;
            interface _CancelAction {
            }
            interface CancelAction extends CombineTypes<[_CancelAction, com.sun.java.swing.action.DelegateAction]> {}
            interface _DelegateAction$$static extends ClassLike {
              new(name: string, icon: javax.swing.Icon): DelegateAction;
            }
            let DelegateAction: _DelegateAction$$static;
            interface _DelegateAction {
              actionPerformed(evt: java.awt.event.ActionEvent): void;
              addActionListener(listener: java.awt.event.ActionListener): void;
              getActionListeners(): java.awt.event.ActionListener[];
              removeActionListener(listener: java.awt.event.ActionListener): void;
              _listener: java.awt.event.ActionListener;
            }
            interface DelegateAction extends CombineTypes<[_DelegateAction, javax.swing.AbstractAction]> {}
            interface _ExitAction$$static extends ClassLike {
              readonly VALUE_ACCELERATOR: javax.swing.KeyStroke;
              readonly VALUE_COMMAND: string;
              readonly VALUE_LARGE_ICON: string;
              readonly VALUE_LONG_DESCRIPTION: string;
              readonly VALUE_MNEMONIC: int;
              readonly VALUE_NAME: string;
              readonly VALUE_SHORT_DESCRIPTION: string;
              readonly VALUE_SMALL_ICON: string;
              new(): ExitAction;
            }
            let ExitAction: _ExitAction$$static;
            interface _ExitAction {
            }
            interface ExitAction extends CombineTypes<[_ExitAction, com.sun.java.swing.action.DelegateAction]> {}
            interface _FileMenu$$static extends ClassLike {
              readonly VALUE_COMMAND: string;
              readonly VALUE_LONG_DESCRIPTION: string;
              readonly VALUE_MNEMONIC: int;
              readonly VALUE_NAME: string;
              readonly VALUE_SHORT_DESCRIPTION: string;
              new(): FileMenu;
            }
            let FileMenu: _FileMenu$$static;
            interface _FileMenu {
              actionPerformed(actionevent: java.awt.event.ActionEvent): void;
            }
            interface FileMenu extends CombineTypes<[_FileMenu, javax.swing.AbstractAction]> {}
            interface _FinishAction$$static extends ClassLike {
              readonly VALUE_ACCELERATOR: javax.swing.KeyStroke;
              readonly VALUE_COMMAND: string;
              readonly VALUE_LARGE_ICON: string;
              readonly VALUE_LONG_DESCRIPTION: string;
              readonly VALUE_MNEMONIC: int;
              readonly VALUE_NAME: string;
              readonly VALUE_SHORT_DESCRIPTION: string;
              readonly VALUE_SMALL_ICON: string;
              new(): FinishAction;
              new(iconPath: string): FinishAction;
            }
            let FinishAction: _FinishAction$$static;
            interface _FinishAction {
            }
            interface FinishAction extends CombineTypes<[_FinishAction, com.sun.java.swing.action.DelegateAction]> {}
            interface _HelpAction$$static extends ClassLike {
              readonly VALUE_ACCELERATOR: javax.swing.KeyStroke;
              readonly VALUE_COMMAND: string;
              readonly VALUE_LARGE_ICON: string;
              readonly VALUE_LONG_DESCRIPTION: string;
              readonly VALUE_MNEMONIC: int;
              readonly VALUE_NAME: string;
              readonly VALUE_SHORT_DESCRIPTION: string;
              readonly VALUE_SMALL_ICON: string;
              new(): HelpAction;
              new(iconPath: string): HelpAction;
            }
            let HelpAction: _HelpAction$$static;
            interface _HelpAction {
            }
            interface HelpAction extends CombineTypes<[_HelpAction, com.sun.java.swing.action.DelegateAction]> {}
            interface _HelpMenu$$static extends ClassLike {
              readonly VALUE_COMMAND: string;
              readonly VALUE_LONG_DESCRIPTION: string;
              readonly VALUE_MNEMONIC: int;
              readonly VALUE_NAME: string;
              readonly VALUE_SHORT_DESCRIPTION: string;
              new(): HelpMenu;
            }
            let HelpMenu: _HelpMenu$$static;
            interface _HelpMenu {
              actionPerformed(actionevent: java.awt.event.ActionEvent): void;
            }
            interface HelpMenu extends CombineTypes<[_HelpMenu, javax.swing.AbstractAction]> {}
            interface _NewAction$$static extends ClassLike {
              readonly VALUE_ACCELERATOR: javax.swing.KeyStroke;
              readonly VALUE_COMMAND: string;
              readonly VALUE_LARGE_ICON: string;
              readonly VALUE_LONG_DESCRIPTION: string;
              readonly VALUE_MNEMONIC: int;
              readonly VALUE_NAME: string;
              readonly VALUE_SHORT_DESCRIPTION: string;
              readonly VALUE_SMALL_ICON: string;
              new(): NewAction;
              new(iconPath: string): NewAction;
            }
            let NewAction: _NewAction$$static;
            interface _NewAction {
            }
            interface NewAction extends CombineTypes<[_NewAction, com.sun.java.swing.action.DelegateAction]> {}
            interface _NextAction$$static extends ClassLike {
              readonly VALUE_ACCELERATOR: javax.swing.KeyStroke;
              readonly VALUE_COMMAND: string;
              readonly VALUE_LARGE_ICON: string;
              readonly VALUE_LONG_DESCRIPTION: string;
              readonly VALUE_MNEMONIC: int;
              readonly VALUE_NAME: string;
              readonly VALUE_SHORT_DESCRIPTION: string;
              readonly VALUE_SMALL_ICON: string;
              new(): NextAction;
              new(iconPath: string): NextAction;
            }
            let NextAction: _NextAction$$static;
            interface _NextAction {
            }
            interface NextAction extends CombineTypes<[_NextAction, com.sun.java.swing.action.DelegateAction]> {}
            interface _OkAction$$static extends ClassLike {
              readonly VALUE_ACCELERATOR: javax.swing.KeyStroke;
              readonly VALUE_COMMAND: string;
              readonly VALUE_LARGE_ICON: string;
              readonly VALUE_LONG_DESCRIPTION: string;
              readonly VALUE_MNEMONIC: int;
              readonly VALUE_NAME: string;
              readonly VALUE_SHORT_DESCRIPTION: string;
              readonly VALUE_SMALL_ICON: string;
              new(): OkAction;
              new(iconPath: string): OkAction;
            }
            let OkAction: _OkAction$$static;
            interface _OkAction {
            }
            interface OkAction extends CombineTypes<[_OkAction, com.sun.java.swing.action.DelegateAction]> {}
            interface _OpenAction$$static extends ClassLike {
              readonly VALUE_ACCELERATOR: javax.swing.KeyStroke;
              readonly VALUE_COMMAND: string;
              readonly VALUE_LARGE_ICON: string;
              readonly VALUE_LONG_DESCRIPTION: string;
              readonly VALUE_MNEMONIC: int;
              readonly VALUE_NAME: string;
              readonly VALUE_SHORT_DESCRIPTION: string;
              readonly VALUE_SMALL_ICON: string;
              new(): OpenAction;
              new(iconPath: string): OpenAction;
            }
            let OpenAction: _OpenAction$$static;
            interface _OpenAction {
            }
            interface OpenAction extends CombineTypes<[_OpenAction, com.sun.java.swing.action.DelegateAction]> {}
            interface _SaveAction$$static extends ClassLike {
              readonly VALUE_ACCELERATOR: javax.swing.KeyStroke;
              readonly VALUE_COMMAND: string;
              readonly VALUE_LARGE_ICON: string;
              readonly VALUE_LONG_DESCRIPTION: string;
              readonly VALUE_MNEMONIC: int;
              readonly VALUE_NAME: string;
              readonly VALUE_SHORT_DESCRIPTION: string;
              readonly VALUE_SMALL_ICON: string;
              new(): SaveAction;
              new(iconPath: string): SaveAction;
            }
            let SaveAction: _SaveAction$$static;
            interface _SaveAction {
            }
            interface SaveAction extends CombineTypes<[_SaveAction, com.sun.java.swing.action.DelegateAction]> {}
            interface _SaveAsAction$$static extends ClassLike {
              readonly VALUE_COMMAND: string;
              readonly VALUE_LARGE_ICON: string;
              readonly VALUE_LONG_DESCRIPTION: string;
              readonly VALUE_MNEMONIC: int;
              readonly VALUE_NAME: string;
              readonly VALUE_SHORT_DESCRIPTION: string;
              readonly VALUE_SMALL_ICON: string;
              new(): SaveAsAction;
              new(iconPath: string): SaveAsAction;
            }
            let SaveAsAction: _SaveAsAction$$static;
            interface _SaveAsAction {
            }
            interface SaveAsAction extends CombineTypes<[_SaveAsAction, com.sun.java.swing.action.DelegateAction]> {}
            interface _StateChangeAction$$static extends ClassLike {
              new(name: string): StateChangeAction;
              new(name: string, icon: javax.swing.Icon): StateChangeAction;
            }
            let StateChangeAction: _StateChangeAction$$static;
            interface _StateChangeAction {
              getItemListener(): java.awt.event.ItemListener;
              isSelected(): boolean;
              itemStateChanged(evt: java.awt.event.ItemEvent): void;
              setItemListener(listener: java.awt.event.ItemListener): void;
              setSelected(newValue: boolean): void;
              _listener: java.awt.event.ItemListener;
              _selected: boolean;
            }
            interface StateChangeAction extends CombineTypes<[_StateChangeAction, com.sun.java.swing.action.DelegateAction, java.awt.event.ItemListener]> {}
            interface _ViewMenu$$static extends ClassLike {
              readonly VALUE_COMMAND: string;
              readonly VALUE_LONG_DESCRIPTION: string;
              readonly VALUE_MNEMONIC: int;
              readonly VALUE_NAME: string;
              readonly VALUE_SHORT_DESCRIPTION: string;
              new(): ViewMenu;
            }
            let ViewMenu: _ViewMenu$$static;
            interface _ViewMenu {
              actionPerformed(actionevent: java.awt.event.ActionEvent): void;
            }
            interface ViewMenu extends CombineTypes<[_ViewMenu, javax.swing.AbstractAction]> {}
          }
          module ui {
            interface _CommonMenuBar$$static extends ClassLike {
              _new(manager: swing.action.ActionManager): CommonMenuBar;
              _new(manager: swing.action.ActionManager, status: StatusBar): CommonMenuBar;
            }
            let CommonMenuBar: _CommonMenuBar$$static;
            interface _CommonMenuBar {
              _addCheckBoxMenuItem(menu: javax.swing.JMenu, a: swing.action.StateChangeAction): void;
              _addCheckBoxMenuItem(menu: javax.swing.JMenu, a: swing.action.StateChangeAction, selected: boolean): void;
              _addMenuItem(menu: javax.swing.JMenu, action: javax.swing.Action): void;
              _addRadioButtonMenuItem(menu: javax.swing.JMenu, group: javax.swing.ButtonGroup, a: swing.action.StateChangeAction): void;
              _addRadioButtonMenuItem(menu: javax.swing.JMenu, group: javax.swing.ButtonGroup, a: swing.action.StateChangeAction, selected: boolean): void;
              _configureMenu(): void;
(): void;
              _configureMenuItem(menuItem: javax.swing.JMenuItem, action: javax.swing.Action): void;
              _configureToggleMenuItem(menuItem: javax.swing.JMenuItem, action: javax.swing.Action): void;
              _createMenu(name: string, mnemonic: char): javax.swing.JMenu;
              _manager: swing.action.ActionManager;
              _statusBar: StatusBar;
            }
            interface CommonMenuBar extends CombineTypes<[_CommonMenuBar, javax.swing.JMenuBar]> {}
            interface _CommonToolBar$$static extends ClassLike {
              _new(manager: swing.action.ActionManager): CommonToolBar;
              _new(manager: swing.action.ActionManager, status: StatusBar): CommonToolBar;
            }
            let CommonToolBar: _CommonToolBar$$static;
            interface _CommonToolBar {
              _addButton(action: javax.swing.Action): void;
              _addComponents(): void;
(): void;
              _addToggleButton(a: swing.action.StateChangeAction): void;
              _addToggleButton(a: swing.action.StateChangeAction, group: javax.swing.ButtonGroup): void;
              _configureButton(button: javax.swing.AbstractButton, action: javax.swing.Action): void;
              _configureToggleButton(button: javax.swing.JToggleButton, action: javax.swing.Action): void;
              _buttonInsets: java.awt.Insets;
              _buttonSize: java.awt.Dimension;
              _manager: swing.action.ActionManager;
              _statusBar: StatusBar;
            }
            interface CommonToolBar extends CombineTypes<[_CommonToolBar, javax.swing.JToolBar]> {}
            interface _CommonUI$$static extends ClassLike {
              centerComponent(source: java.awt.Component, parent: java.awt.Component): void;
              centerComponent(source: java.awt.Component): void;
              createBorder(text: string): javax.swing.border.Border;
              createBorder(): javax.swing.border.Border;
              createButton(action: javax.swing.Action): javax.swing.JButton;
              createButton(text: string, listener: java.awt.event.ActionListener, mnemonic: int): javax.swing.JButton;
              createButton(text: string, listener: java.awt.event.ActionListener): javax.swing.JButton;
              createCheckBox(text: string, mnemonic: int, listener: java.awt.event.ActionListener, selected: boolean): javax.swing.JCheckBox;
              createCheckBox(text: string, mnemonic: int, listener: java.awt.event.ActionListener): javax.swing.JCheckBox;
              createCheckBox(text: string, mnemonic: int, selected: boolean): javax.swing.JCheckBox;
              createCheckBox(text: string, mnemonic: int): javax.swing.JCheckBox;
              createCheckBox(text: string): javax.swing.JCheckBox;
              createComboBox(items: any[], listener: java.awt.event.ActionListener, editable: boolean): javax.swing.JComboBox<any>;
              createComboBox(items: any[], editable: boolean): javax.swing.JComboBox<any>;
              createComboBox(items: java.util.Vector<any>, listener: java.awt.event.ActionListener, editable: boolean): javax.swing.JComboBox<any>;
              createComboBox(items: java.util.Vector<any>, editable: boolean): javax.swing.JComboBox<any>;
              createLabel(text: string, mnemonic: int, comp: java.awt.Component): javax.swing.JLabel;
              createLabel(text: string): javax.swing.JLabel;
              createListPane(list: javax.swing.JList, text: string): javax.swing.JScrollPane;
              createRadioButton(text: string, mnemonic: int, listener: java.awt.event.ActionListener, selected: boolean): javax.swing.JRadioButton;
              createRadioButton(text: string, mnemonic: int, selected: boolean): javax.swing.JRadioButton;
              createRadioButton(text: string, mnemonic: int, listener: java.awt.event.ActionListener): javax.swing.JRadioButton;
              createRadioButton(text: string, mnemonic: int): javax.swing.JRadioButton;
              createRadioButton(text: string): javax.swing.JRadioButton;
              createSmallButton(text: string, listener: java.awt.event.ActionListener, mnemonic: int): javax.swing.JButton;
              createSmallButton(text: string, listener: java.awt.event.ActionListener): javax.swing.JButton;
              createTextField(text: string, listener: java.awt.event.KeyListener, numbers: boolean): javax.swing.JTextField;
              createTextField(text: string, numbers: boolean): javax.swing.JTextField;
              createTextField(text: string, listener: java.awt.event.KeyListener): javax.swing.JTextField;
              createTextField(text: string): javax.swing.JTextField;
              getButtconPrefSize(): java.awt.Dimension;
              getParentFrame(source: java.awt.Component): javax.swing.JFrame;
              msToSec(ms: int): int;
              secToMs(sec: int): int;
              _setButtonSize(button: javax.swing.JButton, size: java.awt.Dimension): void;
              setDefaultCursor(comp: java.awt.Component): void;
              setWaitCursor(comp: java.awt.Component): void;
              stringArrayFromString(string: string, delim: string): string[];
              stringArrayFromString(string: string): string[];
              stringFromStringArray(strings: string[], delim: string): string;
              stringFromStringArray(strings: string[]): string;
              _BUTTCON_HEIGHT: int;
              _BUTTCON_WIDTH: int;
              _BUTTON_HEIGHT: int;
              _BUTTON_WIDTH: int;
              _LABEL_HEIGHT: int;
              _LABEL_WIDTH: int;
              _SM_BUTTON_HEIGHT: int;
              _SM_BUTTON_WIDTH: int;
              _TEXT_HEIGHT: int;
              _TEXT_WIDTH: int;
              _buttconPrefSize: java.awt.Dimension;
              _buttonPrefSize: java.awt.Dimension;
              _labelPrefSize: java.awt.Dimension;
              _smbuttonPrefSize: java.awt.Dimension;
              _textPrefSize: java.awt.Dimension;
              new(): CommonUI;
            }
            let CommonUI: _CommonUI$$static;
            interface _CommonUI {
            }
            interface CommonUI extends CombineTypes<[_CommonUI, java.lang.Object]> {}
            interface _CommonUI$NumberDocument$$static extends ClassLike {
            }
            let CommonUI$NumberDocument: _CommonUI$NumberDocument$$static;
            interface _CommonUI$NumberDocument {
              insertString(offs: int, str: string, atts: javax.swing.text.AttributeSet): void;
            }
            interface CommonUI$NumberDocument extends CombineTypes<[_CommonUI$NumberDocument, javax.swing.text.PlainDocument]> {}
            interface _OkCancelButtonPanel$$static extends ClassLike {
              readonly CANCEL_COMMAND: string;
              readonly OK_COMMAND: string;
              new(listener: java.awt.event.ActionListener): OkCancelButtonPanel;
            }
            let OkCancelButtonPanel: _OkCancelButtonPanel$$static;
            interface _OkCancelButtonPanel {
            }
            interface OkCancelButtonPanel extends CombineTypes<[_OkCancelButtonPanel, javax.swing.JPanel]> {}
            interface _OkCancelDialog$$static extends ClassLike {
              new(title: string, panel: javax.swing.JPanel): OkCancelDialog;
              new(title: string, panel: javax.swing.JPanel, modal: boolean): OkCancelDialog;
            }
            let OkCancelDialog: _OkCancelDialog$$static;
            interface _OkCancelDialog {
              actionPerformed(evt: java.awt.event.ActionEvent): void;
              isOk(): boolean;
              _okPressed: boolean;
            }
            interface OkCancelDialog extends CombineTypes<[_OkCancelDialog, java.awt.event.ActionListener, javax.swing.JDialog]> {}
            interface _SplashScreen$$static extends ClassLike {
              new(f: java.awt.Frame): SplashScreen;
            }
            let SplashScreen: _SplashScreen$$static;
            interface _SplashScreen {
              paint(g: java.awt.Graphics): void;
              setVisible(val: boolean): void;
              _screen: javax.swing.ImageIcon;
            }
            interface SplashScreen extends CombineTypes<[_SplashScreen, java.awt.Window]> {}
            interface _StatusBar$$static extends ClassLike {
              getInstance(): StatusBar;
              setInstance(sb: StatusBar): void;
              _PROGRESS_MAX: int;
              _PROGRESS_MIN: int;
              _statusBar: StatusBar;
              new(): StatusBar;
            }
            let StatusBar: _StatusBar$$static;
            interface _StatusBar {
              actionPerformed(evt: java.awt.event.ActionEvent): void;
              _getFontHeight(): int;
              getPreferredSize(): java.awt.Dimension;
              _getWidth(s: string): int;
              mouseClicked(mouseevent: java.awt.event.MouseEvent): void;
              mouseEntered(evt: java.awt.event.MouseEvent): void;
              mouseExited(evt: java.awt.event.MouseEvent): void;
              mousePressed(mouseevent: java.awt.event.MouseEvent): void;
              mouseReleased(mouseevent: java.awt.event.MouseEvent): void;
              setMessage(message: string): void;
              startBusyBar(): void;
              stopBusyBar(): void;
              _forward: boolean;
              _label: javax.swing.JLabel;
              _preferredSize: java.awt.Dimension;
              _progressBar: javax.swing.JProgressBar;
              _timer: javax.swing.Timer;
            }
            interface StatusBar extends CombineTypes<[_StatusBar, java.awt.event.ActionListener, javax.swing.JPanel, java.awt.event.MouseListener]> {}
            interface _TabsDlg$$static extends ClassLike {
              main(args: string[]): void;
              _tabsDlg: TabsDlg;
              new(title: string, panels: java.util.Vector): TabsDlg;
            }
            let TabsDlg: _TabsDlg$$static;
            interface _TabsDlg {
              addApplyListener(l: java.awt.event.ActionListener): void;
              addCancelListener(l: java.awt.event.ActionListener): void;
              addOkListener(l: java.awt.event.ActionListener): void;
              _createButtonPanel(): javax.swing.JPanel;
              enableApplyButton(enabled: boolean): void;
              removeApplyListener(l: java.awt.event.ActionListener): void;
              removeCancelListener(l: java.awt.event.ActionListener): void;
              removeOkListener(l: java.awt.event.ActionListener): void;
              _applyAction: swing.action.DelegateAction;
              _applyListener: java.awt.event.ActionListener;
              _cancelAction: swing.action.DelegateAction;
              _cancelListener: java.awt.event.ActionListener;
              _okAction: swing.action.DelegateAction;
              _okListener: java.awt.event.ActionListener;
              _tabsPanel: javax.swing.JTabbedPane;
            }
            interface TabsDlg extends CombineTypes<[_TabsDlg, javax.swing.JDialog]> {}
            interface _TabsDlg$ApplyListener$$static extends ClassLike {
            }
            let TabsDlg$ApplyListener: _TabsDlg$ApplyListener$$static;
            interface _TabsDlg$ApplyListener {
              actionPerformed(evt: java.awt.event.ActionEvent): void;
              _this$0: TabsDlg;
            }
            interface TabsDlg$ApplyListener extends CombineTypes<[_TabsDlg$ApplyListener, java.awt.event.ActionListener, java.lang.Object]> {}
            interface _TabsDlg$CancelListener$$static extends ClassLike {
            }
            let TabsDlg$CancelListener: _TabsDlg$CancelListener$$static;
            interface _TabsDlg$CancelListener {
              actionPerformed(evt: java.awt.event.ActionEvent): void;
              _this$0: TabsDlg;
            }
            interface TabsDlg$CancelListener extends CombineTypes<[_TabsDlg$CancelListener, java.awt.event.ActionListener, java.lang.Object]> {}
            interface _TabsDlg$OkListener$$static extends ClassLike {
            }
            let TabsDlg$OkListener: _TabsDlg$OkListener$$static;
            interface _TabsDlg$OkListener {
              actionPerformed(evt: java.awt.event.ActionEvent): void;
              _this$0: TabsDlg;
            }
            interface TabsDlg$OkListener extends CombineTypes<[_TabsDlg$OkListener, java.awt.event.ActionListener, java.lang.Object]> {}
            interface _ToggleActionPropertyChangeListener$$static extends ClassLike {
              new(button: javax.swing.AbstractButton): ToggleActionPropertyChangeListener;
            }
            let ToggleActionPropertyChangeListener: _ToggleActionPropertyChangeListener$$static;
            interface _ToggleActionPropertyChangeListener {
              propertyChange(evt: java.beans.PropertyChangeEvent): void;
              _button: javax.swing.AbstractButton;
            }
            interface ToggleActionPropertyChangeListener extends CombineTypes<[_ToggleActionPropertyChangeListener, java.beans.PropertyChangeListener, java.lang.Object]> {}
            interface _WizardDlg$$static extends ClassLike {
              main(args: string[]): void;
              _wizardDlg: WizardDlg;
              new(frame: javax.swing.JFrame, title: string, panels: java.util.Vector, images: java.util.Vector): WizardDlg;
              new(frame: javax.swing.JFrame, title: string, panels: java.util.Vector): WizardDlg;
              new(title: string, panels: java.util.Vector): WizardDlg;
            }
            let WizardDlg: _WizardDlg$$static;
            interface _WizardDlg {
              addBackListener(l: java.awt.event.ActionListener): void;
              addCancelListener(l: java.awt.event.ActionListener): void;
              addFinishListener(l: java.awt.event.ActionListener): void;
              addNextListener(l: java.awt.event.ActionListener): void;
              _createButtonPanel(): javax.swing.JPanel;
              _enableBackNextButtons(): void;
              removeBackListener(l: java.awt.event.ActionListener): void;
              removeCancelListener(l: java.awt.event.ActionListener): void;
              removeFinishListener(l: java.awt.event.ActionListener): void;
              removeNextListener(l: java.awt.event.ActionListener): void;
              reset(): void;
              setPanels(panels: java.util.Vector): void;
              _setTitle(): void;
              setWestPanel(panel: javax.swing.JPanel): void;
              _backAction: swing.action.DelegateAction;
              _backListener: java.awt.event.ActionListener;
              _cancelAction: swing.action.DelegateAction;
              _cancelListener: java.awt.event.ActionListener;
              _cardShowing: int;
              _finishAction: swing.action.DelegateAction;
              _finishListener: java.awt.event.ActionListener;
              _images: java.util.Vector;
              _nextAction: swing.action.DelegateAction;
              _nextListener: java.awt.event.ActionListener;
              _numCards: int;
              _panels: java.util.Vector;
              _panesLayout: java.awt.CardLayout;
              _panesPanel: javax.swing.JPanel;
              _title: string;
            }
            interface WizardDlg extends CombineTypes<[_WizardDlg, javax.swing.JDialog]> {}
            interface _WizardDlg$BackListener$$static extends ClassLike {
            }
            let WizardDlg$BackListener: _WizardDlg$BackListener$$static;
            interface _WizardDlg$BackListener {
              actionPerformed(evt: java.awt.event.ActionEvent): void;
              _this$0: WizardDlg;
            }
            interface WizardDlg$BackListener extends CombineTypes<[_WizardDlg$BackListener, java.awt.event.ActionListener, java.lang.Object]> {}
            interface _WizardDlg$CancelListener$$static extends ClassLike {
            }
            let WizardDlg$CancelListener: _WizardDlg$CancelListener$$static;
            interface _WizardDlg$CancelListener {
              actionPerformed(evt: java.awt.event.ActionEvent): void;
              _this$0: WizardDlg;
            }
            interface WizardDlg$CancelListener extends CombineTypes<[_WizardDlg$CancelListener, java.awt.event.ActionListener, java.lang.Object]> {}
            interface _WizardDlg$FinishListener$$static extends ClassLike {
            }
            let WizardDlg$FinishListener: _WizardDlg$FinishListener$$static;
            interface _WizardDlg$FinishListener {
              actionPerformed(evt: java.awt.event.ActionEvent): void;
              _this$0: WizardDlg;
            }
            interface WizardDlg$FinishListener extends CombineTypes<[_WizardDlg$FinishListener, java.awt.event.ActionListener, java.lang.Object]> {}
            interface _WizardDlg$NextListener$$static extends ClassLike {
            }
            let WizardDlg$NextListener: _WizardDlg$NextListener$$static;
            interface _WizardDlg$NextListener {
              actionPerformed(evt: java.awt.event.ActionEvent): void;
              _this$0: WizardDlg;
            }
            interface WizardDlg$NextListener extends CombineTypes<[_WizardDlg$NextListener, java.awt.event.ActionListener, java.lang.Object]> {}
          }
        }
      }
    }
  }
  module sun {
    module jvm {
      module hotspot {
        module asm {
          interface _Disassembler$$static extends ClassLike {
            decode(visitor: InstructionVisitor, blob: hotspot.code.CodeBlob): void;
            decode(visitor: InstructionVisitor, blob: hotspot.code.CodeBlob, begin: hotspot.debugger.Address, end: hotspot.debugger.Address): void;
            _load_library(a0: string): long;
            _decode_function: long;
            _options: string;
          }
          let Disassembler: _Disassembler$$static;
          interface _Disassembler {
            _decode(a0: InstructionVisitor, a1: long, a2: byte[], a3: string, a4: long): void;
            _decode(visitor: InstructionVisitor): void;
            _handleEvent(visitor: InstructionVisitor, event: string, arg: long): long;
            _match(event: string, tag: string): boolean;
            _rawPrint(visitor: InstructionVisitor, s: string): void;
            _blob: hotspot.code.CodeBlob;
            _code: byte[];
            _nmethod: hotspot.code.NMethod;
            _startPc: long;
          }
          interface Disassembler extends CombineTypes<[_Disassembler, java.lang.Object]> {}
          interface _DummySymbolFinder$$static extends ClassLike {
            new(): DummySymbolFinder;
          }
          let DummySymbolFinder: _DummySymbolFinder$$static;
          interface _DummySymbolFinder {
            getSymbolFor(address: long): string;
          }
          interface DummySymbolFinder extends CombineTypes<[_DummySymbolFinder, sun.jvm.hotspot.asm.SymbolFinder, java.lang.Object]> {}
          interface _ImmediateOrRegister$$static extends ClassLike {
            new(): ImmediateOrRegister;
          }
          let ImmediateOrRegister: _ImmediateOrRegister$$static;
          interface _ImmediateOrRegister {
          }
          interface ImmediateOrRegister extends CombineTypes<[_ImmediateOrRegister, sun.jvm.hotspot.asm.Operand]> {}
          interface _InstructionVisitor$$static extends ClassLike {
          }
          let InstructionVisitor: _InstructionVisitor$$static;
          interface _InstructionVisitor {
            beginInstruction(a0: long): void;
            endInstruction(a0: long): void;
            epilogue(): void;
            print(a0: string): void;
            printAddress(a0: long): void;
            prologue(): void;
          }
          interface InstructionVisitor extends CombineTypes<[_InstructionVisitor, java.lang.Object]> {}
          interface _Operand$$static extends ClassLike {
            new(): Operand;
          }
          let Operand: _Operand$$static;
          interface _Operand {
            isAddress(): boolean;
            isImmediate(): boolean;
            isRegister(): boolean;
          }
          interface Operand extends CombineTypes<[_Operand, java.lang.Object]> {}
          interface _Register$$static extends ClassLike {
            new(): Register;
            new(number: int): Register;
          }
          let Register: _Register$$static;
          interface _Register {
            equals(x: any): boolean;
            getNumber(): int;
            getNumberOfRegisters(): int;
            hashCode(): int;
            isFloat(): boolean;
            isFramePointer(): boolean;
            isRegister(): boolean;
            isStackPointer(): boolean;
            isValid(): boolean;
            _number: int;
          }
          interface Register extends CombineTypes<[_Register, sun.jvm.hotspot.asm.ImmediateOrRegister]> {}
          interface _SymbolFinder$$static extends ClassLike {
          }
          let SymbolFinder: _SymbolFinder$$static;
          interface _SymbolFinder {
            getSymbolFor(a0: long): string;
(a0: long): string;
          }
          interface SymbolFinder extends CombineTypes<[_SymbolFinder, java.lang.Object]> {}
        }
        module c1 {
          interface _Runtime1$$static extends ClassLike {
            _initialize(db: hotspot.types.TypeDataBase): void;
            _blobsField: hotspot.types.Field;
            new(): Runtime1;
          }
          let Runtime1: _Runtime1$$static;
          interface _Runtime1 {
            blobFor(id: int): hotspot.code.CodeBlob;
            entryFor(id: int): hotspot.debugger.Address;
          }
          interface Runtime1 extends CombineTypes<[_Runtime1, java.lang.Object]> {}
        }
        module ci {
          interface _ciArrayKlass$$static extends ClassLike {
            _initialize(db: hotspot.types.TypeDataBase): void;
            _dimensionField: hotspot.oops.IntField;
            new(addr: hotspot.debugger.Address): ciArrayKlass;
          }
          let ciArrayKlass: _ciArrayKlass$$static;
          interface _ciArrayKlass {
          }
          interface ciArrayKlass extends CombineTypes<[_ciArrayKlass, sun.jvm.hotspot.ci.ciKlass]> {}
          interface _ciBaseObject$$static extends ClassLike {
            _initialize(db: hotspot.types.TypeDataBase): void;
            _identField: hotspot.oops.CIntField;
            new(addr: hotspot.debugger.Address): ciBaseObject;
          }
          let ciBaseObject: _ciBaseObject$$static;
          interface _ciBaseObject {
            dumpReplayData(out: java.io.PrintStream): void;
          }
          interface ciBaseObject extends CombineTypes<[_ciBaseObject, sun.jvm.hotspot.runtime.VMObject]> {}
          interface _ciConstant$$static extends ClassLike {
            _initialize(db: hotspot.types.TypeDataBase): void;
            _typeField: hotspot.oops.CIntField;
            _valueDoubleField: hotspot.types.JDoubleField;
            _valueFloatField: hotspot.types.JFloatField;
            _valueIntField: hotspot.types.JIntField;
            _valueLongField: hotspot.types.JLongField;
            _valueObjectField: hotspot.types.AddressField;
            new(addr: hotspot.debugger.Address): ciConstant;
          }
          let ciConstant: _ciConstant$$static;
          interface _ciConstant {
            dumpReplayData(out: java.io.PrintStream): void;
          }
          interface ciConstant extends CombineTypes<[_ciConstant, sun.jvm.hotspot.runtime.VMObject]> {}
          interface _ciEnv$$static extends ClassLike {
            _initialize(db: hotspot.types.TypeDataBase): void;
            _compilerDataField: hotspot.types.AddressField;
            _dependenciesField: hotspot.types.AddressField;
            _factoryField: hotspot.types.AddressField;
            _taskField: hotspot.types.AddressField;
            new(addr: hotspot.debugger.Address): ciEnv;
          }
          let ciEnv: _ciEnv$$static;
          interface _ciEnv {
            compilerData(): hotspot.opto.Compile;
            dumpReplayData(out: java.io.PrintStream): void;
            factory(): ciObjectFactory;
            task(): hotspot.compiler.CompileTask;
          }
          interface ciEnv extends CombineTypes<[_ciEnv, sun.jvm.hotspot.runtime.VMObject]> {}
          interface _ciField$$static extends ClassLike {
            _initialize(db: hotspot.types.TypeDataBase): void;
            _constantValueField: hotspot.types.AddressField;
            _holderField: hotspot.types.AddressField;
            _isConstantField: hotspot.types.AddressField;
            _nameField: hotspot.types.AddressField;
            _offsetField: hotspot.oops.CIntField;
            _signatureField: hotspot.types.AddressField;
            new(addr: hotspot.debugger.Address): ciField;
          }
          let ciField: _ciField$$static;
          interface _ciField {
          }
          interface ciField extends CombineTypes<[_ciField, sun.jvm.hotspot.runtime.VMObject]> {}
          interface _ciInstance$$static extends ClassLike {
            _initialize(db: hotspot.types.TypeDataBase): void;
            new(addr: hotspot.debugger.Address): ciInstance;
          }
          let ciInstance: _ciInstance$$static;
          interface _ciInstance {
          }
          interface ciInstance extends CombineTypes<[_ciInstance, sun.jvm.hotspot.ci.ciObject]> {}
          interface _ciInstanceKlass$$static extends ClassLike {
            _initialize(db: hotspot.types.TypeDataBase): void;
            _CLASS_STATE_FULLY_INITIALIZED: int;
            _CLASS_STATE_LINKED: int;
            _initStateField: hotspot.oops.CIntField;
            _isSharedField: hotspot.oops.CIntField;
            new(addr: hotspot.debugger.Address): ciInstanceKlass;
          }
          let ciInstanceKlass: _ciInstanceKlass$$static;
          interface _ciInstanceKlass {
            dumpReplayData(out: java.io.PrintStream): void;
            initState(): int;
            isInitialized(): boolean;
            isLinked(): boolean;
            isShared(): boolean;
          }
          interface ciInstanceKlass extends CombineTypes<[_ciInstanceKlass, sun.jvm.hotspot.ci.ciKlass]> {}
          interface _ciKlass$$static extends ClassLike {
            _initialize(db: hotspot.types.TypeDataBase): void;
            _nameField: hotspot.types.AddressField;
            new(addr: hotspot.debugger.Address): ciKlass;
          }
          let ciKlass: _ciKlass$$static;
          interface _ciKlass {
            name(): string;
            printValueOn(tty: java.io.PrintStream): void;
          }
          interface ciKlass extends CombineTypes<[_ciKlass, sun.jvm.hotspot.ci.ciType]> {}
          interface _ciMetadata$$static extends ClassLike {
            _initialize(db: hotspot.types.TypeDataBase): void;
            _metadataField: hotspot.oops.MetadataField;
            new(addr: hotspot.debugger.Address): ciMetadata;
          }
          let ciMetadata: _ciMetadata$$static;
          interface _ciMetadata {
            getMetadata(): hotspot.oops.Metadata;
            printOn(out: java.io.PrintStream): void;
            toString(): string;
          }
          interface ciMetadata extends CombineTypes<[_ciMetadata, sun.jvm.hotspot.ci.ciBaseObject]> {}
          interface _ciMethod$$static extends ClassLike {
            _initialize(db: hotspot.types.TypeDataBase): void;
            _instructionsSizeField: hotspot.oops.CIntField;
            _interpreterInvocationCountField: hotspot.oops.CIntField;
            _interpreterThrowoutCountField: hotspot.oops.CIntField;
            new(addr: hotspot.debugger.Address): ciMethod;
          }
          let ciMethod: _ciMethod$$static;
          interface _ciMethod {
            dumpReplayData(out: java.io.PrintStream): void;
            instructionsSize(): int;
            interpreterInvocationCount(): int;
            interpreterThrowoutCount(): int;
            method(): hotspot.oops.Method;
            nameAsAscii(): string;
            printShortName(st: java.io.PrintStream): void;
            printValueOn(tty: java.io.PrintStream): void;
          }
          interface ciMethod extends CombineTypes<[_ciMethod, sun.jvm.hotspot.ci.ciMetadata]> {}
          interface _ciMethodData$$static extends ClassLike {
            _initialize(db: hotspot.types.TypeDataBase): void;
            _argLocalField: hotspot.oops.CIntField;
            _argReturnedField: hotspot.oops.CIntField;
            _argStackField: hotspot.oops.CIntField;
            _dataField: hotspot.types.AddressField;
            _dataSizeField: hotspot.oops.CIntField;
            _eflagsField: hotspot.oops.CIntField;
            _extraDataSizeField: hotspot.oops.CIntField;
            _hintDiField: hotspot.oops.CIntField;
            _origField: hotspot.types.Field;
            _parametersTypeDataDi: hotspot.oops.CIntField;
            _sizeofMethodDataOopDesc: int;
            _stateField: hotspot.oops.CIntField;
            new(addr: hotspot.debugger.Address): ciMethodData;
          }
          let ciMethodData: _ciMethodData$$static;
          interface _ciMethodData {
            _currentMileage(): int;
            data(): long[];
            _dataAt(dataIndex: int): hotspot.oops.ProfileData;
            _dataSize(): int;
            _dpToDi(dp: int): int;
            dumpReplayData(out: java.io.PrintStream): void;
            _dumpReplayDataCallTypeHelper(out: java.io.PrintStream, round: int, count: int, callTypeData: hotspot.oops.CallTypeDataInterface<ciKlass>): int;
            _dumpReplayDataExtraDataHelper(out: java.io.PrintStream, round: int, count: int): int;
            _dumpReplayDataReceiverTypeHelper(out: java.io.PrintStream, round: int, count: int, vdata: hotspot.oops.ReceiverTypeData<ciKlass,ciMethod>): int;
            _dumpReplayDataTypeHelper(out: java.io.PrintStream, round: int, count: int, index: int, pdata: hotspot.oops.ProfileData, k: ciKlass): int;
            _extraDataBase(): hotspot.oops.DataLayout;
            _extraDataLimit(): hotspot.oops.DataLayout;
            _extraDataSize(): int;
            _fetchDataAt(base: hotspot.debugger.Address, size: long): byte[];
            _firstData(): hotspot.oops.ProfileData;
            _firstDi(): int;
            getKlassAtAddress(addr: hotspot.debugger.Address): ciKlass;
            getKlassAtAddress(a0: hotspot.debugger.Address): any;
            getMethodAtAddress(addr: hotspot.debugger.Address): ciMethod;
            getMethodAtAddress(a0: hotspot.debugger.Address): any;
            _isValid(current: hotspot.oops.ProfileData): boolean;
            _limitDataPosition(): hotspot.oops.DataLayout;
            _nextData(current: hotspot.oops.ProfileData): hotspot.oops.ProfileData;
            _nextExtra(dataLayout: hotspot.oops.DataLayout): hotspot.oops.DataLayout;
            orig(): byte[];
            _outOfBounds(dataIndex: int): boolean;
            _parametersTypeData(): hotspot.oops.ParametersTypeData<ciKlass,ciMethod>;
            printDataOn(st: java.io.PrintStream): void;
            printKlassValueOn(klass: ciKlass, st: java.io.PrintStream): void;
            printKlassValueOn(a0: any, a1: java.io.PrintStream): void;
            printMethodValueOn(method: ciMethod, st: java.io.PrintStream): void;
            printMethodValueOn(a0: any, a1: java.io.PrintStream): void;
            _state(): int;
          }
          interface ciMethodData extends CombineTypes<[_ciMethodData, ciMetadata, hotspot.oops.MethodDataInterface<ciKlass,ciMethod>]> {}
          interface _ciObjArrayKlass$$static extends ClassLike {
            _initialize(db: hotspot.types.TypeDataBase): void;
            _baseElementKlassField: hotspot.types.AddressField;
            _elementKlassField: hotspot.types.AddressField;
            new(addr: hotspot.debugger.Address): ciObjArrayKlass;
          }
          let ciObjArrayKlass: _ciObjArrayKlass$$static;
          interface _ciObjArrayKlass {
          }
          interface ciObjArrayKlass extends CombineTypes<[_ciObjArrayKlass, sun.jvm.hotspot.ci.ciArrayKlass]> {}
          interface _ciObject$$static extends ClassLike {
            _initialize(db: hotspot.types.TypeDataBase): void;
            _handleField: hotspot.types.AddressField;
            _klassField: hotspot.types.AddressField;
            new(addr: hotspot.debugger.Address): ciObject;
          }
          let ciObject: _ciObject$$static;
          interface _ciObject {
            getOop(): hotspot.oops.Oop;
            printOn(out: java.io.PrintStream): void;
            toString(): string;
          }
          interface ciObject extends CombineTypes<[_ciObject, sun.jvm.hotspot.ci.ciBaseObject]> {}
          interface _ciObjectFactory$$static extends ClassLike {
            get(addr: hotspot.debugger.Address): ciObject;
            getMetadata(addr: hotspot.debugger.Address): ciMetadata;
            _initialize(db: hotspot.types.TypeDataBase): void;
            _ciMetadataConstructor: hotspot.runtime.VirtualBaseConstructor<ciMetadata>;
            _ciMetadataField: hotspot.types.AddressField;
            _ciObjectConstructor: hotspot.runtime.VirtualBaseConstructor<ciObject>;
            _ciSymbolConstructor: hotspot.runtime.VirtualBaseConstructor<ciSymbol>;
            _symbolsField: hotspot.types.AddressField;
            new(addr: hotspot.debugger.Address): ciObjectFactory;
          }
          let ciObjectFactory: _ciObjectFactory$$static;
          interface _ciObjectFactory {
            objects(): hotspot.utilities.GrowableArray<ciMetadata>;
            symbols(): hotspot.utilities.GrowableArray<ciSymbol>;
          }
          interface ciObjectFactory extends CombineTypes<[_ciObjectFactory, sun.jvm.hotspot.runtime.VMObject]> {}
          interface _ciSymbol$$static extends ClassLike {
            _initialize(db: hotspot.types.TypeDataBase): void;
            _symbolField: hotspot.types.AddressField;
            new(addr: hotspot.debugger.Address): ciSymbol;
          }
          let ciSymbol: _ciSymbol$$static;
          interface _ciSymbol {
            asUtf88(): string;
          }
          interface ciSymbol extends CombineTypes<[_ciSymbol, sun.jvm.hotspot.ci.ciMetadata]> {}
          interface _ciType$$static extends ClassLike {
            _initialize(db: hotspot.types.TypeDataBase): void;
            _basicTypeField: hotspot.oops.CIntField;
            new(addr: hotspot.debugger.Address): ciType;
          }
          let ciType: _ciType$$static;
          interface _ciType {
          }
          interface ciType extends CombineTypes<[_ciType, sun.jvm.hotspot.ci.ciMetadata]> {}
          interface _ciTypeArrayKlass$$static extends ClassLike {
            _initialize(db: hotspot.types.TypeDataBase): void;
            new(addr: hotspot.debugger.Address): ciTypeArrayKlass;
          }
          let ciTypeArrayKlass: _ciTypeArrayKlass$$static;
          interface _ciTypeArrayKlass {
          }
          interface ciTypeArrayKlass extends CombineTypes<[_ciTypeArrayKlass, sun.jvm.hotspot.ci.ciArrayKlass]> {}
        }
        module classfile {
          interface _ClassLoaderData$$static extends ClassLike {
            _initialize(db: hotspot.types.TypeDataBase): void;
            instantiateWrapperFor(addr: hotspot.debugger.Address): ClassLoaderData;
            _classLoaderFieldOffset: long;
            _hasClassMirrorHolderField: hotspot.oops.CIntField;
            _klassesField: hotspot.oops.MetadataField;
            _nextField: hotspot.types.AddressField;
            new(addr: hotspot.debugger.Address): ClassLoaderData;
          }
          let ClassLoaderData: _ClassLoaderData$$static;
          interface _ClassLoaderData {
            classesDo(v: ClassLoaderDataGraph$ClassVisitor): void;
            find(className: string): hotspot.oops.Klass;
            getClassLoader(): hotspot.oops.Oop;
            getKlasses(): hotspot.oops.Klass;
            gethasClassMirrorHolder(): boolean;
            next(): ClassLoaderData;
          }
          interface ClassLoaderData extends CombineTypes<[_ClassLoaderData, sun.jvm.hotspot.runtime.VMObject]> {}
          interface _ClassLoaderDataGraph$$static extends ClassLike {
            _initialize(db: hotspot.types.TypeDataBase): void;
            _headField: hotspot.types.AddressField;
            new(): ClassLoaderDataGraph;
          }
          let ClassLoaderDataGraph: _ClassLoaderDataGraph$$static;
          interface _ClassLoaderDataGraph {
            classesDo(v: ClassLoaderDataGraph$ClassVisitor): void;
            find(className: string): hotspot.oops.Klass;
            getClassLoaderGraphHead(): ClassLoaderData;
          }
          interface ClassLoaderDataGraph extends CombineTypes<[_ClassLoaderDataGraph, java.lang.Object]> {}
          interface _ClassLoaderDataGraph$ClassAndLoaderVisitor$$static extends ClassLike {
          }
          let ClassLoaderDataGraph$ClassAndLoaderVisitor: _ClassLoaderDataGraph$ClassAndLoaderVisitor$$static;
          interface _ClassLoaderDataGraph$ClassAndLoaderVisitor {
            visit(a0: hotspot.oops.Klass, a1: hotspot.oops.Oop): void;
(a0: hotspot.oops.Klass, a1: hotspot.oops.Oop): void;
          }
          interface ClassLoaderDataGraph$ClassAndLoaderVisitor extends CombineTypes<[_ClassLoaderDataGraph$ClassAndLoaderVisitor, java.lang.Object]> {}
          interface _ClassLoaderDataGraph$ClassVisitor$$static extends ClassLike {
          }
          let ClassLoaderDataGraph$ClassVisitor: _ClassLoaderDataGraph$ClassVisitor$$static;
          interface _ClassLoaderDataGraph$ClassVisitor {
            visit(a0: hotspot.oops.Klass): void;
(a0: hotspot.oops.Klass): void;
          }
          interface ClassLoaderDataGraph$ClassVisitor extends CombineTypes<[_ClassLoaderDataGraph$ClassVisitor, java.lang.Object]> {}
        }
        module code {
          interface _AdapterBlob$$static extends ClassLike {
            _initialize(db: hotspot.types.TypeDataBase): void;
            new(addr: hotspot.debugger.Address): AdapterBlob;
          }
          let AdapterBlob: _AdapterBlob$$static;
          interface _AdapterBlob {
            getName(): string;
            isAdapterBlob(): boolean;
          }
          interface AdapterBlob extends CombineTypes<[_AdapterBlob, sun.jvm.hotspot.code.RuntimeBlob]> {}
          interface _BufferBlob$$static extends ClassLike {
            _initialize(db: hotspot.types.TypeDataBase): void;
            new(addr: hotspot.debugger.Address): BufferBlob;
          }
          let BufferBlob: _BufferBlob$$static;
          interface _BufferBlob {
            isBufferBlob(): boolean;
          }
          interface BufferBlob extends CombineTypes<[_BufferBlob, sun.jvm.hotspot.code.RuntimeBlob]> {}
          interface _CodeBlob$$static extends ClassLike {
            _initialize(db: hotspot.types.TypeDataBase): void;
            _codeBeginField: hotspot.types.AddressField;
            _codeEndField: hotspot.types.AddressField;
            _contentBeginField: hotspot.types.AddressField;
            _dataEndField: hotspot.types.AddressField;
            _dataOffsetField: hotspot.types.CIntegerField;
            _frameCompleteOffsetField: hotspot.types.CIntegerField;
            _frameSizeField: hotspot.types.CIntegerField;
            _headerSizeField: hotspot.types.CIntegerField;
            _matcherInterpreterFramePointerReg: int;
            _nameField: hotspot.types.AddressField;
            _oopMapsField: hotspot.types.AddressField;
            _sizeField: hotspot.types.CIntegerField;
            new(addr: hotspot.debugger.Address): CodeBlob;
          }
          let CodeBlob: _CodeBlob$$static;
          interface _CodeBlob {
            asNMethodOrNull(): NMethod;
            blobContains(addr: hotspot.debugger.Address): boolean;
            callerMustGCArguments(): boolean;
            codeBegin(): hotspot.debugger.Address;
            codeContains(addr: hotspot.debugger.Address): boolean;
            codeEnd(): hotspot.debugger.Address;
            contains(addr: hotspot.debugger.Address): boolean;
            contentBegin(): hotspot.debugger.Address;
            contentContains(addr: hotspot.debugger.Address): boolean;
            contentEnd(): hotspot.debugger.Address;
            dataBegin(): hotspot.debugger.Address;
            dataContains(addr: hotspot.debugger.Address): boolean;
            dataEnd(): hotspot.debugger.Address;
            getCodeSize(): int;
            getContentSize(): int;
            getDataOffset(): int;
            getDataSize(): int;
            getFrameCompleteOffset(): long;
            getFrameSize(): long;
            getFrameSizeWords(): long;
            getHeaderSize(): int;
            getName(): string;
            getOopMapForReturnAddress(returnAddress: hotspot.debugger.Address, debugging: boolean): hotspot.compiler.ImmutableOopMap;
            getOopMaps(): hotspot.compiler.ImmutableOopMapSet;
            getSize(): int;
            headerBegin(): hotspot.debugger.Address;
            headerEnd(): hotspot.debugger.Address;
            isAdapterBlob(): boolean;
            isBufferBlob(): boolean;
            isCompiled(): boolean;
            isDeoptimizationStub(): boolean;
            isExceptionStub(): boolean;
            isFrameCompleteAt(a: hotspot.debugger.Address): boolean;
            isJavaMethod(): boolean;
            isNMethod(): boolean;
            isNativeMethod(): boolean;
            isOSRMethod(): boolean;
            isRuntimeStub(): boolean;
            isSafepointStub(): boolean;
            isUncommonTrapStub(): boolean;
            print(): void;
            _printComponentsOn(tty: java.io.PrintStream): void;
            printOn(tty: java.io.PrintStream): void;
          }
          interface CodeBlob extends CombineTypes<[_CodeBlob, sun.jvm.hotspot.runtime.VMObject]> {}
          interface _CodeCache$$static extends ClassLike {
            _initialize(db: hotspot.types.TypeDataBase): void;
            _heapArray: hotspot.utilities.GrowableArray<hotspot.memory.CodeHeap>;
            _virtualConstructor: hotspot.runtime.VirtualConstructor;
            new(): CodeCache;
          }
          let CodeCache: _CodeCache$$static;
          interface _CodeCache {
            contains(p: hotspot.debugger.Address): boolean;
            createCodeBlobWrapper(codeBlobAddr: hotspot.debugger.Address): CodeBlob;
            findBlob(start: hotspot.debugger.Address): CodeBlob;
            findBlobUnsafe(start: hotspot.debugger.Address): CodeBlob;
            findNMethod(start: hotspot.debugger.Address): NMethod;
            findNMethodUnsafe(start: hotspot.debugger.Address): NMethod;
            _highBound(): hotspot.debugger.Address;
            iterate(visitor: CodeCacheVisitor): void;
            _lowBound(): hotspot.debugger.Address;
          }
          interface CodeCache extends CombineTypes<[_CodeCache, java.lang.Object]> {}
          interface _CodeCacheVisitor$$static extends ClassLike {
          }
          let CodeCacheVisitor: _CodeCacheVisitor$$static;
          interface _CodeCacheVisitor {
            epilogue(): void;
            prologue(a0: hotspot.debugger.Address, a1: hotspot.debugger.Address): void;
            visit(a0: CodeBlob): void;
          }
          interface CodeCacheVisitor extends CombineTypes<[_CodeCacheVisitor, java.lang.Object]> {}
          interface _CompiledMethod$$static extends ClassLike {
            getMethodOffset(): int;
            _initialize(db: hotspot.types.TypeDataBase): void;
            _deoptHandlerBeginField: hotspot.types.AddressField;
            _deoptMhHandlerBeginField: hotspot.types.AddressField;
            _methodField: hotspot.types.AddressField;
            _scopesDataBeginField: hotspot.types.AddressField;
            new(addr: hotspot.debugger.Address): CompiledMethod;
          }
          let CompiledMethod: _CompiledMethod$$static;
          interface _CompiledMethod {
            deoptHandlerBegin(): hotspot.debugger.Address;
            deoptMhHandlerBegin(): hotspot.debugger.Address;
            getMethod(): hotspot.oops.Method;
            isCompiled(): boolean;
            scopesDataBegin(): hotspot.debugger.Address;
          }
          interface CompiledMethod extends CombineTypes<[_CompiledMethod, sun.jvm.hotspot.code.CodeBlob]> {}
          interface _CompressedReadStream$$static extends ClassLike {
            new(buffer: hotspot.debugger.Address): CompressedReadStream;
            new(buffer: hotspot.debugger.Address, position: int): CompressedReadStream;
          }
          let CompressedReadStream: _CompressedReadStream$$static;
          interface _CompressedReadStream {
            dump(): void;
            dump(sizeLimit: int): void;
            dumpOn(tty: java.io.PrintStream, sizeLimit: int): void;
            _read(index: int): short;
            _read(): short;
            readBoolean(): boolean;
            readByte(): byte;
            readChar(): char;
            readDouble(): double;
            readFloat(): float;
            readInt(): int;
            readLong(): long;
            readShort(): short;
            readSignedInt(): int;
          }
          interface CompressedReadStream extends CombineTypes<[_CompressedReadStream, sun.jvm.hotspot.code.CompressedStream]> {}
          interface _CompressedStream$$static extends ClassLike {
            readonly BitsPerByte: int;
            readonly LogBitsPerByte: int;
            new(buffer: hotspot.debugger.Address): CompressedStream;
            new(buffer: hotspot.debugger.Address, position: int): CompressedStream;
          }
          let CompressedStream: _CompressedStream$$static;
          interface _CompressedStream {
            decodeSign(value: int): int;
            encodeSign(value: int): int;
            getBuffer(): hotspot.debugger.Address;
            getPosition(): int;
            reverseInt(i: int): int;
            setPosition(position: int): void;
            _buffer: hotspot.debugger.Address;
            _position: int;
          }
          interface CompressedStream extends CombineTypes<[_CompressedStream, java.lang.Object]> {}
          interface _CompressedWriteStream$$static extends ClassLike {
            new(buffer: hotspot.debugger.Address): CompressedWriteStream;
            new(buffer: hotspot.debugger.Address, position: int): CompressedWriteStream;
          }
          let CompressedWriteStream: _CompressedWriteStream$$static;
          interface _CompressedWriteStream {
          }
          interface CompressedWriteStream extends CombineTypes<[_CompressedWriteStream, sun.jvm.hotspot.code.CompressedStream]> {}
          interface _ConstantDoubleValue$$static extends ClassLike {
            new(value: double): ConstantDoubleValue;
            _new(stream: DebugInfoReadStream): ConstantDoubleValue;
          }
          let ConstantDoubleValue: _ConstantDoubleValue$$static;
          interface _ConstantDoubleValue {
            getValue(): double;
            isConstantDouble(): boolean;
            print(): void;
            printOn(tty: java.io.PrintStream): void;
            _value: double;
          }
          interface ConstantDoubleValue extends CombineTypes<[_ConstantDoubleValue, sun.jvm.hotspot.code.ScopeValue]> {}
          interface _ConstantIntValue$$static extends ClassLike {
            new(value: int): ConstantIntValue;
            _new(stream: DebugInfoReadStream): ConstantIntValue;
          }
          let ConstantIntValue: _ConstantIntValue$$static;
          interface _ConstantIntValue {
            getValue(): int;
            isConstantInt(): boolean;
            print(): void;
            printOn(tty: java.io.PrintStream): void;
            _value: int;
          }
          interface ConstantIntValue extends CombineTypes<[_ConstantIntValue, sun.jvm.hotspot.code.ScopeValue]> {}
          interface _ConstantLongValue$$static extends ClassLike {
            new(value: long): ConstantLongValue;
            _new(stream: DebugInfoReadStream): ConstantLongValue;
          }
          let ConstantLongValue: _ConstantLongValue$$static;
          interface _ConstantLongValue {
            getValue(): long;
            isConstantLong(): boolean;
            print(): void;
            printOn(tty: java.io.PrintStream): void;
            _value: long;
          }
          interface ConstantLongValue extends CombineTypes<[_ConstantLongValue, sun.jvm.hotspot.code.ScopeValue]> {}
          interface _ConstantOopReadValue$$static extends ClassLike {
            new(stream: DebugInfoReadStream): ConstantOopReadValue;
          }
          let ConstantOopReadValue: _ConstantOopReadValue$$static;
          interface _ConstantOopReadValue {
            getValue(): hotspot.debugger.OopHandle;
            isConstantOop(): boolean;
            print(): void;
            printOn(tty: java.io.PrintStream): void;
            _value: hotspot.debugger.OopHandle;
          }
          interface ConstantOopReadValue extends CombineTypes<[_ConstantOopReadValue, sun.jvm.hotspot.code.ScopeValue]> {}
          interface _DebugInfoReadStream$$static extends ClassLike {
            new(code: NMethod, offset: int): DebugInfoReadStream;
            new(code: NMethod, offset: int, objectPool: java.util.List<ObjectValue>): DebugInfoReadStream;
          }
          let DebugInfoReadStream: _DebugInfoReadStream$$static;
          interface _DebugInfoReadStream {
            _getCachedObject(): ScopeValue;
            readBCI(): int;
            readMethod(): hotspot.oops.Method;
            _readObjectValue(): ScopeValue;
            readOopHandle(): hotspot.debugger.OopHandle;
            _InvocationEntryBCI: int;
            _code: NMethod;
            _objectPool: java.util.List<ObjectValue>;
          }
          interface DebugInfoReadStream extends CombineTypes<[_DebugInfoReadStream, sun.jvm.hotspot.code.CompressedReadStream]> {}
          interface _DebugInformationRecorder$$static extends ClassLike {
            readonly SERIALIZED_NULL: int;
            readonly SYNCHRONIZATION_ENTRY_BCI: int;
            new(): DebugInformationRecorder;
          }
          let DebugInformationRecorder: _DebugInformationRecorder$$static;
          interface _DebugInformationRecorder {
          }
          interface DebugInformationRecorder extends CombineTypes<[_DebugInformationRecorder, java.lang.Object]> {}
          interface _DeoptimizationBlob$$static extends ClassLike {
            _initialize(db: hotspot.types.TypeDataBase): void;
            new(addr: hotspot.debugger.Address): DeoptimizationBlob;
          }
          let DeoptimizationBlob: _DeoptimizationBlob$$static;
          interface _DeoptimizationBlob {
            isDeoptimizationStub(): boolean;
          }
          interface DeoptimizationBlob extends CombineTypes<[_DeoptimizationBlob, sun.jvm.hotspot.code.SingletonBlob]> {}
          interface _ExceptionBlob$$static extends ClassLike {
            _initialize(db: hotspot.types.TypeDataBase): void;
            new(addr: hotspot.debugger.Address): ExceptionBlob;
          }
          let ExceptionBlob: _ExceptionBlob$$static;
          interface _ExceptionBlob {
            isExceptionStub(): boolean;
          }
          interface ExceptionBlob extends CombineTypes<[_ExceptionBlob, sun.jvm.hotspot.code.SingletonBlob]> {}
          interface _Location$$static extends ClassLike {
            _initialize(db: hotspot.types.TypeDataBase): void;
            _OFFSET_MASK: int;
            _OFFSET_SHIFT: int;
            _TYPE_ADDR: int;
            _TYPE_DBL: int;
            _TYPE_FLOAT_IN_DBL: int;
            _TYPE_INT_IN_LONG: int;
            _TYPE_INVALID: int;
            _TYPE_LNG: int;
            _TYPE_MASK: int;
            _TYPE_NARROWOOP: int;
            _TYPE_NORMAL: int;
            _TYPE_OOP: int;
            _TYPE_SHIFT: int;
            _WHERE_IN_REGISTER: int;
            _WHERE_MASK: int;
            _WHERE_ON_STACK: int;
            _WHERE_SHIFT: int;
            _new(where: Location$Where, type: Location$Type, offset: int): Location;
            new(stream: DebugInfoReadStream): Location;
          }
          let Location: _Location$$static;
          interface _Location {
            getOffset(): short;
            getRegisterNumber(): int;
            getStackOffset(): int;
            getType(): Location$Type;
            getWhere(): Location$Where;
            holdsAddr(): boolean;
            holdsDouble(): boolean;
            holdsFloat(): boolean;
            holdsInt(): boolean;
            holdsLong(): boolean;
            holdsNarrowOop(): boolean;
            holdsOop(): boolean;
            isIllegal(): boolean;
            isRegister(): boolean;
            isStack(): boolean;
            print(): void;
            printOn(tty: java.io.PrintStream): void;
            _setOffset(offset: int): void;
            _setType(type: Location$Type): void;
            _setWhere(where: Location$Where): void;
            _value: int;
          }
          interface Location extends CombineTypes<[_Location, java.lang.Object]> {}
          interface _Location$Type$$static extends ClassLike {
            readonly ADDR: Location$Type;
            readonly DBL: Location$Type;
            readonly FLOAT_IN_DBL: Location$Type;
            readonly INT_IN_LONG: Location$Type;
            readonly INVALID: Location$Type;
            readonly LNG: Location$Type;
            readonly NARROWOOP: Location$Type;
            readonly NORMAL: Location$Type;
            readonly OOP: Location$Type;
          }
          let Location$Type: _Location$Type$$static;
          interface _Location$Type {
            getValue(): int;
            toString(): string;
            _value: string;
          }
          interface Location$Type extends CombineTypes<[_Location$Type, java.lang.Object]> {}
          interface _Location$Where$$static extends ClassLike {
            readonly IN_REGISTER: Location$Where;
            readonly ON_STACK: Location$Where;
          }
          let Location$Where: _Location$Where$$static;
          interface _Location$Where {
            getValue(): int;
            toString(): string;
            _value: string;
          }
          interface Location$Where extends CombineTypes<[_Location$Where, java.lang.Object]> {}
          interface _LocationValue$$static extends ClassLike {
            new(location: Location): LocationValue;
            _new(stream: DebugInfoReadStream): LocationValue;
          }
          let LocationValue: _LocationValue$$static;
          interface _LocationValue {
            getLocation(): Location;
            isLocation(): boolean;
            print(): void;
            printOn(tty: java.io.PrintStream): void;
            _location: Location;
          }
          interface LocationValue extends CombineTypes<[_LocationValue, sun.jvm.hotspot.code.ScopeValue]> {}
          interface _MethodHandlesAdapterBlob$$static extends ClassLike {
            _initialize(db: hotspot.types.TypeDataBase): void;
            new(addr: hotspot.debugger.Address): MethodHandlesAdapterBlob;
          }
          let MethodHandlesAdapterBlob: _MethodHandlesAdapterBlob$$static;
          interface _MethodHandlesAdapterBlob {
            getName(): string;
            isMethodHandlesAdapterBlob(): boolean;
          }
          interface MethodHandlesAdapterBlob extends CombineTypes<[_MethodHandlesAdapterBlob, sun.jvm.hotspot.code.AdapterBlob]> {}
          interface _MonitorValue$$static extends ClassLike {
            new(stream: DebugInfoReadStream): MonitorValue;
          }
          let MonitorValue: _MonitorValue$$static;
          interface _MonitorValue {
            basicLock(): Location;
            eliminated(): boolean;
            owner(): ScopeValue;
            printOn(tty: java.io.PrintStream): void;
            _basicLock: Location;
            _eliminated: boolean;
            _owner: ScopeValue;
          }
          interface MonitorValue extends CombineTypes<[_MonitorValue, java.lang.Object]> {}
          interface _NMethod$$static extends ClassLike {
            getEntryBCIOffset(): int;
            getEntryPointOffset(): int;
            getOSREntryPointOffset(): int;
            getVerifiedEntryPointOffset(): int;
            _initialize(db: hotspot.types.TypeDataBase): void;
            _match_desc(pc: PCDesc, pc_offset: int, approximate: boolean): boolean;
            _compLevelField: hotspot.types.CIntegerField;
            _dependenciesOffsetField: hotspot.types.CIntegerField;
            _entryBCIField: hotspot.types.CIntegerField;
            _entryPointField: hotspot.types.AddressField;
            _exceptionOffsetField: hotspot.types.CIntegerField;
            _handlerTableOffsetField: hotspot.types.CIntegerField;
            _metadataOffsetField: hotspot.types.CIntegerField;
            _nmethodEndOffsetField: hotspot.types.CIntegerField;
            _nulChkTableOffsetField: hotspot.types.CIntegerField;
            _oopsOffsetField: hotspot.types.CIntegerField;
            _origPCOffsetField: hotspot.types.CIntegerField;
            _osrEntryPointField: hotspot.types.AddressField;
            _osrLinkField: hotspot.types.AddressField;
            _pcDescSize: long;
            _scopesPCsOffsetField: hotspot.types.CIntegerField;
            _stubOffsetField: hotspot.types.CIntegerField;
            _verifiedEntryPointField: hotspot.types.AddressField;
            new(addr: hotspot.debugger.Address): NMethod;
          }
          let NMethod: _NMethod$$static;
          interface _NMethod {
            canBeDeoptimized(): boolean;
            constantsBegin(): hotspot.debugger.Address;
            constantsContains(addr: hotspot.debugger.Address): boolean;
            constantsEnd(): hotspot.debugger.Address;
            constantsSize(): int;
            dependenciesBegin(): hotspot.debugger.Address;
            dependenciesEnd(): hotspot.debugger.Address;
            dependenciesSize(): int;
            dumpReplayData(out: java.io.PrintStream): void;
            exceptionBegin(): hotspot.debugger.Address;
            _find_pc_desc(pc: long, a1: boolean): PCDesc;
            _find_pc_desc_internal(pc: long, a1: boolean): PCDesc;
            flagsToString(): string;
            getAddress(): hotspot.debugger.Address;
            _getCompLevel(): int;
            _getDependenciesOffset(): int;
            _getEntryBCI(): int;
            getEntryPoint(): hotspot.debugger.Address;
            _getExceptionOffset(): int;
            _getHandlerTableOffset(): int;
            getMetadataAt(index: int): hotspot.debugger.Address;
            getMetadataLength(): int;
            _getMetadataOffset(): int;
            getMethodAt(index: int): hotspot.oops.Method;
            _getNMethodEndOffset(): int;
            getName(): string;
            _getNulChkTableOffset(): int;
            getOSREntryBCI(): int;
            getOSRLink(): NMethod;
            getOopAt(index: int): hotspot.debugger.OopHandle;
            getOopsLength(): int;
            _getOopsOffset(): int;
            getPCDescAt(pc: hotspot.debugger.Address): PCDesc;
            getPCDescNearDbg(pc: hotspot.debugger.Address): PCDesc;
            getSafepoints(): java.util.Map<hotspot.debugger.Address,PCDesc>;
            getScopeDescAt(pc: hotspot.debugger.Address): ScopeDesc;
            getScopeDescNearDbg(pc: hotspot.debugger.Address): ScopeDesc;
            _getScopesPCsOffset(): int;
            _getStubOffset(): int;
            getVerifiedEntryPoint(): hotspot.debugger.Address;
            handlerTableBegin(): hotspot.debugger.Address;
            handlerTableContains(addr: hotspot.debugger.Address): boolean;
            handlerTableEnd(): hotspot.debugger.Address;
            handlerTableSize(): int;
            instsBegin(): hotspot.debugger.Address;
            instsContains(addr: hotspot.debugger.Address): boolean;
            instsEnd(): hotspot.debugger.Address;
            instsSize(): int;
            isDeoptEntry(pc: hotspot.debugger.Address): boolean;
            isDeoptMhEntry(pc: hotspot.debugger.Address): boolean;
            isDeoptPc(pc: hotspot.debugger.Address): boolean;
            isJavaMethod(): boolean;
            isMethodHandleReturn(returnPc: hotspot.debugger.Address): boolean;
            isNMethod(): boolean;
            isNativeMethod(): boolean;
            isOSRMethod(): boolean;
            metadataBegin(): hotspot.debugger.Address;
            metadataContains(addr: hotspot.debugger.Address): boolean;
            metadataEnd(): hotspot.debugger.Address;
            metadataSize(): int;
            nulChkTableBegin(): hotspot.debugger.Address;
            nulChkTableContains(addr: hotspot.debugger.Address): boolean;
            nulChkTableEnd(): hotspot.debugger.Address;
            nulChkTableSize(): int;
            oopsBegin(): hotspot.debugger.Address;
            oopsContains(addr: hotspot.debugger.Address): boolean;
            oopsEnd(): hotspot.debugger.Address;
            oopsSize(): int;
            origPCOffset(): int;
            _pc_desc_at(pc: long): PCDesc;
            _pc_desc_near(pc: long): PCDesc;
            print(): void;
            _printComponentsOn(tty: java.io.PrintStream): void;
            scope_desc_in(begin: long, a1: long): ScopeDesc;
            scopesDataContains(addr: hotspot.debugger.Address): boolean;
            scopesDataEnd(): hotspot.debugger.Address;
            scopesDataSize(): int;
            scopesPCsBegin(): hotspot.debugger.Address;
            scopesPCsContains(addr: hotspot.debugger.Address): boolean;
            scopesPCsEnd(): hotspot.debugger.Address;
            scopesPCsSize(): int;
            stubBegin(): hotspot.debugger.Address;
            stubContains(addr: hotspot.debugger.Address): boolean;
            stubEnd(): hotspot.debugger.Address;
            stubSize(): int;
            toString(): string;
            totalSize(): int;
          }
          interface NMethod extends CombineTypes<[_NMethod, sun.jvm.hotspot.code.CompiledMethod]> {}
          interface _ObjectValue$$static extends ClassLike {
            new(id: int): ObjectValue;
          }
          let ObjectValue: _ObjectValue$$static;
          interface _ObjectValue {
            fieldsSize(): int;
            getFieldAt(i: int): ScopeValue;
            getFieldsValue(): java.util.List<ScopeValue>;
            getKlass(): ScopeValue;
            getValue(): hotspot.debugger.OopHandle;
            id(): int;
            isObject(): boolean;
            print(): void;
            _printFieldsOn(tty: java.io.PrintStream): void;
            printOn(tty: java.io.PrintStream): void;
            _readObject(stream: DebugInfoReadStream): void;
            _fieldsValue: java.util.List<ScopeValue>;
            _id: int;
            _klass: ScopeValue;
          }
          interface ObjectValue extends CombineTypes<[_ObjectValue, sun.jvm.hotspot.code.ScopeValue]> {}
          interface _PCDesc$$static extends ClassLike {
            _initialize(db: hotspot.types.TypeDataBase): void;
            _isMethodHandleInvokeMask: int;
            _objDecodeOffsetField: hotspot.types.CIntegerField;
            _pcFlagsField: hotspot.types.CIntegerField;
            _pcOffsetField: hotspot.types.CIntegerField;
            _reexecuteMask: int;
            _returnOopMask: int;
            _scopeDecodeOffsetField: hotspot.types.CIntegerField;
            new(addr: hotspot.debugger.Address): PCDesc;
          }
          let PCDesc: _PCDesc$$static;
          interface _PCDesc {
            getObjDecodeOffset(): int;
            getPCOffset(): int;
            getRealPC(code: NMethod): hotspot.debugger.Address;
            getReexecute(): boolean;
            getScopeDecodeOffset(): int;
            isMethodHandleInvoke(): boolean;
            print(code: NMethod): void;
            printOn(tty: java.io.PrintStream, code: NMethod): void;
          }
          interface PCDesc extends CombineTypes<[_PCDesc, sun.jvm.hotspot.runtime.VMObject]> {}
          interface _RuntimeBlob$$static extends ClassLike {
            _initialize(db: hotspot.types.TypeDataBase): void;
            _NOT_YET_COMPUTED: int;
            _UNDEFINED: int;
            new(addr: hotspot.debugger.Address): RuntimeBlob;
          }
          let RuntimeBlob: _RuntimeBlob$$static;
          interface _RuntimeBlob {
            _linkOffset: int;
          }
          interface RuntimeBlob extends CombineTypes<[_RuntimeBlob, sun.jvm.hotspot.code.CodeBlob]> {}
          interface _RuntimeStub$$static extends ClassLike {
            _initialize(db: hotspot.types.TypeDataBase): void;
            _callerMustGCArgumentsField: hotspot.types.CIntegerField;
            new(addr: hotspot.debugger.Address): RuntimeStub;
          }
          let RuntimeStub: _RuntimeStub$$static;
          interface _RuntimeStub {
            callerMustGCArguments(): boolean;
            getName(): string;
            isRuntimeStub(): boolean;
          }
          interface RuntimeStub extends CombineTypes<[_RuntimeStub, sun.jvm.hotspot.code.RuntimeBlob]> {}
          interface _SafepointBlob$$static extends ClassLike {
            _initialize(db: hotspot.types.TypeDataBase): void;
            new(addr: hotspot.debugger.Address): SafepointBlob;
          }
          let SafepointBlob: _SafepointBlob$$static;
          interface _SafepointBlob {
            isSafepointStub(): boolean;
          }
          interface SafepointBlob extends CombineTypes<[_SafepointBlob, sun.jvm.hotspot.code.SingletonBlob]> {}
          interface _ScopeDesc$$static extends ClassLike {
            new(code: NMethod, decodeOffset: int, objectDecodeOffset: int, reexecute: boolean): ScopeDesc;
          }
          let ScopeDesc: _ScopeDesc$$static;
          interface _ScopeDesc {
            _decodeMonitorValues(decodeOffset: int): java.util.List<MonitorValue>;
            _decodeObjectValues(decodeOffset: int): java.util.List<ObjectValue>;
            _decodeScopeValues(decodeOffset: int): java.util.List<ScopeValue>;
            equals(arg: any): boolean;
            getBCI(): int;
            getDecodeOffset(): int;
            getExpressions(): java.util.List<ScopeValue>;
            getLocals(): java.util.List<ScopeValue>;
            getMethod(): hotspot.oops.Method;
            getMonitors(): java.util.List<MonitorValue>;
            getNMethod(): NMethod;
            getObjects(): java.util.List<ObjectValue>;
            getReexecute(): boolean;
            isTop(): boolean;
            printValue(): void;
            printValueOn(tty: java.io.PrintStream): void;
            sender(): ScopeDesc;
            _streamAt(decodeOffset: int): DebugInfoReadStream;
            _bci: int;
            _code: NMethod;
            _decodeOffset: int;
            _expressionsDecodeOffset: int;
            _localsDecodeOffset: int;
            _method: hotspot.oops.Method;
            _monitorsDecodeOffset: int;
            _objects: java.util.List<ObjectValue>;
            _reexecute: boolean;
            _senderDecodeOffset: int;
          }
          interface ScopeDesc extends CombineTypes<[_ScopeDesc, java.lang.Object]> {}
          interface _ScopeValue$$static extends ClassLike {
            readFrom(stream: DebugInfoReadStream): ScopeValue;
            _CONSTANT_DOUBLE_CODE: int;
            _CONSTANT_INT_CODE: int;
            _CONSTANT_LONG_CODE: int;
            _CONSTANT_OBJECT_CODE: int;
            _CONSTANT_OBJECT_ID_CODE: int;
            _CONSTANT_OOP_CODE: int;
            _LOCATION_CODE: int;
            new(): ScopeValue;
          }
          let ScopeValue: _ScopeValue$$static;
          interface _ScopeValue {
            isConstantDouble(): boolean;
            isConstantInt(): boolean;
            isConstantLong(): boolean;
            isConstantOop(): boolean;
            isLocation(): boolean;
            isObject(): boolean;
            printOn(a0: java.io.PrintStream): void;
(a0: java.io.PrintStream): void;
          }
          interface ScopeValue extends CombineTypes<[_ScopeValue, java.lang.Object]> {}
          interface _SingletonBlob$$static extends ClassLike {
            _initialize(db: hotspot.types.TypeDataBase): void;
            new(addr: hotspot.debugger.Address): SingletonBlob;
          }
          let SingletonBlob: _SingletonBlob$$static;
          interface _SingletonBlob {
            isSingletonBlob(): boolean;
          }
          interface SingletonBlob extends CombineTypes<[_SingletonBlob, sun.jvm.hotspot.code.RuntimeBlob]> {}
          interface _Stub$$static extends ClassLike {
            new(addr: hotspot.debugger.Address): Stub;
          }
          let Stub: _Stub$$static;
          interface _Stub {
            codeBegin(): hotspot.debugger.Address;
            codeEnd(): hotspot.debugger.Address;
            getAddress(): hotspot.debugger.Address;
            getSize(): long;
            printOn(tty: java.io.PrintStream): void;
            verify(): void;
          }
          interface Stub extends CombineTypes<[_Stub, sun.jvm.hotspot.runtime.VMObject]> {}
          interface _StubQueue$$static extends ClassLike {
            _initialize(db: hotspot.types.TypeDataBase): void;
            _bufferLimitField: hotspot.types.CIntegerField;
            _numberOfStubsField: hotspot.types.CIntegerField;
            _queueBeginField: hotspot.types.CIntegerField;
            _queueEndField: hotspot.types.CIntegerField;
            _stubBufferField: hotspot.types.AddressField;
            new(addr: hotspot.debugger.Address, stubType: java.lang.Class): StubQueue;
          }
          let StubQueue: _StubQueue$$static;
          interface _StubQueue {
            _checkIndex(i: long): void;
            contains(pc: hotspot.debugger.Address): boolean;
            _getBufferLimit(): long;
            getFirst(): Stub;
            _getIndexOf(s: Stub): long;
            getNext(s: Stub): Stub;
            getNumberOfStubs(): int;
            getPrev(s: Stub): Stub;
            _getQueueBegin(): long;
            _getQueueEnd(): long;
            _getStubAt(offset: long): Stub;
            _getStubBuffer(): hotspot.debugger.Address;
            getStubContaining(pc: hotspot.debugger.Address): Stub;
            _getStubSize(s: Stub): long;
            stubContains(s: Stub, pc: hotspot.debugger.Address): boolean;
            _stubType: java.lang.Class<any>;
          }
          interface StubQueue extends CombineTypes<[_StubQueue, sun.jvm.hotspot.runtime.VMObject]> {}
          interface _UncommonTrapBlob$$static extends ClassLike {
            _initialize(db: hotspot.types.TypeDataBase): void;
            new(addr: hotspot.debugger.Address): UncommonTrapBlob;
          }
          let UncommonTrapBlob: _UncommonTrapBlob$$static;
          interface _UncommonTrapBlob {
            isUncommonTrapStub(): boolean;
          }
          interface UncommonTrapBlob extends CombineTypes<[_UncommonTrapBlob, sun.jvm.hotspot.code.SingletonBlob]> {}
          interface _VMRegImpl$$static extends ClassLike {
            getRegisterName(index: int): string;
            getStack0(): hotspot.runtime.VMReg;
            getStackSlotSize(): int;
            _initialize(db: hotspot.types.TypeDataBase): void;
            _regNameField: hotspot.types.AddressField;
            _stack0: hotspot.runtime.VMReg;
            _stack0Addr: hotspot.debugger.Address;
            _stack0Val: int;
            _stackSlotSize: int;
            new(): VMRegImpl;
          }
          let VMRegImpl: _VMRegImpl$$static;
          interface _VMRegImpl {
          }
          interface VMRegImpl extends CombineTypes<[_VMRegImpl, java.lang.Object]> {}
          interface _VtableBlob$$static extends ClassLike {
            new(addr: hotspot.debugger.Address): VtableBlob;
          }
          let VtableBlob: _VtableBlob$$static;
          interface _VtableBlob {
            getName(): string;
            isVtableBlob(): boolean;
          }
          interface VtableBlob extends CombineTypes<[_VtableBlob, sun.jvm.hotspot.code.BufferBlob]> {}
        }
        module compiler {
          interface _CompileTask$$static extends ClassLike {
            _initialize(db: hotspot.types.TypeDataBase): void;
            _compLevelField: hotspot.oops.CIntField;
            _methodField: hotspot.types.AddressField;
            _osrBciField: hotspot.oops.CIntField;
            new(addr: hotspot.debugger.Address): CompileTask;
          }
          let CompileTask: _CompileTask$$static;
          interface _CompileTask {
            compLevel(): int;
            method(): hotspot.oops.Method;
            osrBci(): int;
          }
          interface CompileTask extends CombineTypes<[_CompileTask, sun.jvm.hotspot.runtime.VMObject]> {}
          interface _ImmutableOopMap$$static extends ClassLike {
            _initialize(db: hotspot.types.TypeDataBase): void;
            _classSize: long;
            _countField: hotspot.types.CIntegerField;
            new(addr: hotspot.debugger.Address): ImmutableOopMap;
          }
          let ImmutableOopMap: _ImmutableOopMap$$static;
          interface _ImmutableOopMap {
            _getCount(): long;
            getData(): hotspot.debugger.Address;
          }
          interface ImmutableOopMap extends CombineTypes<[_ImmutableOopMap, sun.jvm.hotspot.runtime.VMObject]> {}
          interface _ImmutableOopMapPair$$static extends ClassLike {
            classSize(): long;
            _initialize(db: hotspot.types.TypeDataBase): void;
            _classSize: long;
            _oopmapOffsetField: hotspot.types.CIntegerField;
            _pcOffsetField: hotspot.types.CIntegerField;
            new(address: hotspot.debugger.Address): ImmutableOopMapPair;
          }
          let ImmutableOopMapPair: _ImmutableOopMapPair$$static;
          interface _ImmutableOopMapPair {
            getOffset(): int;
            getPC(): int;
            toString(): string;
            _address: hotspot.debugger.Address;
          }
          interface ImmutableOopMapPair extends CombineTypes<[_ImmutableOopMapPair, java.lang.Object]> {}
          interface _ImmutableOopMapSet$$static extends ClassLike {
            allDo(fr: hotspot.runtime.Frame, cb: hotspot.code.CodeBlob, regMap: hotspot.runtime.RegisterMap, visitor: OopMapVisitor, debugging: boolean): void;
            _initialize(db: hotspot.types.TypeDataBase): void;
            oopsDo(fr: hotspot.runtime.Frame, cb: hotspot.code.CodeBlob, regMap: hotspot.runtime.RegisterMap, oopVisitor: hotspot.runtime.AddressVisitor, debugging: boolean): void;
            updateRegisterMap(fr: hotspot.runtime.Frame, cb: hotspot.code.CodeBlob, regMap: hotspot.runtime.RegisterMap, debugging: boolean): void;
            _C_SAVED_ON_ENTRY_REG_COUNT: int;
            _DEBUG: boolean;
            _REG_COUNT: int;
            _SAVED_ON_ENTRY_REG_COUNT: int;
            _classSize: long;
            _countField: hotspot.types.CIntegerField;
            _omDataField: hotspot.types.AddressField;
            _sizeField: hotspot.types.CIntegerField;
            new(addr: hotspot.debugger.Address): ImmutableOopMapSet;
          }
          let ImmutableOopMapSet: _ImmutableOopMapSet$$static;
          interface _ImmutableOopMapSet {
            _dataStart(): hotspot.debugger.Address;
            findMapAtOffset(pcOffset: long, a1: boolean): ImmutableOopMap;
            getCount(): int;
            getMap(pair: ImmutableOopMapPair): ImmutableOopMap;
            getMapAt(index: int): ImmutableOopMap;
            getPairAt(index: int): ImmutableOopMapPair;
            _getSize(): int;
            pairAt(index: int): ImmutableOopMapPair;
            _pairStart(): hotspot.debugger.Address;
            toString(): string;
          }
          interface ImmutableOopMapSet extends CombineTypes<[_ImmutableOopMapSet, sun.jvm.hotspot.runtime.VMObject]> {}
          interface _ImmutableOopMapSet$MyVisitor$$static extends ClassLike {
            new(oopVisitor: hotspot.runtime.AddressVisitor): ImmutableOopMapSet$MyVisitor;
          }
          let ImmutableOopMapSet$MyVisitor: _ImmutableOopMapSet$MyVisitor$$static;
          interface _ImmutableOopMapSet$MyVisitor {
            setAddressVisitor(addressVisitor: hotspot.runtime.AddressVisitor): void;
            visitDerivedOopLocation(baseOopAddr: hotspot.debugger.Address, derivedOopAddr: hotspot.debugger.Address): void;
            visitNarrowOopLocation(narrowOopAddr: hotspot.debugger.Address): void;
            visitOopLocation(oopAddr: hotspot.debugger.Address): void;
            _addressVisitor: hotspot.runtime.AddressVisitor;
          }
          interface ImmutableOopMapSet$MyVisitor extends CombineTypes<[_ImmutableOopMapSet$MyVisitor, sun.jvm.hotspot.compiler.OopMapVisitor, java.lang.Object]> {}
          interface _OopMapStream$$static extends ClassLike {
            new(oopMap: ImmutableOopMap): OopMapStream;
          }
          let OopMapStream: _OopMapStream$$static;
          interface _OopMapStream {
            _findNext(): void;
            getCurrent(): OopMapValue;
            isDone(): boolean;
            next(): void;
            _omv: OopMapValue;
            _omvValid: boolean;
            _oopMap: ImmutableOopMap;
            _position: int;
            _size: int;
            _stream: hotspot.code.CompressedReadStream;
          }
          interface OopMapStream extends CombineTypes<[_OopMapStream, java.lang.Object]> {}
          interface _OopMapValue$$static extends ClassLike {
            _initialize(db: hotspot.types.TypeDataBase): void;
            _CALLEE_SAVED_VALUE: int;
            _DERIVED_OOP_VALUE: int;
            _NARROWOOP_VALUE: int;
            _OOP_VALUE: int;
            _REGISTER_BITS: int;
            _REGISTER_MASK: int;
            _REGISTER_MASK_IN_PLACE: int;
            _REGISTER_SHIFT: int;
            _TYPE_BITS: int;
            _TYPE_MASK: int;
            _TYPE_MASK_IN_PLACE: int;
            _TYPE_SHIFT: int;
            new(): OopMapValue;
            new(reg: hotspot.runtime.VMReg, t: OopMapValue$OopTypes): OopMapValue;
            new(reg: hotspot.runtime.VMReg, t: OopMapValue$OopTypes, reg2: hotspot.runtime.VMReg): OopMapValue;
            new(stream: hotspot.code.CompressedReadStream): OopMapValue;
          }
          let OopMapValue: _OopMapValue$$static;
          interface _OopMapValue {
            getContentReg(): hotspot.runtime.VMReg;
            getReg(): hotspot.runtime.VMReg;
            getStackOffset(): int;
            getType(): OopMapValue$OopTypes;
            _getValue(): int;
            isCalleeSaved(): boolean;
            isDerivedOop(): boolean;
            isNarrowOop(): boolean;
            isOop(): boolean;
            isRegisterLoc(): boolean;
            isStackLoc(): boolean;
            readFrom(stream: hotspot.code.CompressedReadStream): void;
            setContentReg(r: hotspot.runtime.VMReg): void;
            setReg(r: hotspot.runtime.VMReg): void;
            setType(t: OopMapValue$OopTypes): void;
            _setValue(value: short): void;
            _contentReg: short;
            _value: short;
          }
          interface OopMapValue extends CombineTypes<[_OopMapValue, java.lang.Object]> {}
          interface _OopMapValue$OopTypes$$static extends ClassLike {
            readonly CALLEE_SAVED_VALUE: OopMapValue$OopTypes;
            readonly DERIVED_OOP_VALUE: OopMapValue$OopTypes;
            readonly NARROWOOP_VALUE: OopMapValue$OopTypes;
            readonly OOP_VALUE: OopMapValue$OopTypes;
            _new(): OopMapValue$OopTypes;
          }
          let OopMapValue$OopTypes: _OopMapValue$OopTypes$$static;
          interface _OopMapValue$OopTypes {
            _getValue(): int;
(): int;
          }
          interface OopMapValue$OopTypes extends CombineTypes<[_OopMapValue$OopTypes, java.lang.Object]> {}
          interface _OopMapVisitor$$static extends ClassLike {
          }
          let OopMapVisitor: _OopMapVisitor$$static;
          interface _OopMapVisitor {
            visitDerivedOopLocation(a0: hotspot.debugger.Address, a1: hotspot.debugger.Address): void;
            visitNarrowOopLocation(a0: hotspot.debugger.Address): void;
            visitOopLocation(a0: hotspot.debugger.Address): void;
          }
          interface OopMapVisitor extends CombineTypes<[_OopMapVisitor, java.lang.Object]> {}
        }
        module debugger {
          module aarch64 {
            interface _AARCH64ThreadContext$$static extends ClassLike {
              readonly FP: int;
              readonly LR: int;
              readonly NPRGREG: int;
              readonly PC: int;
              readonly PSTATE: int;
              readonly R0: int;
              readonly R1: int;
              readonly R10: int;
              readonly R11: int;
              readonly R12: int;
              readonly R13: int;
              readonly R14: int;
              readonly R15: int;
              readonly R16: int;
              readonly R17: int;
              readonly R18: int;
              readonly R19: int;
              readonly R2: int;
              readonly R20: int;
              readonly R21: int;
              readonly R22: int;
              readonly R23: int;
              readonly R24: int;
              readonly R25: int;
              readonly R26: int;
              readonly R27: int;
              readonly R28: int;
              readonly R3: int;
              readonly R4: int;
              readonly R5: int;
              readonly R6: int;
              readonly R7: int;
              readonly R8: int;
              readonly R9: int;
              readonly SP: int;
              new(): AARCH64ThreadContext;
            }
            let AARCH64ThreadContext: _AARCH64ThreadContext$$static;
            interface _AARCH64ThreadContext {
              getNumRegisters(): int;
              getRegister(index: int): long;
              getRegisterAsAddress(a0: int): Address;
              getRegisterName(index: int): string;
              getTopFrame(dbg: Debugger): debugger.cdbg.CFrame;
              setRegister(index: int, value: long): void;
              setRegisterAsAddress(a0: int, a1: Address): void;
              _data: long[];
            }
            interface AARCH64ThreadContext extends CombineTypes<[_AARCH64ThreadContext, sun.jvm.hotspot.debugger.ThreadContext, java.lang.Object]> {}
          }
          module amd64 {
            interface _AMD64ThreadContext$$static extends ClassLike {
              readonly CS: int;
              readonly DS: int;
              readonly ERR: int;
              readonly ES: int;
              readonly FS: int;
              readonly FSBASE: int;
              readonly GS: int;
              readonly GSBASE: int;
              readonly NPRGREG: int;
              readonly R10: int;
              readonly R11: int;
              readonly R12: int;
              readonly R13: int;
              readonly R14: int;
              readonly R15: int;
              readonly R8: int;
              readonly R9: int;
              readonly RAX: int;
              readonly RBP: int;
              readonly RBX: int;
              readonly RCX: int;
              readonly RDI: int;
              readonly RDX: int;
              readonly RFL: int;
              readonly RIP: int;
              readonly RSI: int;
              readonly RSP: int;
              readonly SS: int;
              readonly TRAPNO: int;
              _regNames: string[];
              new(): AMD64ThreadContext;
            }
            let AMD64ThreadContext: _AMD64ThreadContext$$static;
            interface _AMD64ThreadContext {
              getNumRegisters(): int;
              getRegister(index: int): long;
              getRegisterAsAddress(a0: int): Address;
              getRegisterName(index: int): string;
              getTopFrame(dbg: Debugger): debugger.cdbg.CFrame;
              setRegister(index: int, value: long): void;
              setRegisterAsAddress(a0: int, a1: Address): void;
              _data: long[];
            }
            interface AMD64ThreadContext extends CombineTypes<[_AMD64ThreadContext, sun.jvm.hotspot.debugger.ThreadContext, java.lang.Object]> {}
          }
          module bsd {
            module aarch64 {
              interface _BsdAARCH64CFrame$$static extends ClassLike {
                _ADDRESS_SIZE: int;
                new(dbg: BsdDebugger, fp: Address, pc: Address): BsdAARCH64CFrame;
              }
              let BsdAARCH64CFrame: _BsdAARCH64CFrame$$static;
              interface _BsdAARCH64CFrame {
                closestSymbolToPC(): debugger.cdbg.ClosestSymbol;
                localVariableBase(): Address;
                pc(): Address;
                sender(thread: ThreadProxy): debugger.cdbg.CFrame;
                _dbg: BsdDebugger;
                _fp: Address;
                _pc: Address;
                _sp: Address;
              }
              interface BsdAARCH64CFrame extends CombineTypes<[_BsdAARCH64CFrame, sun.jvm.hotspot.debugger.cdbg.basic.BasicCFrame]> {}
              interface _BsdAARCH64ThreadContext$$static extends ClassLike {
                new(debugger: BsdDebugger): BsdAARCH64ThreadContext;
              }
              let BsdAARCH64ThreadContext: _BsdAARCH64ThreadContext$$static;
              interface _BsdAARCH64ThreadContext {
                getRegisterAsAddress(index: int): Address;
                setRegisterAsAddress(index: int, value: Address): void;
                _debugger: BsdDebugger;
              }
              interface BsdAARCH64ThreadContext extends CombineTypes<[_BsdAARCH64ThreadContext, sun.jvm.hotspot.debugger.aarch64.AARCH64ThreadContext]> {}
            }
            module amd64 {
              interface _BsdAMD64CFrame$$static extends ClassLike {
                _ADDRESS_SIZE: int;
                new(dbg: BsdDebugger, rbp: Address, rip: Address): BsdAMD64CFrame;
              }
              let BsdAMD64CFrame: _BsdAMD64CFrame$$static;
              interface _BsdAMD64CFrame {
                closestSymbolToPC(): debugger.cdbg.ClosestSymbol;
                localVariableBase(): Address;
                pc(): Address;
                sender(thread: ThreadProxy): debugger.cdbg.CFrame;
                _dbg: BsdDebugger;
                _rbp: Address;
                _rip: Address;
              }
              interface BsdAMD64CFrame extends CombineTypes<[_BsdAMD64CFrame, sun.jvm.hotspot.debugger.cdbg.basic.BasicCFrame]> {}
              interface _BsdAMD64ThreadContext$$static extends ClassLike {
                new(debugger: BsdDebugger): BsdAMD64ThreadContext;
              }
              let BsdAMD64ThreadContext: _BsdAMD64ThreadContext$$static;
              interface _BsdAMD64ThreadContext {
                getRegisterAsAddress(index: int): Address;
                setRegisterAsAddress(index: int, value: Address): void;
                _debugger: BsdDebugger;
              }
              interface BsdAMD64ThreadContext extends CombineTypes<[_BsdAMD64ThreadContext, sun.jvm.hotspot.debugger.amd64.AMD64ThreadContext]> {}
            }
            module x86 {
              interface _BsdX86CFrame$$static extends ClassLike {
                _ADDRESS_SIZE: int;
                new(dbg: BsdDebugger, ebp: Address, pc: Address): BsdX86CFrame;
              }
              let BsdX86CFrame: _BsdX86CFrame$$static;
              interface _BsdX86CFrame {
                closestSymbolToPC(): debugger.cdbg.ClosestSymbol;
                localVariableBase(): Address;
                pc(): Address;
                sender(thread: ThreadProxy): debugger.cdbg.CFrame;
                _dbg: BsdDebugger;
                _ebp: Address;
                _pc: Address;
              }
              interface BsdX86CFrame extends CombineTypes<[_BsdX86CFrame, sun.jvm.hotspot.debugger.cdbg.basic.BasicCFrame]> {}
              interface _BsdX86ThreadContext$$static extends ClassLike {
                new(debugger: BsdDebugger): BsdX86ThreadContext;
              }
              let BsdX86ThreadContext: _BsdX86ThreadContext$$static;
              interface _BsdX86ThreadContext {
                getRegisterAsAddress(index: int): Address;
                setRegisterAsAddress(index: int, value: Address): void;
                _debugger: BsdDebugger;
              }
              interface BsdX86ThreadContext extends CombineTypes<[_BsdX86ThreadContext, sun.jvm.hotspot.debugger.x86.X86ThreadContext]> {}
            }
            interface _BsdAddress$$static extends ClassLike {
              _check(arg: boolean, failMessage: string): void;
              main(args: string[]): void;
              _new(debugger: BsdDebugger, addr: long): BsdAddress;
            }
            let BsdAddress: _BsdAddress$$static;
            interface _BsdAddress {
              addOffsetTo(offset: long): Address;
              addOffsetToAsOopHandle(offset: long): OopHandle;
              andWithMask(mask: long): Address;
              asLongValue(): long;
              equals(arg: any): boolean;
              getAddressAt(offset: long): Address;
              getCIntegerAt(offset: long, a1: long, numBytes: boolean): long;
              getCompKlassAddressAt(offset: long): Address;
              getCompOopAddressAt(offset: long): Address;
              getCompOopHandleAt(offset: long): OopHandle;
              getJBooleanAt(offset: long): boolean;
              getJByteAt(offset: long): byte;
              getJCharAt(offset: long): char;
              getJDoubleAt(offset: long): double;
              getJFloatAt(offset: long): float;
              getJIntAt(offset: long): int;
              getJLongAt(offset: long): long;
              getJShortAt(offset: long): short;
              getOopHandleAt(offset: long): OopHandle;
              greaterThan(a: Address): boolean;
              greaterThanOrEqual(a: Address): boolean;
              hashCode(): int;
              lessThan(a: Address): boolean;
              lessThanOrEqual(a: Address): boolean;
              minus(arg: Address): long;
              orWithMask(mask: long): Address;
              setAddressAt(offset: long, a1: Address): void;
              setCIntegerAt(offset: long, a1: long, numBytes: long): void;
              setJBooleanAt(offset: long, a1: boolean): void;
              setJByteAt(offset: long, a1: byte): void;
              setJCharAt(offset: long, a1: char): void;
              setJDoubleAt(offset: long, a1: double): void;
              setJFloatAt(offset: long, a1: float): void;
              setJIntAt(offset: long, a1: int): void;
              setJLongAt(offset: long, a1: long): void;
              setJShortAt(offset: long, a1: short): void;
              setOopHandleAt(offset: long, a1: OopHandle): void;
              toString(): string;
              xorWithMask(mask: long): Address;
              _addr: long;
              _debugger: BsdDebugger;
            }
            interface BsdAddress extends CombineTypes<[_BsdAddress, java.lang.Object, sun.jvm.hotspot.debugger.Address]> {}
            interface _BsdCDebugger$$static extends ClassLike {
              _new(dbg: BsdDebugger): BsdCDebugger;
            }
            let BsdCDebugger: _BsdCDebugger$$static;
            interface _BsdCDebugger {
              canDemangle(): boolean;
              demangle(sym: string): string;
              getLoadObjectList(): java.util.List<debugger.cdbg.LoadObject>;
              getNameOfFile(fileName: string): string;
              getProcessControl(): debugger.cdbg.ProcessControl;
              getThreadList(): java.util.List<ThreadProxy>;
              loadObjectContainingPC(pc: Address): debugger.cdbg.LoadObject;
              topFrameForThread(thread: ThreadProxy): debugger.cdbg.CFrame;
              _dbg: BsdDebugger;
            }
            interface BsdCDebugger extends CombineTypes<[_BsdCDebugger, sun.jvm.hotspot.debugger.cdbg.CDebugger, java.lang.Object]> {}
            interface _BsdDebugger$$static extends ClassLike {
            }
            let BsdDebugger: _BsdDebugger$$static;
            interface _BsdDebugger {
              addressValueToString(a0: long): string;
              getAddressValue(a0: Address): long;
              getLoadObjectList(): java.util.List<debugger.cdbg.LoadObject>;
              getThreadIntegerRegisterSet(a0: long): long[];
              getThreadList(): java.util.List<ThreadProxy>;
              lookup(a0: long): debugger.cdbg.ClosestSymbol;
              readAddress(a0: long): BsdAddress;
              readCInteger(a0: long, a1: long, a2: boolean): long;
              readCompKlassAddress(a0: long): BsdAddress;
              readCompOopAddress(a0: long): BsdAddress;
              readCompOopHandle(a0: long): BsdOopHandle;
              readJBoolean(a0: long): boolean;
              readJByte(a0: long): byte;
              readJChar(a0: long): char;
              readJDouble(a0: long): double;
              readJFloat(a0: long): float;
              readJInt(a0: long): int;
              readJLong(a0: long): long;
              readJShort(a0: long): short;
              readOopHandle(a0: long): BsdOopHandle;
            }
            interface BsdDebugger extends CombineTypes<[_BsdDebugger, java.lang.Object, sun.jvm.hotspot.debugger.JVMDebugger]> {}
            interface _BsdDebuggerLocal$$static extends ClassLike {
              getAddressSize(): int;
              _init0(): void;
              new(machDesc: MachineDescription, useCache: boolean): BsdDebuggerLocal;
            }
            let BsdDebuggerLocal: _BsdDebuggerLocal$$static;
            interface _BsdDebuggerLocal {
              addressValueToString(address: long): string;
              attach(processID: int): void;
              attach(execName: string, coreName: string): void;
              _attach0(a0: int): void;
              _attach0(a0: string, a1: string): void;
              _checkAttached(): void;
              consoleExecuteCommand(cmd: string): string;
              _createClosestSymbol(name: string, offset: long): debugger.cdbg.ClosestSymbol;
              _createLoadObject(fileName: string, size: long, a2: long): debugger.cdbg.LoadObject;
              detach(): boolean;
              _detach0(): void;
              _findABIVersion(): void;
              getAddressValue(addr: Address): long;
              getCDebugger(): debugger.cdbg.CDebugger;
              getCPU(): string;
              getConsolePrompt(): string;
              getJavaThreadsInfo(): long[];
              getLoadObjectList(): java.util.List<debugger.cdbg.LoadObject>;
              getMachineDescription(): MachineDescription;
              getOS(): string;
              getProcessList(): java.util.List<ProcessInfo>;
              getThreadForIdentifierAddress(threadIdAddr: Address, uniqueThreadIdAddr: Address): ThreadProxy;
              getThreadForIdentifierAddress(addr: Address): ThreadProxy;
              getThreadForThreadId(id: long): ThreadProxy;
              getThreadIntegerRegisterSet(unique_thread_id: long): long[];
              _getThreadIntegerRegisterSet0(a0: long): long[];
              getThreadList(): java.util.List<ThreadProxy>;
              _handleGCC32ABI(addr: long, a1: string): long;
              hasConsole(): boolean;
              hasProcessList(): boolean;
              lookup(objectName: string, symbol: string): Address;
              lookup(addr: long): debugger.cdbg.ClosestSymbol;
              _lookupByAddress0(a0: long): debugger.cdbg.ClosestSymbol;
              _lookupByName0(a0: string, a1: string): long;
              lookupOop(objectName: string, symbol: string): OopHandle;
              newAddress(value: long): Address;
              parseAddress(addressString: string): Address;
              readAddress(address: long): BsdAddress;
              readBytesFromProcess(address: long, a1: long): ReadResult;
              _readBytesFromProcess0(a0: long, a1: long): byte[];
              readCompKlassAddress(address: long): BsdAddress;
              readCompOopAddress(address: long): BsdAddress;
              readCompOopHandle(address: long): BsdOopHandle;
              readOopHandle(address: long): BsdOopHandle;
              _requireAttach(): void;
              _attached: boolean;
              _cdbg: BsdCDebugger;
              _isCore: boolean;
              _isDarwin: boolean;
              _loadObjectList: java.util.List<debugger.cdbg.LoadObject>;
              _p_ps_prochandle: long;
              _symbolicator: long;
              _task: long;
              _threadList: java.util.List<ThreadProxy>;
              _useGCC32ABI: boolean;
              _workerThread: BsdDebuggerLocal$BsdDebuggerLocalWorkerThread;
            }
            interface BsdDebuggerLocal extends CombineTypes<[_BsdDebuggerLocal, sun.jvm.hotspot.debugger.bsd.BsdDebugger, sun.jvm.hotspot.debugger.DebuggerBase]> {}
            interface _BsdDebuggerLocal$BsdDebuggerLocalWorkerThread$$static extends ClassLike {
              new(this$0: BsdDebuggerLocal, debugger: BsdDebuggerLocal): BsdDebuggerLocal$BsdDebuggerLocalWorkerThread;
            }
            let BsdDebuggerLocal$BsdDebuggerLocalWorkerThread: _BsdDebuggerLocal$BsdDebuggerLocalWorkerThread$$static;
            interface _BsdDebuggerLocal$BsdDebuggerLocalWorkerThread {
              execute(task: BsdDebuggerLocal$WorkerThreadTask): BsdDebuggerLocal$WorkerThreadTask;
              run(): void;
              _debugger: BsdDebuggerLocal;
              _lastException: DebuggerException;
              _task: BsdDebuggerLocal$WorkerThreadTask;
              _this$0: BsdDebuggerLocal;
            }
            interface BsdDebuggerLocal$BsdDebuggerLocalWorkerThread extends CombineTypes<[_BsdDebuggerLocal$BsdDebuggerLocalWorkerThread, java.lang.Thread]> {}
            interface _BsdDebuggerLocal$WorkerThreadTask$$static extends ClassLike {
            }
            let BsdDebuggerLocal$WorkerThreadTask: _BsdDebuggerLocal$WorkerThreadTask$$static;
            interface _BsdDebuggerLocal$WorkerThreadTask {
              doit(a0: BsdDebuggerLocal): void;
(a0: BsdDebuggerLocal): void;
            }
            interface BsdDebuggerLocal$WorkerThreadTask extends CombineTypes<[_BsdDebuggerLocal$WorkerThreadTask, java.lang.Object]> {}
            interface _BsdOopHandle$$static extends ClassLike {
              _new(debugger: BsdDebugger, addr: long): BsdOopHandle;
            }
            let BsdOopHandle: _BsdOopHandle$$static;
            interface _BsdOopHandle {
              addOffsetTo(offset: long): Address;
              andWithMask(mask: long): Address;
              equals(arg: any): boolean;
              orWithMask(mask: long): Address;
              xorWithMask(mask: long): Address;
            }
            interface BsdOopHandle extends CombineTypes<[_BsdOopHandle, sun.jvm.hotspot.debugger.bsd.BsdAddress, sun.jvm.hotspot.debugger.OopHandle]> {}
            interface _BsdThread$$static extends ClassLike {
              _new(debugger: BsdDebugger, threadIdAddr: Address, uniqueThreadIdAddr: Address): BsdThread;
              _new(debugger: BsdDebugger, id: long): BsdThread;
            }
            let BsdThread: _BsdThread$$static;
            interface _BsdThread {
              canSetContext(): boolean;
              equals(obj: any): boolean;
              getContext(): ThreadContext;
              getUniqueThreadId(): long;
              hashCode(): int;
              setContext(context: ThreadContext): void;
              toString(): string;
              _debugger: BsdDebugger;
              _thread_id: int;
              _unique_thread_id: long;
            }
            interface BsdThread extends CombineTypes<[_BsdThread, sun.jvm.hotspot.debugger.ThreadProxy, java.lang.Object]> {}
            interface _BsdThreadContextFactory$$static extends ClassLike {
              _createThreadContext(dbg: BsdDebugger): ThreadContext;
              _new(): BsdThreadContextFactory;
            }
            let BsdThreadContextFactory: _BsdThreadContextFactory$$static;
            interface _BsdThreadContextFactory {
            }
            interface BsdThreadContextFactory extends CombineTypes<[_BsdThreadContextFactory, java.lang.Object]> {}
            interface _SharedObject$$static extends ClassLike {
              _new(dbg: BsdDebugger, filename: string, size: long, a3: Address): SharedObject;
            }
            let SharedObject: _SharedObject$$static;
            interface _SharedObject {
              closestSymbolToPC(pcAsAddr: Address): debugger.cdbg.ClosestSymbol;
              _getAddressValue(addr: Address): long;
              _newAddress(address: long): Address;
              _dbg: BsdDebugger;
            }
            interface SharedObject extends CombineTypes<[_SharedObject, sun.jvm.hotspot.debugger.posix.DSO]> {}
          }
          module cdbg {
            module basic {
              interface _BasicArrayType$$static extends ClassLike {
                new(name: string, elementType: Type, sizeInBytes: int): BasicArrayType;
              }
              let BasicArrayType: _BasicArrayType$$static;
              interface _BasicArrayType {
                asArray(): ArrayType;
                _createCVVariant(cvAttributes: int): Type;
                getElementType(): Type;
                getLength(): int;
                iterateObject(a: Address, v: ObjectVisitor, f: FieldIdentifier): void;
                _resolveTypes(db: BasicCDebugInfoDataBase, listener: ResolveListener): Type;
                visit(v: TypeVisitor): void;
                _elementType: Type;
                _length: int;
              }
              interface BasicArrayType extends CombineTypes<[_BasicArrayType, sun.jvm.hotspot.debugger.cdbg.ArrayType, sun.jvm.hotspot.debugger.cdbg.basic.BasicType]> {}
              interface _BasicBaseClass$$static extends ClassLike {
                new(accessControl: int, isVirtual: boolean, type: Type): BasicBaseClass;
              }
              let BasicBaseClass: _BasicBaseClass$$static;
              interface _BasicBaseClass {
                getAccessControl(): int;
                getType(): Type;
                isVirtual(): boolean;
                resolveTypes(containingType: Type, db: BasicCDebugInfoDataBase, listener: ResolveListener): void;
                _accessControl: int;
                _isVirtual: boolean;
                _type: Type;
              }
              interface BasicBaseClass extends CombineTypes<[_BasicBaseClass, java.lang.Object, sun.jvm.hotspot.debugger.cdbg.BaseClass]> {}
              interface _BasicBitType$$static extends ClassLike {
                _highBit(sizeInBits: int): long;
                _maskFor(sizeInBits: int): long;
                new(underlyingType: Type, sizeInBits: int, lsbOffset: int): BasicBitType;
              }
              let BasicBitType: _BasicBitType$$static;
              interface _BasicBitType {
                asBit(): BitType;
                _createCVVariant(cvAttributes: int): Type;
                getOffset(): int;
                getSize(): int;
                getSizeInBits(): int;
                isUnsigned(): boolean;
                iterateObject(a: Address, v: ObjectVisitor, f: FieldIdentifier): void;
                _resolveTypes(db: BasicCDebugInfoDataBase, listener: ResolveListener): Type;
                visit(v: TypeVisitor): void;
                _offset: int;
                _sizeInBits: int;
                _underlyingType: Type;
              }
              interface BasicBitType extends CombineTypes<[_BasicBitType, sun.jvm.hotspot.debugger.cdbg.basic.BasicIntType, sun.jvm.hotspot.debugger.cdbg.BitType]> {}
              interface _BasicBlockSym$$static extends ClassLike {
                new(parent: BlockSym, length: long, a2: Address, addr: string): BasicBlockSym;
              }
              let BasicBlockSym: _BasicBlockSym$$static;
              interface _BasicBlockSym {
                addLocal(local: LocalSym): void;
                asBlock(): BlockSym;
                getAddress(): Address;
                getLength(): long;
                getLocal(i: int): LocalSym;
                getNumLocals(): int;
                getParent(): BlockSym;
                resolve(db: BasicCDebugInfoDataBase, listener: ResolveListener): void;
                _addr: Address;
                _length: long;
                _locals: java.util.List<LocalSym>;
                _parent: BlockSym;
              }
              interface BasicBlockSym extends CombineTypes<[_BasicBlockSym, sun.jvm.hotspot.debugger.cdbg.basic.BasicSym, sun.jvm.hotspot.debugger.cdbg.BlockSym]> {}
              interface _BasicCDebugInfoDataBase$$static extends ClassLike {
                _COMPLETE_STATE: int;
                _CONSTRUCTION_STATE: int;
                _INITIALIZED_STATE: int;
                _RESOLVED_STATE: int;
                new(): BasicCDebugInfoDataBase;
              }
              let BasicCDebugInfoDataBase: _BasicCDebugInfoDataBase$$static;
              interface _BasicCDebugInfoDataBase {
                addBlock(key: any, block: BlockSym): void;
                addGlobalSym(sym: GlobalSym): void;
                addLineNumberInfo(info: BasicLineNumberInfo): void;
                addType(lazyKey: any, type: Type): void;
                beginConstruction(): void;
                debugInfoForPC(pc: Address): BlockSym;
                endConstruction(): void;
                iterate(v: TypeVisitor): void;
                iterate(v: LineNumberVisitor): void;
                lineNumberForPC(pc: Address): LineNumberInfo;
                lookupSym(name: string): GlobalSym;
                lookupType(name: string): Type;
                lookupType(name: string, cvAttributes: int): Type;
                resolve(listener: ResolveListener): void;
                _resolveLazyMap(listener: ResolveListener): void;
                resolveSym(containingSymbol: Sym, targetSym: Sym, listener: ResolveListener, detail: string): Sym;
                resolveType(containingType: Type, targetType: Type, listener: ResolveListener, detail: string): Type;
                resolveType(containingSymbol: Sym, targetType: Type, listener: ResolveListener, detail: string): Type;
                _searchBlocks(addr: Address, lowIdx: int, highIdx: int): BlockSym;
                _blocks: java.util.List<BlockSym>;
                _lazySymMap: java.util.Map<any,BlockSym>;
                _lazyTypeMap: java.util.Map<any,Type>;
                _lineNumbers: BasicLineNumberMapping;
                _nameToSymMap: java.util.Map<string,GlobalSym>;
                _nameToTypeMap: java.util.Map<string,Type>;
                _state: int;
                _types: java.util.List<Type>;
              }
              interface BasicCDebugInfoDataBase extends CombineTypes<[_BasicCDebugInfoDataBase, sun.jvm.hotspot.debugger.cdbg.CDebugInfoDataBase, java.lang.Object]> {}
              interface _BasicCFrame$$static extends ClassLike {
                _new(dbg: CDebugger): BasicCFrame;
              }
              let BasicCFrame: _BasicCFrame$$static;
              interface _BasicCFrame {
                blockForPC(): BlockSym;
                closestSymbolToPC(): ClosestSymbol;
                _dbg(): CDebugger;
                iterateLocals(v: ObjectVisitor): void;
                loadObjectForPC(): LoadObject;
                _dbg: CDebugger;
              }
              interface BasicCFrame extends CombineTypes<[_BasicCFrame, sun.jvm.hotspot.debugger.cdbg.CFrame, java.lang.Object]> {}
              interface _BasicCompoundType$$static extends ClassLike {
                new(name: string, size: int, kind: CompoundTypeKind): BasicCompoundType;
              }
              let BasicCompoundType: _BasicCompoundType$$static;
              interface _BasicCompoundType {
                addBaseClass(b: BaseClass): void;
                addField(f: Field): void;
                asCompound(): CompoundType;
                _createCVVariant(cvAttributes: int): Type;
                getBaseClass(i: int): BaseClass;
                getField(i: int): Field;
                getNumBaseClasses(): int;
                getNumFields(): int;
                isClass(): boolean;
                isStruct(): boolean;
                isUnion(): boolean;
                iterateObject(a: Address, v: ObjectVisitor, f: FieldIdentifier): void;
                _resolveTypes(db: BasicCDebugInfoDataBase, listener: ResolveListener): Type;
                visit(v: TypeVisitor): void;
                _baseClasses: java.util.List<BaseClass>;
                _fields: java.util.List<Field>;
                _kind: CompoundTypeKind;
              }
              interface BasicCompoundType extends CombineTypes<[_BasicCompoundType, sun.jvm.hotspot.debugger.cdbg.CompoundType, sun.jvm.hotspot.debugger.cdbg.basic.BasicType]> {}
              interface _BasicDebugEvent$$static extends ClassLike {
                newAccessViolationEvent(thread: ThreadProxy, pc: Address, wasWrite: boolean, addr: Address): BasicDebugEvent;
                _newAddressEvent(type: DebugEvent$Type, thread: ThreadProxy, addr: Address): BasicDebugEvent;
                newBreakpointEvent(thread: ThreadProxy, pc: Address): BasicDebugEvent;
                newLoadObjectLoadEvent(thread: ThreadProxy, base: Address): BasicDebugEvent;
                newLoadObjectUnloadEvent(thread: ThreadProxy, base: Address): BasicDebugEvent;
                _newPCEvent(type: DebugEvent$Type, thread: ThreadProxy, pc: Address): BasicDebugEvent;
                newSingleStepEvent(thread: ThreadProxy, pc: Address): BasicDebugEvent;
                newUnknownEvent(thread: ThreadProxy, detail: string): BasicDebugEvent;
                new(type: DebugEvent$Type, thread: ThreadProxy): BasicDebugEvent;
              }
              let BasicDebugEvent: _BasicDebugEvent$$static;
              interface _BasicDebugEvent {
                getAddress(): Address;
                getPC(): Address;
                getThread(): ThreadProxy;
                getType(): DebugEvent$Type;
                getUnknownEventDetail(): string;
                getWasWrite(): boolean;
                setAddress(address: Address): void;
                setPC(pc: Address): void;
                setThread(thread: ThreadProxy): void;
                setType(type: DebugEvent$Type): void;
                setUnknownEventDetail(msg: string): void;
                setWasWrite(val: boolean): void;
                _address: Address;
                _detail: string;
                _pc: Address;
                _thread: ThreadProxy;
                _type: DebugEvent$Type;
                _wasWrite: boolean;
              }
              interface BasicDebugEvent extends CombineTypes<[_BasicDebugEvent, java.lang.Object, sun.jvm.hotspot.debugger.cdbg.DebugEvent]> {}
              interface _BasicDoubleType$$static extends ClassLike {
                new(name: string, size: int): BasicDoubleType;
              }
              let BasicDoubleType: _BasicDoubleType$$static;
              interface _BasicDoubleType {
                asDouble(): DoubleType;
                _createCVVariant(cvAttributes: int): Type;
                iterateObject(a: Address, v: ObjectVisitor, f: FieldIdentifier): void;
                visit(v: TypeVisitor): void;
              }
              interface BasicDoubleType extends CombineTypes<[_BasicDoubleType, sun.jvm.hotspot.debugger.cdbg.DoubleType, sun.jvm.hotspot.debugger.cdbg.basic.BasicType]> {}
              interface _BasicEnumType$$static extends ClassLike {
                new(name: string, underlyingType: Type): BasicEnumType;
              }
              let BasicEnumType: _BasicEnumType$$static;
              interface _BasicEnumType {
                addEnum(name: string, val: long): void;
                asEnum(): EnumType;
                _createCVVariant(cvAttributes: int): Type;
                enumNameForValue(val: long): string;
                getEnumName(i: int): string;
                getEnumValue(i: int): long;
                getNumEnumerates(): int;
                getSize(): int;
                isUnsigned(): boolean;
                iterateObject(a: Address, v: ObjectVisitor, f: FieldIdentifier): void;
                _resolveTypes(db: BasicCDebugInfoDataBase, listener: ResolveListener): Type;
                visit(v: TypeVisitor): void;
                _enums: java.util.List<BasicEnumType$Enum>;
                _underlyingType: Type;
              }
              interface BasicEnumType extends CombineTypes<[_BasicEnumType, sun.jvm.hotspot.debugger.cdbg.EnumType, sun.jvm.hotspot.debugger.cdbg.basic.BasicIntType]> {}
              interface _BasicEnumType$Enum$$static extends ClassLike {
                _new(name: string, value: long): BasicEnumType$Enum;
              }
              let BasicEnumType$Enum: _BasicEnumType$Enum$$static;
              interface _BasicEnumType$Enum {
                _getName(): string;
                _getValue(): long;
                _name: string;
                _value: long;
              }
              interface BasicEnumType$Enum extends CombineTypes<[_BasicEnumType$Enum, java.lang.Object]> {}
              interface _BasicField$$static extends ClassLike {
                new(name: string, type: Type, accessControl: int, isStatic: boolean): BasicField;
              }
              let BasicField: _BasicField$$static;
              interface _BasicField {
                getAccessControl(): int;
                getAddress(): Address;
                getName(): string;
                getOffset(): long;
                getType(): Type;
                isStatic(): boolean;
                resolveTypes(containingType: Type, db: BasicCDebugInfoDataBase, listener: ResolveListener): void;
                setAddress(address: Address): void;
                setOffset(offset: long): void;
                _accessControl: int;
                _address: Address;
                _isStatic: boolean;
                _name: string;
                _offset: long;
                _type: Type;
              }
              interface BasicField extends CombineTypes<[_BasicField, java.lang.Object, sun.jvm.hotspot.debugger.cdbg.Field]> {}
              interface _BasicFloatType$$static extends ClassLike {
                new(name: string, size: int): BasicFloatType;
              }
              let BasicFloatType: _BasicFloatType$$static;
              interface _BasicFloatType {
                asFloat(): FloatType;
                _createCVVariant(cvAttributes: int): Type;
                iterateObject(a: Address, v: ObjectVisitor, f: FieldIdentifier): void;
                visit(v: TypeVisitor): void;
              }
              interface BasicFloatType extends CombineTypes<[_BasicFloatType, sun.jvm.hotspot.debugger.cdbg.FloatType, sun.jvm.hotspot.debugger.cdbg.basic.BasicType]> {}
              interface _BasicFunctionSym$$static extends ClassLike {
                new(parent: BlockSym, length: long, a2: Address, addr: string, name: Type, type: boolean): BasicFunctionSym;
              }
              let BasicFunctionSym: _BasicFunctionSym$$static;
              interface _BasicFunctionSym {
                asFunction(): FunctionSym;
                getType(): Type;
                isModuleLocal(): boolean;
                resolve(db: BasicCDebugInfoDataBase, listener: ResolveListener): void;
                toString(): string;
                _isModuleLocal: boolean;
                _type: Type;
              }
              interface BasicFunctionSym extends CombineTypes<[_BasicFunctionSym, sun.jvm.hotspot.debugger.cdbg.FunctionSym, sun.jvm.hotspot.debugger.cdbg.basic.BasicBlockSym]> {}
              interface _BasicFunctionType$$static extends ClassLike {
                new(name: string, size: int, returnType: Type): BasicFunctionType;
                _new(name: string, size: int, returnType: Type, cvAttributes: int): BasicFunctionType;
              }
              let BasicFunctionType: _BasicFunctionType$$static;
              interface _BasicFunctionType {
                addArgumentType(t: Type): void;
                asFunction(): FunctionType;
                _createCVVariant(cvAttributes: int): Type;
                getArgumentType(i: int): Type;
                getNumArguments(): int;
                getReturnType(): Type;
                iterateObject(a: Address, v: ObjectVisitor, f: FieldIdentifier): void;
                _resolveTypes(db: BasicCDebugInfoDataBase, listener: ResolveListener): Type;
                visit(v: TypeVisitor): void;
                _argumentTypes: java.util.List<Type>;
                _returnType: Type;
              }
              interface BasicFunctionType extends CombineTypes<[_BasicFunctionType, sun.jvm.hotspot.debugger.cdbg.FunctionType, sun.jvm.hotspot.debugger.cdbg.basic.BasicType]> {}
              interface _BasicGlobalSym$$static extends ClassLike {
                new(name: string, type: Type, addr: Address, isModuleLocal: boolean): BasicGlobalSym;
              }
              let BasicGlobalSym: _BasicGlobalSym$$static;
              interface _BasicGlobalSym {
                asGlobal(): GlobalSym;
                getAddress(): Address;
                getType(): Type;
                isModuleLocal(): boolean;
                resolve(db: BasicCDebugInfoDataBase, listener: ResolveListener): void;
                _addr: Address;
                _isModuleLocal: boolean;
                _type: Type;
              }
              interface BasicGlobalSym extends CombineTypes<[_BasicGlobalSym, sun.jvm.hotspot.debugger.cdbg.basic.BasicSym, sun.jvm.hotspot.debugger.cdbg.GlobalSym]> {}
              interface _BasicIndexableFieldIdentifier$$static extends ClassLike {
                new(type: Type, index: int): BasicIndexableFieldIdentifier;
              }
              let BasicIndexableFieldIdentifier: _BasicIndexableFieldIdentifier$$static;
              interface _BasicIndexableFieldIdentifier {
                getIndex(): int;
                getType(): Type;
                toString(): string;
                _index: int;
                _type: Type;
              }
              interface BasicIndexableFieldIdentifier extends CombineTypes<[_BasicIndexableFieldIdentifier, sun.jvm.hotspot.debugger.cdbg.IndexableFieldIdentifier, java.lang.Object]> {}
              interface _BasicIntType$$static extends ClassLike {
                new(name: string, size: int, unsigned: boolean): BasicIntType;
                _new(name: string, size: int, unsigned: boolean, cvAttributes: int): BasicIntType;
              }
              let BasicIntType: _BasicIntType$$static;
              interface _BasicIntType {
                asInt(): IntType;
                _createCVVariant(cvAttributes: int): Type;
                getIntSize(): int;
                isUnsigned(): boolean;
                iterateObject(a: Address, v: ObjectVisitor, f: FieldIdentifier): void;
                visit(v: TypeVisitor): void;
                _unsigned: boolean;
              }
              interface BasicIntType extends CombineTypes<[_BasicIntType, sun.jvm.hotspot.debugger.cdbg.IntType, sun.jvm.hotspot.debugger.cdbg.basic.BasicType]> {}
              interface _BasicLineNumberInfo$$static extends ClassLike {
                new(sourceFileName: string, lineNo: int, startPC: Address, endPC: Address): BasicLineNumberInfo;
              }
              let BasicLineNumberInfo: _BasicLineNumberInfo$$static;
              interface _BasicLineNumberInfo {
                getEndPC(): Address;
                getLineNumber(): int;
                getSourceFileName(): string;
                getStartPC(): Address;
                setEndPC(pc: Address): void;
                _endPC: Address;
                _lineNo: int;
                _sourceFileName: string;
                _startPC: Address;
              }
              interface BasicLineNumberInfo extends CombineTypes<[_BasicLineNumberInfo, java.lang.Object, sun.jvm.hotspot.debugger.cdbg.LineNumberInfo]> {}
              interface _BasicLineNumberMapping$$static extends ClassLike {
                new(): BasicLineNumberMapping;
              }
              let BasicLineNumberMapping: _BasicLineNumberMapping$$static;
              interface _BasicLineNumberMapping {
                addLineNumberInfo(info: BasicLineNumberInfo): void;
                _check(addr: Address, idx: int): boolean;
                _get(i: int): BasicLineNumberInfo;
                iterate(v: LineNumberVisitor): void;
                lineNumberForPC(pc: Address): BasicLineNumberInfo;
                recomputeEndPCs(): void;
                _searchLineNumbers(addr: Address, lowIdx: int, highIdx: int): BasicLineNumberInfo;
                sort(): void;
                _infoList: java.util.List<BasicLineNumberInfo>;
              }
              interface BasicLineNumberMapping extends CombineTypes<[_BasicLineNumberMapping, java.lang.Object]> {}
              interface _BasicLocalSym$$static extends ClassLike {
                new(name: string, type: Type, frameOffset: long): BasicLocalSym;
              }
              let BasicLocalSym: _BasicLocalSym$$static;
              interface _BasicLocalSym {
                asLocal(): LocalSym;
                getFrameOffset(): long;
                getType(): Type;
                resolve(db: BasicCDebugInfoDataBase, listener: ResolveListener): void;
                _frameOffset: long;
                _type: Type;
              }
              interface BasicLocalSym extends CombineTypes<[_BasicLocalSym, sun.jvm.hotspot.debugger.cdbg.basic.BasicSym, sun.jvm.hotspot.debugger.cdbg.LocalSym]> {}
              interface _BasicMemberFunctionType$$static extends ClassLike {
                new(name: string, size: int, returnType: Type, containingClass: Type, thisType: Type, thisAdjust: long): BasicMemberFunctionType;
              }
              let BasicMemberFunctionType: _BasicMemberFunctionType$$static;
              interface _BasicMemberFunctionType {
                asMemberFunction(): MemberFunctionType;
                _createCVVariant(cvAttributes: int): Type;
                getContainingClass(): Type;
                getThisAdjust(): long;
                getThisType(): Type;
                iterateObject(a: Address, v: ObjectVisitor, f: FieldIdentifier): void;
                _resolveTypes(db: BasicCDebugInfoDataBase, listener: ResolveListener): Type;
                visit(v: TypeVisitor): void;
                _containingClass: Type;
                _thisAdjust: long;
                _thisType: Type;
              }
              interface BasicMemberFunctionType extends CombineTypes<[_BasicMemberFunctionType, sun.jvm.hotspot.debugger.cdbg.MemberFunctionType, sun.jvm.hotspot.debugger.cdbg.basic.BasicFunctionType]> {}
              interface _BasicNamedFieldIdentifier$$static extends ClassLike {
                new(field: Field): BasicNamedFieldIdentifier;
              }
              let BasicNamedFieldIdentifier: _BasicNamedFieldIdentifier$$static;
              interface _BasicNamedFieldIdentifier {
                getName(): string;
                getType(): Type;
                toString(): string;
                _field: Field;
              }
              interface BasicNamedFieldIdentifier extends CombineTypes<[_BasicNamedFieldIdentifier, java.lang.Object, sun.jvm.hotspot.debugger.cdbg.NamedFieldIdentifier]> {}
              interface _BasicPointerType$$static extends ClassLike {
                new(size: int, targetType: Type): BasicPointerType;
              }
              let BasicPointerType: _BasicPointerType$$static;
              interface _BasicPointerType {
                asPointer(): PointerType;
                _computeName(): void;
                _createCVVariant(cvAttributes: int): Type;
                getTargetType(): Type;
                iterateObject(a: Address, v: ObjectVisitor, f: FieldIdentifier): void;
                _resolveTypes(db: BasicCDebugInfoDataBase, listener: ResolveListener): Type;
                visit(v: TypeVisitor): void;
                _targetType: Type;
              }
              interface BasicPointerType extends CombineTypes<[_BasicPointerType, sun.jvm.hotspot.debugger.cdbg.PointerType, sun.jvm.hotspot.debugger.cdbg.basic.BasicType]> {}
              interface _BasicRefType$$static extends ClassLike {
                new(name: string, size: int, targetType: Type): BasicRefType;
              }
              let BasicRefType: _BasicRefType$$static;
              interface _BasicRefType {
                asRef(): RefType;
                _computeName(): void;
                _createCVVariant(cvAttributes: int): Type;
                getTargetType(): Type;
                iterateObject(a: Address, v: ObjectVisitor, f: FieldIdentifier): void;
                _resolveTypes(db: BasicCDebugInfoDataBase, listener: ResolveListener): Type;
                visit(v: TypeVisitor): void;
                _targetType: Type;
              }
              interface BasicRefType extends CombineTypes<[_BasicRefType, sun.jvm.hotspot.debugger.cdbg.RefType, sun.jvm.hotspot.debugger.cdbg.basic.BasicType]> {}
              interface _BasicSym$$static extends ClassLike {
                _new(name: string): BasicSym;
              }
              let BasicSym: _BasicSym$$static;
              interface _BasicSym {
                asBlock(): BlockSym;
                asFunction(): FunctionSym;
                asGlobal(): GlobalSym;
                asLocal(): LocalSym;
                getName(): string;
                isBlock(): boolean;
                isFunction(): boolean;
                isGlobal(): boolean;
                isLazy(): boolean;
                isLocal(): boolean;
                resolve(a0: BasicCDebugInfoDataBase, a1: ResolveListener): void;
(a0: BasicCDebugInfoDataBase, a1: ResolveListener): void;
                toString(): string;
                _name: string;
              }
              interface BasicSym extends CombineTypes<[_BasicSym, sun.jvm.hotspot.debugger.cdbg.Sym, java.lang.Object]> {}
              interface _BasicType$$static extends ClassLike {
                _new(name: string, size: int): BasicType;
                _new(name: string, size: int, cvAttributes: int): BasicType;
              }
              let BasicType: _BasicType$$static;
              interface _BasicType {
                _addCVVariant(t: Type): void;
                asArray(): ArrayType;
                asBit(): BitType;
                asCompound(): CompoundType;
                asDouble(): DoubleType;
                asEnum(): EnumType;
                asFloat(): FloatType;
                asFunction(): FunctionType;
                asInt(): IntType;
                asMemberFunction(): MemberFunctionType;
                asPointer(): PointerType;
                asRef(): RefType;
                asVoid(): VoidType;
                _createCVVariant(a0: int): Type;
                _findCVVariant(cvAttributes: int): Type;
                _getCVAttributes(): int;
                getCVVariant(cvAttributes: int): Type;
                getName(): string;
                getSize(): int;
                isArray(): boolean;
                isBit(): boolean;
                isCompound(): boolean;
                isConst(): boolean;
                isDouble(): boolean;
                isEnum(): boolean;
                isFloat(): boolean;
                isFunction(): boolean;
                isInt(): boolean;
                isLazy(): boolean;
                isMemberFunction(): boolean;
                isPointer(): boolean;
                isRef(): boolean;
                isVoid(): boolean;
                isVolatile(): boolean;
                iterateObject(a: Address, v: ObjectVisitor): void;
                iterateObject(a0: Address, a1: ObjectVisitor, a2: FieldIdentifier): void;
                _resolveTypes(db: BasicCDebugInfoDataBase, listener: ResolveListener): Type;
                _setName(name: string): void;
                toString(): string;
                visit(a0: TypeVisitor): void;
                _cvAttributes: int;
                _cvVariants: java.util.List<Type>;
                _name: string;
                _size: int;
              }
              interface BasicType extends CombineTypes<[_BasicType, sun.jvm.hotspot.debugger.cdbg.Type, java.lang.Object, sun.jvm.hotspot.debugger.cdbg.CVAttributes]> {}
              interface _BasicVoidType$$static extends ClassLike {
                new(): BasicVoidType;
              }
              let BasicVoidType: _BasicVoidType$$static;
              interface _BasicVoidType {
                asVoid(): VoidType;
                _createCVVariant(cvAttributes: int): Type;
                iterateObject(a: Address, v: ObjectVisitor, f: FieldIdentifier): void;
                visit(v: TypeVisitor): void;
              }
              interface BasicVoidType extends CombineTypes<[_BasicVoidType, sun.jvm.hotspot.debugger.cdbg.VoidType, sun.jvm.hotspot.debugger.cdbg.basic.BasicType]> {}
              interface _CompoundTypeKind$$static extends ClassLike {
                readonly CLASS: CompoundTypeKind;
                readonly STRUCT: CompoundTypeKind;
                readonly UNION: CompoundTypeKind;
              }
              let CompoundTypeKind: _CompoundTypeKind$$static;
              interface _CompoundTypeKind {
              }
              interface CompoundTypeKind extends CombineTypes<[_CompoundTypeKind, java.lang.Object]> {}
              interface _LazyBlockSym$$static extends ClassLike {
                new(key: any): LazyBlockSym;
              }
              let LazyBlockSym: _LazyBlockSym$$static;
              interface _LazyBlockSym {
                asBlock(): BlockSym;
                getAddress(): Address;
                getKey(): any;
                getLength(): long;
                getLocal(i: int): LocalSym;
                getNumLocals(): int;
                getParent(): BlockSym;
                isLazy(): boolean;
                resolve(db: BasicCDebugInfoDataBase, listener: ResolveListener): void;
                _key: any;
              }
              interface LazyBlockSym extends CombineTypes<[_LazyBlockSym, sun.jvm.hotspot.debugger.cdbg.basic.BasicSym, sun.jvm.hotspot.debugger.cdbg.BlockSym]> {}
              interface _LazyType$$static extends ClassLike {
                new(key: any): LazyType;
              }
              let LazyType: _LazyType$$static;
              interface _LazyType {
                _createCVVariant(cvAttributes: int): Type;
                getKey(): any;
                isLazy(): boolean;
                iterateObject(a: Address, v: ObjectVisitor, f: FieldIdentifier): void;
                _resolveTypes(db: BasicCDebugInfoDataBase, listener: ResolveListener): Type;
                visit(v: TypeVisitor): void;
                _cvAttributes: int;
                _key: any;
              }
              interface LazyType extends CombineTypes<[_LazyType, sun.jvm.hotspot.debugger.cdbg.basic.BasicType]> {}
              interface _ResolveListener$$static extends ClassLike {
              }
              let ResolveListener: _ResolveListener$$static;
              interface _ResolveListener {
                resolveFailed(a0: Type, a1: LazyType, a2: string): void;
                resolveFailed(a0: Type, a1: string): void;
                resolveFailed(a0: Sym, a1: LazyType, a2: string): void;
                resolveFailed(a0: Sym, a1: LazyBlockSym, a2: string): void;
              }
              interface ResolveListener extends CombineTypes<[_ResolveListener, java.lang.Object]> {}
            }
            interface _AccessControl$$static extends ClassLike {
              readonly NO_PROTECTION: int;
              readonly PRIVATE: int;
              readonly PROTECTED: int;
              readonly PUBLIC: int;
            }
            let AccessControl: _AccessControl$$static;
            interface _AccessControl {
            }
            interface AccessControl extends CombineTypes<[_AccessControl, java.lang.Object]> {}
            interface _ArrayType$$static extends ClassLike {
            }
            let ArrayType: _ArrayType$$static;
            interface _ArrayType {
              getElementType(): Type;
              getLength(): int;
            }
            interface ArrayType extends CombineTypes<[_ArrayType, sun.jvm.hotspot.debugger.cdbg.Type, java.lang.Object]> {}
            interface _BaseClass$$static extends ClassLike {
            }
            let BaseClass: _BaseClass$$static;
            interface _BaseClass {
              getAccessControl(): int;
              getType(): Type;
              isVirtual(): boolean;
            }
            interface BaseClass extends CombineTypes<[_BaseClass, java.lang.Object]> {}
            interface _BitType$$static extends ClassLike {
            }
            let BitType: _BitType$$static;
            interface _BitType {
              getOffset(): int;
              getSizeInBits(): int;
            }
            interface BitType extends CombineTypes<[_BitType, java.lang.Object, sun.jvm.hotspot.debugger.cdbg.IntType]> {}
            interface _BlockSym$$static extends ClassLike {
            }
            let BlockSym: _BlockSym$$static;
            interface _BlockSym {
              getAddress(): Address;
              getLength(): long;
              getLocal(a0: int): LocalSym;
              getName(): string;
              getNumLocals(): int;
              getParent(): BlockSym;
            }
            interface BlockSym extends CombineTypes<[_BlockSym, sun.jvm.hotspot.debugger.cdbg.Sym, java.lang.Object]> {}
            interface _CDebugInfoDataBase$$static extends ClassLike {
            }
            let CDebugInfoDataBase: _CDebugInfoDataBase$$static;
            interface _CDebugInfoDataBase {
              debugInfoForPC(a0: Address): BlockSym;
              iterate(a0: TypeVisitor): void;
              iterate(a0: LineNumberVisitor): void;
              lineNumberForPC(a0: Address): LineNumberInfo;
              lookupSym(a0: string): GlobalSym;
              lookupType(a0: string): Type;
              lookupType(a0: string, a1: int): Type;
            }
            interface CDebugInfoDataBase extends CombineTypes<[_CDebugInfoDataBase, java.lang.Object]> {}
            interface _CDebugger$$static extends ClassLike {
            }
            let CDebugger: _CDebugger$$static;
            interface _CDebugger {
              canDemangle(): boolean;
              demangle(a0: string): string;
              getLoadObjectList(): java.util.List<LoadObject>;
              getNameOfFile(a0: string): string;
              getProcessControl(): ProcessControl;
              getThreadList(): java.util.List<ThreadProxy>;
              loadObjectContainingPC(a0: Address): LoadObject;
              topFrameForThread(a0: ThreadProxy): CFrame;
            }
            interface CDebugger extends CombineTypes<[_CDebugger, java.lang.Object]> {}
            interface _CFrame$$static extends ClassLike {
            }
            let CFrame: _CFrame$$static;
            interface _CFrame {
              blockForPC(): BlockSym;
              closestSymbolToPC(): ClosestSymbol;
              iterateLocals(a0: ObjectVisitor): void;
              loadObjectForPC(): LoadObject;
              localVariableBase(): Address;
              pc(): Address;
              sender(a0: ThreadProxy): CFrame;
            }
            interface CFrame extends CombineTypes<[_CFrame, java.lang.Object]> {}
            interface _CVAttributes$$static extends ClassLike {
              readonly CONST: int;
              readonly VOLATILE: int;
            }
            let CVAttributes: _CVAttributes$$static;
            interface _CVAttributes {
            }
            interface CVAttributes extends CombineTypes<[_CVAttributes, java.lang.Object]> {}
            interface _ClosestSymbol$$static extends ClassLike {
              new(name: string, offset: long): ClosestSymbol;
            }
            let ClosestSymbol: _ClosestSymbol$$static;
            interface _ClosestSymbol {
              getName(): string;
              getOffset(): long;
              offsetAsHex(): string;
              _name: string;
              _offset: long;
            }
            interface ClosestSymbol extends CombineTypes<[_ClosestSymbol, java.lang.Object]> {}
            interface _CompoundType$$static extends ClassLike {
            }
            let CompoundType: _CompoundType$$static;
            interface _CompoundType {
              getBaseClass(a0: int): BaseClass;
              getField(a0: int): Field;
              getNumBaseClasses(): int;
              getNumFields(): int;
              isClass(): boolean;
              isStruct(): boolean;
              isUnion(): boolean;
            }
            interface CompoundType extends CombineTypes<[_CompoundType, java.lang.Object]> {}
            interface _DebugEvent$$static extends ClassLike {
            }
            let DebugEvent: _DebugEvent$$static;
            interface _DebugEvent {
              getAddress(): Address;
              getPC(): Address;
              getThread(): ThreadProxy;
              getType(): DebugEvent$Type;
              getUnknownEventDetail(): string;
              getWasWrite(): boolean;
            }
            interface DebugEvent extends CombineTypes<[_DebugEvent, java.lang.Object]> {}
            interface _DebugEvent$Type$$static extends ClassLike {
              readonly ACCESS_VIOLATION: DebugEvent$Type;
              readonly BREAKPOINT: DebugEvent$Type;
              readonly LOADOBJECT_LOAD: DebugEvent$Type;
              readonly LOADOBJECT_UNLOAD: DebugEvent$Type;
              readonly SINGLE_STEP: DebugEvent$Type;
              readonly UNKNOWN: DebugEvent$Type;
            }
            let DebugEvent$Type: _DebugEvent$Type$$static;
            interface _DebugEvent$Type {
            }
            interface DebugEvent$Type extends CombineTypes<[_DebugEvent$Type, java.lang.Object]> {}
            interface _DefaultObjectVisitor$$static extends ClassLike {
              new(): DefaultObjectVisitor;
            }
            let DefaultObjectVisitor: _DefaultObjectVisitor$$static;
            interface _DefaultObjectVisitor {
              doArray(f: FieldIdentifier, val: Address): void;
              doBit(f: FieldIdentifier, val: long): void;
              doCompound(f: FieldIdentifier, addressOfEmbeddedCompoundObject: Address): void;
              doDouble(f: FieldIdentifier, val: double): void;
              doEnum(f: FieldIdentifier, val: long, a2: string): void;
              doFloat(f: FieldIdentifier, val: float): void;
              doInt(f: FieldIdentifier, val: long): void;
              doPointer(f: FieldIdentifier, val: Address): void;
              doRef(f: FieldIdentifier, val: Address): void;
              enterType(type: Type, objectAddress: Address): void;
              exitType(): void;
            }
            interface DefaultObjectVisitor extends CombineTypes<[_DefaultObjectVisitor, java.lang.Object, sun.jvm.hotspot.debugger.cdbg.ObjectVisitor]> {}
            interface _DoubleType$$static extends ClassLike {
            }
            let DoubleType: _DoubleType$$static;
            interface _DoubleType {
            }
            interface DoubleType extends CombineTypes<[_DoubleType, sun.jvm.hotspot.debugger.cdbg.Type, java.lang.Object]> {}
            interface _EnumType$$static extends ClassLike {
            }
            let EnumType: _EnumType$$static;
            interface _EnumType {
              enumNameForValue(a0: long): string;
              getEnumName(a0: int): string;
              getEnumValue(a0: int): long;
              getNumEnumerates(): int;
            }
            interface EnumType extends CombineTypes<[_EnumType, java.lang.Object, sun.jvm.hotspot.debugger.cdbg.IntType]> {}
            interface _Field$$static extends ClassLike {
            }
            let Field: _Field$$static;
            interface _Field {
              getAccessControl(): int;
              getAddress(): Address;
              getName(): string;
              getOffset(): long;
              getType(): Type;
              isStatic(): boolean;
            }
            interface Field extends CombineTypes<[_Field, java.lang.Object]> {}
            interface _FieldIdentifier$$static extends ClassLike {
            }
            let FieldIdentifier: _FieldIdentifier$$static;
            interface _FieldIdentifier {
              getType(): Type;
              toString(): string;
            }
            interface FieldIdentifier extends CombineTypes<[_FieldIdentifier, java.lang.Object]> {}
            interface _FloatType$$static extends ClassLike {
            }
            let FloatType: _FloatType$$static;
            interface _FloatType {
            }
            interface FloatType extends CombineTypes<[_FloatType, sun.jvm.hotspot.debugger.cdbg.Type, java.lang.Object]> {}
            interface _FunctionSym$$static extends ClassLike {
            }
            let FunctionSym: _FunctionSym$$static;
            interface _FunctionSym {
              getType(): Type;
              isModuleLocal(): boolean;
              toString(): string;
            }
            interface FunctionSym extends CombineTypes<[_FunctionSym, sun.jvm.hotspot.debugger.cdbg.BlockSym, java.lang.Object]> {}
            interface _FunctionType$$static extends ClassLike {
            }
            let FunctionType: _FunctionType$$static;
            interface _FunctionType {
              getArgumentType(a0: int): Type;
              getNumArguments(): int;
              getReturnType(): Type;
            }
            interface FunctionType extends CombineTypes<[_FunctionType, sun.jvm.hotspot.debugger.cdbg.Type, java.lang.Object]> {}
            interface _GlobalSym$$static extends ClassLike {
            }
            let GlobalSym: _GlobalSym$$static;
            interface _GlobalSym {
              getAddress(): Address;
              getName(): string;
              getType(): Type;
              isModuleLocal(): boolean;
            }
            interface GlobalSym extends CombineTypes<[_GlobalSym, sun.jvm.hotspot.debugger.cdbg.Sym, java.lang.Object]> {}
            interface _IndexableFieldIdentifier$$static extends ClassLike {
            }
            let IndexableFieldIdentifier: _IndexableFieldIdentifier$$static;
            interface _IndexableFieldIdentifier {
              getIndex(): int;
(): int;
            }
            interface IndexableFieldIdentifier extends CombineTypes<[_IndexableFieldIdentifier, sun.jvm.hotspot.debugger.cdbg.FieldIdentifier, java.lang.Object]> {}
            interface _IntType$$static extends ClassLike {
            }
            let IntType: _IntType$$static;
            interface _IntType {
              getIntSize(): int;
              isUnsigned(): boolean;
            }
            interface IntType extends CombineTypes<[_IntType, sun.jvm.hotspot.debugger.cdbg.Type, java.lang.Object]> {}
            interface _LineNumberInfo$$static extends ClassLike {
            }
            let LineNumberInfo: _LineNumberInfo$$static;
            interface _LineNumberInfo {
              getEndPC(): Address;
              getLineNumber(): int;
              getSourceFileName(): string;
              getStartPC(): Address;
            }
            interface LineNumberInfo extends CombineTypes<[_LineNumberInfo, java.lang.Object]> {}
            interface _LineNumberVisitor$$static extends ClassLike {
            }
            let LineNumberVisitor: _LineNumberVisitor$$static;
            interface _LineNumberVisitor {
              doLineNumber(a0: LineNumberInfo): void;
(a0: LineNumberInfo): void;
            }
            interface LineNumberVisitor extends CombineTypes<[_LineNumberVisitor, java.lang.Object]> {}
            interface _LoadObject$$static extends ClassLike {
            }
            let LoadObject: _LoadObject$$static;
            interface _LoadObject {
              closestSymbolToPC(a0: Address): ClosestSymbol;
              debugInfoForPC(a0: Address): BlockSym;
              getBase(): Address;
              getDebugInfoDataBase(): CDebugInfoDataBase;
              getName(): string;
              getSize(): long;
              lineNumberForPC(a0: Address): LineNumberInfo;
            }
            interface LoadObject extends CombineTypes<[_LoadObject, java.lang.Object]> {}
            interface _LoadObjectComparator$$static extends ClassLike {
              new(): LoadObjectComparator;
            }
            let LoadObjectComparator: _LoadObjectComparator$$static;
            interface _LoadObjectComparator {
              compare(lo1: LoadObject, lo2: LoadObject): int;
              compare(a0: any, a1: any): int;
              equals(o: any): boolean;
            }
            interface LoadObjectComparator extends CombineTypes<[_LoadObjectComparator, java.util.Comparator<LoadObject>, java.lang.Object]> {}
            interface _LocalSym$$static extends ClassLike {
            }
            let LocalSym: _LocalSym$$static;
            interface _LocalSym {
              getFrameOffset(): long;
              getName(): string;
              getType(): Type;
            }
            interface LocalSym extends CombineTypes<[_LocalSym, sun.jvm.hotspot.debugger.cdbg.Sym, java.lang.Object]> {}
            interface _MemberFunctionType$$static extends ClassLike {
            }
            let MemberFunctionType: _MemberFunctionType$$static;
            interface _MemberFunctionType {
              getContainingClass(): Type;
              getThisAdjust(): long;
              getThisType(): Type;
            }
            interface MemberFunctionType extends CombineTypes<[_MemberFunctionType, java.lang.Object, sun.jvm.hotspot.debugger.cdbg.FunctionType]> {}
            interface _NamedFieldIdentifier$$static extends ClassLike {
            }
            let NamedFieldIdentifier: _NamedFieldIdentifier$$static;
            interface _NamedFieldIdentifier {
              getName(): string;
(): string;
            }
            interface NamedFieldIdentifier extends CombineTypes<[_NamedFieldIdentifier, sun.jvm.hotspot.debugger.cdbg.FieldIdentifier, java.lang.Object]> {}
            interface _ObjectVisitor$$static extends ClassLike {
            }
            let ObjectVisitor: _ObjectVisitor$$static;
            interface _ObjectVisitor {
              doArray(a0: FieldIdentifier, a1: Address): void;
              doBit(a0: FieldIdentifier, a1: long): void;
              doCompound(a0: FieldIdentifier, a1: Address): void;
              doDouble(a0: FieldIdentifier, a1: double): void;
              doEnum(a0: FieldIdentifier, a1: long, a2: string): void;
              doFloat(a0: FieldIdentifier, a1: float): void;
              doInt(a0: FieldIdentifier, a1: long): void;
              doPointer(a0: FieldIdentifier, a1: Address): void;
              doRef(a0: FieldIdentifier, a1: Address): void;
              enterType(a0: Type, a1: Address): void;
              exitType(): void;
            }
            interface ObjectVisitor extends CombineTypes<[_ObjectVisitor, java.lang.Object]> {}
            interface _PointerType$$static extends ClassLike {
            }
            let PointerType: _PointerType$$static;
            interface _PointerType {
              getTargetType(): Type;
(): Type;
            }
            interface PointerType extends CombineTypes<[_PointerType, sun.jvm.hotspot.debugger.cdbg.Type, java.lang.Object]> {}
            interface _ProcessControl$$static extends ClassLike {
            }
            let ProcessControl: _ProcessControl$$static;
            interface _ProcessControl {
              clearBreakpoint(a0: Address): void;
              debugEventContinue(): void;
              debugEventPoll(): DebugEvent;
              isBreakpointSet(a0: Address): boolean;
              isSuspended(): boolean;
              resume(): void;
              setBreakpoint(a0: Address): void;
              suspend(): void;
            }
            interface ProcessControl extends CombineTypes<[_ProcessControl, java.lang.Object]> {}
            interface _RefType$$static extends ClassLike {
            }
            let RefType: _RefType$$static;
            interface _RefType {
              getTargetType(): Type;
(): Type;
            }
            interface RefType extends CombineTypes<[_RefType, sun.jvm.hotspot.debugger.cdbg.Type, java.lang.Object]> {}
            interface _Sym$$static extends ClassLike {
            }
            let Sym: _Sym$$static;
            interface _Sym {
              asBlock(): BlockSym;
              asFunction(): FunctionSym;
              asGlobal(): GlobalSym;
              asLocal(): LocalSym;
              getName(): string;
              isBlock(): boolean;
              isFunction(): boolean;
              isGlobal(): boolean;
              isLocal(): boolean;
              toString(): string;
            }
            interface Sym extends CombineTypes<[_Sym, java.lang.Object]> {}
            interface _TemplateType$$static extends ClassLike {
            }
            let TemplateType: _TemplateType$$static;
            interface _TemplateType {
              getNumTemplateArguments(): int;
              instantiate(a0: Type[]): Type;
              instantiate(a0: java.util.List<Type>): Type;
            }
            interface TemplateType extends CombineTypes<[_TemplateType, sun.jvm.hotspot.debugger.cdbg.Type, java.lang.Object]> {}
            interface _Type$$static extends ClassLike {
            }
            let Type: _Type$$static;
            interface _Type {
              asArray(): ArrayType;
              asBit(): BitType;
              asCompound(): CompoundType;
              asDouble(): DoubleType;
              asEnum(): EnumType;
              asFloat(): FloatType;
              asFunction(): FunctionType;
              asInt(): IntType;
              asMemberFunction(): MemberFunctionType;
              asPointer(): PointerType;
              asRef(): RefType;
              asVoid(): VoidType;
              getName(): string;
              getSize(): int;
              isArray(): boolean;
              isBit(): boolean;
              isCompound(): boolean;
              isConst(): boolean;
              isDouble(): boolean;
              isEnum(): boolean;
              isFloat(): boolean;
              isFunction(): boolean;
              isInt(): boolean;
              isMemberFunction(): boolean;
              isPointer(): boolean;
              isRef(): boolean;
              isVoid(): boolean;
              isVolatile(): boolean;
              iterateObject(a0: Address, a1: ObjectVisitor): void;
              iterateObject(a0: Address, a1: ObjectVisitor, a2: FieldIdentifier): void;
              toString(): string;
            }
            interface Type extends CombineTypes<[_Type, java.lang.Object]> {}
            interface _TypeVisitor$$static extends ClassLike {
            }
            let TypeVisitor: _TypeVisitor$$static;
            interface _TypeVisitor {
              doArrayType(a0: ArrayType): void;
              doBitType(a0: BitType): void;
              doCompoundType(a0: CompoundType): void;
              doDoubleType(a0: DoubleType): void;
              doEnumType(a0: EnumType): void;
              doFloatType(a0: FloatType): void;
              doFunctionType(a0: FunctionType): void;
              doIntType(a0: IntType): void;
              doMemberFunctionType(a0: MemberFunctionType): void;
              doPointerType(a0: PointerType): void;
              doRefType(a0: RefType): void;
              doVoidType(a0: VoidType): void;
            }
            interface TypeVisitor extends CombineTypes<[_TypeVisitor, java.lang.Object]> {}
            interface _VoidType$$static extends ClassLike {
            }
            let VoidType: _VoidType$$static;
            interface _VoidType {
            }
            interface VoidType extends CombineTypes<[_VoidType, sun.jvm.hotspot.debugger.cdbg.Type, java.lang.Object]> {}
          }
          module dummy {
            interface _DummyAddress$$static extends ClassLike {
              _check(arg: boolean, failMessage: string): void;
              main(args: string[]): void;
              _badDouble: double;
              _badLong: long;
              _new(debugger: DummyDebugger, addr: long): DummyAddress;
            }
            let DummyAddress: _DummyAddress$$static;
            interface _DummyAddress {
              addOffsetTo(offset: long): Address;
              addOffsetToAsOopHandle(offset: long): OopHandle;
              andWithMask(mask: long): Address;
              asLongValue(): long;
              equals(arg: any): boolean;
              getAddressAt(offset: long): Address;
              getCIntegerAt(offset: long, a1: long, numBytes: boolean): long;
              getCompKlassAddressAt(offset: long): Address;
              getCompOopAddressAt(offset: long): Address;
              getCompOopHandleAt(offset: long): OopHandle;
              getJBooleanAt(offset: long): boolean;
              getJByteAt(offset: long): byte;
              getJCharAt(offset: long): char;
              getJDoubleAt(offset: long): double;
              getJFloatAt(offset: long): float;
              getJIntAt(offset: long): int;
              getJLongAt(offset: long): long;
              getJShortAt(offset: long): short;
              getOopHandleAt(offset: long): OopHandle;
              greaterThan(arg: Address): boolean;
              greaterThanOrEqual(arg: Address): boolean;
              hashCode(): int;
              lessThan(arg: Address): boolean;
              lessThanOrEqual(arg: Address): boolean;
              minus(arg: Address): long;
              orWithMask(mask: long): Address;
              setAddressAt(offset: long, a1: Address): void;
              setCIntegerAt(offset: long, a1: long, numBytes: long): void;
              setJBooleanAt(offset: long, a1: boolean): void;
              setJByteAt(offset: long, a1: byte): void;
              setJCharAt(offset: long, a1: char): void;
              setJDoubleAt(offset: long, a1: double): void;
              setJFloatAt(offset: long, a1: float): void;
              setJIntAt(offset: long, a1: int): void;
              setJLongAt(offset: long, a1: long): void;
              setJShortAt(offset: long, a1: short): void;
              setOopHandleAt(offset: long, a1: OopHandle): void;
              toString(): string;
              xorWithMask(mask: long): Address;
              _addr: long;
              _debugger: DummyDebugger;
            }
            interface DummyAddress extends CombineTypes<[_DummyAddress, java.lang.Object, sun.jvm.hotspot.debugger.Address]> {}
            interface _DummyDebugger$$static extends ClassLike {
              new(machDesc: MachineDescription): DummyDebugger;
            }
            let DummyDebugger: _DummyDebugger$$static;
            interface _DummyDebugger {
              _addressToString(addr: DummyAddress): string;
              attach(processID: int): void;
              attach(executableName: string, coreFileName: string): void;
              _charToNibble(ascii: char): int;
              consoleExecuteCommand(cmd: string): string;
              detach(): boolean;
              getAddressValue(addr: Address): long;
              getCDebugger(): debugger.cdbg.CDebugger;
              getCPU(): string;
              getConsolePrompt(): string;
              getMachineDescription(): MachineDescription;
              getOS(): string;
              getProcessList(): java.util.List<ProcessInfo>;
              getThreadForIdentifierAddress(addr: Address): ThreadProxy;
              getThreadForThreadId(id: long): ThreadProxy;
              hasConsole(): boolean;
              hasProcessList(): boolean;
              lookup(objectName: string, symbol: string): Address;
              lookupOop(objectName: string, symbol: string): OopHandle;
              parseAddress(addrStr: string): Address;
              readBytesFromProcess(address: long, a1: long): ReadResult;
              _machDesc: MachineDescription;
            }
            interface DummyDebugger extends CombineTypes<[_DummyDebugger, sun.jvm.hotspot.debugger.DebuggerBase]> {}
            interface _DummyOopHandle$$static extends ClassLike {
              _new(debugger: DummyDebugger, addr: long): DummyOopHandle;
            }
            let DummyOopHandle: _DummyOopHandle$$static;
            interface _DummyOopHandle {
              addOffsetTo(offset: long): Address;
              andWithMask(mask: long): Address;
              equals(arg: any): boolean;
              orWithMask(mask: long): Address;
              xorWithMask(mask: long): Address;
            }
            interface DummyOopHandle extends CombineTypes<[_DummyOopHandle, sun.jvm.hotspot.debugger.dummy.DummyAddress, sun.jvm.hotspot.debugger.OopHandle]> {}
          }
          module linux {
            module aarch64 {
              interface _LinuxAARCH64CFrame$$static extends ClassLike {
                _ADDRESS_SIZE: int;
                new(dbg: LinuxDebugger, fp: Address, pc: Address): LinuxAARCH64CFrame;
              }
              let LinuxAARCH64CFrame: _LinuxAARCH64CFrame$$static;
              interface _LinuxAARCH64CFrame {
                closestSymbolToPC(): debugger.cdbg.ClosestSymbol;
                localVariableBase(): Address;
                pc(): Address;
                sender(thread: ThreadProxy): debugger.cdbg.CFrame;
                _dbg: LinuxDebugger;
                _fp: Address;
                _pc: Address;
                _sp: Address;
              }
              interface LinuxAARCH64CFrame extends CombineTypes<[_LinuxAARCH64CFrame, sun.jvm.hotspot.debugger.cdbg.basic.BasicCFrame]> {}
              interface _LinuxAARCH64ThreadContext$$static extends ClassLike {
                new(debugger: LinuxDebugger): LinuxAARCH64ThreadContext;
              }
              let LinuxAARCH64ThreadContext: _LinuxAARCH64ThreadContext$$static;
              interface _LinuxAARCH64ThreadContext {
                getRegisterAsAddress(index: int): Address;
                setRegisterAsAddress(index: int, value: Address): void;
                _debugger: LinuxDebugger;
              }
              interface LinuxAARCH64ThreadContext extends CombineTypes<[_LinuxAARCH64ThreadContext, sun.jvm.hotspot.debugger.aarch64.AARCH64ThreadContext]> {}
            }
            module amd64 {
              interface _DwarfParser$$static extends ClassLike {
                _cleanerFor(context: long): java.lang.Runnable;
                _createDwarfContext(a0: long): long;
                _destroyDwarfContext(a0: long): void;
                _init0(): void;
                _CLEANER: java.lang.ref.Cleaner;
                new(lib: Address): DwarfParser;
              }
              let DwarfParser: _DwarfParser$$static;
              interface _DwarfParser {
                getBasePointerOffsetFromCFA(): int;
                getCFAOffset(): int;
                getCFARegister(): int;
                getReturnAddressOffsetFromCFA(): int;
                isBPOffsetAvailable(): boolean;
                isIn(pc: Address): boolean;
                _isIn0(a0: long): boolean;
                processDwarf(pc: Address): void;
                _processDwarf0(a0: long): void;
                _p_dwarf_context: long;
              }
              interface DwarfParser extends CombineTypes<[_DwarfParser, java.lang.Object]> {}
              interface _LinuxAMD64CFrame$$static extends ClassLike {
                getTopFrame(dbg: LinuxDebugger, rip: Address, context: ThreadContext): LinuxAMD64CFrame;
                _ADDRESS_SIZE: int;
              }
              let LinuxAMD64CFrame: _LinuxAMD64CFrame$$static;
              interface _LinuxAMD64CFrame {
                closestSymbolToPC(): debugger.cdbg.ClosestSymbol;
                _getNextCFA(nextDwarf: DwarfParser, context: ThreadContext): Address;
                _getNextPC(useDwarf: boolean): Address;
                _isValidFrame(nextCFA: Address, context: ThreadContext): boolean;
                localVariableBase(): Address;
                pc(): Address;
                sender(thread: ThreadProxy): debugger.cdbg.CFrame;
                _cfa: Address;
                _dbg: LinuxDebugger;
                _dwarf: DwarfParser;
                _finalFrame: boolean;
                _rip: Address;
              }
              interface LinuxAMD64CFrame extends CombineTypes<[_LinuxAMD64CFrame, sun.jvm.hotspot.debugger.cdbg.basic.BasicCFrame]> {}
              interface _LinuxAMD64ThreadContext$$static extends ClassLike {
                new(debugger: LinuxDebugger): LinuxAMD64ThreadContext;
              }
              let LinuxAMD64ThreadContext: _LinuxAMD64ThreadContext$$static;
              interface _LinuxAMD64ThreadContext {
                getRegisterAsAddress(index: int): Address;
                setRegisterAsAddress(index: int, value: Address): void;
                _debugger: LinuxDebugger;
              }
              interface LinuxAMD64ThreadContext extends CombineTypes<[_LinuxAMD64ThreadContext, sun.jvm.hotspot.debugger.amd64.AMD64ThreadContext]> {}
            }
            module ppc64 {
              interface _LinuxPPC64CFrame$$static extends ClassLike {
                PPC64_STACK_BIAS: int;
                _address_size: int;
                new(dbg: LinuxDebugger, sp: Address, pc: Address, address_size: int): LinuxPPC64CFrame;
              }
              let LinuxPPC64CFrame: _LinuxPPC64CFrame$$static;
              interface _LinuxPPC64CFrame {
                closestSymbolToPC(): debugger.cdbg.ClosestSymbol;
                localVariableBase(): Address;
                pc(): Address;
                sender(thread: ThreadProxy): debugger.cdbg.CFrame;
                _dbg: LinuxDebugger;
                _pc: Address;
                _sp: Address;
              }
              interface LinuxPPC64CFrame extends CombineTypes<[_LinuxPPC64CFrame, sun.jvm.hotspot.debugger.cdbg.basic.BasicCFrame]> {}
              interface _LinuxPPC64ThreadContext$$static extends ClassLike {
                new(debugger: LinuxDebugger): LinuxPPC64ThreadContext;
              }
              let LinuxPPC64ThreadContext: _LinuxPPC64ThreadContext$$static;
              interface _LinuxPPC64ThreadContext {
                getRegisterAsAddress(index: int): Address;
                setRegisterAsAddress(index: int, value: Address): void;
                _debugger: LinuxDebugger;
              }
              interface LinuxPPC64ThreadContext extends CombineTypes<[_LinuxPPC64ThreadContext, sun.jvm.hotspot.debugger.ppc64.PPC64ThreadContext]> {}
            }
            module riscv64 {
              interface _LinuxRISCV64CFrame$$static extends ClassLike {
                _ADDRESS_SIZE: int;
                _C_FRAME_LINK_OFFSET: int;
                _C_FRAME_RETURN_ADDR_OFFSET: int;
                new(dbg: LinuxDebugger, fp: Address, pc: Address): LinuxRISCV64CFrame;
              }
              let LinuxRISCV64CFrame: _LinuxRISCV64CFrame$$static;
              interface _LinuxRISCV64CFrame {
                closestSymbolToPC(): debugger.cdbg.ClosestSymbol;
                localVariableBase(): Address;
                pc(): Address;
                sender(thread: ThreadProxy): debugger.cdbg.CFrame;
                _dbg: LinuxDebugger;
                _fp: Address;
                _pc: Address;
                _sp: Address;
              }
              interface LinuxRISCV64CFrame extends CombineTypes<[_LinuxRISCV64CFrame, sun.jvm.hotspot.debugger.cdbg.basic.BasicCFrame]> {}
              interface _LinuxRISCV64ThreadContext$$static extends ClassLike {
                new(debugger: LinuxDebugger): LinuxRISCV64ThreadContext;
              }
              let LinuxRISCV64ThreadContext: _LinuxRISCV64ThreadContext$$static;
              interface _LinuxRISCV64ThreadContext {
                getRegisterAsAddress(index: int): Address;
                setRegisterAsAddress(index: int, value: Address): void;
                _debugger: LinuxDebugger;
              }
              interface LinuxRISCV64ThreadContext extends CombineTypes<[_LinuxRISCV64ThreadContext, sun.jvm.hotspot.debugger.riscv64.RISCV64ThreadContext]> {}
            }
            module x86 {
              interface _LinuxX86CFrame$$static extends ClassLike {
                _ADDRESS_SIZE: int;
                new(dbg: LinuxDebugger, ebp: Address, pc: Address): LinuxX86CFrame;
              }
              let LinuxX86CFrame: _LinuxX86CFrame$$static;
              interface _LinuxX86CFrame {
                closestSymbolToPC(): debugger.cdbg.ClosestSymbol;
                localVariableBase(): Address;
                pc(): Address;
                sender(thread: ThreadProxy): debugger.cdbg.CFrame;
                _dbg: LinuxDebugger;
                _ebp: Address;
                _pc: Address;
              }
              interface LinuxX86CFrame extends CombineTypes<[_LinuxX86CFrame, sun.jvm.hotspot.debugger.cdbg.basic.BasicCFrame]> {}
              interface _LinuxX86ThreadContext$$static extends ClassLike {
                new(debugger: LinuxDebugger): LinuxX86ThreadContext;
              }
              let LinuxX86ThreadContext: _LinuxX86ThreadContext$$static;
              interface _LinuxX86ThreadContext {
                getRegisterAsAddress(index: int): Address;
                setRegisterAsAddress(index: int, value: Address): void;
                _debugger: LinuxDebugger;
              }
              interface LinuxX86ThreadContext extends CombineTypes<[_LinuxX86ThreadContext, sun.jvm.hotspot.debugger.x86.X86ThreadContext]> {}
            }
            interface _LinuxAddress$$static extends ClassLike {
              _check(arg: boolean, failMessage: string): void;
              main(args: string[]): void;
              new(debugger: LinuxDebugger, addr: long): LinuxAddress;
            }
            let LinuxAddress: _LinuxAddress$$static;
            interface _LinuxAddress {
              addOffsetTo(offset: long): Address;
              addOffsetToAsOopHandle(offset: long): OopHandle;
              andWithMask(mask: long): Address;
              asLongValue(): long;
              equals(arg: any): boolean;
              getAddressAt(offset: long): Address;
              getCIntegerAt(offset: long, a1: long, numBytes: boolean): long;
              getCompKlassAddressAt(offset: long): Address;
              getCompOopAddressAt(offset: long): Address;
              getCompOopHandleAt(offset: long): OopHandle;
              getJBooleanAt(offset: long): boolean;
              getJByteAt(offset: long): byte;
              getJCharAt(offset: long): char;
              getJDoubleAt(offset: long): double;
              getJFloatAt(offset: long): float;
              getJIntAt(offset: long): int;
              getJLongAt(offset: long): long;
              getJShortAt(offset: long): short;
              getOopHandleAt(offset: long): OopHandle;
              greaterThan(a: Address): boolean;
              greaterThanOrEqual(a: Address): boolean;
              hashCode(): int;
              lessThan(a: Address): boolean;
              lessThanOrEqual(a: Address): boolean;
              minus(arg: Address): long;
              orWithMask(mask: long): Address;
              setAddressAt(offset: long, a1: Address): void;
              setCIntegerAt(offset: long, a1: long, numBytes: long): void;
              setJBooleanAt(offset: long, a1: boolean): void;
              setJByteAt(offset: long, a1: byte): void;
              setJCharAt(offset: long, a1: char): void;
              setJDoubleAt(offset: long, a1: double): void;
              setJFloatAt(offset: long, a1: float): void;
              setJIntAt(offset: long, a1: int): void;
              setJLongAt(offset: long, a1: long): void;
              setJShortAt(offset: long, a1: short): void;
              setOopHandleAt(offset: long, a1: OopHandle): void;
              toString(): string;
              xorWithMask(mask: long): Address;
              _addr: long;
              _debugger: LinuxDebugger;
            }
            interface LinuxAddress extends CombineTypes<[_LinuxAddress, java.lang.Object, sun.jvm.hotspot.debugger.Address]> {}
            interface _LinuxCDebugger$$static extends ClassLike {
              _new(dbg: LinuxDebugger): LinuxCDebugger;
            }
            let LinuxCDebugger: _LinuxCDebugger$$static;
            interface _LinuxCDebugger {
              canDemangle(): boolean;
              demangle(sym: string): string;
              getLoadObjectList(): java.util.List<debugger.cdbg.LoadObject>;
              getNameOfFile(fileName: string): string;
              getProcessControl(): debugger.cdbg.ProcessControl;
              getThreadList(): java.util.List<ThreadProxy>;
              loadObjectContainingPC(pc: Address): debugger.cdbg.LoadObject;
              topFrameForThread(thread: ThreadProxy): debugger.cdbg.CFrame;
              _dbg: LinuxDebugger;
            }
            interface LinuxCDebugger extends CombineTypes<[_LinuxCDebugger, sun.jvm.hotspot.debugger.cdbg.CDebugger, java.lang.Object]> {}
            interface _LinuxDebugger$$static extends ClassLike {
            }
            let LinuxDebugger: _LinuxDebugger$$static;
            interface _LinuxDebugger {
              addressValueToString(a0: long): string;
              demangle(a0: string): string;
              findLibPtrByAddress(a0: Address): Address;
              getAddressValue(a0: Address): long;
              getLoadObjectList(): java.util.List<debugger.cdbg.LoadObject>;
              getThreadIntegerRegisterSet(a0: int): long[];
              getThreadList(): java.util.List<ThreadProxy>;
              lookup(a0: long): debugger.cdbg.ClosestSymbol;
              readAddress(a0: long): LinuxAddress;
              readCInteger(a0: long, a1: long, a2: boolean): long;
              readCompKlassAddress(a0: long): LinuxAddress;
              readCompOopAddress(a0: long): LinuxAddress;
              readCompOopHandle(a0: long): LinuxOopHandle;
              readJBoolean(a0: long): boolean;
              readJByte(a0: long): byte;
              readJChar(a0: long): char;
              readJDouble(a0: long): double;
              readJFloat(a0: long): float;
              readJInt(a0: long): int;
              readJLong(a0: long): long;
              readJShort(a0: long): short;
              readOopHandle(a0: long): LinuxOopHandle;
            }
            interface LinuxDebugger extends CombineTypes<[_LinuxDebugger, java.lang.Object, sun.jvm.hotspot.debugger.JVMDebugger]> {}
            interface _LinuxDebuggerLocal$$static extends ClassLike {
              getAddressSize(): int;
              _init0(): void;
              new(machDesc: MachineDescription, useCache: boolean): LinuxDebuggerLocal;
            }
            let LinuxDebuggerLocal: _LinuxDebuggerLocal$$static;
            interface _LinuxDebuggerLocal {
              addressValueToString(address: long): string;
              attach(processID: int): void;
              attach(execName: string, coreName: string): void;
              _attach0(a0: int): void;
              _attach0(a0: string, a1: string): void;
              _checkAttached(): void;
              consoleExecuteCommand(cmd: string): string;
              _createClosestSymbol(name: string, offset: long): debugger.cdbg.ClosestSymbol;
              _createLoadObject(fileName: string, size: long, a2: long): debugger.cdbg.LoadObject;
              demangle(a0: string): string;
              detach(): boolean;
              _detach0(): void;
              _fillNSpidMap(proc: java.nio.file.Path): void;
              _findABIVersion(): void;
              findLibPtrByAddress(pc: Address): Address;
              findLibPtrByAddress0(a0: long): long;
              getAddressValue(addr: Address): long;
              getCDebugger(): debugger.cdbg.CDebugger;
              getCPU(): string;
              getConsolePrompt(): string;
              getHostPID(id: int): int;
              getLoadObjectList(): java.util.List<debugger.cdbg.LoadObject>;
              getMachineDescription(): MachineDescription;
              _getNamespacePID(statusPath: java.nio.file.Path): int;
              getOS(): string;
              getProcessList(): java.util.List<ProcessInfo>;
              getThreadForIdentifierAddress(addr: Address): ThreadProxy;
              getThreadForThreadId(id: long): ThreadProxy;
              getThreadIntegerRegisterSet(lwp_id: int): long[];
              _getThreadIntegerRegisterSet0(a0: int): long[];
              getThreadList(): java.util.List<ThreadProxy>;
              _handleGCC32ABI(addr: long, a1: string): long;
              hasConsole(): boolean;
              hasProcessList(): boolean;
              lookup(objectName: string, symbol: string): Address;
              lookup(addr: long): debugger.cdbg.ClosestSymbol;
              _lookupByAddress0(a0: long): debugger.cdbg.ClosestSymbol;
              _lookupByName0(a0: string, a1: string): long;
              lookupOop(objectName: string, symbol: string): OopHandle;
              newAddress(value: long): Address;
              parseAddress(addressString: string): Address;
              readAddress(address: long): LinuxAddress;
              readBytesFromProcess(address: long, a1: long): ReadResult;
              _readBytesFromProcess0(a0: long, a1: long): byte[];
              readCompKlassAddress(address: long): LinuxAddress;
              readCompOopAddress(address: long): LinuxAddress;
              readCompOopHandle(address: long): LinuxOopHandle;
              readOopHandle(address: long): LinuxOopHandle;
              _requireAttach(): void;
              _setSAAltRoot0(a0: string): void;
              _attached: boolean;
              _cdbg: LinuxCDebugger;
              _isCore: boolean;
              _loadObjectList: java.util.List<debugger.cdbg.LoadObject>;
              _nspidMap: java.util.Map<int,int>;
              _p_ps_prochandle: long;
              _threadList: java.util.List<ThreadProxy>;
              _useGCC32ABI: boolean;
              _workerThread: LinuxDebuggerLocal$LinuxDebuggerLocalWorkerThread;
            }
            interface LinuxDebuggerLocal extends CombineTypes<[_LinuxDebuggerLocal, sun.jvm.hotspot.debugger.linux.LinuxDebugger, sun.jvm.hotspot.debugger.DebuggerBase]> {}
            interface _LinuxDebuggerLocal$LinuxDebuggerLocalWorkerThread$$static extends ClassLike {
              new(this$0: LinuxDebuggerLocal, debugger: LinuxDebuggerLocal): LinuxDebuggerLocal$LinuxDebuggerLocalWorkerThread;
            }
            let LinuxDebuggerLocal$LinuxDebuggerLocalWorkerThread: _LinuxDebuggerLocal$LinuxDebuggerLocalWorkerThread$$static;
            interface _LinuxDebuggerLocal$LinuxDebuggerLocalWorkerThread {
              execute(task: LinuxDebuggerLocal$WorkerThreadTask): LinuxDebuggerLocal$WorkerThreadTask;
              run(): void;
              _debugger: LinuxDebuggerLocal;
              _lastException: DebuggerException;
              _task: LinuxDebuggerLocal$WorkerThreadTask;
              _this$0: LinuxDebuggerLocal;
            }
            interface LinuxDebuggerLocal$LinuxDebuggerLocalWorkerThread extends CombineTypes<[_LinuxDebuggerLocal$LinuxDebuggerLocalWorkerThread, java.lang.Thread]> {}
            interface _LinuxDebuggerLocal$WorkerThreadTask$$static extends ClassLike {
            }
            let LinuxDebuggerLocal$WorkerThreadTask: _LinuxDebuggerLocal$WorkerThreadTask$$static;
            interface _LinuxDebuggerLocal$WorkerThreadTask {
              doit(a0: LinuxDebuggerLocal): void;
(a0: LinuxDebuggerLocal): void;
            }
            interface LinuxDebuggerLocal$WorkerThreadTask extends CombineTypes<[_LinuxDebuggerLocal$WorkerThreadTask, java.lang.Object]> {}
            interface _LinuxOopHandle$$static extends ClassLike {
              new(debugger: LinuxDebugger, addr: long): LinuxOopHandle;
            }
            let LinuxOopHandle: _LinuxOopHandle$$static;
            interface _LinuxOopHandle {
              addOffsetTo(offset: long): Address;
              andWithMask(mask: long): Address;
              equals(arg: any): boolean;
              orWithMask(mask: long): Address;
              xorWithMask(mask: long): Address;
            }
            interface LinuxOopHandle extends CombineTypes<[_LinuxOopHandle, sun.jvm.hotspot.debugger.linux.LinuxAddress, sun.jvm.hotspot.debugger.OopHandle]> {}
            interface _LinuxThread$$static extends ClassLike {
              _new(debugger: LinuxDebugger, addr: Address): LinuxThread;
              _new(debugger: LinuxDebugger, id: long): LinuxThread;
            }
            let LinuxThread: _LinuxThread$$static;
            interface _LinuxThread {
              canSetContext(): boolean;
              equals(obj: any): boolean;
              getContext(): ThreadContext;
              hashCode(): int;
              setContext(context: ThreadContext): void;
              toString(): string;
              _debugger: LinuxDebugger;
              _lwp_id: int;
            }
            interface LinuxThread extends CombineTypes<[_LinuxThread, sun.jvm.hotspot.debugger.ThreadProxy, java.lang.Object]> {}
            interface _LinuxThreadContextFactory$$static extends ClassLike {
              _createThreadContext(dbg: LinuxDebugger): ThreadContext;
              _new(): LinuxThreadContextFactory;
            }
            let LinuxThreadContextFactory: _LinuxThreadContextFactory$$static;
            interface _LinuxThreadContextFactory {
            }
            interface LinuxThreadContextFactory extends CombineTypes<[_LinuxThreadContextFactory, java.lang.Object]> {}
            interface _SharedObject$$static extends ClassLike {
              _new(dbg: LinuxDebugger, filename: string, size: long, a3: Address): SharedObject;
            }
            let SharedObject: _SharedObject$$static;
            interface _SharedObject {
              closestSymbolToPC(pcAsAddr: Address): debugger.cdbg.ClosestSymbol;
              _getAddressValue(addr: Address): long;
              _newAddress(address: long): Address;
              _dbg: LinuxDebugger;
            }
            interface SharedObject extends CombineTypes<[_SharedObject, sun.jvm.hotspot.debugger.posix.DSO]> {}
          }
          module posix {
            module elf {
              interface _ELFException$$static extends ClassLike {
                new(): ELFException;
                new(message: string): ELFException;
                new(cause: java.lang.Throwable): ELFException;
                new(message: string, cause: java.lang.Throwable): ELFException;
              }
              let ELFException: _ELFException$$static;
              interface _ELFException {
              }
              interface ELFException extends CombineTypes<[_ELFException, java.lang.RuntimeException]> {}
              interface _ELFFile$$static extends ClassLike {
                readonly CLASS_32: byte;
                readonly CLASS_64: byte;
                readonly CLASS_INVALID: byte;
                readonly DATA_INVALID: byte;
                readonly DATA_LSB: byte;
                readonly DATA_MSB: byte;
                readonly ELF_MAGIC_NUMBER: byte[];
                readonly NDX_ENCODING: byte;
                readonly NDX_MAGIC_0: byte;
                readonly NDX_MAGIC_1: byte;
                readonly NDX_MAGIC_2: byte;
                readonly NDX_MAGIC_3: byte;
                readonly NDX_OBJECT_SIZE: byte;
                readonly NDX_VERSION: byte;
                readonly VERSION_CURRENT: byte;
                readonly VERSION_INVALID: byte;
              }
              let ELFFile: _ELFFile$$static;
              interface _ELFFile {
                close(): void;
                getEncoding(): byte;
                getHeader(): ELFHeader;
                getMagicNumber(): byte[];
                getObjectSize(): byte;
                getVersion(): byte;
              }
              interface ELFFile extends CombineTypes<[_ELFFile, java.lang.Object]> {}
              interface _ELFFileParser$$static extends ClassLike {
                getParser(): ELFFileParser;
                main(args: string[]): void;
                _elfParser: ELFFileParser;
                new(): ELFFileParser;
              }
              let ELFFileParser: _ELFFileParser$$static;
              interface _ELFFileParser {
                parse(filename: string): ELFFile;
                parse(source: DataSource): ELFFile;
              }
              interface ELFFileParser extends CombineTypes<[_ELFFileParser, java.lang.Object]> {}
              interface _ELFFileParser$ELFFileImpl$$static extends ClassLike {
                _new(this$0: ELFFileParser, file: DataSource): ELFFileParser$ELFFileImpl;
              }
              let ELFFileParser$ELFFileImpl: _ELFFileParser$ELFFileImpl$$static;
              interface _ELFFileParser$ELFFileImpl {
                _assert32bitLong(x: long): void;
                _byteSwap(arg: short): short;
                _byteSwap(arg: int): int;
                _byteSwap(arg: long): long;
                close(): void;
                getEncoding(): byte;
                _getFilePointer(): long;
                getHeader(): ELFHeader;
                getMagicNumber(): byte[];
                getObjectSize(): byte;
                getVersion(): byte;
                _readByte(): byte;
                _readBytes(b: byte[]): int;
                _readInt(): int;
                _readLong(): long;
                _readShort(): short;
                _readUnsignedByte(): short;
                _readUnsignedInt(): long;
                _readUnsignedShort(): int;
                _readWord(): long;
                _seek(offset: long): void;
                _unsignedByte(arg: byte): short;
                _unsignedByte(arg: short): int;
                _unsignedByte(arg: int): long;
                _unsignedByteSwap(arg: short): int;
                _unsignedByteSwap(arg: int): long;
                _file: DataSource;
                _header: ELFHeader;
                _ident: byte[];
              }
              interface ELFFileParser$ELFFileImpl extends CombineTypes<[_ELFFileParser$ELFFileImpl, sun.jvm.hotspot.debugger.posix.elf.ELFFile, java.lang.Object]> {}
              interface _ELFFileParser$ELFFileImpl$ELFHashTableImpl$$static extends ClassLike {
                _new(this$1: ELFFileParser$ELFFileImpl, offset: long, a2: int): ELFFileParser$ELFFileImpl$ELFHashTableImpl;
              }
              let ELFFileParser$ELFFileImpl$ELFHashTableImpl: _ELFFileParser$ELFFileImpl$ELFHashTableImpl$$static;
              interface _ELFFileParser$ELFFileImpl$ELFHashTableImpl {
                getSymbol(symbolName: string): ELFSymbol;
                _buckets: int[];
                _chains: int[];
                _num_buckets: int;
                _num_chains: int;
              }
              interface ELFFileParser$ELFFileImpl$ELFHashTableImpl extends CombineTypes<[_ELFFileParser$ELFFileImpl$ELFHashTableImpl, sun.jvm.hotspot.debugger.posix.elf.ELFHashTable, java.lang.Object]> {}
              interface _ELFFileParser$ELFFileImpl$ELFHeaderImpl$$static extends ClassLike {
                _new(this$1: ELFFileParser$ELFFileImpl): ELFFileParser$ELFFileImpl$ELFHeaderImpl;
              }
              let ELFFileParser$ELFFileImpl$ELFHeaderImpl: _ELFFileParser$ELFFileImpl$ELFHeaderImpl$$static;
              interface _ELFFileParser$ELFFileImpl$ELFHeaderImpl {
                _findStringTableWithName(tableName: string): ELFStringTable;
                getArch(): short;
                getDynamicStringTable(): ELFStringTable;
                getDynamicSymbolTableSection(): ELFSectionHeader;
                getELFSymbol(symbolName: string): ELFSymbol;
                getELFSymbol(address: long): ELFSymbol;
                getFileType(): short;
                getHashTable(): ELFHashTable;
                getNumberOfSectionHeaders(): short;
                getSectionHeader(index: int): ELFSectionHeader;
                getSectionHeaderSize(): short;
                getSectionHeaderStringTable(): ELFStringTable;
                getStringTable(): ELFStringTable;
                getSymbolTableSection(): ELFSectionHeader;
                _getSymbolTableSection(type: int): ELFSectionHeader;
                _arch: short;
                _dynamicSymbolTableSection: ELFSectionHeader;
                _eh_size: short;
                _entry_point: long;
                _file_type: short;
                _flags: int;
                _hashTable: ELFHashTable;
                _ident: byte[];
                _num_ph: short;
                _num_sh: short;
                _ph_entry_size: short;
                _ph_offset: long;
                _programHeaders: hotspot.utilities.memo.MemoizedObject[];
                _sectionHeaders: hotspot.utilities.memo.MemoizedObject[];
                _sh_entry_size: short;
                _sh_offset: long;
                _sh_string_ndx: short;
                _symbolTableSection: ELFSectionHeader;
                _this$1: ELFFileParser$ELFFileImpl;
                _version: int;
              }
              interface ELFFileParser$ELFFileImpl$ELFHeaderImpl extends CombineTypes<[_ELFFileParser$ELFFileImpl$ELFHeaderImpl, java.lang.Object, sun.jvm.hotspot.debugger.posix.elf.ELFHeader]> {}
              interface _ELFFileParser$ELFFileImpl$ELFSectionHeaderImpl$$static extends ClassLike {
                _new(this$1: ELFFileParser$ELFFileImpl, offset: long): ELFFileParser$ELFFileImpl$ELFSectionHeaderImpl;
              }
              let ELFFileParser$ELFFileImpl$ELFSectionHeaderImpl: _ELFFileParser$ELFFileImpl$ELFSectionHeaderImpl$$static;
              interface _ELFFileParser$ELFFileImpl$ELFSectionHeaderImpl {
                getELFSymbol(index: int): ELFSymbol;
                getHashTable(): ELFHashTable;
                getLink(): int;
                getName(): string;
                getNumberOfSymbols(): int;
                getOffset(): long;
                getStringTable(): ELFStringTable;
                getType(): int;
                _address: long;
                _address_alignment: long;
                _entry_size: long;
                _flags: long;
                _hashTable: hotspot.utilities.memo.MemoizedObject;
                _info: int;
                _link: int;
                _name_ndx: int;
                _section_offset: long;
                _size: long;
                _stringTable: hotspot.utilities.memo.MemoizedObject;
                _symbols: hotspot.utilities.memo.MemoizedObject[];
                _this$1: ELFFileParser$ELFFileImpl;
                _type: int;
              }
              interface ELFFileParser$ELFFileImpl$ELFSectionHeaderImpl extends CombineTypes<[_ELFFileParser$ELFFileImpl$ELFSectionHeaderImpl, java.lang.Object, sun.jvm.hotspot.debugger.posix.elf.ELFSectionHeader]> {}
              interface _ELFFileParser$ELFFileImpl$ELFStringTableImpl$$static extends ClassLike {
                _new(this$1: ELFFileParser$ELFFileImpl, offset: long, a2: int): ELFFileParser$ELFFileImpl$ELFStringTableImpl;
              }
              let ELFFileParser$ELFFileImpl$ELFStringTableImpl: _ELFFileParser$ELFFileImpl$ELFStringTableImpl$$static;
              interface _ELFFileParser$ELFFileImpl$ELFStringTableImpl {
                get(index: int): string;
                getNumStrings(): int;
                _data: byte[];
                _numStrings: int;
              }
              interface ELFFileParser$ELFFileImpl$ELFStringTableImpl extends CombineTypes<[_ELFFileParser$ELFFileImpl$ELFStringTableImpl, sun.jvm.hotspot.debugger.posix.elf.ELFStringTable, java.lang.Object]> {}
              interface _ELFFileParser$ELFFileImpl$ELFSymbolImpl$$static extends ClassLike {
                _new(this$1: ELFFileParser$ELFFileImpl, offset: long, a2: int): ELFFileParser$ELFFileImpl$ELFSymbolImpl;
              }
              let ELFFileParser$ELFFileImpl$ELFSymbolImpl: _ELFFileParser$ELFFileImpl$ELFSymbolImpl$$static;
              interface _ELFFileParser$ELFFileImpl$ELFSymbolImpl {
                getBinding(): int;
                getName(): string;
                getOffset(): long;
                getSize(): long;
                getType(): int;
                getValue(): long;
                _info: byte;
                _name_ndx: int;
                _offset: long;
                _other: byte;
                _section_header_ndx: short;
                _section_type: int;
                _size: long;
                _this$1: ELFFileParser$ELFFileImpl;
                _value: long;
              }
              interface ELFFileParser$ELFFileImpl$ELFSymbolImpl extends CombineTypes<[_ELFFileParser$ELFFileImpl$ELFSymbolImpl, sun.jvm.hotspot.debugger.posix.elf.ELFSymbol, java.lang.Object]> {}
              interface _ELFHashTable$$static extends ClassLike {
              }
              let ELFHashTable: _ELFHashTable$$static;
              interface _ELFHashTable {
                getSymbol(a0: string): ELFSymbol;
(a0: string): ELFSymbol;
              }
              interface ELFHashTable extends CombineTypes<[_ELFHashTable, java.lang.Object]> {}
              interface _ELFHeader$$static extends ClassLike {
                readonly ARCH_68k: int;
                readonly ARCH_88k: int;
                readonly ARCH_ATT: int;
                readonly ARCH_MIPS: int;
                readonly ARCH_NONE: int;
                readonly ARCH_SPARC: int;
                readonly ARCH_i386: int;
                readonly ARCH_i860: int;
                readonly FT_CORE: int;
                readonly FT_DYN: int;
                readonly FT_EXEC: int;
                readonly FT_HICPROC: int;
                readonly FT_LOCPROC: int;
                readonly FT_NONE: int;
                readonly FT_REL: int;
              }
              let ELFHeader: _ELFHeader$$static;
              interface _ELFHeader {
                getArch(): short;
                getDynamicStringTable(): ELFStringTable;
                getDynamicSymbolTableSection(): ELFSectionHeader;
                getELFSymbol(a0: string): ELFSymbol;
                getELFSymbol(a0: long): ELFSymbol;
                getFileType(): short;
                getHashTable(): ELFHashTable;
                getNumberOfSectionHeaders(): short;
                getSectionHeader(a0: int): ELFSectionHeader;
                getSectionHeaderSize(): short;
                getSectionHeaderStringTable(): ELFStringTable;
                getStringTable(): ELFStringTable;
                getSymbolTableSection(): ELFSectionHeader;
              }
              interface ELFHeader extends CombineTypes<[_ELFHeader, java.lang.Object]> {}
              interface _ELFProgramHeader$$static extends ClassLike {
                readonly TYPE_DYNAMIC: int;
                readonly TYPE_HIPROC: int;
                readonly TYPE_INTERP: int;
                readonly TYPE_LOAD: int;
                readonly TYPE_LOPROC: int;
                readonly TYPE_NOTE: int;
                readonly TYPE_NULL: int;
                readonly TYPE_PHDR: int;
                readonly TYPE_SHLIB: int;
              }
              let ELFProgramHeader: _ELFProgramHeader$$static;
              interface _ELFProgramHeader {
                getType(): int;
(): int;
              }
              interface ELFProgramHeader extends CombineTypes<[_ELFProgramHeader, java.lang.Object]> {}
              interface _ELFSectionHeader$$static extends ClassLike {
                readonly DYNAMIC_STRING_TABLE_NAME: string;
                readonly FLAG_ALLOC: int;
                readonly FLAG_EXEC_INSTR: int;
                readonly FLAG_MASK: int;
                readonly FLAG_WRITE: int;
                readonly NDX_ABS: int;
                readonly NDX_COMMON: int;
                readonly NDX_HIPROC: int;
                readonly NDX_HIRESERVE: int;
                readonly NDX_LOPROC: int;
                readonly NDX_LORESERVE: int;
                readonly NDX_UNDEFINED: int;
                readonly STRING_TABLE_NAME: string;
                readonly TYPE_DYNAMIC: int;
                readonly TYPE_DYNSYM: int;
                readonly TYPE_HASH: int;
                readonly TYPE_HIPROC: int;
                readonly TYPE_HIUSER: int;
                readonly TYPE_LOPROC: int;
                readonly TYPE_LOUSER: int;
                readonly TYPE_NOBITS: int;
                readonly TYPE_NOTE: int;
                readonly TYPE_NULL: int;
                readonly TYPE_PROGBITS: int;
                readonly TYPE_RELO: int;
                readonly TYPE_RELO_EXPLICIT: int;
                readonly TYPE_SHLIB: int;
                readonly TYPE_STRTBL: int;
                readonly TYPE_SYMTBL: int;
              }
              let ELFSectionHeader: _ELFSectionHeader$$static;
              interface _ELFSectionHeader {
                getELFSymbol(a0: int): ELFSymbol;
                getHashTable(): ELFHashTable;
                getLink(): int;
                getName(): string;
                getNumberOfSymbols(): int;
                getOffset(): long;
                getStringTable(): ELFStringTable;
                getType(): int;
              }
              interface ELFSectionHeader extends CombineTypes<[_ELFSectionHeader, java.lang.Object]> {}
              interface _ELFStringTable$$static extends ClassLike {
              }
              let ELFStringTable: _ELFStringTable$$static;
              interface _ELFStringTable {
                get(a0: int): string;
                getNumStrings(): int;
              }
              interface ELFStringTable extends CombineTypes<[_ELFStringTable, java.lang.Object]> {}
              interface _ELFSymbol$$static extends ClassLike {
                readonly BINDING_GLOBAL: int;
                readonly BINDING_HIPROC: int;
                readonly BINDING_LOCAL: int;
                readonly BINDING_LOPROC: int;
                readonly BINDING_WEAK: int;
                readonly TYPE_FILE: byte;
                readonly TYPE_FUNCTION: byte;
                readonly TYPE_HIPROC: byte;
                readonly TYPE_LOPROC: byte;
                readonly TYPE_NOOBJECT: byte;
                readonly TYPE_OBJECT: byte;
                readonly TYPE_SECTION: byte;
              }
              let ELFSymbol: _ELFSymbol$$static;
              interface _ELFSymbol {
                getBinding(): int;
                getName(): string;
                getOffset(): long;
                getSize(): long;
                getType(): int;
                getValue(): long;
              }
              interface ELFSymbol extends CombineTypes<[_ELFSymbol, java.lang.Object]> {}
            }
            interface _AddressDataSource$$static extends ClassLike {
              _new(addr: Address): AddressDataSource;
            }
            let AddressDataSource: _AddressDataSource$$static;
            interface _AddressDataSource {
              close(): void;
              getFilePointer(): long;
              read(b: byte[]): int;
              readByte(): byte;
              readInt(): int;
              readLong(): long;
              readShort(): short;
              seek(pos: long): void;
              _addr: Address;
              _offset: long;
            }
            interface AddressDataSource extends CombineTypes<[_AddressDataSource, sun.jvm.hotspot.debugger.DataSource, java.lang.Object]> {}
            interface _DSO$$static extends ClassLike {
              new(filename: string, size: long, a2: Address): DSO;
            }
            let DSO: _DSO$$static;
            interface _DSO {
              debugInfoForPC(pc: Address): debugger.cdbg.BlockSym;
              equals(o: any): boolean;
              _getAddressValue(a0: Address): long;
              getBase(): Address;
              getDebugInfoDataBase(): debugger.cdbg.CDebugInfoDataBase;
              getName(): string;
              getSize(): long;
              hashCode(): int;
              lineNumberForPC(pc: Address): debugger.cdbg.LineNumberInfo;
              _newAddress(a0: long): Address;
              _addr: Address;
              _filename: string;
              _size: long;
            }
            interface DSO extends CombineTypes<[_DSO, sun.jvm.hotspot.debugger.cdbg.LoadObject, java.lang.Object]> {}
          }
          module ppc64 {
            interface _PPC64ThreadContext$$static extends ClassLike {
              readonly LR: int;
              readonly NIP: int;
              readonly NPRGREG: int;
              readonly PC: int;
              readonly R0: int;
              readonly R1: int;
              readonly R10: int;
              readonly R11: int;
              readonly R12: int;
              readonly R13: int;
              readonly R14: int;
              readonly R15: int;
              readonly R16: int;
              readonly R17: int;
              readonly R18: int;
              readonly R19: int;
              readonly R2: int;
              readonly R20: int;
              readonly R21: int;
              readonly R22: int;
              readonly R23: int;
              readonly R24: int;
              readonly R25: int;
              readonly R26: int;
              readonly R27: int;
              readonly R28: int;
              readonly R29: int;
              readonly R3: int;
              readonly R30: int;
              readonly R31: int;
              readonly R4: int;
              readonly R5: int;
              readonly R6: int;
              readonly R7: int;
              readonly R8: int;
              readonly R9: int;
              readonly SP: int;
              _regNames: string[];
              new(): PPC64ThreadContext;
            }
            let PPC64ThreadContext: _PPC64ThreadContext$$static;
            interface _PPC64ThreadContext {
              getNumRegisters(): int;
              getRegister(index: int): long;
              getRegisterAsAddress(a0: int): Address;
              getRegisterName(index: int): string;
              getTopFrame(dbg: Debugger): debugger.cdbg.CFrame;
              setRegister(index: int, value: long): void;
              setRegisterAsAddress(a0: int, a1: Address): void;
              _data: long[];
            }
            interface PPC64ThreadContext extends CombineTypes<[_PPC64ThreadContext, sun.jvm.hotspot.debugger.ThreadContext, java.lang.Object]> {}
          }
          module remote {
            module aarch64 {
              interface _RemoteAARCH64Thread$$static extends ClassLike {
                new(debugger: RemoteDebuggerClient, addr: Address): RemoteAARCH64Thread;
                new(debugger: RemoteDebuggerClient, id: long): RemoteAARCH64Thread;
              }
              let RemoteAARCH64Thread: _RemoteAARCH64Thread$$static;
              interface _RemoteAARCH64Thread {
                getContext(): ThreadContext;
              }
              interface RemoteAARCH64Thread extends CombineTypes<[_RemoteAARCH64Thread, sun.jvm.hotspot.debugger.remote.RemoteThread]> {}
              interface _RemoteAARCH64ThreadContext$$static extends ClassLike {
                new(debugger: RemoteDebuggerClient): RemoteAARCH64ThreadContext;
              }
              let RemoteAARCH64ThreadContext: _RemoteAARCH64ThreadContext$$static;
              interface _RemoteAARCH64ThreadContext {
                getRegisterAsAddress(index: int): Address;
                setRegisterAsAddress(index: int, value: Address): void;
                _debugger: RemoteDebuggerClient;
              }
              interface RemoteAARCH64ThreadContext extends CombineTypes<[_RemoteAARCH64ThreadContext, sun.jvm.hotspot.debugger.aarch64.AARCH64ThreadContext]> {}
              interface _RemoteAARCH64ThreadFactory$$static extends ClassLike {
                new(debugger: RemoteDebuggerClient): RemoteAARCH64ThreadFactory;
              }
              let RemoteAARCH64ThreadFactory: _RemoteAARCH64ThreadFactory$$static;
              interface _RemoteAARCH64ThreadFactory {
                createThreadWrapper(threadIdentifierAddr: Address): ThreadProxy;
                createThreadWrapper(id: long): ThreadProxy;
                _debugger: RemoteDebuggerClient;
              }
              interface RemoteAARCH64ThreadFactory extends CombineTypes<[_RemoteAARCH64ThreadFactory, java.lang.Object, sun.jvm.hotspot.debugger.remote.RemoteThreadFactory]> {}
            }
            module amd64 {
              interface _RemoteAMD64Thread$$static extends ClassLike {
                new(debugger: RemoteDebuggerClient, addr: Address): RemoteAMD64Thread;
                new(debugger: RemoteDebuggerClient, id: long): RemoteAMD64Thread;
              }
              let RemoteAMD64Thread: _RemoteAMD64Thread$$static;
              interface _RemoteAMD64Thread {
                getContext(): ThreadContext;
              }
              interface RemoteAMD64Thread extends CombineTypes<[_RemoteAMD64Thread, sun.jvm.hotspot.debugger.remote.RemoteThread]> {}
              interface _RemoteAMD64ThreadContext$$static extends ClassLike {
                new(debugger: RemoteDebuggerClient): RemoteAMD64ThreadContext;
              }
              let RemoteAMD64ThreadContext: _RemoteAMD64ThreadContext$$static;
              interface _RemoteAMD64ThreadContext {
                getRegisterAsAddress(index: int): Address;
                setRegisterAsAddress(index: int, value: Address): void;
                _debugger: RemoteDebuggerClient;
              }
              interface RemoteAMD64ThreadContext extends CombineTypes<[_RemoteAMD64ThreadContext, sun.jvm.hotspot.debugger.amd64.AMD64ThreadContext]> {}
              interface _RemoteAMD64ThreadFactory$$static extends ClassLike {
                new(debugger: RemoteDebuggerClient): RemoteAMD64ThreadFactory;
              }
              let RemoteAMD64ThreadFactory: _RemoteAMD64ThreadFactory$$static;
              interface _RemoteAMD64ThreadFactory {
                createThreadWrapper(threadIdentifierAddr: Address): ThreadProxy;
                createThreadWrapper(id: long): ThreadProxy;
                _debugger: RemoteDebuggerClient;
              }
              interface RemoteAMD64ThreadFactory extends CombineTypes<[_RemoteAMD64ThreadFactory, java.lang.Object, sun.jvm.hotspot.debugger.remote.RemoteThreadFactory]> {}
            }
            module ppc64 {
              interface _RemotePPC64Thread$$static extends ClassLike {
                new(debugger: RemoteDebuggerClient, addr: Address): RemotePPC64Thread;
                new(debugger: RemoteDebuggerClient, id: long): RemotePPC64Thread;
              }
              let RemotePPC64Thread: _RemotePPC64Thread$$static;
              interface _RemotePPC64Thread {
                getContext(): ThreadContext;
              }
              interface RemotePPC64Thread extends CombineTypes<[_RemotePPC64Thread, sun.jvm.hotspot.debugger.remote.RemoteThread]> {}
              interface _RemotePPC64ThreadContext$$static extends ClassLike {
                new(debugger: RemoteDebuggerClient): RemotePPC64ThreadContext;
              }
              let RemotePPC64ThreadContext: _RemotePPC64ThreadContext$$static;
              interface _RemotePPC64ThreadContext {
                getRegisterAsAddress(index: int): Address;
                setRegisterAsAddress(index: int, value: Address): void;
                _debugger: RemoteDebuggerClient;
              }
              interface RemotePPC64ThreadContext extends CombineTypes<[_RemotePPC64ThreadContext, sun.jvm.hotspot.debugger.ppc64.PPC64ThreadContext]> {}
              interface _RemotePPC64ThreadFactory$$static extends ClassLike {
                new(debugger: RemoteDebuggerClient): RemotePPC64ThreadFactory;
              }
              let RemotePPC64ThreadFactory: _RemotePPC64ThreadFactory$$static;
              interface _RemotePPC64ThreadFactory {
                createThreadWrapper(threadIdentifierAddr: Address): ThreadProxy;
                createThreadWrapper(id: long): ThreadProxy;
                _debugger: RemoteDebuggerClient;
              }
              interface RemotePPC64ThreadFactory extends CombineTypes<[_RemotePPC64ThreadFactory, java.lang.Object, sun.jvm.hotspot.debugger.remote.RemoteThreadFactory]> {}
            }
            module riscv64 {
              interface _RemoteRISCV64Thread$$static extends ClassLike {
                new(debugger: RemoteDebuggerClient, addr: Address): RemoteRISCV64Thread;
                new(debugger: RemoteDebuggerClient, id: long): RemoteRISCV64Thread;
              }
              let RemoteRISCV64Thread: _RemoteRISCV64Thread$$static;
              interface _RemoteRISCV64Thread {
                getContext(): ThreadContext;
              }
              interface RemoteRISCV64Thread extends CombineTypes<[_RemoteRISCV64Thread, sun.jvm.hotspot.debugger.remote.RemoteThread]> {}
              interface _RemoteRISCV64ThreadContext$$static extends ClassLike {
                new(debugger: RemoteDebuggerClient): RemoteRISCV64ThreadContext;
              }
              let RemoteRISCV64ThreadContext: _RemoteRISCV64ThreadContext$$static;
              interface _RemoteRISCV64ThreadContext {
                getRegisterAsAddress(index: int): Address;
                setRegisterAsAddress(index: int, value: Address): void;
                _debugger: RemoteDebuggerClient;
              }
              interface RemoteRISCV64ThreadContext extends CombineTypes<[_RemoteRISCV64ThreadContext, sun.jvm.hotspot.debugger.riscv64.RISCV64ThreadContext]> {}
              interface _RemoteRISCV64ThreadFactory$$static extends ClassLike {
                new(debugger: RemoteDebuggerClient): RemoteRISCV64ThreadFactory;
              }
              let RemoteRISCV64ThreadFactory: _RemoteRISCV64ThreadFactory$$static;
              interface _RemoteRISCV64ThreadFactory {
                createThreadWrapper(threadIdentifierAddr: Address): ThreadProxy;
                createThreadWrapper(id: long): ThreadProxy;
                _debugger: RemoteDebuggerClient;
              }
              interface RemoteRISCV64ThreadFactory extends CombineTypes<[_RemoteRISCV64ThreadFactory, java.lang.Object, sun.jvm.hotspot.debugger.remote.RemoteThreadFactory]> {}
            }
            module x86 {
              interface _RemoteX86Thread$$static extends ClassLike {
                new(debugger: RemoteDebuggerClient, addr: Address): RemoteX86Thread;
                new(debugger: RemoteDebuggerClient, id: long): RemoteX86Thread;
              }
              let RemoteX86Thread: _RemoteX86Thread$$static;
              interface _RemoteX86Thread {
                getContext(): ThreadContext;
              }
              interface RemoteX86Thread extends CombineTypes<[_RemoteX86Thread, sun.jvm.hotspot.debugger.remote.RemoteThread]> {}
              interface _RemoteX86ThreadContext$$static extends ClassLike {
                new(debugger: RemoteDebuggerClient): RemoteX86ThreadContext;
              }
              let RemoteX86ThreadContext: _RemoteX86ThreadContext$$static;
              interface _RemoteX86ThreadContext {
                getRegisterAsAddress(index: int): Address;
                setRegisterAsAddress(index: int, value: Address): void;
                _debugger: RemoteDebuggerClient;
              }
              interface RemoteX86ThreadContext extends CombineTypes<[_RemoteX86ThreadContext, sun.jvm.hotspot.debugger.x86.X86ThreadContext]> {}
              interface _RemoteX86ThreadFactory$$static extends ClassLike {
                new(debugger: RemoteDebuggerClient): RemoteX86ThreadFactory;
              }
              let RemoteX86ThreadFactory: _RemoteX86ThreadFactory$$static;
              interface _RemoteX86ThreadFactory {
                createThreadWrapper(threadIdentifierAddr: Address): ThreadProxy;
                createThreadWrapper(id: long): ThreadProxy;
                _debugger: RemoteDebuggerClient;
              }
              interface RemoteX86ThreadFactory extends CombineTypes<[_RemoteX86ThreadFactory, java.lang.Object, sun.jvm.hotspot.debugger.remote.RemoteThreadFactory]> {}
            }
            interface _RemoteAddress$$static extends ClassLike {
              _check(arg: boolean, failMessage: string): void;
              main(args: string[]): void;
              _new(debugger: RemoteDebuggerClient, addr: long): RemoteAddress;
            }
            let RemoteAddress: _RemoteAddress$$static;
            interface _RemoteAddress {
              addOffsetTo(offset: long): Address;
              addOffsetToAsOopHandle(offset: long): OopHandle;
              andWithMask(mask: long): Address;
              asLongValue(): long;
              equals(arg: any): boolean;
              getAddressAt(offset: long): Address;
              getCIntegerAt(offset: long, a1: long, numBytes: boolean): long;
              getCompKlassAddressAt(offset: long): Address;
              getCompOopAddressAt(offset: long): Address;
              getCompOopHandleAt(offset: long): OopHandle;
              getJBooleanAt(offset: long): boolean;
              getJByteAt(offset: long): byte;
              getJCharAt(offset: long): char;
              getJDoubleAt(offset: long): double;
              getJFloatAt(offset: long): float;
              getJIntAt(offset: long): int;
              getJLongAt(offset: long): long;
              getJShortAt(offset: long): short;
              getOopHandleAt(offset: long): OopHandle;
              greaterThan(arg: Address): boolean;
              greaterThanOrEqual(arg: Address): boolean;
              hashCode(): int;
              lessThan(arg: Address): boolean;
              lessThanOrEqual(arg: Address): boolean;
              minus(arg: Address): long;
              orWithMask(mask: long): Address;
              setAddressAt(offset: long, a1: Address): void;
              setCIntegerAt(offset: long, a1: long, numBytes: long): void;
              setJBooleanAt(offset: long, a1: boolean): void;
              setJByteAt(offset: long, a1: byte): void;
              setJCharAt(offset: long, a1: char): void;
              setJDoubleAt(offset: long, a1: double): void;
              setJFloatAt(offset: long, a1: float): void;
              setJIntAt(offset: long, a1: int): void;
              setJLongAt(offset: long, a1: long): void;
              setJShortAt(offset: long, a1: short): void;
              setOopHandleAt(offset: long, a1: OopHandle): void;
              toString(): string;
              xorWithMask(mask: long): Address;
              _addr: long;
              _debugger: RemoteDebuggerClient;
            }
            interface RemoteAddress extends CombineTypes<[_RemoteAddress, java.lang.Object, sun.jvm.hotspot.debugger.Address]> {}
            interface _RemoteDebugger$$static extends ClassLike {
            }
            let RemoteDebugger: _RemoteDebugger$$static;
            interface _RemoteDebugger {
              areThreadsEqual(a0: long, a1: boolean, a2: long, a3: boolean): boolean;
              consoleExecuteCommand(a0: string): string;
              execCommandOnServer(command: string, options: java.util.Map<string,any>): string;
              getCPU(): string;
              getConsolePrompt(): string;
              getHeapOopSize(): long;
              getJBooleanSize(): long;
              getJByteSize(): long;
              getJCharSize(): long;
              getJDoubleSize(): long;
              getJFloatSize(): long;
              getJIntSize(): long;
              getJLongSize(): long;
              getJShortSize(): long;
              getKlassPtrSize(): long;
              getMachineDescription(): MachineDescription;
              getNarrowKlassBase(): long;
              getNarrowKlassShift(): int;
              getNarrowOopBase(): long;
              getNarrowOopShift(): int;
              getOS(): string;
              getThreadHashCode(a0: long, a1: boolean): int;
              getThreadIntegerRegisterSet(a0: long, a1: boolean): long[];
              hasConsole(): boolean;
              lookupInProcess(a0: string, a1: string): long;
              readBytesFromProcess(a0: long, a1: long): ReadResult;
            }
            interface RemoteDebugger extends CombineTypes<[_RemoteDebugger, java.rmi.Remote, java.lang.Object]> {}
            interface _RemoteDebuggerClient$$static extends ClassLike {
              _cacheSize: int;
              new(remoteDebugger: RemoteDebugger): RemoteDebuggerClient;
            }
            let RemoteDebuggerClient: _RemoteDebuggerClient$$static;
            interface _RemoteDebuggerClient {
              addressValueToString(addr: long): string;
              _areThreadsEqual(addr1: Address, addr2: Address): boolean;
              _areThreadsEqual(id1: long, a1: long): boolean;
              _areThreadsEqual(addr1: Address, id2: long): boolean;
              _areThreadsEqual(id1: long, a1: Address): boolean;
              attach(processID: int): void;
              attach(executableName: string, coreFileName: string): void;
              configureJavaPrimitiveTypeSizes(jbooleanSize: long, a1: long, jbyteSize: long, a3: long, jcharSize: long, a5: long, jdoubleSize: long, a7: long): void;
              consoleExecuteCommand(cmd: string): string;
              detach(): boolean;
              execCommandOnServer(command: string, options: java.util.Map<string,any>): string;
              findSymbol(symbol: string): string;
              getAddressValue(addr: Address): long;
              getCDebugger(): debugger.cdbg.CDebugger;
              getCPU(): string;
              getConsolePrompt(): string;
              getMachineDescription(): MachineDescription;
              getOS(): string;
              getProcessList(): java.util.List<ProcessInfo>;
              getRemoteProcessAddressSize(): int;
              getThreadForIdentifierAddress(addr: Address): ThreadProxy;
              getThreadForThreadId(id: long): ThreadProxy;
              _getThreadHashCode(a: Address): int;
              _getThreadHashCode(id: long): int;
              getThreadIntegerRegisterSet(addr: Address): long[];
              getThreadIntegerRegisterSet(id: long): long[];
              hasConsole(): boolean;
              hasProcessList(): boolean;
              lookup(objectName: string, symbol: string): Address;
              lookupOop(objectName: string, symbol: string): OopHandle;
              newAddress(value: long): Address;
              parseAddress(addressString: string): Address;
              _readAddress(address: long): RemoteAddress;
              readBytesFromProcess(address: long, a1: long): ReadResult;
              _readCompKlassAddress(address: long): RemoteAddress;
              _readCompOopAddress(address: long): RemoteAddress;
              _readCompOopHandle(address: long): RemoteOopHandle;
              _readOopHandle(address: long): RemoteOopHandle;
              setMachineDescription(machDesc: MachineDescription): void;
              _remoteDebugger: RemoteDebugger;
              _threadFactory: RemoteThreadFactory;
            }
            interface RemoteDebuggerClient extends CombineTypes<[_RemoteDebuggerClient, sun.jvm.hotspot.debugger.DebuggerBase, sun.jvm.hotspot.debugger.JVMDebugger]> {}
            interface _RemoteDebuggerServer$$static extends ClassLike {
              new(): RemoteDebuggerServer;
              new(debugger: JVMDebugger, port: int): RemoteDebuggerServer;
              new(debugger: JVMDebugger): RemoteDebuggerServer;
            }
            let RemoteDebuggerServer: _RemoteDebuggerServer$$static;
            interface _RemoteDebuggerServer {
              areThreadsEqual(addrOrId1: long, a1: boolean, isAddress1: long, addrOrId2: boolean): boolean;
              consoleExecuteCommand(cmd: string): string;
              execCommandOnServer(command: string, options: java.util.Map<string,any>): string;
              getCPU(): string;
              getConsolePrompt(): string;
              getHeapOopSize(): long;
              getJBooleanSize(): long;
              getJByteSize(): long;
              getJCharSize(): long;
              getJDoubleSize(): long;
              getJFloatSize(): long;
              getJIntSize(): long;
              getJLongSize(): long;
              getJShortSize(): long;
              getKlassPtrSize(): long;
              getMachineDescription(): MachineDescription;
              getNarrowKlassBase(): long;
              getNarrowKlassShift(): int;
              getNarrowOopBase(): long;
              getNarrowOopShift(): int;
              getOS(): string;
              getThreadHashCode(addrOrId: long, a1: boolean): int;
              getThreadIntegerRegisterSet(addrOrId: long, a1: boolean): long[];
              _getThreadProxy(addrOrId: long, a1: boolean): ThreadProxy;
              hasConsole(): boolean;
              lookupInProcess(objectName: string, symbol: string): long;
              readBytesFromProcess(address: long, a1: long): ReadResult;
              _debugger: JVMDebugger;
            }
            interface RemoteDebuggerServer extends CombineTypes<[_RemoteDebuggerServer, sun.jvm.hotspot.debugger.remote.RemoteDebugger, java.rmi.server.UnicastRemoteObject]> {}
            interface _RemoteOopHandle$$static extends ClassLike {
              _new(debugger: RemoteDebuggerClient, addr: long): RemoteOopHandle;
            }
            let RemoteOopHandle: _RemoteOopHandle$$static;
            interface _RemoteOopHandle {
              addOffsetTo(offset: long): Address;
              andWithMask(mask: long): Address;
              orWithMask(mask: long): Address;
              xorWithMask(mask: long): Address;
            }
            interface RemoteOopHandle extends CombineTypes<[_RemoteOopHandle, sun.jvm.hotspot.debugger.remote.RemoteAddress, sun.jvm.hotspot.debugger.OopHandle]> {}
            interface _RemoteThread$$static extends ClassLike {
              new(debugger: RemoteDebuggerClient, addr: Address): RemoteThread;
              new(debugger: RemoteDebuggerClient, id: long): RemoteThread;
            }
            let RemoteThread: _RemoteThread$$static;
            interface _RemoteThread {
              canSetContext(): boolean;
              equals(o: any): boolean;
              hashCode(): int;
              setContext(context: ThreadContext): void;
              toString(): string;
              _addr: Address;
              _debugger: RemoteDebuggerClient;
              _id: long;
            }
            interface RemoteThread extends CombineTypes<[_RemoteThread, sun.jvm.hotspot.debugger.ThreadProxy, java.lang.Object]> {}
            interface _RemoteThreadFactory$$static extends ClassLike {
            }
            let RemoteThreadFactory: _RemoteThreadFactory$$static;
            interface _RemoteThreadFactory {
              createThreadWrapper(a0: Address): ThreadProxy;
              createThreadWrapper(a0: long): ThreadProxy;
            }
            interface RemoteThreadFactory extends CombineTypes<[_RemoteThreadFactory, java.lang.Object]> {}
          }
          module riscv64 {
            interface _RISCV64ThreadContext$$static extends ClassLike {
              readonly FP: int;
              readonly LR: int;
              readonly NPRGREG: int;
              readonly PC: int;
              readonly R0: int;
              readonly R1: int;
              readonly R10: int;
              readonly R11: int;
              readonly R12: int;
              readonly R13: int;
              readonly R14: int;
              readonly R15: int;
              readonly R16: int;
              readonly R17: int;
              readonly R18: int;
              readonly R19: int;
              readonly R2: int;
              readonly R20: int;
              readonly R21: int;
              readonly R22: int;
              readonly R23: int;
              readonly R24: int;
              readonly R25: int;
              readonly R26: int;
              readonly R27: int;
              readonly R28: int;
              readonly R29: int;
              readonly R3: int;
              readonly R30: int;
              readonly R31: int;
              readonly R4: int;
              readonly R5: int;
              readonly R6: int;
              readonly R7: int;
              readonly R8: int;
              readonly R9: int;
              readonly SP: int;
              new(): RISCV64ThreadContext;
            }
            let RISCV64ThreadContext: _RISCV64ThreadContext$$static;
            interface _RISCV64ThreadContext {
              getNumRegisters(): int;
              getRegister(index: int): long;
              getRegisterAsAddress(a0: int): Address;
              getRegisterName(index: int): string;
              getTopFrame(dbg: Debugger): debugger.cdbg.CFrame;
              setRegister(index: int, value: long): void;
              setRegisterAsAddress(a0: int, a1: Address): void;
              _data: long[];
            }
            interface RISCV64ThreadContext extends CombineTypes<[_RISCV64ThreadContext, sun.jvm.hotspot.debugger.ThreadContext, java.lang.Object]> {}
          }
          module win32 {
            module coff {
              interface _AuxBfEfRecord$$static extends ClassLike {
              }
              let AuxBfEfRecord: _AuxBfEfRecord$$static;
              interface _AuxBfEfRecord {
                getLineNumber(): short;
                getPointerToNextFunction(): int;
              }
              interface AuxBfEfRecord extends CombineTypes<[_AuxBfEfRecord, java.lang.Object, sun.jvm.hotspot.debugger.win32.coff.AuxSymbolRecord]> {}
              interface _AuxFileRecord$$static extends ClassLike {
              }
              let AuxFileRecord: _AuxFileRecord$$static;
              interface _AuxFileRecord {
                getName(): string;
(): string;
              }
              interface AuxFileRecord extends CombineTypes<[_AuxFileRecord, java.lang.Object, sun.jvm.hotspot.debugger.win32.coff.AuxSymbolRecord]> {}
              interface _AuxFunctionDefinitionRecord$$static extends ClassLike {
              }
              let AuxFunctionDefinitionRecord: _AuxFunctionDefinitionRecord$$static;
              interface _AuxFunctionDefinitionRecord {
                getPointerToLineNumber(): int;
                getPointerToNextFunction(): int;
                getTagIndex(): int;
                getTotalSize(): int;
              }
              interface AuxFunctionDefinitionRecord extends CombineTypes<[_AuxFunctionDefinitionRecord, java.lang.Object, sun.jvm.hotspot.debugger.win32.coff.AuxSymbolRecord]> {}
              interface _AuxSectionDefinitionsRecord$$static extends ClassLike {
              }
              let AuxSectionDefinitionsRecord: _AuxSectionDefinitionsRecord$$static;
              interface _AuxSectionDefinitionsRecord {
                getCheckSum(): int;
                getLength(): int;
                getNumber(): short;
                getNumberOfLineNumbers(): short;
                getNumberOfRelocations(): short;
                getSelection(): byte;
              }
              interface AuxSectionDefinitionsRecord extends CombineTypes<[_AuxSectionDefinitionsRecord, java.lang.Object, sun.jvm.hotspot.debugger.win32.coff.AuxSymbolRecord]> {}
              interface _AuxSymbolRecord$$static extends ClassLike {
                readonly BF_EF_RECORD: int;
                readonly FILE: int;
                readonly FUNCTION_DEFINITION: int;
                readonly SECTION_DEFINITION: int;
                readonly WEAK_EXTERNAL: int;
              }
              let AuxSymbolRecord: _AuxSymbolRecord$$static;
              interface _AuxSymbolRecord {
                getType(): int;
(): int;
              }
              interface AuxSymbolRecord extends CombineTypes<[_AuxSymbolRecord, java.lang.Object]> {}
              interface _AuxWeakExternalRecord$$static extends ClassLike {
                readonly IMAGE_WEAK_EXTERN_SEARCH_ALIAS: int;
                readonly IMAGE_WEAK_EXTERN_SEARCH_LIBRARY: int;
                readonly IMAGE_WEAK_EXTERN_SEARCH_NOLIBRARY: int;
              }
              let AuxWeakExternalRecord: _AuxWeakExternalRecord$$static;
              interface _AuxWeakExternalRecord {
                getCharacteristics(): int;
                getTagIndex(): int;
              }
              interface AuxWeakExternalRecord extends CombineTypes<[_AuxWeakExternalRecord, java.lang.Object, sun.jvm.hotspot.debugger.win32.coff.AuxSymbolRecord]> {}
              interface _COFFException$$static extends ClassLike {
                new(): COFFException;
                new(cause: java.lang.Throwable): COFFException;
                new(message: string): COFFException;
                new(message: string, cause: java.lang.Throwable): COFFException;
              }
              let COFFException: _COFFException$$static;
              interface _COFFException {
              }
              interface COFFException extends CombineTypes<[_COFFException, java.lang.RuntimeException]> {}
              interface _COFFFile$$static extends ClassLike {
              }
              let COFFFile: _COFFFile$$static;
              interface _COFFFile {
                close(): void;
                getHeader(): COFFHeader;
                isImage(): boolean;
              }
              interface COFFFile extends CombineTypes<[_COFFFile, java.lang.Object]> {}
              interface _COFFFileParser$$static extends ClassLike {
                getParser(): COFFFileParser;
                _COFF_HEADER_SIZE: int;
                _LINE_NUMBER_SIZE: int;
                _RELOCATION_SIZE: int;
                _SECTION_HEADER_SIZE: int;
                _SYMBOL_SIZE: int;
                _soleInstance: COFFFileParser;
              }
              let COFFFileParser: _COFFFileParser$$static;
              interface _COFFFileParser {
                parse(filename: string): COFFFile;
                parse(source: DataSource): COFFFile;
              }
              interface COFFFileParser extends CombineTypes<[_COFFFileParser, java.lang.Object]> {}
              interface _COFFFileParser$COFFFileImpl$$static extends ClassLike {
                _new(this$0: COFFFileParser, file: DataSource): COFFFileParser$COFFFileImpl;
              }
              let COFFFileParser$COFFFileImpl: _COFFFileParser$COFFFileImpl$$static;
              interface _COFFFileParser$COFFFileImpl {
                _byteSwap(arg: short): short;
                _byteSwap(arg: int): int;
                _byteSwap(arg: long): long;
                close(): void;
                _getFilePointer(): long;
                getHeader(): COFFHeader;
                _initialize(): void;
                isImage(): boolean;
                _readByte(): byte;
                _readByteAt(offset: long): byte;
                _readBytes(b: byte[]): int;
                _readBytesAt(offset: long, a1: byte[]): int;
                _readCString(): string;
                _readDouble(): double;
                _readFloat(): float;
                _readInt(): int;
                _readIntAt(offset: long): int;
                _readLong(): long;
                _readLongAt(offset: long): long;
                _readShort(): short;
                _readShortAt(offset: long): short;
                _seek(offset: long): void;
                _file: DataSource;
                _filePos: long;
                _header: hotspot.utilities.memo.MemoizedObject;
                _imageHeaderOffset: long;
                _isImage: boolean;
              }
              interface COFFFileParser$COFFFileImpl extends CombineTypes<[_COFFFileParser$COFFFileImpl, sun.jvm.hotspot.debugger.win32.coff.COFFFile, java.lang.Object]> {}
              interface _COFFFileParser$COFFFileImpl$COFFHeaderImpl$$static extends ClassLike {
                _new(this$1: COFFFileParser$COFFFileImpl): COFFFileParser$COFFFileImpl$COFFHeaderImpl;
              }
              let COFFFileParser$COFFFileImpl$COFFHeaderImpl: _COFFFileParser$COFFFileImpl$COFFHeaderImpl$$static;
              interface _COFFFileParser$COFFFileImpl$COFFHeaderImpl {
                getCOFFSymbol(index: int): COFFSymbol;
                getCharacteristics(): short;
                getMachineType(): short;
                getNumberOfSections(): short;
                getNumberOfStrings(): int;
                getNumberOfSymbols(): int;
                getOptionalHeader(): OptionalHeader;
                getPointerToSymbolTable(): int;
                getSectionHeader(index: int): SectionHeader;
                getSizeOfOptionalHeader(): short;
                getString(i: int): string;
                _getStringTable(): COFFFileParser$COFFFileImpl$COFFHeaderImpl$StringTable;
                getTimeDateStamp(): int;
                hasCharacteristic(characteristic: short): boolean;
                _rvaToFileOffset(rva: int): int;
                _characteristics: short;
                _machine: short;
                _numberOfSections: short;
                _numberOfSymbols: int;
                _pointerToSymbolTable: int;
                _sectionHeaders: hotspot.utilities.memo.MemoizedObject[];
                _sizeOfOptionalHeader: short;
                _stringTable: hotspot.utilities.memo.MemoizedObject;
                _symbols: hotspot.utilities.memo.MemoizedObject[];
                _this$1: COFFFileParser$COFFFileImpl;
                _timeDateStamp: int;
              }
              interface COFFFileParser$COFFFileImpl$COFFHeaderImpl extends CombineTypes<[_COFFFileParser$COFFFileImpl$COFFHeaderImpl, sun.jvm.hotspot.debugger.win32.coff.COFFHeader, java.lang.Object]> {}
              interface _COFFFileParser$COFFFileImpl$COFFHeaderImpl$AuxBfEfRecordImpl$$static extends ClassLike {
                _new(this$2: COFFFileParser$COFFFileImpl$COFFHeaderImpl, offset: int): COFFFileParser$COFFFileImpl$COFFHeaderImpl$AuxBfEfRecordImpl;
              }
              let COFFFileParser$COFFFileImpl$COFFHeaderImpl$AuxBfEfRecordImpl: _COFFFileParser$COFFFileImpl$COFFHeaderImpl$AuxBfEfRecordImpl$$static;
              interface _COFFFileParser$COFFFileImpl$COFFHeaderImpl$AuxBfEfRecordImpl {
                getLineNumber(): short;
                getPointerToNextFunction(): int;
                getType(): int;
                _lineNumber: short;
                _pointerToNextFunction: int;
              }
              interface COFFFileParser$COFFFileImpl$COFFHeaderImpl$AuxBfEfRecordImpl extends CombineTypes<[_COFFFileParser$COFFFileImpl$COFFHeaderImpl$AuxBfEfRecordImpl, sun.jvm.hotspot.debugger.win32.coff.AuxBfEfRecord, java.lang.Object]> {}
              interface _COFFFileParser$COFFFileImpl$COFFHeaderImpl$AuxFileRecordImpl$$static extends ClassLike {
                _new(this$2: COFFFileParser$COFFFileImpl$COFFHeaderImpl, offset: int): COFFFileParser$COFFFileImpl$COFFHeaderImpl$AuxFileRecordImpl;
              }
              let COFFFileParser$COFFFileImpl$COFFHeaderImpl$AuxFileRecordImpl: _COFFFileParser$COFFFileImpl$COFFHeaderImpl$AuxFileRecordImpl$$static;
              interface _COFFFileParser$COFFFileImpl$COFFHeaderImpl$AuxFileRecordImpl {
                getName(): string;
                getType(): int;
                _name: string;
              }
              interface COFFFileParser$COFFFileImpl$COFFHeaderImpl$AuxFileRecordImpl extends CombineTypes<[_COFFFileParser$COFFFileImpl$COFFHeaderImpl$AuxFileRecordImpl, sun.jvm.hotspot.debugger.win32.coff.AuxFileRecord, java.lang.Object]> {}
              interface _COFFFileParser$COFFFileImpl$COFFHeaderImpl$AuxFunctionDefinitionRecordImpl$$static extends ClassLike {
                _new(this$2: COFFFileParser$COFFFileImpl$COFFHeaderImpl, offset: int): COFFFileParser$COFFFileImpl$COFFHeaderImpl$AuxFunctionDefinitionRecordImpl;
              }
              let COFFFileParser$COFFFileImpl$COFFHeaderImpl$AuxFunctionDefinitionRecordImpl: _COFFFileParser$COFFFileImpl$COFFHeaderImpl$AuxFunctionDefinitionRecordImpl$$static;
              interface _COFFFileParser$COFFFileImpl$COFFHeaderImpl$AuxFunctionDefinitionRecordImpl {
                getPointerToLineNumber(): int;
                getPointerToNextFunction(): int;
                getTagIndex(): int;
                getTotalSize(): int;
                getType(): int;
                _pointerToLineNumber: int;
                _pointerToNextFunction: int;
                _tagIndex: int;
                _totalSize: int;
              }
              interface COFFFileParser$COFFFileImpl$COFFHeaderImpl$AuxFunctionDefinitionRecordImpl extends CombineTypes<[_COFFFileParser$COFFFileImpl$COFFHeaderImpl$AuxFunctionDefinitionRecordImpl, java.lang.Object, sun.jvm.hotspot.debugger.win32.coff.AuxFunctionDefinitionRecord]> {}
              interface _COFFFileParser$COFFFileImpl$COFFHeaderImpl$AuxSectionDefinitionsRecordImpl$$static extends ClassLike {
                _new(this$2: COFFFileParser$COFFFileImpl$COFFHeaderImpl, offset: int): COFFFileParser$COFFFileImpl$COFFHeaderImpl$AuxSectionDefinitionsRecordImpl;
              }
              let COFFFileParser$COFFFileImpl$COFFHeaderImpl$AuxSectionDefinitionsRecordImpl: _COFFFileParser$COFFFileImpl$COFFHeaderImpl$AuxSectionDefinitionsRecordImpl$$static;
              interface _COFFFileParser$COFFFileImpl$COFFHeaderImpl$AuxSectionDefinitionsRecordImpl {
                getCheckSum(): int;
                getLength(): int;
                getNumber(): short;
                getNumberOfLineNumbers(): short;
                getNumberOfRelocations(): short;
                getSelection(): byte;
                getType(): int;
                _checkSum: int;
                _length: int;
                _number: short;
                _numberOfLineNumbers: short;
                _numberOfRelocations: short;
                _selection: byte;
              }
              interface COFFFileParser$COFFFileImpl$COFFHeaderImpl$AuxSectionDefinitionsRecordImpl extends CombineTypes<[_COFFFileParser$COFFFileImpl$COFFHeaderImpl$AuxSectionDefinitionsRecordImpl, sun.jvm.hotspot.debugger.win32.coff.AuxSectionDefinitionsRecord, java.lang.Object]> {}
              interface _COFFFileParser$COFFFileImpl$COFFHeaderImpl$AuxWeakExternalRecordImpl$$static extends ClassLike {
                _new(this$2: COFFFileParser$COFFFileImpl$COFFHeaderImpl, offset: int): COFFFileParser$COFFFileImpl$COFFHeaderImpl$AuxWeakExternalRecordImpl;
              }
              let COFFFileParser$COFFFileImpl$COFFHeaderImpl$AuxWeakExternalRecordImpl: _COFFFileParser$COFFFileImpl$COFFHeaderImpl$AuxWeakExternalRecordImpl$$static;
              interface _COFFFileParser$COFFFileImpl$COFFHeaderImpl$AuxWeakExternalRecordImpl {
                getCharacteristics(): int;
                getTagIndex(): int;
                getType(): int;
                _characteristics: int;
                _tagIndex: int;
              }
              interface COFFFileParser$COFFFileImpl$COFFHeaderImpl$AuxWeakExternalRecordImpl extends CombineTypes<[_COFFFileParser$COFFFileImpl$COFFHeaderImpl$AuxWeakExternalRecordImpl, sun.jvm.hotspot.debugger.win32.coff.AuxWeakExternalRecord, java.lang.Object]> {}
              interface _COFFFileParser$COFFFileImpl$COFFHeaderImpl$COFFLineNumberImpl$$static extends ClassLike {
                _new(this$2: COFFFileParser$COFFFileImpl$COFFHeaderImpl, offset: int): COFFFileParser$COFFFileImpl$COFFHeaderImpl$COFFLineNumberImpl;
              }
              let COFFFileParser$COFFFileImpl$COFFHeaderImpl$COFFLineNumberImpl: _COFFFileParser$COFFFileImpl$COFFHeaderImpl$COFFLineNumberImpl$$static;
              interface _COFFFileParser$COFFFileImpl$COFFHeaderImpl$COFFLineNumberImpl {
                getLineNumber(): short;
                getType(): int;
                _lineNumber: short;
                _type: int;
              }
              interface COFFFileParser$COFFFileImpl$COFFHeaderImpl$COFFLineNumberImpl extends CombineTypes<[_COFFFileParser$COFFFileImpl$COFFHeaderImpl$COFFLineNumberImpl, sun.jvm.hotspot.debugger.win32.coff.COFFLineNumber, java.lang.Object]> {}
              interface _COFFFileParser$COFFFileImpl$COFFHeaderImpl$COFFRelocationImpl$$static extends ClassLike {
                _new(this$2: COFFFileParser$COFFFileImpl$COFFHeaderImpl, offset: int): COFFFileParser$COFFFileImpl$COFFHeaderImpl$COFFRelocationImpl;
              }
              let COFFFileParser$COFFFileImpl$COFFHeaderImpl$COFFRelocationImpl: _COFFFileParser$COFFFileImpl$COFFHeaderImpl$COFFRelocationImpl$$static;
              interface _COFFFileParser$COFFFileImpl$COFFHeaderImpl$COFFRelocationImpl {
                getSymbolTableIndex(): int;
                getType(): short;
                getVirtualAddress(): int;
                _symbolTableIndex: int;
                _type: short;
                _virtualAddress: int;
              }
              interface COFFFileParser$COFFFileImpl$COFFHeaderImpl$COFFRelocationImpl extends CombineTypes<[_COFFFileParser$COFFFileImpl$COFFHeaderImpl$COFFRelocationImpl, sun.jvm.hotspot.debugger.win32.coff.COFFRelocation, java.lang.Object]> {}
              interface _COFFFileParser$COFFFileImpl$COFFHeaderImpl$COFFSymbolImpl$$static extends ClassLike {
                new(this$2: COFFFileParser$COFFFileImpl$COFFHeaderImpl, offset: int): COFFFileParser$COFFFileImpl$COFFHeaderImpl$COFFSymbolImpl;
              }
              let COFFFileParser$COFFFileImpl$COFFHeaderImpl$COFFSymbolImpl: _COFFFileParser$COFFFileImpl$COFFHeaderImpl$COFFSymbolImpl$$static;
              interface _COFFFileParser$COFFFileImpl$COFFHeaderImpl$COFFSymbolImpl {
                getAuxBfEfRecord(): AuxBfEfRecord;
                getAuxFileRecord(): AuxFileRecord;
                getAuxFunctionDefinitionRecord(): AuxFunctionDefinitionRecord;
                getAuxSectionDefinitionsRecord(): AuxSectionDefinitionsRecord;
                getAuxWeakExternalRecord(): AuxWeakExternalRecord;
                getName(): string;
                getNumberOfAuxSymbols(): byte;
                getOffset(): int;
                getSectionNumber(): short;
                getStorageClass(): byte;
                getType(): short;
                getValue(): int;
                isBfOrEfSymbol(): boolean;
                isFile(): boolean;
                isFunctionDefinition(): boolean;
                isSectionDefinition(): boolean;
                isWeakExternal(): boolean;
                _auxBfEfRecord: hotspot.utilities.memo.MemoizedObject;
                _auxFileRecord: hotspot.utilities.memo.MemoizedObject;
                _auxFunctionDefinitionRecord: hotspot.utilities.memo.MemoizedObject;
                _auxSectionDefinitionsRecord: hotspot.utilities.memo.MemoizedObject;
                _auxWeakExternalRecord: hotspot.utilities.memo.MemoizedObject;
                _name: string;
                _numberOfAuxSymbols: byte;
                _offset: int;
                _sectionNumber: short;
                _storageClass: byte;
                _this$2: COFFFileParser$COFFFileImpl$COFFHeaderImpl;
                _type: short;
                _value: int;
              }
              interface COFFFileParser$COFFFileImpl$COFFHeaderImpl$COFFSymbolImpl extends CombineTypes<[_COFFFileParser$COFFFileImpl$COFFHeaderImpl$COFFSymbolImpl, sun.jvm.hotspot.debugger.win32.coff.COFFSymbolConstants, sun.jvm.hotspot.debugger.win32.coff.COFFSymbol, java.lang.Object]> {}
              interface _COFFFileParser$COFFFileImpl$COFFHeaderImpl$DataDirectoryImpl$$static extends ClassLike {
                _new(this$2: COFFFileParser$COFFFileImpl$COFFHeaderImpl, offset: int): COFFFileParser$COFFFileImpl$COFFHeaderImpl$DataDirectoryImpl;
              }
              let COFFFileParser$COFFFileImpl$COFFHeaderImpl$DataDirectoryImpl: _COFFFileParser$COFFFileImpl$COFFHeaderImpl$DataDirectoryImpl$$static;
              interface _COFFFileParser$COFFFileImpl$COFFHeaderImpl$DataDirectoryImpl {
                getRVA(): int;
                getSize(): int;
                _rva: int;
                _size: int;
              }
              interface COFFFileParser$COFFFileImpl$COFFHeaderImpl$DataDirectoryImpl extends CombineTypes<[_COFFFileParser$COFFFileImpl$COFFHeaderImpl$DataDirectoryImpl, java.lang.Object, sun.jvm.hotspot.debugger.win32.coff.DataDirectory]> {}
              interface _COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugDirectoryEntryImpl$$static extends ClassLike {
                _new(this$2: COFFFileParser$COFFFileImpl$COFFHeaderImpl, offset: int): COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugDirectoryEntryImpl;
              }
              let COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugDirectoryEntryImpl: _COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugDirectoryEntryImpl$$static;
              interface _COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugDirectoryEntryImpl {
                getAddressOfRawData(): int;
                getCharacteristics(): int;
                getDebugVC50(): DebugVC50;
                getMajorVersion(): short;
                getMinorVersion(): short;
                getPointerToRawData(): int;
                getRawDataByte(i: int): byte;
                getSizeOfData(): int;
                getTimeDateStamp(): int;
                getType(): int;
                _addressOfRawData: int;
                _characteristics: int;
                _majorVersion: short;
                _minorVersion: short;
                _pointerToRawData: int;
                _sizeOfData: int;
                _this$2: COFFFileParser$COFFFileImpl$COFFHeaderImpl;
                _timeDateStamp: int;
                _type: int;
              }
              interface COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugDirectoryEntryImpl extends CombineTypes<[_COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugDirectoryEntryImpl, sun.jvm.hotspot.debugger.win32.coff.DebugTypes, sun.jvm.hotspot.debugger.win32.coff.DebugDirectoryEntry, java.lang.Object]> {}
              interface _COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugDirectoryImpl$$static extends ClassLike {
                _DEBUG_DIRECTORY_ENTRY_SIZE: int;
                _new(this$2: COFFFileParser$COFFFileImpl$COFFHeaderImpl, offset: int, size: int): COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugDirectoryImpl;
              }
              let COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugDirectoryImpl: _COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugDirectoryImpl$$static;
              interface _COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugDirectoryImpl {
                getEntry(i: int): DebugDirectoryEntry;
                getNumEntries(): int;
                _numEntries: int;
                _offset: int;
                _size: int;
                _this$2: COFFFileParser$COFFFileImpl$COFFHeaderImpl;
              }
              interface COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugDirectoryImpl extends CombineTypes<[_COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugDirectoryImpl, java.lang.Object, sun.jvm.hotspot.debugger.win32.coff.DebugDirectory]> {}
              interface _COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$$static extends ClassLike {
                _new(this$2: COFFFileParser$COFFFileImpl$COFFHeaderImpl, offset: int): COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl;
              }
              let COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl: _COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$$static;
              interface _COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl {
                _biasTypeIndex(index: int): int;
                getSubsectionDirectory(): DebugVC50SubsectionDirectory;
                getSubsectionDirectoryOffset(): int;
                _globalOffset(offset: int): int;
                _lengthPrefixedStringLengthAt(absoluteOffset: int): int;
                _numericLeafLengthAt(absoluteOffset: int): int;
                _readDoubleNumericLeafAt(absoluteOffset: int): double;
                _readFloatNumericLeafAt(absoluteOffset: int): float;
                _readIntNumericLeafAt(absoluteOffset: int): int;
                _readLengthPrefixedStringAt(absoluteOffset: int): string;
                _readLongNumericLeafAt(absoluteOffset: int): long;
                _unbiasTypeIndex(index: int): int;
                _verify(): void;
                _lfaBase: int;
                _subsectionDirectory: hotspot.utilities.memo.MemoizedObject;
                _subsectionDirectoryOffset: int;
                _this$2: COFFFileParser$COFFFileImpl$COFFHeaderImpl;
              }
              interface COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl extends CombineTypes<[_COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl, sun.jvm.hotspot.debugger.win32.coff.DebugVC50, java.lang.Object, sun.jvm.hotspot.debugger.win32.coff.DebugVC50TypeLeafIndices]> {}
              interface _COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SSAlignSymImpl$$static extends ClassLike {
                _new(this$3: COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl, ssType: short, iMod: short, ssSize: int, offset: int): COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SSAlignSymImpl;
              }
              let COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SSAlignSymImpl: _COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SSAlignSymImpl$$static;
              interface _COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SSAlignSymImpl {
                getSymbolIterator(): DebugVC50SymbolIterator;
                _offset: int;
                _this$3: COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl;
              }
              interface COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SSAlignSymImpl extends CombineTypes<[_COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SSAlignSymImpl, sun.jvm.hotspot.debugger.win32.coff.COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SubsectionImpl, sun.jvm.hotspot.debugger.win32.coff.DebugVC50SSAlignSym]> {}
              interface _COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SSFileIndexImpl$$static extends ClassLike {
                _new(this$3: COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl, ssType: short, iMod: short, ssSize: int, offset: int): COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SSFileIndexImpl;
              }
              let COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SSFileIndexImpl: _COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SSFileIndexImpl$$static;
              interface _COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SSFileIndexImpl {
                getModStart(): short[];
                getNameRef(): int[];
                getNames(): string[];
                getNumModules(): short;
                getNumReferences(): short;
                getRefCount(): short[];
                _cMod: short;
                _cRef: short;
                _cRefCnt: hotspot.utilities.memo.MemoizedObject;
                _modStart: hotspot.utilities.memo.MemoizedObject;
                _nameRef: hotspot.utilities.memo.MemoizedObject;
                _names: hotspot.utilities.memo.MemoizedObject;
                _offset: int;
                _this$3: COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl;
              }
              interface COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SSFileIndexImpl extends CombineTypes<[_COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SSFileIndexImpl, sun.jvm.hotspot.debugger.win32.coff.COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SubsectionImpl, sun.jvm.hotspot.debugger.win32.coff.DebugVC50SSFileIndex]> {}
              interface _COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SSGlobalPubImpl$$static extends ClassLike {
                _new(this$3: COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl, ssType: short, iMod: short, ssSize: int, offset: int): COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SSGlobalPubImpl;
              }
              let COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SSGlobalPubImpl: _COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SSGlobalPubImpl$$static;
              interface _COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SSGlobalPubImpl {
              }
              interface COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SSGlobalPubImpl extends CombineTypes<[_COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SSGlobalPubImpl, sun.jvm.hotspot.debugger.win32.coff.DebugVC50SSGlobalPub, sun.jvm.hotspot.debugger.win32.coff.COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SSSymbolBaseImpl]> {}
              interface _COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SSGlobalSymImpl$$static extends ClassLike {
                _new(this$3: COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl, ssType: short, iMod: short, ssSize: int, offset: int): COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SSGlobalSymImpl;
              }
              let COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SSGlobalSymImpl: _COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SSGlobalSymImpl$$static;
              interface _COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SSGlobalSymImpl {
              }
              interface COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SSGlobalSymImpl extends CombineTypes<[_COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SSGlobalSymImpl, sun.jvm.hotspot.debugger.win32.coff.COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SSSymbolBaseImpl, sun.jvm.hotspot.debugger.win32.coff.DebugVC50SSGlobalSym]> {}
              interface _COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SSGlobalTypesImpl$$static extends ClassLike {
                _new(this$3: COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl, ssType: short, iMod: short, ssSize: int, offset: int): COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SSGlobalTypesImpl;
              }
              let COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SSGlobalTypesImpl: _COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SSGlobalTypesImpl$$static;
              interface _COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SSGlobalTypesImpl {
                getNumTypes(): int;
                getTypeIterator(): DebugVC50TypeIterator;
                getTypeOffset(i: int): int;
                _offsetOfFirstType(): int;
                _cType: int;
                _offset: int;
                _this$3: COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl;
              }
              interface COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SSGlobalTypesImpl extends CombineTypes<[_COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SSGlobalTypesImpl, sun.jvm.hotspot.debugger.win32.coff.COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SubsectionImpl, sun.jvm.hotspot.debugger.win32.coff.DebugVC50SSGlobalTypes]> {}
              interface _COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SSLibrariesImpl$$static extends ClassLike {
                _new(this$3: COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl, ssType: short, iMod: short, ssSize: int, offset: int): COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SSLibrariesImpl;
              }
              let COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SSLibrariesImpl: _COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SSLibrariesImpl$$static;
              interface _COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SSLibrariesImpl {
              }
              interface COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SSLibrariesImpl extends CombineTypes<[_COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SSLibrariesImpl, sun.jvm.hotspot.debugger.win32.coff.COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SubsectionImpl, sun.jvm.hotspot.debugger.win32.coff.DebugVC50SSLibraries]> {}
              interface _COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SSMPCImpl$$static extends ClassLike {
                _new(this$3: COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl, ssType: short, iMod: short, ssSize: int, offset: int): COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SSMPCImpl;
              }
              let COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SSMPCImpl: _COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SSMPCImpl$$static;
              interface _COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SSMPCImpl {
              }
              interface COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SSMPCImpl extends CombineTypes<[_COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SSMPCImpl, sun.jvm.hotspot.debugger.win32.coff.DebugVC50SSMPC, sun.jvm.hotspot.debugger.win32.coff.COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SubsectionImpl]> {}
              interface _COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SSModuleImpl$$static extends ClassLike {
                _HEADER_SIZE: int;
                _SEG_INFO_SIZE: int;
                _new(this$3: COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl, ssType: short, iMod: short, ssSize: int, offset: int): COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SSModuleImpl;
              }
              let COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SSModuleImpl: _COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SSModuleImpl$$static;
              interface _COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SSModuleImpl {
                getDebuggingStyle(): short;
                getLibrariesIndex(): short;
                getName(): string;
                getNumCodeSegments(): short;
                getOverlayNumber(): short;
                getSegInfo(i: int): DebugVC50SegInfo;
                _cSeg: short;
                _iLib: short;
                _name: hotspot.utilities.memo.MemoizedObject;
                _offset: int;
                _ovlNumber: short;
                _segInfo: hotspot.utilities.memo.MemoizedObject;
                _style: short;
                _this$3: COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl;
              }
              interface COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SSModuleImpl extends CombineTypes<[_COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SSModuleImpl, sun.jvm.hotspot.debugger.win32.coff.DebugVC50SSModule, sun.jvm.hotspot.debugger.win32.coff.COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SubsectionImpl]> {}
              interface _COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SSOffsetMap16Impl$$static extends ClassLike {
                _new(this$3: COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl, ssType: short, iMod: short, ssSize: int, offset: int): COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SSOffsetMap16Impl;
              }
              let COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SSOffsetMap16Impl: _COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SSOffsetMap16Impl$$static;
              interface _COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SSOffsetMap16Impl {
              }
              interface COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SSOffsetMap16Impl extends CombineTypes<[_COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SSOffsetMap16Impl, sun.jvm.hotspot.debugger.win32.coff.COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SubsectionImpl, sun.jvm.hotspot.debugger.win32.coff.DebugVC50SSOffsetMap16]> {}
              interface _COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SSOffsetMap32Impl$$static extends ClassLike {
                _new(this$3: COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl, ssType: short, iMod: short, ssSize: int, offset: int): COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SSOffsetMap32Impl;
              }
              let COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SSOffsetMap32Impl: _COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SSOffsetMap32Impl$$static;
              interface _COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SSOffsetMap32Impl {
              }
              interface COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SSOffsetMap32Impl extends CombineTypes<[_COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SSOffsetMap32Impl, sun.jvm.hotspot.debugger.win32.coff.DebugVC50SSOffsetMap32, sun.jvm.hotspot.debugger.win32.coff.COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SubsectionImpl]> {}
              interface _COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SSPreCompImpl$$static extends ClassLike {
                _new(this$3: COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl, ssType: short, iMod: short, ssSize: int, offset: int): COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SSPreCompImpl;
              }
              let COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SSPreCompImpl: _COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SSPreCompImpl$$static;
              interface _COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SSPreCompImpl {
              }
              interface COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SSPreCompImpl extends CombineTypes<[_COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SSPreCompImpl, sun.jvm.hotspot.debugger.win32.coff.COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SubsectionImpl, sun.jvm.hotspot.debugger.win32.coff.DebugVC50SSPreComp]> {}
              interface _COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SSPublicImpl$$static extends ClassLike {
                _new(this$3: COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl, ssType: short, iMod: short, ssSize: int, offset: int): COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SSPublicImpl;
              }
              let COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SSPublicImpl: _COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SSPublicImpl$$static;
              interface _COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SSPublicImpl {
              }
              interface COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SSPublicImpl extends CombineTypes<[_COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SSPublicImpl, sun.jvm.hotspot.debugger.win32.coff.DebugVC50SSPublic, sun.jvm.hotspot.debugger.win32.coff.COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SubsectionImpl]> {}
              interface _COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SSPublicSymImpl$$static extends ClassLike {
                _new(this$3: COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl, ssType: short, iMod: short, ssSize: int, offset: int): COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SSPublicSymImpl;
              }
              let COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SSPublicSymImpl: _COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SSPublicSymImpl$$static;
              interface _COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SSPublicSymImpl {
              }
              interface COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SSPublicSymImpl extends CombineTypes<[_COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SSPublicSymImpl, sun.jvm.hotspot.debugger.win32.coff.COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SubsectionImpl, sun.jvm.hotspot.debugger.win32.coff.DebugVC50SSPublicSym]> {}
              interface _COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SSSegMapImpl$$static extends ClassLike {
                _new(this$3: COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl, ssType: short, iMod: short, ssSize: int, offset: int): COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SSSegMapImpl;
              }
              let COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SSSegMapImpl: _COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SSSegMapImpl$$static;
              interface _COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SSSegMapImpl {
                getNumLogicalSegDesc(): short;
                getNumSegDesc(): short;
                getSegDesc(i: int): DebugVC50SegDesc;
                _cSeg: short;
                _cSegLog: short;
                _segDescs: hotspot.utilities.memo.MemoizedObject;
                _this$3: COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl;
              }
              interface COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SSSegMapImpl extends CombineTypes<[_COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SSSegMapImpl, sun.jvm.hotspot.debugger.win32.coff.DebugVC50SSSegMap, sun.jvm.hotspot.debugger.win32.coff.COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SubsectionImpl]> {}
              interface _COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SSSegNameImpl$$static extends ClassLike {
                _new(this$3: COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl, ssType: short, iMod: short, ssSize: int, offset: int): COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SSSegNameImpl;
              }
              let COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SSSegNameImpl: _COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SSSegNameImpl$$static;
              interface _COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SSSegNameImpl {
                getSegName(i: int): string;
                _names: hotspot.utilities.memo.MemoizedObject;
                _offset: int;
                _size: int;
                _this$3: COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl;
              }
              interface COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SSSegNameImpl extends CombineTypes<[_COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SSSegNameImpl, sun.jvm.hotspot.debugger.win32.coff.COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SubsectionImpl, sun.jvm.hotspot.debugger.win32.coff.DebugVC50SSSegName]> {}
              interface _COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SSSrcLnSegImpl$$static extends ClassLike {
                _new(this$3: COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl, ssType: short, iMod: short, ssSize: int, offset: int): COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SSSrcLnSegImpl;
              }
              let COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SSSrcLnSegImpl: _COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SSSrcLnSegImpl$$static;
              interface _COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SSSrcLnSegImpl {
              }
              interface COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SSSrcLnSegImpl extends CombineTypes<[_COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SSSrcLnSegImpl, sun.jvm.hotspot.debugger.win32.coff.COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SubsectionImpl, sun.jvm.hotspot.debugger.win32.coff.DebugVC50SSSrcLnSeg]> {}
              interface _COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SSSrcModuleImpl$$static extends ClassLike {
                _new(this$3: COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl, ssType: short, iMod: short, ssSize: int, offset: int): COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SSSrcModuleImpl;
              }
              let COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SSSrcModuleImpl: _COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SSSrcModuleImpl$$static;
              interface _COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SSSrcModuleImpl {
                getNumCodeSegments(): int;
                getNumSourceFiles(): int;
                getSegment(i: int): int;
                getSegmentEndOffset(i: int): int;
                getSegmentStartOffset(i: int): int;
                getSourceFileDesc(i: int): DebugVC50SrcModFileDesc;
                _baseSrcFiles: hotspot.utilities.memo.MemoizedObject;
                _cFile: short;
                _cSeg: short;
                _offset: int;
                _segOffsets: hotspot.utilities.memo.MemoizedObject;
                _segs: hotspot.utilities.memo.MemoizedObject;
                _this$3: COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl;
              }
              interface COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SSSrcModuleImpl extends CombineTypes<[_COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SSSrcModuleImpl, sun.jvm.hotspot.debugger.win32.coff.COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SubsectionImpl, sun.jvm.hotspot.debugger.win32.coff.DebugVC50SSSrcModule]> {}
              interface _COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SSStaticSymImpl$$static extends ClassLike {
                _new(this$3: COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl, ssType: short, iMod: short, ssSize: int, offset: int): COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SSStaticSymImpl;
              }
              let COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SSStaticSymImpl: _COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SSStaticSymImpl$$static;
              interface _COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SSStaticSymImpl {
              }
              interface COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SSStaticSymImpl extends CombineTypes<[_COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SSStaticSymImpl, sun.jvm.hotspot.debugger.win32.coff.DebugVC50SSStaticSym, sun.jvm.hotspot.debugger.win32.coff.COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SSSymbolBaseImpl]> {}
              interface _COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SSSymbolBaseImpl$$static extends ClassLike {
                _HEADER_SIZE: int;
                _new(this$3: COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl, ssType: short, iMod: short, ssSize: int, offset: int): COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SSSymbolBaseImpl;
              }
              let COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SSSymbolBaseImpl: _COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SSSymbolBaseImpl$$static;
              interface _COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SSSymbolBaseImpl {
                getAddrHashIndex(): short;
                getAddrHashSize(): int;
                getSymHashIndex(): short;
                getSymHashSize(): int;
                getSymTabSize(): int;
                getSymbolIterator(): DebugVC50SymbolIterator;
                _addrHash: short;
                _cbAddrHash: int;
                _cbSymHash: int;
                _cbSymbol: int;
                _offset: int;
                _symHash: short;
                _this$3: COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl;
              }
              interface COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SSSymbolBaseImpl extends CombineTypes<[_COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SSSymbolBaseImpl, sun.jvm.hotspot.debugger.win32.coff.DebugVC50SSSymbolBase, sun.jvm.hotspot.debugger.win32.coff.COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SubsectionImpl]> {}
              interface _COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SSSymbolsImpl$$static extends ClassLike {
                _new(this$3: COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl, ssType: short, iMod: short, ssSize: int, offset: int): COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SSSymbolsImpl;
              }
              let COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SSSymbolsImpl: _COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SSSymbolsImpl$$static;
              interface _COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SSSymbolsImpl {
              }
              interface COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SSSymbolsImpl extends CombineTypes<[_COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SSSymbolsImpl, sun.jvm.hotspot.debugger.win32.coff.COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SubsectionImpl, sun.jvm.hotspot.debugger.win32.coff.DebugVC50SSSymbols]> {}
              interface _COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SSTypesImpl$$static extends ClassLike {
                _new(this$3: COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl, ssType: short, iMod: short, ssSize: int, offset: int): COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SSTypesImpl;
              }
              let COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SSTypesImpl: _COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SSTypesImpl$$static;
              interface _COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SSTypesImpl {
              }
              interface COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SSTypesImpl extends CombineTypes<[_COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SSTypesImpl, sun.jvm.hotspot.debugger.win32.coff.DebugVC50SSTypes, sun.jvm.hotspot.debugger.win32.coff.COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SubsectionImpl]> {}
              interface _COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SegDescImpl$$static extends ClassLike {
                _new(this$3: COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl, offset: int): COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SegDescImpl;
              }
              let COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SegDescImpl: _COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SegDescImpl$$static;
              interface _COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SegDescImpl {
                getClassName(): short;
                getFlags(): short;
                getFrame(): short;
                getGroup(): short;
                getName(): short;
                getOffset(): int;
                getOverlayNum(): short;
                getSize(): int;
                _cbSeg: int;
                _flags: short;
                _frame: short;
                _group: short;
                _iClassName: short;
                _iSegName: short;
                _offset: int;
                _ovl: short;
              }
              interface COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SegDescImpl extends CombineTypes<[_COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SegDescImpl, java.lang.Object, sun.jvm.hotspot.debugger.win32.coff.DebugVC50SegDesc]> {}
              interface _COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SegInfoImpl$$static extends ClassLike {
                _new(this$3: COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl, offset: int): COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SegInfoImpl;
              }
              let COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SegInfoImpl: _COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SegInfoImpl$$static;
              interface _COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SegInfoImpl {
                getOffset(): int;
                getSegment(): short;
                getSegmentCodeSize(): int;
                _cbSeg: int;
                _offset: int;
                _seg: short;
              }
              interface COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SegInfoImpl extends CombineTypes<[_COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SegInfoImpl, java.lang.Object, sun.jvm.hotspot.debugger.win32.coff.DebugVC50SegInfo]> {}
              interface _COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SrcModFileDescImpl$$static extends ClassLike {
                _new(this$3: COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl, offset: int, baseOffset: int): COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SrcModFileDescImpl;
              }
              let COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SrcModFileDescImpl: _COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SrcModFileDescImpl$$static;
              interface _COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SrcModFileDescImpl {
                getLineNumberMap(i: int): DebugVC50SrcModLineNumberMap;
                getNumCodeSegments(): int;
                getSegmentEndOffset(i: int): int;
                getSegmentStartOffset(i: int): int;
                getSourceFileName(): string;
                _baseSrcLn: hotspot.utilities.memo.MemoizedObject;
                _cSeg: short;
                _name: hotspot.utilities.memo.MemoizedObject;
                _segOffsets: hotspot.utilities.memo.MemoizedObject;
                _this$3: COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl;
              }
              interface COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SrcModFileDescImpl extends CombineTypes<[_COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SrcModFileDescImpl, sun.jvm.hotspot.debugger.win32.coff.DebugVC50SrcModFileDesc, java.lang.Object]> {}
              interface _COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SrcModLineNumberMapImpl$$static extends ClassLike {
                _new(this$3: COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl, offset: int): COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SrcModLineNumberMapImpl;
              }
              let COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SrcModLineNumberMapImpl: _COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SrcModLineNumberMapImpl$$static;
              interface _COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SrcModLineNumberMapImpl {
                getCodeOffset(i: int): int;
                getLineNumber(i: int): int;
                getNumSourceLinePairs(): int;
                getSegment(): int;
                _cPair: short;
                _lineNumbers: hotspot.utilities.memo.MemoizedObject;
                _offsets: hotspot.utilities.memo.MemoizedObject;
                _seg: short;
                _this$3: COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl;
              }
              interface COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SrcModLineNumberMapImpl extends CombineTypes<[_COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SrcModLineNumberMapImpl, java.lang.Object, sun.jvm.hotspot.debugger.win32.coff.DebugVC50SrcModLineNumberMap]> {}
              interface _COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SubsectionDirectoryImpl$$static extends ClassLike {
                _new(this$3: COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl, offset: int): COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SubsectionDirectoryImpl;
              }
              let COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SubsectionDirectoryImpl: _COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SubsectionDirectoryImpl$$static;
              interface _COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SubsectionDirectoryImpl {
                getEntryLength(): short;
                getHeaderLength(): short;
                getNumEntries(): int;
                getSubsection(i: int): DebugVC50Subsection;
                _dirEntryLength: short;
                _dirHeaderLength: short;
                _numEntries: int;
                _offset: int;
                _this$3: COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl;
              }
              interface COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SubsectionDirectoryImpl extends CombineTypes<[_COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SubsectionDirectoryImpl, sun.jvm.hotspot.debugger.win32.coff.DebugVC50SubsectionDirectory, java.lang.Object, sun.jvm.hotspot.debugger.win32.coff.DebugVC50SubsectionTypes]> {}
              interface _COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SubsectionImpl$$static extends ClassLike {
                _new(this$3: COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl, ssType: short, iMod: short, ssSize: int, offset: int): COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SubsectionImpl;
              }
              let COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SubsectionImpl: _COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SubsectionImpl$$static;
              interface _COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SubsectionImpl {
                getSubsectionModuleIndex(): short;
                getSubsectionSize(): int;
                getSubsectionType(): short;
                _iMod: short;
                _ssSize: int;
                _ssType: short;
              }
              interface COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SubsectionImpl extends CombineTypes<[_COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SubsectionImpl, sun.jvm.hotspot.debugger.win32.coff.DebugVC50Subsection, java.lang.Object]> {}
              interface _COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SymbolIteratorImpl$$static extends ClassLike {
                _HEADER_SIZE: int;
                _new(this$3: COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl, base: int, size: int): COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SymbolIteratorImpl;
              }
              let COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SymbolIteratorImpl: _COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SymbolIteratorImpl$$static;
              interface _COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SymbolIteratorImpl {
                advanceToEntryThisSymbol(): void;
                done(): boolean;
                getBPRelName(): string;
                getBPRelOffset(): int;
                getBPRelType(): int;
                getBlockEnd(): DebugVC50SymbolIterator;
                getBlockEndOffset(): int;
                getBlockLength(): int;
                getBlockName(): string;
                getBlockOffset(): int;
                getBlockParent(): DebugVC50SymbolIterator;
                getBlockParentOffset(): int;
                getBlockSegment(): short;
                getChangeModel(): short;
                getChangeOffset(): int;
                getChangeSegment(): short;
                getCompilerFlags(): int;
                getCompilerTargetProcessor(): byte;
                getComplierVersion(): string;
                getConstantName(): string;
                getConstantType(): int;
                getConstantValueAsDouble(): double;
                getConstantValueAsFloat(): float;
                getConstantValueAsInt(): int;
                getConstantValueAsLong(): long;
                getLGDataName(): string;
                getLGDataOffset(): int;
                getLGDataSegment(): short;
                getLGDataType(): int;
                getLGProcDebugEnd(): int;
                getLGProcDebugStart(): int;
                getLGProcEnd(): DebugVC50SymbolIterator;
                getLGProcEndOffset(): int;
                getLGProcFlags(): byte;
                getLGProcLength(): int;
                getLGProcName(): string;
                getLGProcNext(): DebugVC50SymbolIterator;
                getLGProcNextOffset(): int;
                getLGProcOffset(): int;
                getLGProcParent(): DebugVC50SymbolIterator;
                getLGProcParentOffset(): int;
                getLGProcSegment(): short;
                getLGProcType(): int;
                getLThreadName(): string;
                getLThreadOffset(): int;
                getLThreadSegment(): short;
                getLThreadType(): int;
                getLabelFlags(): byte;
                getLabelName(): string;
                getLabelOffset(): int;
                getLabelSegment(): short;
                getLength(): short;
                getManyRegCount(): byte;
                getManyRegName(): string;
                getManyRegRegister(i: int): byte;
                getManyRegType(): int;
                getObjectCodeViewSignature(): int;
                getObjectName(): string;
                getOffset(): int;
                getRegRelName(): string;
                getRegRelOffset(): int;
                getRegRelRegister(): short;
                getRegRelType(): int;
                getRegisterEnum(): short;
                getRegisterSymbolName(): string;
                getRegisterSymbolType(): int;
                getReturnFlags(): short;
                getReturnRegister(i: int): byte;
                getReturnRegisterCount(): byte;
                getReturnStyle(): byte;
                getSearchSegment(): short;
                getSearchSymbolOffset(): int;
                getThunkAdjustorTargetName(): string;
                getThunkAdjustorThisDelta(): short;
                getThunkEnd(): DebugVC50SymbolIterator;
                getThunkEndOffset(): int;
                getThunkLength(): short;
                getThunkName(): string;
                getThunkNext(): DebugVC50SymbolIterator;
                getThunkNextOffset(): int;
                getThunkOffset(): int;
                getThunkPCodeOffset(): int;
                getThunkPCodeSegment(): short;
                getThunkParent(): DebugVC50SymbolIterator;
                getThunkParentOffset(): int;
                getThunkSegment(): short;
                getThunkType(): byte;
                getThunkVCallDisplacement(): short;
                getType(): int;
                getUDTName(): string;
                getUDTType(): int;
                getVTableOffset(): int;
                getVTablePath(): int;
                getVTableRoot(): int;
                getVTableSegment(): short;
                _lengthPrefixedStringLengthAt(offsetInSym: int): int;
                next(): void;
                _numericLeafLengthAt(offsetInSym: int): int;
                _readDoubleNumericLeafAt(offsetInSym: int): double;
                _readFloatNumericLeafAt(offsetInSym: int): float;
                _readIntNumericLeafAt(offsetInSym: int): int;
                _readLengthPrefixedStringAt(offsetInSym: int): string;
                _readLongNumericLeafAt(offsetInSym: int): long;
                _symSeek(offsetInSym: int): void;
                _base: int;
                _curSymSize: int;
                _curSymType: int;
                _pos: int;
                _size: int;
                _this$3: COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl;
              }
              interface COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SymbolIteratorImpl extends CombineTypes<[_COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50SymbolIteratorImpl, java.lang.Object, sun.jvm.hotspot.debugger.win32.coff.DebugVC50SymbolIterator]> {}
              interface _COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50TypeIteratorImpl$$static extends ClassLike {
                _new(this$3: COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl, parent: DebugVC50SSGlobalTypes, base: int, numTypes: int): COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50TypeIteratorImpl;
              }
              let COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50TypeIteratorImpl: _COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50TypeIteratorImpl$$static;
              interface _COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50TypeIteratorImpl {
                done(): boolean;
                getArgListCount(): int;
                getArgListType(i: int): int;
                getArrayElementType(): int;
                getArrayIndexType(): int;
                getArrayLength(): int;
                getArrayName(): string;
                getBClassAttribute(): short;
                getBClassOffset(): int;
                getBClassType(): int;
                getBasicArrayType(): int;
                getBitfieldFieldType(): int;
                getBitfieldLength(): byte;
                getBitfieldPosition(): byte;
                getClassCount(): short;
                getClassDerivationList(): int;
                getClassFieldList(): int;
                getClassFieldListIterator(): DebugVC50TypeIterator;
                getClassName(): string;
                getClassProperty(): short;
                getClassSize(): int;
                getClassVShape(): int;
                getDefaultArgExpression(): string;
                getDefaultArgType(): int;
                getDerivedCount(): int;
                getDerivedType(i: int): int;
                getDimArrayDimInfo(): int;
                getDimArrayName(): string;
                getDimArrayType(): int;
                getEnumCount(): short;
                getEnumFieldList(): int;
                getEnumFieldListIterator(): DebugVC50TypeIterator;
                getEnumName(): string;
                getEnumProperty(): short;
                getEnumType(): int;
                getEnumerateAttribute(): short;
                getEnumerateName(): string;
                getEnumerateValue(): long;
                getFriendClsType(): int;
                getFriendFcnName(): string;
                getFriendFcnType(): int;
                getIVBClassAttribute(): short;
                getIVBClassBType(): int;
                getIVBClassVBOff(): int;
                getIVBClassVBPOff(): int;
                getIVBClassVBPType(): int;
                getIndexIterator(): DebugVC50TypeIterator;
                getIndexValue(): int;
                getLabelAddressMode(): short;
                getLength(): short;
                getMFunctionArgumentList(): int;
                getMFunctionArgumentListIterator(): DebugVC50TypeIterator;
                getMFunctionCallingConvention(): byte;
                getMFunctionContainingClass(): int;
                getMFunctionNumberOfParameters(): short;
                getMFunctionReturnType(): int;
                getMFunctionThis(): int;
                getMFunctionThisAdjust(): int;
                getMListAttribute(): short;
                getMListLength(): int;
                getMListType(i: int): int;
                getMListVtabOffset(): int;
                getMemberAttribute(): short;
                getMemberModifyAttribute(): short;
                getMemberModifyName(): string;
                getMemberModifyType(): int;
                getMemberName(): string;
                getMemberOffset(): int;
                getMemberType(): int;
                getMethodCount(): short;
                getMethodList(): int;
                getMethodName(): string;
                getModifierAttribute(): short;
                getModifierIndex(): int;
                getNestedExAttribute(): short;
                getNestedExName(): string;
                getNestedExType(): int;
                getNestedName(): string;
                getNestedType(): int;
                getNumTypes(): int;
                getNumericDataAt(byteOffset: int): byte[];
                getNumericDoubleAt(byteOffset: int): double;
                getNumericFloatAt(byteOffset: int): float;
                getNumericIntAt(byteOffset: int): int;
                getNumericLengthAt(byteOffset: int): int;
                getNumericLongAt(byteOffset: int): long;
                getNumericTypeAt(byteOffset: int): short;
                getOneMethodAttribute(): short;
                getOneMethodName(): string;
                getOneMethodType(): int;
                getOneMethodVBaseOff(): int;
                getPointerAttributes(): int;
                getPointerBasedOnTypeIndex(): int;
                getPointerBasedOnTypeName(): string;
                getPointerToMemberClass(): int;
                getPointerToMemberFormat(): short;
                getPointerType(): int;
                getProcedureArgumentList(): int;
                getProcedureArgumentListIterator(): DebugVC50TypeIterator;
                getProcedureCallingConvention(): byte;
                getProcedureNumberOfParameters(): short;
                getProcedureReturnType(): int;
                getRefSym(): DebugVC50SymbolIterator;
                getSkipIndex(): int;
                getStaticAttribute(): short;
                getStaticName(): string;
                getStaticType(): int;
                getTypeIndex(): int;
                getUnionCount(): short;
                getUnionFieldList(): int;
                getUnionFieldListIterator(): DebugVC50TypeIterator;
                getUnionName(): string;
                getUnionProperty(): short;
                getUnionSize(): int;
                getVBClassAttribute(): short;
                getVBClassBaseClassType(): int;
                getVBClassVBOff(): int;
                getVBClassVBPOff(): int;
                getVBClassVirtualBaseClassType(): int;
                getVFTPathBase(i: int): int;
                getVFTPathCount(): int;
                getVFuncOffOffset(): int;
                getVFuncOffType(): int;
                getVFuncTabType(): int;
                getVTShapeCount(): short;
                getVTShapeDescriptor(i: int): int;
                _isIntroducingVirtual(mprop: int): boolean;
                isMListIntroducingVirtual(): boolean;
                isOneMethodIntroducingVirtual(): boolean;
                _lengthPrefixedStringLengthAt(offset: int): int;
                _loadTypeRecord(): void;
                _loadTypeString(): void;
                next(): void;
                _numericLeafLengthAt(offset: int): int;
                _readIntNumericLeafAt(offset: int): int;
                _readLengthPrefixedStringAt(offset: int): string;
                _typeSeek(offset: int): void;
                typeStringDone(): boolean;
                typeStringLeaf(): int;
                _typeStringLength(): int;
                typeStringNext(): void;
                typeStringOffset(): int;
                _base: int;
                _numTypes: int;
                _parent: DebugVC50SSGlobalTypes;
                _this$3: COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl;
                _typeIndex: int;
                _typeRecordOffset: int;
                _typeRecordSize: int;
                _typeStringLeaf: int;
                _typeStringOffset: int;
              }
              interface COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50TypeIteratorImpl extends CombineTypes<[_COFFFileParser$COFFFileImpl$COFFHeaderImpl$DebugVC50Impl$DebugVC50TypeIteratorImpl, sun.jvm.hotspot.debugger.win32.coff.DebugVC50MemberAttributes, sun.jvm.hotspot.debugger.win32.coff.DebugVC50TypeEnums, java.lang.Object, sun.jvm.hotspot.debugger.win32.coff.DebugVC50TypeIterator, sun.jvm.hotspot.debugger.win32.coff.DebugVC50TypeLeafIndices]> {}
              interface _COFFFileParser$COFFFileImpl$COFFHeaderImpl$ExportDirectoryTableImpl$$static extends ClassLike {
                _new(this$2: COFFFileParser$COFFFileImpl$COFFHeaderImpl, exportDataDirRVA: int, size: int): COFFFileParser$COFFFileImpl$COFFHeaderImpl$ExportDirectoryTableImpl;
              }
              let COFFFileParser$COFFFileImpl$COFFHeaderImpl$ExportDirectoryTableImpl: _COFFFileParser$COFFFileImpl$COFFHeaderImpl$ExportDirectoryTableImpl$$static;
              interface _COFFFileParser$COFFFileImpl$COFFHeaderImpl$ExportDirectoryTableImpl {
                getDLLName(): string;
                getExportAddress(ordinal: short): int;
                getExportAddressForwarder(ordinal: short): string;
                _getExportAddressTable(): int[];
                getExportAddressTableRVA(): int;
                getExportFlags(): int;
                getExportName(i: int): string;
                _getExportNamePointerTable(): int[];
                _getExportNameTable(): COFFFileParser$COFFFileImpl$COFFHeaderImpl$ExportNameTable;
                getExportOrdinal(i: int): short;
                _getExportOrdinalTable(): short[];
                getMajorVersion(): short;
                getMinorVersion(): short;
                getNamePointerTableRVA(): int;
                getNameRVA(): int;
                getNumberOfAddressTableEntries(): int;
                getNumberOfNamePointers(): int;
                getOrdinalBase(): int;
                getOrdinalTableRVA(): int;
                getTimeDateStamp(): int;
                isExportAddressForwarder(ordinal: short): boolean;
                _addressTableEntries: int;
                _dllName: hotspot.utilities.memo.MemoizedObject;
                _exportAddressTable: hotspot.utilities.memo.MemoizedObject;
                _exportAddressTableRVA: int;
                _exportDataDirRVA: int;
                _exportFlags: int;
                _exportNamePointerTable: hotspot.utilities.memo.MemoizedObject;
                _exportNameTable: hotspot.utilities.memo.MemoizedObject;
                _exportOrdinalTable: hotspot.utilities.memo.MemoizedObject;
                _majorVersion: short;
                _minorVersion: short;
                _namePointerTableRVA: int;
                _nameRVA: int;
                _numberOfNamePointers: int;
                _offset: int;
                _ordinalBase: int;
                _ordinalTableRVA: int;
                _size: int;
                _this$2: COFFFileParser$COFFFileImpl$COFFHeaderImpl;
                _timeDateStamp: int;
              }
              interface COFFFileParser$COFFFileImpl$COFFHeaderImpl$ExportDirectoryTableImpl extends CombineTypes<[_COFFFileParser$COFFFileImpl$COFFHeaderImpl$ExportDirectoryTableImpl, sun.jvm.hotspot.debugger.win32.coff.ExportDirectoryTable, java.lang.Object]> {}
              interface _COFFFileParser$COFFFileImpl$COFFHeaderImpl$ExportNameTable$$static extends ClassLike {
                _new(this$2: COFFFileParser$COFFFileImpl$COFFHeaderImpl, exportNamePointerTable: int[]): COFFFileParser$COFFFileImpl$COFFHeaderImpl$ExportNameTable;
              }
              let COFFFileParser$COFFFileImpl$COFFHeaderImpl$ExportNameTable: _COFFFileParser$COFFFileImpl$COFFHeaderImpl$ExportNameTable$$static;
              interface _COFFFileParser$COFFFileImpl$COFFHeaderImpl$ExportNameTable {
                _get(i: int): string;
                _names: hotspot.utilities.memo.MemoizedObject[];
                _this$2: COFFFileParser$COFFFileImpl$COFFHeaderImpl;
              }
              interface COFFFileParser$COFFFileImpl$COFFHeaderImpl$ExportNameTable extends CombineTypes<[_COFFFileParser$COFFFileImpl$COFFHeaderImpl$ExportNameTable, java.lang.Object]> {}
              interface _COFFFileParser$COFFFileImpl$COFFHeaderImpl$OptionalHeaderDataDirectoriesImpl$$static extends ClassLike {
                _DATA_DIRECTORY_SIZE: int;
                _new(this$2: COFFFileParser$COFFFileImpl$COFFHeaderImpl, offset: int, numberOfRvaAndSizes: int): COFFFileParser$COFFFileImpl$COFFHeaderImpl$OptionalHeaderDataDirectoriesImpl;
              }
              let COFFFileParser$COFFFileImpl$COFFHeaderImpl$OptionalHeaderDataDirectoriesImpl: _COFFFileParser$COFFFileImpl$COFFHeaderImpl$OptionalHeaderDataDirectoriesImpl$$static;
              interface _COFFFileParser$COFFFileImpl$COFFHeaderImpl$OptionalHeaderDataDirectoriesImpl {
                _checkIndex(index: int): int;
                getArchitecture(): DataDirectory;
                getBaseRelocationTable(): DataDirectory;
                getBoundImportTable(): DataDirectory;
                getCOMPlusRuntimeHeader(): DataDirectory;
                getCertificateTable(): DataDirectory;
                getDebug(): DataDirectory;
                getDebugDirectory(): DebugDirectory;
                getDelayImportDescriptor(): DataDirectory;
                getExceptionTable(): DataDirectory;
                getExportDirectoryTable(): ExportDirectoryTable;
                getExportTable(): DataDirectory;
                getGlobalPtr(): DataDirectory;
                getImportAddressTable(): DataDirectory;
                getImportTable(): DataDirectory;
                getLoadConfigTable(): DataDirectory;
                getResourceTable(): DataDirectory;
                getTLSTable(): DataDirectory;
                _dataDirectories: hotspot.utilities.memo.MemoizedObject[];
                _debugDirectory: hotspot.utilities.memo.MemoizedObject;
                _exportDirectoryTable: hotspot.utilities.memo.MemoizedObject;
                _numberOfRvaAndSizes: int;
                _this$2: COFFFileParser$COFFFileImpl$COFFHeaderImpl;
              }
              interface COFFFileParser$COFFFileImpl$COFFHeaderImpl$OptionalHeaderDataDirectoriesImpl extends CombineTypes<[_COFFFileParser$COFFFileImpl$COFFHeaderImpl$OptionalHeaderDataDirectoriesImpl, java.lang.Object, sun.jvm.hotspot.debugger.win32.coff.OptionalHeaderDataDirectories]> {}
              interface _COFFFileParser$COFFFileImpl$COFFHeaderImpl$OptionalHeaderImpl$$static extends ClassLike {
                _PE32_DATA_DIRECTORIES_OFFSET: int;
                _PE32_PLUS_DATA_DIRECTORIES_OFFSET: int;
                _PE32_PLUS_WINDOWS_SPECIFIC_FIELDS_OFFSET: int;
                _PE32_WINDOWS_SPECIFIC_FIELDS_OFFSET: int;
                _STANDARD_FIELDS_OFFSET: int;
                _new(this$2: COFFFileParser$COFFFileImpl$COFFHeaderImpl, offset: int): COFFFileParser$COFFFileImpl$COFFHeaderImpl$OptionalHeaderImpl;
              }
              let COFFFileParser$COFFFileImpl$COFFHeaderImpl$OptionalHeaderImpl: _COFFFileParser$COFFFileImpl$COFFHeaderImpl$OptionalHeaderImpl$$static;
              interface _COFFFileParser$COFFFileImpl$COFFHeaderImpl$OptionalHeaderImpl {
                getDataDirectories(): OptionalHeaderDataDirectories;
                getMagicNumber(): short;
                getStandardFields(): OptionalHeaderStandardFields;
                getWindowsSpecificFields(): OptionalHeaderWindowsSpecificFields;
                _dataDirectories: hotspot.utilities.memo.MemoizedObject;
                _magic: short;
                _standardFields: hotspot.utilities.memo.MemoizedObject;
                _this$2: COFFFileParser$COFFFileImpl$COFFHeaderImpl;
                _windowsSpecificFields: hotspot.utilities.memo.MemoizedObject;
              }
              interface COFFFileParser$COFFFileImpl$COFFHeaderImpl$OptionalHeaderImpl extends CombineTypes<[_COFFFileParser$COFFFileImpl$COFFHeaderImpl$OptionalHeaderImpl, sun.jvm.hotspot.debugger.win32.coff.OptionalHeader, java.lang.Object]> {}
              interface _COFFFileParser$COFFFileImpl$COFFHeaderImpl$OptionalHeaderStandardFieldsImpl$$static extends ClassLike {
                _new(this$2: COFFFileParser$COFFFileImpl$COFFHeaderImpl, offset: int, isPE32Plus: boolean): COFFFileParser$COFFFileImpl$COFFHeaderImpl$OptionalHeaderStandardFieldsImpl;
              }
              let COFFFileParser$COFFFileImpl$COFFHeaderImpl$OptionalHeaderStandardFieldsImpl: _COFFFileParser$COFFFileImpl$COFFHeaderImpl$OptionalHeaderStandardFieldsImpl$$static;
              interface _COFFFileParser$COFFFileImpl$COFFHeaderImpl$OptionalHeaderStandardFieldsImpl {
                getAddressOfEntryPoint(): int;
                getBaseOfCode(): int;
                getBaseOfData(): int;
                getMajorLinkerVersion(): byte;
                getMinorLinkerVersion(): byte;
                getSizeOfCode(): int;
                getSizeOfInitializedData(): int;
                getSizeOfUninitializedData(): int;
                _addressOfEntryPoint: int;
                _baseOfCode: int;
                _baseOfData: int;
                _isPE32Plus: boolean;
                _majorLinkerVersion: byte;
                _minorLinkerVersion: byte;
                _sizeOfCode: int;
                _sizeOfInitializedData: int;
                _sizeOfUninitializedData: int;
              }
              interface COFFFileParser$COFFFileImpl$COFFHeaderImpl$OptionalHeaderStandardFieldsImpl extends CombineTypes<[_COFFFileParser$COFFFileImpl$COFFHeaderImpl$OptionalHeaderStandardFieldsImpl, java.lang.Object, sun.jvm.hotspot.debugger.win32.coff.OptionalHeaderStandardFields]> {}
              interface _COFFFileParser$COFFFileImpl$COFFHeaderImpl$OptionalHeaderWindowsSpecificFieldsImpl$$static extends ClassLike {
                _new(this$2: COFFFileParser$COFFFileImpl$COFFHeaderImpl, offset: int, isPE32Plus: boolean): COFFFileParser$COFFFileImpl$COFFHeaderImpl$OptionalHeaderWindowsSpecificFieldsImpl;
              }
              let COFFFileParser$COFFFileImpl$COFFHeaderImpl$OptionalHeaderWindowsSpecificFieldsImpl: _COFFFileParser$COFFFileImpl$COFFHeaderImpl$OptionalHeaderWindowsSpecificFieldsImpl$$static;
              interface _COFFFileParser$COFFFileImpl$COFFHeaderImpl$OptionalHeaderWindowsSpecificFieldsImpl {
                getCheckSum(): int;
                getDLLCharacteristics(): short;
                getFileAlignment(): int;
                getImageBase(): long;
                getLoaderFlags(): int;
                getMajorImageVersion(): short;
                getMajorOperatingSystemVersion(): short;
                getMajorSubsystemVersion(): short;
                getMinorImageVersion(): short;
                getMinorOperatingSystemVersion(): short;
                getMinorSubsystemVersion(): short;
                getNumberOfRvaAndSizes(): int;
                getSectionAlignment(): int;
                getSizeOfHeaders(): int;
                getSizeOfHeapCommit(): long;
                getSizeOfHeapReserve(): long;
                getSizeOfImage(): int;
                getSizeOfStackCommit(): long;
                getSizeOfStackReserve(): long;
                getSubsystem(): short;
                _maskInt(arg: long): long;
                _checkSum: int;
                _dllCharacteristics: short;
                _fileAlignment: int;
                _imageBase: long;
                _loaderFlags: int;
                _majorImageVersion: short;
                _majorOperatingSystemVersion: short;
                _majorSubsystemVersion: short;
                _minorImageVersion: short;
                _minorOperatingSystemVersion: short;
                _minorSubsystemVersion: short;
                _numberOfRvaAndSizes: int;
                _sectionAlignment: int;
                _sizeOfHeaders: int;
                _sizeOfHeapCommit: long;
                _sizeOfHeapReserve: long;
                _sizeOfImage: int;
                _sizeOfStackCommit: long;
                _sizeOfStackReserve: long;
                _subsystem: short;
              }
              interface COFFFileParser$COFFFileImpl$COFFHeaderImpl$OptionalHeaderWindowsSpecificFieldsImpl extends CombineTypes<[_COFFFileParser$COFFFileImpl$COFFHeaderImpl$OptionalHeaderWindowsSpecificFieldsImpl, sun.jvm.hotspot.debugger.win32.coff.OptionalHeaderWindowsSpecificFields, java.lang.Object]> {}
              interface _COFFFileParser$COFFFileImpl$COFFHeaderImpl$SectionHeaderImpl$$static extends ClassLike {
                new(this$2: COFFFileParser$COFFFileImpl$COFFHeaderImpl, offset: int): COFFFileParser$COFFFileImpl$COFFHeaderImpl$SectionHeaderImpl;
              }
              let COFFFileParser$COFFFileImpl$COFFHeaderImpl$SectionHeaderImpl: _COFFFileParser$COFFFileImpl$COFFHeaderImpl$SectionHeaderImpl$$static;
              interface _COFFFileParser$COFFFileImpl$COFFHeaderImpl$SectionHeaderImpl {
                getCOFFLineNumber(index: int): COFFLineNumber;
                getCOFFRelocation(index: int): COFFRelocation;
                getName(): string;
                getNumberOfLineNumbers(): short;
                getNumberOfRelocations(): short;
                getPointerToLineNumbers(): int;
                getPointerToRawData(): int;
                getPointerToRelocations(): int;
                getSectionFlags(): int;
                getSize(): int;
                getSizeOfRawData(): int;
                getVirtualAddress(): int;
                hasSectionFlag(flag: int): boolean;
                _characteristics: int;
                _lineNumbers: hotspot.utilities.memo.MemoizedObject[];
                _name: string;
                _numberOfLineNumbers: short;
                _numberOfRelocations: short;
                _pointerToLineNumbers: int;
                _pointerToRawData: int;
                _pointerToRelocations: int;
                _relocations: hotspot.utilities.memo.MemoizedObject[];
                _sizeOfRawData: int;
                _this$2: COFFFileParser$COFFFileImpl$COFFHeaderImpl;
                _virtualAddress: int;
                _virtualSize: int;
              }
              interface COFFFileParser$COFFFileImpl$COFFHeaderImpl$SectionHeaderImpl extends CombineTypes<[_COFFFileParser$COFFFileImpl$COFFHeaderImpl$SectionHeaderImpl, java.lang.Object, sun.jvm.hotspot.debugger.win32.coff.SectionHeader]> {}
              interface _COFFFileParser$COFFFileImpl$COFFHeaderImpl$StringTable$$static extends ClassLike {
                _new(this$2: COFFFileParser$COFFFileImpl$COFFHeaderImpl, offset: int): COFFFileParser$COFFFileImpl$COFFHeaderImpl$StringTable;
              }
              let COFFFileParser$COFFFileImpl$COFFHeaderImpl$StringTable: _COFFFileParser$COFFFileImpl$COFFHeaderImpl$StringTable$$static;
              interface _COFFFileParser$COFFFileImpl$COFFHeaderImpl$StringTable {
                _get(i: int): string;
                _getAtOffset(offset: int): string;
                _getNum(): int;
                _strings: COFFFileParser$COFFFileImpl$COFFHeaderImpl$StringTable$COFFString[];
              }
              interface COFFFileParser$COFFFileImpl$COFFHeaderImpl$StringTable extends CombineTypes<[_COFFFileParser$COFFFileImpl$COFFHeaderImpl$StringTable, java.lang.Object]> {}
              interface _COFFFileParser$COFFFileImpl$COFFHeaderImpl$StringTable$COFFString$$static extends ClassLike {
                _new(this$3: COFFFileParser$COFFFileImpl$COFFHeaderImpl$StringTable, str: string, offset: int): COFFFileParser$COFFFileImpl$COFFHeaderImpl$StringTable$COFFString;
              }
              let COFFFileParser$COFFFileImpl$COFFHeaderImpl$StringTable$COFFString: _COFFFileParser$COFFFileImpl$COFFHeaderImpl$StringTable$COFFString$$static;
              interface _COFFFileParser$COFFFileImpl$COFFHeaderImpl$StringTable$COFFString {
                _offset: int;
                _str: string;
              }
              interface COFFFileParser$COFFFileImpl$COFFHeaderImpl$StringTable$COFFString extends CombineTypes<[_COFFFileParser$COFFFileImpl$COFFHeaderImpl$StringTable$COFFString, java.lang.Object]> {}
              interface _COFFHeader$$static extends ClassLike {
              }
              let COFFHeader: _COFFHeader$$static;
              interface _COFFHeader {
                getCOFFSymbol(a0: int): COFFSymbol;
                getCharacteristics(): short;
                getMachineType(): short;
                getNumberOfSections(): short;
                getNumberOfStrings(): int;
                getNumberOfSymbols(): int;
                getOptionalHeader(): OptionalHeader;
                getPointerToSymbolTable(): int;
                getSectionHeader(a0: int): SectionHeader;
                getSizeOfOptionalHeader(): short;
                getString(a0: int): string;
                getTimeDateStamp(): int;
                hasCharacteristic(a0: short): boolean;
              }
              interface COFFHeader extends CombineTypes<[_COFFHeader, java.lang.Object]> {}
              interface _COFFLineNumber$$static extends ClassLike {
              }
              let COFFLineNumber: _COFFLineNumber$$static;
              interface _COFFLineNumber {
                getLineNumber(): short;
                getType(): int;
              }
              interface COFFLineNumber extends CombineTypes<[_COFFLineNumber, java.lang.Object]> {}
              interface _COFFRelocation$$static extends ClassLike {
              }
              let COFFRelocation: _COFFRelocation$$static;
              interface _COFFRelocation {
                getSymbolTableIndex(): int;
                getType(): short;
                getVirtualAddress(): int;
              }
              interface COFFRelocation extends CombineTypes<[_COFFRelocation, java.lang.Object]> {}
              interface _COFFSymbol$$static extends ClassLike {
              }
              let COFFSymbol: _COFFSymbol$$static;
              interface _COFFSymbol {
                getAuxBfEfRecord(): AuxBfEfRecord;
                getAuxFileRecord(): AuxFileRecord;
                getAuxFunctionDefinitionRecord(): AuxFunctionDefinitionRecord;
                getAuxSectionDefinitionsRecord(): AuxSectionDefinitionsRecord;
                getAuxWeakExternalRecord(): AuxWeakExternalRecord;
                getName(): string;
                getNumberOfAuxSymbols(): byte;
                getOffset(): int;
                getSectionNumber(): short;
                getStorageClass(): byte;
                getType(): short;
                getValue(): int;
                isBfOrEfSymbol(): boolean;
                isFile(): boolean;
                isFunctionDefinition(): boolean;
                isSectionDefinition(): boolean;
                isWeakExternal(): boolean;
              }
              interface COFFSymbol extends CombineTypes<[_COFFSymbol, java.lang.Object]> {}
              interface _COFFSymbolConstants$$static extends ClassLike {
                readonly IMAGE_SYM_ABSOLUTE: short;
                readonly IMAGE_SYM_CLASS_ARGUMENT: byte;
                readonly IMAGE_SYM_CLASS_AUTOMATIC: byte;
                readonly IMAGE_SYM_CLASS_BIT_FIELD: byte;
                readonly IMAGE_SYM_CLASS_BLOCK: byte;
                readonly IMAGE_SYM_CLASS_END_OF_FUNCTION: byte;
                readonly IMAGE_SYM_CLASS_END_OF_STRUCT: byte;
                readonly IMAGE_SYM_CLASS_ENUM_TAG: byte;
                readonly IMAGE_SYM_CLASS_EXTERNAL: byte;
                readonly IMAGE_SYM_CLASS_EXTERNAL_DEF: byte;
                readonly IMAGE_SYM_CLASS_FILE: byte;
                readonly IMAGE_SYM_CLASS_FUNCTION: byte;
                readonly IMAGE_SYM_CLASS_LABEL: byte;
                readonly IMAGE_SYM_CLASS_MEMBER_OF_ENUM: byte;
                readonly IMAGE_SYM_CLASS_MEMBER_OF_STRUCT: byte;
                readonly IMAGE_SYM_CLASS_MEMBER_OF_UNION: byte;
                readonly IMAGE_SYM_CLASS_NULL: byte;
                readonly IMAGE_SYM_CLASS_REGISTER: byte;
                readonly IMAGE_SYM_CLASS_REGISTER_PARAM: byte;
                readonly IMAGE_SYM_CLASS_SECTION: byte;
                readonly IMAGE_SYM_CLASS_STATIC: byte;
                readonly IMAGE_SYM_CLASS_STRUCT_TAG: byte;
                readonly IMAGE_SYM_CLASS_TYPE_DEFINITION: byte;
                readonly IMAGE_SYM_CLASS_UNDEFINED_LABEL: byte;
                readonly IMAGE_SYM_CLASS_UNDEFINED_STATIC: byte;
                readonly IMAGE_SYM_CLASS_UNION_TAG: byte;
                readonly IMAGE_SYM_CLASS_WEAK_EXTERNAL: byte;
                readonly IMAGE_SYM_DEBUG: short;
                readonly IMAGE_SYM_DTYPE_ARRAY: short;
                readonly IMAGE_SYM_DTYPE_FUNCTION: short;
                readonly IMAGE_SYM_DTYPE_NULL: short;
                readonly IMAGE_SYM_DTYPE_POINTER: short;
                readonly IMAGE_SYM_TYPE_BYTE: short;
                readonly IMAGE_SYM_TYPE_CHAR: short;
                readonly IMAGE_SYM_TYPE_DOUBLE: short;
                readonly IMAGE_SYM_TYPE_DWORD: short;
                readonly IMAGE_SYM_TYPE_ENUM: short;
                readonly IMAGE_SYM_TYPE_FLOAT: short;
                readonly IMAGE_SYM_TYPE_INT: short;
                readonly IMAGE_SYM_TYPE_LONG: short;
                readonly IMAGE_SYM_TYPE_MOE: short;
                readonly IMAGE_SYM_TYPE_NULL: short;
                readonly IMAGE_SYM_TYPE_SHORT: short;
                readonly IMAGE_SYM_TYPE_STRUCT: short;
                readonly IMAGE_SYM_TYPE_UINT: short;
                readonly IMAGE_SYM_TYPE_UNION: short;
                readonly IMAGE_SYM_TYPE_VOID: short;
                readonly IMAGE_SYM_TYPE_WORD: short;
                readonly IMAGE_SYM_UNDEFINED: short;
              }
              let COFFSymbolConstants: _COFFSymbolConstants$$static;
              interface _COFFSymbolConstants {
              }
              interface COFFSymbolConstants extends CombineTypes<[_COFFSymbolConstants, java.lang.Object]> {}
              interface _COMDATSelectionTypes$$static extends ClassLike {
                readonly IMAGE_COMDAT_SELECT_ANY: byte;
                readonly IMAGE_COMDAT_SELECT_ASSOCIATIVE: byte;
                readonly IMAGE_COMDAT_SELECT_EXACT_MATCH: byte;
                readonly IMAGE_COMDAT_SELECT_LARGEST: byte;
                readonly IMAGE_COMDAT_SELECT_NODUPLICATES: byte;
                readonly IMAGE_COMDAT_SELECT_SAME_SIZE: byte;
              }
              let COMDATSelectionTypes: _COMDATSelectionTypes$$static;
              interface _COMDATSelectionTypes {
              }
              interface COMDATSelectionTypes extends CombineTypes<[_COMDATSelectionTypes, java.lang.Object]> {}
              interface _Characteristics$$static extends ClassLike {
                readonly IMAGE_FILE_16BIT_MACHINE: short;
                readonly IMAGE_FILE_32BIT_MACHINE: short;
                readonly IMAGE_FILE_AGGRESSIVE_WS_TRIM: short;
                readonly IMAGE_FILE_BYTES_REVERSED_HI: short;
                readonly IMAGE_FILE_BYTES_REVERSED_LO: short;
                readonly IMAGE_FILE_DEBUG_STRIPPED: short;
                readonly IMAGE_FILE_DLL: short;
                readonly IMAGE_FILE_EXECUTABLE_IMAGE: short;
                readonly IMAGE_FILE_LARGE_ADDRESS_AWARE: short;
                readonly IMAGE_FILE_LINE_NUMS_STRIPPED: short;
                readonly IMAGE_FILE_LOCAL_SYMS_STRIPPED: short;
                readonly IMAGE_FILE_RELOCS_STRIPPED: short;
                readonly IMAGE_FILE_REMOVABLE_RUN_FROM_SWAP: short;
                readonly IMAGE_FILE_SYSTEM: short;
                readonly IMAGE_FILE_UP_SYSTEM_ONLY: short;
              }
              let Characteristics: _Characteristics$$static;
              interface _Characteristics {
              }
              interface Characteristics extends CombineTypes<[_Characteristics, java.lang.Object]> {}
              interface _DLLCharacteristics$$static extends ClassLike {
                readonly IMAGE_DLLCHARACTERISTICS_NO_BIND: short;
                readonly IMAGE_DLLCHARACTERISTICS_TERMINAL_SERVER_AWARE: short;
                readonly IMAGE_DLLCHARACTERISTICS_WDM_DRIVER: short;
              }
              let DLLCharacteristics: _DLLCharacteristics$$static;
              interface _DLLCharacteristics {
              }
              interface DLLCharacteristics extends CombineTypes<[_DLLCharacteristics, java.lang.Object]> {}
              interface _DataDirectory$$static extends ClassLike {
              }
              let DataDirectory: _DataDirectory$$static;
              interface _DataDirectory {
                getRVA(): int;
                getSize(): int;
              }
              interface DataDirectory extends CombineTypes<[_DataDirectory, java.lang.Object]> {}
              interface _DebugDirectory$$static extends ClassLike {
              }
              let DebugDirectory: _DebugDirectory$$static;
              interface _DebugDirectory {
                getEntry(a0: int): DebugDirectoryEntry;
                getNumEntries(): int;
              }
              interface DebugDirectory extends CombineTypes<[_DebugDirectory, java.lang.Object]> {}
              interface _DebugDirectoryEntry$$static extends ClassLike {
              }
              let DebugDirectoryEntry: _DebugDirectoryEntry$$static;
              interface _DebugDirectoryEntry {
                getAddressOfRawData(): int;
                getCharacteristics(): int;
                getDebugVC50(): DebugVC50;
                getMajorVersion(): short;
                getMinorVersion(): short;
                getPointerToRawData(): int;
                getRawDataByte(a0: int): byte;
                getSizeOfData(): int;
                getTimeDateStamp(): int;
                getType(): int;
              }
              interface DebugDirectoryEntry extends CombineTypes<[_DebugDirectoryEntry, java.lang.Object]> {}
              interface _DebugTypes$$static extends ClassLike {
                readonly IMAGE_DEBUG_TYPE_BORLAND: int;
                readonly IMAGE_DEBUG_TYPE_CODEVIEW: int;
                readonly IMAGE_DEBUG_TYPE_COFF: int;
                readonly IMAGE_DEBUG_TYPE_EXCEPTION: int;
                readonly IMAGE_DEBUG_TYPE_FIXUP: int;
                readonly IMAGE_DEBUG_TYPE_FPO: int;
                readonly IMAGE_DEBUG_TYPE_MISC: int;
                readonly IMAGE_DEBUG_TYPE_OMAP_FROM_SRC: int;
                readonly IMAGE_DEBUG_TYPE_OMAP_TO_SRC: int;
                readonly IMAGE_DEBUG_TYPE_UNKNOWN: int;
              }
              let DebugTypes: _DebugTypes$$static;
              interface _DebugTypes {
              }
              interface DebugTypes extends CombineTypes<[_DebugTypes, java.lang.Object]> {}
              interface _DebugVC50$$static extends ClassLike {
              }
              let DebugVC50: _DebugVC50$$static;
              interface _DebugVC50 {
                getSubsectionDirectory(): DebugVC50SubsectionDirectory;
                getSubsectionDirectoryOffset(): int;
              }
              interface DebugVC50 extends CombineTypes<[_DebugVC50, java.lang.Object]> {}
              interface _DebugVC50MemberAttributes$$static extends ClassLike {
                readonly MEMATTR_ACCESS_MASK: short;
                readonly MEMATTR_ACCESS_NO_PROTECTION: short;
                readonly MEMATTR_ACCESS_PRIVATE: short;
                readonly MEMATTR_ACCESS_PROTECTED: short;
                readonly MEMATTR_ACCESS_PUBLIC: short;
                readonly MEMATTR_COMPGENX_MASK: short;
                readonly MEMATTR_MPROP_FRIEND: short;
                readonly MEMATTR_MPROP_INTRODUCING_VIRTUAL: short;
                readonly MEMATTR_MPROP_MASK: short;
                readonly MEMATTR_MPROP_PURE_INTRODUCING_VIRTUAL: short;
                readonly MEMATTR_MPROP_PURE_VIRTUAL: short;
                readonly MEMATTR_MPROP_STATIC: short;
                readonly MEMATTR_MPROP_VANILLA: short;
                readonly MEMATTR_MPROP_VIRTUAL: short;
                readonly MEMATTR_NOCONSTRUCT_MASK: short;
                readonly MEMATTR_NOINHERIT_MASK: short;
                readonly MEMATTR_PSEUDO_MASK: short;
              }
              let DebugVC50MemberAttributes: _DebugVC50MemberAttributes$$static;
              interface _DebugVC50MemberAttributes {
              }
              interface DebugVC50MemberAttributes extends CombineTypes<[_DebugVC50MemberAttributes, java.lang.Object]> {}
              interface _DebugVC50ReservedTypes$$static extends ClassLike {
                readonly T_32PBOOL08: int;
                readonly T_32PBOOL16: int;
                readonly T_32PBOOL32: int;
                readonly T_32PBOOL64: int;
                readonly T_32PCHAR: int;
                readonly T_32PCPLX128: int;
                readonly T_32PCPLX32: int;
                readonly T_32PCPLX64: int;
                readonly T_32PCPLX80: int;
                readonly T_32PFBOOL08: int;
                readonly T_32PFBOOL16: int;
                readonly T_32PFBOOL32: int;
                readonly T_32PFBOOL64: int;
                readonly T_32PFCHAR: int;
                readonly T_32PFCPLX128: int;
                readonly T_32PFCPLX32: int;
                readonly T_32PFCPLX64: int;
                readonly T_32PFCPLX80: int;
                readonly T_32PFINT2: int;
                readonly T_32PFINT4: int;
                readonly T_32PFINT8: int;
                readonly T_32PFLONG: int;
                readonly T_32PFQUAD: int;
                readonly T_32PFRCHAR: int;
                readonly T_32PFREAL128: int;
                readonly T_32PFREAL32: int;
                readonly T_32PFREAL48: int;
                readonly T_32PFREAL64: int;
                readonly T_32PFREAL80: int;
                readonly T_32PFSHORT: int;
                readonly T_32PFUCHAR: int;
                readonly T_32PFUINT2: int;
                readonly T_32PFUINT4: int;
                readonly T_32PFUINT8: int;
                readonly T_32PFULONG: int;
                readonly T_32PFUQUAD: int;
                readonly T_32PFUSHORT: int;
                readonly T_32PFVOID: int;
                readonly T_32PFWCHAR: int;
                readonly T_32PINT2: int;
                readonly T_32PINT4: int;
                readonly T_32PINT8: int;
                readonly T_32PLONG: int;
                readonly T_32PQUAD: int;
                readonly T_32PRCHAR: int;
                readonly T_32PREAL128: int;
                readonly T_32PREAL32: int;
                readonly T_32PREAL48: int;
                readonly T_32PREAL64: int;
                readonly T_32PREAL80: int;
                readonly T_32PSHORT: int;
                readonly T_32PUCHAR: int;
                readonly T_32PUINT2: int;
                readonly T_32PUINT4: int;
                readonly T_32PUINT8: int;
                readonly T_32PULONG: int;
                readonly T_32PUQUAD: int;
                readonly T_32PUSHORT: int;
                readonly T_32PVOID: int;
                readonly T_32PWCHAR: int;
                readonly T_64PBOOL08: int;
                readonly T_64PBOOL16: int;
                readonly T_64PBOOL32: int;
                readonly T_64PBOOL64: int;
                readonly T_64PCHAR: int;
                readonly T_64PCPLX128: int;
                readonly T_64PCPLX32: int;
                readonly T_64PCPLX64: int;
                readonly T_64PCPLX80: int;
                readonly T_64PINT2: int;
                readonly T_64PINT4: int;
                readonly T_64PINT8: int;
                readonly T_64PLONG: int;
                readonly T_64PQUAD: int;
                readonly T_64PRCHAR: int;
                readonly T_64PREAL128: int;
                readonly T_64PREAL32: int;
                readonly T_64PREAL48: int;
                readonly T_64PREAL64: int;
                readonly T_64PREAL80: int;
                readonly T_64PSHORT: int;
                readonly T_64PUCHAR: int;
                readonly T_64PUINT2: int;
                readonly T_64PUINT4: int;
                readonly T_64PUINT8: int;
                readonly T_64PULONG: int;
                readonly T_64PUQUAD: int;
                readonly T_64PUSHORT: int;
                readonly T_64PVOID: int;
                readonly T_64PWCHAR: int;
                readonly T_ABS: int;
                readonly T_BIT: int;
                readonly T_BOOL08: int;
                readonly T_BOOL16: int;
                readonly T_BOOL32: int;
                readonly T_BOOL64: int;
                readonly T_CHAR: int;
                readonly T_CPLX128: int;
                readonly T_CPLX32: int;
                readonly T_CPLX64: int;
                readonly T_CPLX80: int;
                readonly T_CURRENCY: int;
                readonly T_FBASICSTR: int;
                readonly T_INT2: int;
                readonly T_INT4: int;
                readonly T_INT8: int;
                readonly T_LONG: int;
                readonly T_NBASICSTR: int;
                readonly T_NOTTRANS: int;
                readonly T_NOTYPE: int;
                readonly T_PASCHAR: int;
                readonly T_PBOOL08: int;
                readonly T_PBOOL16: int;
                readonly T_PBOOL32: int;
                readonly T_PBOOL64: int;
                readonly T_PCHAR: int;
                readonly T_PCPLX128: int;
                readonly T_PCPLX32: int;
                readonly T_PCPLX64: int;
                readonly T_PCPLX80: int;
                readonly T_PFBOOL08: int;
                readonly T_PFBOOL16: int;
                readonly T_PFBOOL32: int;
                readonly T_PFBOOL64: int;
                readonly T_PFCHAR: int;
                readonly T_PFCPLX128: int;
                readonly T_PFCPLX32: int;
                readonly T_PFCPLX64: int;
                readonly T_PFCPLX80: int;
                readonly T_PFINT2: int;
                readonly T_PFINT4: int;
                readonly T_PFINT8: int;
                readonly T_PFLONG: int;
                readonly T_PFQUAD: int;
                readonly T_PFRCHAR: int;
                readonly T_PFREAL128: int;
                readonly T_PFREAL32: int;
                readonly T_PFREAL48: int;
                readonly T_PFREAL64: int;
                readonly T_PFREAL80: int;
                readonly T_PFSHORT: int;
                readonly T_PFUCHAR: int;
                readonly T_PFUINT2: int;
                readonly T_PFUINT4: int;
                readonly T_PFUINT8: int;
                readonly T_PFULONG: int;
                readonly T_PFUQUAD: int;
                readonly T_PFUSHORT: int;
                readonly T_PFVOID: int;
                readonly T_PFWCHAR: int;
                readonly T_PHBOOL08: int;
                readonly T_PHBOOL16: int;
                readonly T_PHBOOL32: int;
                readonly T_PHBOOL64: int;
                readonly T_PHCHAR: int;
                readonly T_PHCPLX128: int;
                readonly T_PHCPLX32: int;
                readonly T_PHCPLX64: int;
                readonly T_PHCPLX80: int;
                readonly T_PHINT2: int;
                readonly T_PHINT4: int;
                readonly T_PHINT8: int;
                readonly T_PHLONG: int;
                readonly T_PHQUAD: int;
                readonly T_PHRCHAR: int;
                readonly T_PHREAL128: int;
                readonly T_PHREAL32: int;
                readonly T_PHREAL48: int;
                readonly T_PHREAL64: int;
                readonly T_PHREAL80: int;
                readonly T_PHSHORT: int;
                readonly T_PHUCHAR: int;
                readonly T_PHUINT2: int;
                readonly T_PHUINT4: int;
                readonly T_PHUINT8: int;
                readonly T_PHULONG: int;
                readonly T_PHUQUAD: int;
                readonly T_PHUSHORT: int;
                readonly T_PHVOID: int;
                readonly T_PHWCHAR: int;
                readonly T_PINT2: int;
                readonly T_PINT4: int;
                readonly T_PINT8: int;
                readonly T_PLONG: int;
                readonly T_PQUAD: int;
                readonly T_PRCHAR: int;
                readonly T_PREAL128: int;
                readonly T_PREAL32: int;
                readonly T_PREAL48: int;
                readonly T_PREAL64: int;
                readonly T_PREAL80: int;
                readonly T_PSHORT: int;
                readonly T_PUCHAR: int;
                readonly T_PUINT2: int;
                readonly T_PUINT4: int;
                readonly T_PUINT8: int;
                readonly T_PULONG: int;
                readonly T_PUQUAD: int;
                readonly T_PUSHORT: int;
                readonly T_PVOID: int;
                readonly T_PWCHAR: int;
                readonly T_QUAD: int;
                readonly T_RCHAR: int;
                readonly T_REAL128: int;
                readonly T_REAL32: int;
                readonly T_REAL48: int;
                readonly T_REAL64: int;
                readonly T_REAL80: int;
                readonly T_SEGMENT: int;
                readonly T_SHORT: int;
                readonly T_UCHAR: int;
                readonly T_UINT2: int;
                readonly T_UINT4: int;
                readonly T_UINT8: int;
                readonly T_ULONG: int;
                readonly T_UQUAD: int;
                readonly T_USHORT: int;
                readonly T_VOID: int;
                readonly T_WCHAR: int;
              }
              let DebugVC50ReservedTypes: _DebugVC50ReservedTypes$$static;
              interface _DebugVC50ReservedTypes {
              }
              interface DebugVC50ReservedTypes extends CombineTypes<[_DebugVC50ReservedTypes, java.lang.Object]> {}
              interface _DebugVC50SSAlignSym$$static extends ClassLike {
              }
              let DebugVC50SSAlignSym: _DebugVC50SSAlignSym$$static;
              interface _DebugVC50SSAlignSym {
                getSymbolIterator(): DebugVC50SymbolIterator;
(): DebugVC50SymbolIterator;
              }
              interface DebugVC50SSAlignSym extends CombineTypes<[_DebugVC50SSAlignSym, sun.jvm.hotspot.debugger.win32.coff.DebugVC50Subsection, java.lang.Object]> {}
              interface _DebugVC50SSFileIndex$$static extends ClassLike {
              }
              let DebugVC50SSFileIndex: _DebugVC50SSFileIndex$$static;
              interface _DebugVC50SSFileIndex {
                getModStart(): short[];
                getNameRef(): int[];
                getNames(): string[];
                getNumModules(): short;
                getNumReferences(): short;
                getRefCount(): short[];
              }
              interface DebugVC50SSFileIndex extends CombineTypes<[_DebugVC50SSFileIndex, sun.jvm.hotspot.debugger.win32.coff.DebugVC50Subsection, java.lang.Object]> {}
              interface _DebugVC50SSGlobalPub$$static extends ClassLike {
              }
              let DebugVC50SSGlobalPub: _DebugVC50SSGlobalPub$$static;
              interface _DebugVC50SSGlobalPub {
              }
              interface DebugVC50SSGlobalPub extends CombineTypes<[_DebugVC50SSGlobalPub, sun.jvm.hotspot.debugger.win32.coff.DebugVC50SSSymbolBase, java.lang.Object]> {}
              interface _DebugVC50SSGlobalSym$$static extends ClassLike {
              }
              let DebugVC50SSGlobalSym: _DebugVC50SSGlobalSym$$static;
              interface _DebugVC50SSGlobalSym {
              }
              interface DebugVC50SSGlobalSym extends CombineTypes<[_DebugVC50SSGlobalSym, sun.jvm.hotspot.debugger.win32.coff.DebugVC50SSSymbolBase, java.lang.Object]> {}
              interface _DebugVC50SSGlobalTypes$$static extends ClassLike {
              }
              let DebugVC50SSGlobalTypes: _DebugVC50SSGlobalTypes$$static;
              interface _DebugVC50SSGlobalTypes {
                getNumTypes(): int;
                getTypeIterator(): DebugVC50TypeIterator;
                getTypeOffset(a0: int): int;
              }
              interface DebugVC50SSGlobalTypes extends CombineTypes<[_DebugVC50SSGlobalTypes, sun.jvm.hotspot.debugger.win32.coff.DebugVC50Subsection, java.lang.Object]> {}
              interface _DebugVC50SSLibraries$$static extends ClassLike {
              }
              let DebugVC50SSLibraries: _DebugVC50SSLibraries$$static;
              interface _DebugVC50SSLibraries {
              }
              interface DebugVC50SSLibraries extends CombineTypes<[_DebugVC50SSLibraries, sun.jvm.hotspot.debugger.win32.coff.DebugVC50Subsection, java.lang.Object]> {}
              interface _DebugVC50SSMPC$$static extends ClassLike {
              }
              let DebugVC50SSMPC: _DebugVC50SSMPC$$static;
              interface _DebugVC50SSMPC {
              }
              interface DebugVC50SSMPC extends CombineTypes<[_DebugVC50SSMPC, sun.jvm.hotspot.debugger.win32.coff.DebugVC50Subsection, java.lang.Object]> {}
              interface _DebugVC50SSModule$$static extends ClassLike {
              }
              let DebugVC50SSModule: _DebugVC50SSModule$$static;
              interface _DebugVC50SSModule {
                getDebuggingStyle(): short;
                getLibrariesIndex(): short;
                getName(): string;
                getNumCodeSegments(): short;
                getOverlayNumber(): short;
                getSegInfo(a0: int): DebugVC50SegInfo;
              }
              interface DebugVC50SSModule extends CombineTypes<[_DebugVC50SSModule, sun.jvm.hotspot.debugger.win32.coff.DebugVC50Subsection, java.lang.Object]> {}
              interface _DebugVC50SSOffsetMap16$$static extends ClassLike {
              }
              let DebugVC50SSOffsetMap16: _DebugVC50SSOffsetMap16$$static;
              interface _DebugVC50SSOffsetMap16 {
              }
              interface DebugVC50SSOffsetMap16 extends CombineTypes<[_DebugVC50SSOffsetMap16, sun.jvm.hotspot.debugger.win32.coff.DebugVC50Subsection, java.lang.Object]> {}
              interface _DebugVC50SSOffsetMap32$$static extends ClassLike {
              }
              let DebugVC50SSOffsetMap32: _DebugVC50SSOffsetMap32$$static;
              interface _DebugVC50SSOffsetMap32 {
              }
              interface DebugVC50SSOffsetMap32 extends CombineTypes<[_DebugVC50SSOffsetMap32, sun.jvm.hotspot.debugger.win32.coff.DebugVC50Subsection, java.lang.Object]> {}
              interface _DebugVC50SSPreComp$$static extends ClassLike {
              }
              let DebugVC50SSPreComp: _DebugVC50SSPreComp$$static;
              interface _DebugVC50SSPreComp {
              }
              interface DebugVC50SSPreComp extends CombineTypes<[_DebugVC50SSPreComp, sun.jvm.hotspot.debugger.win32.coff.DebugVC50Subsection, java.lang.Object]> {}
              interface _DebugVC50SSPublic$$static extends ClassLike {
              }
              let DebugVC50SSPublic: _DebugVC50SSPublic$$static;
              interface _DebugVC50SSPublic {
              }
              interface DebugVC50SSPublic extends CombineTypes<[_DebugVC50SSPublic, sun.jvm.hotspot.debugger.win32.coff.DebugVC50Subsection, java.lang.Object]> {}
              interface _DebugVC50SSPublicSym$$static extends ClassLike {
              }
              let DebugVC50SSPublicSym: _DebugVC50SSPublicSym$$static;
              interface _DebugVC50SSPublicSym {
              }
              interface DebugVC50SSPublicSym extends CombineTypes<[_DebugVC50SSPublicSym, sun.jvm.hotspot.debugger.win32.coff.DebugVC50Subsection, java.lang.Object]> {}
              interface _DebugVC50SSSegMap$$static extends ClassLike {
              }
              let DebugVC50SSSegMap: _DebugVC50SSSegMap$$static;
              interface _DebugVC50SSSegMap {
                getNumLogicalSegDesc(): short;
                getNumSegDesc(): short;
                getSegDesc(a0: int): DebugVC50SegDesc;
              }
              interface DebugVC50SSSegMap extends CombineTypes<[_DebugVC50SSSegMap, sun.jvm.hotspot.debugger.win32.coff.DebugVC50Subsection, java.lang.Object]> {}
              interface _DebugVC50SSSegName$$static extends ClassLike {
              }
              let DebugVC50SSSegName: _DebugVC50SSSegName$$static;
              interface _DebugVC50SSSegName {
                getSegName(a0: int): string;
(a0: int): string;
              }
              interface DebugVC50SSSegName extends CombineTypes<[_DebugVC50SSSegName, sun.jvm.hotspot.debugger.win32.coff.DebugVC50Subsection, java.lang.Object]> {}
              interface _DebugVC50SSSrcLnSeg$$static extends ClassLike {
              }
              let DebugVC50SSSrcLnSeg: _DebugVC50SSSrcLnSeg$$static;
              interface _DebugVC50SSSrcLnSeg {
              }
              interface DebugVC50SSSrcLnSeg extends CombineTypes<[_DebugVC50SSSrcLnSeg, sun.jvm.hotspot.debugger.win32.coff.DebugVC50Subsection, java.lang.Object]> {}
              interface _DebugVC50SSSrcModule$$static extends ClassLike {
              }
              let DebugVC50SSSrcModule: _DebugVC50SSSrcModule$$static;
              interface _DebugVC50SSSrcModule {
                getNumCodeSegments(): int;
                getNumSourceFiles(): int;
                getSegment(a0: int): int;
                getSegmentEndOffset(a0: int): int;
                getSegmentStartOffset(a0: int): int;
                getSourceFileDesc(a0: int): DebugVC50SrcModFileDesc;
              }
              interface DebugVC50SSSrcModule extends CombineTypes<[_DebugVC50SSSrcModule, sun.jvm.hotspot.debugger.win32.coff.DebugVC50Subsection, java.lang.Object]> {}
              interface _DebugVC50SSStaticSym$$static extends ClassLike {
              }
              let DebugVC50SSStaticSym: _DebugVC50SSStaticSym$$static;
              interface _DebugVC50SSStaticSym {
              }
              interface DebugVC50SSStaticSym extends CombineTypes<[_DebugVC50SSStaticSym, sun.jvm.hotspot.debugger.win32.coff.DebugVC50SSSymbolBase, java.lang.Object]> {}
              interface _DebugVC50SSSymbolBase$$static extends ClassLike {
              }
              let DebugVC50SSSymbolBase: _DebugVC50SSSymbolBase$$static;
              interface _DebugVC50SSSymbolBase {
                getAddrHashIndex(): short;
                getAddrHashSize(): int;
                getSymHashIndex(): short;
                getSymHashSize(): int;
                getSymTabSize(): int;
                getSymbolIterator(): DebugVC50SymbolIterator;
              }
              interface DebugVC50SSSymbolBase extends CombineTypes<[_DebugVC50SSSymbolBase, sun.jvm.hotspot.debugger.win32.coff.DebugVC50Subsection, java.lang.Object]> {}
              interface _DebugVC50SSSymbols$$static extends ClassLike {
              }
              let DebugVC50SSSymbols: _DebugVC50SSSymbols$$static;
              interface _DebugVC50SSSymbols {
              }
              interface DebugVC50SSSymbols extends CombineTypes<[_DebugVC50SSSymbols, sun.jvm.hotspot.debugger.win32.coff.DebugVC50Subsection, java.lang.Object]> {}
              interface _DebugVC50SSTypes$$static extends ClassLike {
              }
              let DebugVC50SSTypes: _DebugVC50SSTypes$$static;
              interface _DebugVC50SSTypes {
              }
              interface DebugVC50SSTypes extends CombineTypes<[_DebugVC50SSTypes, sun.jvm.hotspot.debugger.win32.coff.DebugVC50Subsection, java.lang.Object]> {}
              interface _DebugVC50SegDesc$$static extends ClassLike {
              }
              let DebugVC50SegDesc: _DebugVC50SegDesc$$static;
              interface _DebugVC50SegDesc {
                getClassName(): short;
                getFlags(): short;
                getFrame(): short;
                getGroup(): short;
                getName(): short;
                getOffset(): int;
                getOverlayNum(): short;
                getSize(): int;
              }
              interface DebugVC50SegDesc extends CombineTypes<[_DebugVC50SegDesc, java.lang.Object]> {}
              interface _DebugVC50SegDescEnums$$static extends ClassLike {
                readonly SEGMAP_32BIT_MASK: short;
                readonly SEGMAP_ABS_MASK: short;
                readonly SEGMAP_EXECUTABLE_MASK: short;
                readonly SEGMAP_GROUP_MASK: short;
                readonly SEGMAP_READABLE_MASK: short;
                readonly SEGMAP_SEL_MASK: short;
                readonly SEGMAP_WRITABLE_MASK: short;
              }
              let DebugVC50SegDescEnums: _DebugVC50SegDescEnums$$static;
              interface _DebugVC50SegDescEnums {
              }
              interface DebugVC50SegDescEnums extends CombineTypes<[_DebugVC50SegDescEnums, java.lang.Object]> {}
              interface _DebugVC50SegInfo$$static extends ClassLike {
              }
              let DebugVC50SegInfo: _DebugVC50SegInfo$$static;
              interface _DebugVC50SegInfo {
                getOffset(): int;
                getSegment(): short;
                getSegmentCodeSize(): int;
              }
              interface DebugVC50SegInfo extends CombineTypes<[_DebugVC50SegInfo, java.lang.Object]> {}
              interface _DebugVC50SrcModFileDesc$$static extends ClassLike {
              }
              let DebugVC50SrcModFileDesc: _DebugVC50SrcModFileDesc$$static;
              interface _DebugVC50SrcModFileDesc {
                getLineNumberMap(a0: int): DebugVC50SrcModLineNumberMap;
                getNumCodeSegments(): int;
                getSegmentEndOffset(a0: int): int;
                getSegmentStartOffset(a0: int): int;
                getSourceFileName(): string;
              }
              interface DebugVC50SrcModFileDesc extends CombineTypes<[_DebugVC50SrcModFileDesc, java.lang.Object]> {}
              interface _DebugVC50SrcModLineNumberMap$$static extends ClassLike {
              }
              let DebugVC50SrcModLineNumberMap: _DebugVC50SrcModLineNumberMap$$static;
              interface _DebugVC50SrcModLineNumberMap {
                getCodeOffset(a0: int): int;
                getLineNumber(a0: int): int;
                getNumSourceLinePairs(): int;
                getSegment(): int;
              }
              interface DebugVC50SrcModLineNumberMap extends CombineTypes<[_DebugVC50SrcModLineNumberMap, java.lang.Object]> {}
              interface _DebugVC50Subsection$$static extends ClassLike {
              }
              let DebugVC50Subsection: _DebugVC50Subsection$$static;
              interface _DebugVC50Subsection {
                getSubsectionModuleIndex(): short;
                getSubsectionSize(): int;
                getSubsectionType(): short;
              }
              interface DebugVC50Subsection extends CombineTypes<[_DebugVC50Subsection, java.lang.Object]> {}
              interface _DebugVC50SubsectionDirectory$$static extends ClassLike {
              }
              let DebugVC50SubsectionDirectory: _DebugVC50SubsectionDirectory$$static;
              interface _DebugVC50SubsectionDirectory {
                getEntryLength(): short;
                getHeaderLength(): short;
                getNumEntries(): int;
                getSubsection(a0: int): DebugVC50Subsection;
              }
              interface DebugVC50SubsectionDirectory extends CombineTypes<[_DebugVC50SubsectionDirectory, java.lang.Object]> {}
              interface _DebugVC50SubsectionTypes$$static extends ClassLike {
                readonly SST_ALIGN_SYM: short;
                readonly SST_FILE_INDEX: short;
                readonly SST_GLOBAL_PUB: short;
                readonly SST_GLOBAL_SYM: short;
                readonly SST_GLOBAL_TYPES: short;
                readonly SST_LIBRARIES: short;
                readonly SST_MODULE: short;
                readonly SST_MPC: short;
                readonly SST_OFFSET_MAP_16: short;
                readonly SST_OFFSET_MAP_32: short;
                readonly SST_PRE_COMP: short;
                readonly SST_PUBLIC: short;
                readonly SST_PUBLIC_SYM: short;
                readonly SST_SEG_MAP: short;
                readonly SST_SEG_NAME: short;
                readonly SST_SRC_LN_SEG: short;
                readonly SST_SRC_MODULE: short;
                readonly SST_STATIC_SYM: short;
                readonly SST_SYMBOLS: short;
                readonly SST_TYPES: short;
                readonly SST_UNUSED: short;
              }
              let DebugVC50SubsectionTypes: _DebugVC50SubsectionTypes$$static;
              interface _DebugVC50SubsectionTypes {
              }
              interface DebugVC50SubsectionTypes extends CombineTypes<[_DebugVC50SubsectionTypes, java.lang.Object]> {}
              interface _DebugVC50SymbolEnums$$static extends ClassLike {
                readonly COMPFLAG_AMBIENT_CODE_MASK: int;
                readonly COMPFLAG_AMBIENT_CODE_SHIFT: int;
                readonly COMPFLAG_AMBIENT_DATA_MASK: int;
                readonly COMPFLAG_AMBIENT_DATA_SHIFT: int;
                readonly COMPFLAG_AMBIENT_MODEL_FAR: int;
                readonly COMPFLAG_AMBIENT_MODEL_HUGE: int;
                readonly COMPFLAG_AMBIENT_MODEL_NEAR: int;
                readonly COMPFLAG_FLOAT_PACKAGE_ALTMATH: int;
                readonly COMPFLAG_FLOAT_PACKAGE_EMULATOR: int;
                readonly COMPFLAG_FLOAT_PACKAGE_HARDWARE: int;
                readonly COMPFLAG_FLOAT_PACKAGE_MASK: int;
                readonly COMPFLAG_FLOAT_PACKAGE_SHIFT: int;
                readonly COMPFLAG_FLOAT_PRECISION_ANSI_C: int;
                readonly COMPFLAG_FLOAT_PRECISION_MASK: int;
                readonly COMPFLAG_FLOAT_PRECISION_SHIFT: int;
                readonly COMPFLAG_LANGUAGE_BASIC: int;
                readonly COMPFLAG_LANGUAGE_C: int;
                readonly COMPFLAG_LANGUAGE_COBOL: int;
                readonly COMPFLAG_LANGUAGE_CPP: int;
                readonly COMPFLAG_LANGUAGE_FORTRAN: int;
                readonly COMPFLAG_LANGUAGE_MASK: int;
                readonly COMPFLAG_LANGUAGE_MASM: int;
                readonly COMPFLAG_LANGUAGE_PASCAL: int;
                readonly COMPFLAG_LANGUAGE_SHIFT: int;
                readonly COMPFLAG_MODE32_MASK: int;
                readonly COMPFLAG_PCODE_PRESENT_MASK: int;
                readonly EXMODEL_CODE: short;
                readonly EXMODEL_JUMP_TABLE: short;
                readonly EXMODEL_MICROFOCUS_COBOL: short;
                readonly EXMODEL_NATIVE: short;
                readonly EXMODEL_NOT_CODE: short;
                readonly EXMODEL_PADDING: short;
                readonly EXMODEL_PADDING_FOR_ALIGNMENT: short;
                readonly EXMODEL_PCODE: short;
                readonly FUNCRET_INDIRECT_CALLER_FAR: byte;
                readonly FUNCRET_INDIRECT_CALLER_NEAR: byte;
                readonly FUNCRET_INDIRECT_RETURNEE_FAR: byte;
                readonly FUNCRET_INDIRECT_RETURNEE_NEAR: byte;
                readonly FUNCRET_IN_REGISTERS: byte;
                readonly FUNCRET_RETURNEE_STACK_CLEANUP_MASK: short;
                readonly FUNCRET_VARARGS_LEFT_TO_RIGHT_MASK: short;
                readonly FUNCRET_VOID: byte;
                readonly MACHTYPE_ALPHA: byte;
                readonly MACHTYPE_INTEL_80286: byte;
                readonly MACHTYPE_INTEL_80386: byte;
                readonly MACHTYPE_INTEL_80486: byte;
                readonly MACHTYPE_INTEL_8080: byte;
                readonly MACHTYPE_INTEL_8086: byte;
                readonly MACHTYPE_INTEL_PENTIUM: byte;
                readonly MACHTYPE_INTEL_PENTIUM_PRO: byte;
                readonly MACHTYPE_MC68000: byte;
                readonly MACHTYPE_MC68010: byte;
                readonly MACHTYPE_MC68020: byte;
                readonly MACHTYPE_MC68030: byte;
                readonly MACHTYPE_MC68040: byte;
                readonly MACHTYPE_MIPS_R4000: byte;
                readonly MACHTYPE_MIPS_RESERVED: byte;
                readonly MACHTYPE_MIPS_RESERVED2: byte;
                readonly MACHTYPE_PPC601: byte;
                readonly MACHTYPE_PPC603: byte;
                readonly MACHTYPE_PPC604: byte;
                readonly MACHTYPE_PPC620: byte;
                readonly PROCFLAGS_FAR_RETURN: byte;
                readonly PROCFLAGS_FRAME_POINTER_OMITTED: byte;
                readonly PROCFLAGS_INTERRUPT_ROUTINE: byte;
                readonly PROCFLAGS_NEVER_RETURN: byte;
                readonly THUNK_ADJUSTOR: byte;
                readonly THUNK_NO_TYPE: byte;
                readonly THUNK_PCODE: byte;
                readonly THUNK_VCALL: byte;
              }
              let DebugVC50SymbolEnums: _DebugVC50SymbolEnums$$static;
              interface _DebugVC50SymbolEnums {
              }
              interface DebugVC50SymbolEnums extends CombineTypes<[_DebugVC50SymbolEnums, java.lang.Object]> {}
              interface _DebugVC50SymbolIterator$$static extends ClassLike {
              }
              let DebugVC50SymbolIterator: _DebugVC50SymbolIterator$$static;
              interface _DebugVC50SymbolIterator {
                advanceToEntryThisSymbol(): void;
                done(): boolean;
                getBPRelName(): string;
                getBPRelOffset(): int;
                getBPRelType(): int;
                getBlockEnd(): DebugVC50SymbolIterator;
                getBlockEndOffset(): int;
                getBlockLength(): int;
                getBlockName(): string;
                getBlockOffset(): int;
                getBlockParent(): DebugVC50SymbolIterator;
                getBlockParentOffset(): int;
                getBlockSegment(): short;
                getChangeModel(): short;
                getChangeOffset(): int;
                getChangeSegment(): short;
                getCompilerFlags(): int;
                getCompilerTargetProcessor(): byte;
                getComplierVersion(): string;
                getConstantName(): string;
                getConstantType(): int;
                getConstantValueAsDouble(): double;
                getConstantValueAsFloat(): float;
                getConstantValueAsInt(): int;
                getConstantValueAsLong(): long;
                getLGDataName(): string;
                getLGDataOffset(): int;
                getLGDataSegment(): short;
                getLGDataType(): int;
                getLGProcDebugEnd(): int;
                getLGProcDebugStart(): int;
                getLGProcEnd(): DebugVC50SymbolIterator;
                getLGProcEndOffset(): int;
                getLGProcFlags(): byte;
                getLGProcLength(): int;
                getLGProcName(): string;
                getLGProcNext(): DebugVC50SymbolIterator;
                getLGProcNextOffset(): int;
                getLGProcOffset(): int;
                getLGProcParent(): DebugVC50SymbolIterator;
                getLGProcParentOffset(): int;
                getLGProcSegment(): short;
                getLGProcType(): int;
                getLThreadName(): string;
                getLThreadOffset(): int;
                getLThreadSegment(): short;
                getLThreadType(): int;
                getLabelFlags(): byte;
                getLabelName(): string;
                getLabelOffset(): int;
                getLabelSegment(): short;
                getLength(): short;
                getManyRegCount(): byte;
                getManyRegName(): string;
                getManyRegRegister(a0: int): byte;
                getManyRegType(): int;
                getObjectCodeViewSignature(): int;
                getObjectName(): string;
                getOffset(): int;
                getRegRelName(): string;
                getRegRelOffset(): int;
                getRegRelRegister(): short;
                getRegRelType(): int;
                getRegisterEnum(): short;
                getRegisterSymbolName(): string;
                getRegisterSymbolType(): int;
                getReturnFlags(): short;
                getReturnRegister(a0: int): byte;
                getReturnRegisterCount(): byte;
                getReturnStyle(): byte;
                getSearchSegment(): short;
                getSearchSymbolOffset(): int;
                getThunkAdjustorTargetName(): string;
                getThunkAdjustorThisDelta(): short;
                getThunkEnd(): DebugVC50SymbolIterator;
                getThunkEndOffset(): int;
                getThunkLength(): short;
                getThunkName(): string;
                getThunkNext(): DebugVC50SymbolIterator;
                getThunkNextOffset(): int;
                getThunkOffset(): int;
                getThunkPCodeOffset(): int;
                getThunkPCodeSegment(): short;
                getThunkParent(): DebugVC50SymbolIterator;
                getThunkParentOffset(): int;
                getThunkSegment(): short;
                getThunkType(): byte;
                getThunkVCallDisplacement(): short;
                getType(): int;
                getUDTName(): string;
                getUDTType(): int;
                getVTableOffset(): int;
                getVTablePath(): int;
                getVTableRoot(): int;
                getVTableSegment(): short;
                next(): void;
              }
              interface DebugVC50SymbolIterator extends CombineTypes<[_DebugVC50SymbolIterator, sun.jvm.hotspot.debugger.win32.coff.DebugVC50SymbolTypes, sun.jvm.hotspot.debugger.win32.coff.DebugVC50SymbolEnums, java.lang.Object]> {}
              interface _DebugVC50SymbolTypes$$static extends ClassLike {
                readonly S_ALIGN: int;
                readonly S_BLOCK32: int;
                readonly S_BPREL32: int;
                readonly S_CEXMODEL32: int;
                readonly S_COBOLUDT: int;
                readonly S_COBOLUDT2: int;
                readonly S_COMPILE: int;
                readonly S_CONSTANT: int;
                readonly S_CVRESERVE: int;
                readonly S_DATAREF: int;
                readonly S_END: int;
                readonly S_ENDARG: int;
                readonly S_ENTRYTHIS: int;
                readonly S_GDATA32: int;
                readonly S_GPROC32: int;
                readonly S_GPROCMIPS: int;
                readonly S_GTHREAD32: int;
                readonly S_LABEL32: int;
                readonly S_LDATA32: int;
                readonly S_LPROC32: int;
                readonly S_LPROCMIPS: int;
                readonly S_LTHREAD32: int;
                readonly S_MANYREG: int;
                readonly S_MANYREG2: int;
                readonly S_OBJNAME: int;
                readonly S_PROCREF: int;
                readonly S_PUB32: int;
                readonly S_REGISTER: int;
                readonly S_REGREL32: int;
                readonly S_RETURN: int;
                readonly S_SKIP: int;
                readonly S_SSEARCH: int;
                readonly S_THUNK32: int;
                readonly S_UDT: int;
                readonly S_VFTTABLE32: int;
                readonly S_WITH32: int;
              }
              let DebugVC50SymbolTypes: _DebugVC50SymbolTypes$$static;
              interface _DebugVC50SymbolTypes {
              }
              interface DebugVC50SymbolTypes extends CombineTypes<[_DebugVC50SymbolTypes, java.lang.Object]> {}
              interface _DebugVC50TypeEnums$$static extends ClassLike {
                readonly CALLCONV_FAR_C: byte;
                readonly CALLCONV_FAR_FASTCALL: byte;
                readonly CALLCONV_FAR_PASCAL: byte;
                readonly CALLCONV_FAR_STDCALL: byte;
                readonly CALLCONV_FAR_SYSCALL: byte;
                readonly CALLCONV_GENERIC: byte;
                readonly CALLCONV_MIPS_CALL: byte;
                readonly CALLCONV_NEAR_C: byte;
                readonly CALLCONV_NEAR_FASTCALL: byte;
                readonly CALLCONV_NEAR_PASCAL: byte;
                readonly CALLCONV_NEAR_STDCALL: byte;
                readonly CALLCONV_NEAR_SYSCALL: byte;
                readonly CALLCONV_RESERVED: byte;
                readonly CALLCONV_THIS_CALL: byte;
                readonly LABEL_ADDR_MODE_FAR: short;
                readonly LABEL_ADDR_MODE_NEAR: short;
                readonly MODIFIER_CONST_MASK: int;
                readonly MODIFIER_UNALIGNED_MASK: int;
                readonly MODIFIER_VOLATILE_MASK: int;
                readonly POINTER_CONST_MASK: int;
                readonly POINTER_ISFLAT32_MASK: int;
                readonly POINTER_PTRMODE_MASK: int;
                readonly POINTER_PTRMODE_POINTER: int;
                readonly POINTER_PTRMODE_PTR_TO_DATA_MEMBER: int;
                readonly POINTER_PTRMODE_PTR_TO_METHOD: int;
                readonly POINTER_PTRMODE_REFERENCE: int;
                readonly POINTER_PTRMODE_SHIFT: int;
                readonly POINTER_PTRTYPE_64_BIT: int;
                readonly POINTER_PTRTYPE_BASED_ON_ADDRESS_OF_SYMBOL: int;
                readonly POINTER_PTRTYPE_BASED_ON_SEGMENT: int;
                readonly POINTER_PTRTYPE_BASED_ON_SEGMENT_OF_SYMBOL_ADDRESS: int;
                readonly POINTER_PTRTYPE_BASED_ON_SEGMENT_OF_VALUE: int;
                readonly POINTER_PTRTYPE_BASED_ON_SELF: int;
                readonly POINTER_PTRTYPE_BASED_ON_TYPE: int;
                readonly POINTER_PTRTYPE_BASED_ON_VALUE: int;
                readonly POINTER_PTRTYPE_FAR: int;
                readonly POINTER_PTRTYPE_FAR_32_BIT: int;
                readonly POINTER_PTRTYPE_HUGE: int;
                readonly POINTER_PTRTYPE_MASK: int;
                readonly POINTER_PTRTYPE_NEAR: int;
                readonly POINTER_PTRTYPE_NEAR_32_BIT: int;
                readonly POINTER_PTRTYPE_SHIFT: int;
                readonly POINTER_RESTRICT_MASK: int;
                readonly POINTER_UNALIGNED_MASK: int;
                readonly POINTER_VOLATILE_MASK: int;
                readonly PROPERTY_CNESTED: short;
                readonly PROPERTY_CTOR: short;
                readonly PROPERTY_FWDREF: short;
                readonly PROPERTY_ISNESTED: short;
                readonly PROPERTY_OPASSIGN: short;
                readonly PROPERTY_OPCAST: short;
                readonly PROPERTY_OVEROPS: short;
                readonly PROPERTY_PACKED: short;
                readonly PROPERTY_SCOPED: short;
                readonly PTR_FORMAT_DATA_NVF_NVB: short;
                readonly PTR_FORMAT_DATA_VB: short;
                readonly PTR_FORMAT_METHOD_NVB_MAP: short;
                readonly PTR_FORMAT_METHOD_NVB_SAP: short;
                readonly PTR_FORMAT_METHOD_VB: short;
                readonly RESERVED_MODE_DIRECT: int;
                readonly RESERVED_MODE_FAR_32_PTR: int;
                readonly RESERVED_MODE_FAR_PTR: int;
                readonly RESERVED_MODE_HUGE_PTR: int;
                readonly RESERVED_MODE_MASK: int;
                readonly RESERVED_MODE_NEAR_32_PTR: int;
                readonly RESERVED_MODE_NEAR_64_PTR: int;
                readonly RESERVED_MODE_NEAR_PTR: int;
                readonly RESERVED_SIZE_INT_1_BYTE: int;
                readonly RESERVED_SIZE_INT_2_BYTE: int;
                readonly RESERVED_SIZE_INT_4_BYTE: int;
                readonly RESERVED_SIZE_INT_8_BYTE: int;
                readonly RESERVED_SIZE_MASK: int;
                readonly RESERVED_SIZE_REALLY_INT_2_BYTE: int;
                readonly RESERVED_SIZE_REALLY_INT_2_BYTE_U: int;
                readonly RESERVED_SIZE_REALLY_INT_4_BYTE: int;
                readonly RESERVED_SIZE_REALLY_INT_4_BYTE_U: int;
                readonly RESERVED_SIZE_REALLY_INT_8_BYTE: int;
                readonly RESERVED_SIZE_REALLY_INT_8_BYTE_U: int;
                readonly RESERVED_SIZE_REALLY_INT_CHAR: int;
                readonly RESERVED_SIZE_REALLY_INT_WCHAR: int;
                readonly RESERVED_SIZE_REAL_128_BIT: int;
                readonly RESERVED_SIZE_REAL_32_BIT: int;
                readonly RESERVED_SIZE_REAL_48_BIT: int;
                readonly RESERVED_SIZE_REAL_64_BIT: int;
                readonly RESERVED_SIZE_REAL_80_BIT: int;
                readonly RESERVED_SIZE_SPECIAL2_BIT: int;
                readonly RESERVED_SIZE_SPECIAL2_PASCAL_CHAR: int;
                readonly RESERVED_SIZE_SPECIAL_ABSOLUTE_SYMBOL: int;
                readonly RESERVED_SIZE_SPECIAL_BASIC_8_BYTE: int;
                readonly RESERVED_SIZE_SPECIAL_FAR_BASIC_STRING: int;
                readonly RESERVED_SIZE_SPECIAL_NEAR_BASIC_STRING: int;
                readonly RESERVED_SIZE_SPECIAL_NO_TYPE: int;
                readonly RESERVED_SIZE_SPECIAL_SEGMENT: int;
                readonly RESERVED_SIZE_SPECIAL_UNTRANSLATED: int;
                readonly RESERVED_SIZE_SPECIAL_VOID: int;
                readonly RESERVED_TYPE_BOOLEAN: int;
                readonly RESERVED_TYPE_COMPLEX: int;
                readonly RESERVED_TYPE_MASK: int;
                readonly RESERVED_TYPE_REAL: int;
                readonly RESERVED_TYPE_REALLY_INT: int;
                readonly RESERVED_TYPE_SIGNED_INT: int;
                readonly RESERVED_TYPE_SPECIAL: int;
                readonly RESERVED_TYPE_SPECIAL2: int;
                readonly RESERVED_TYPE_UNSIGNED_INT: int;
                readonly VTENTRY_ADDRESS_PT_DISP: int;
                readonly VTENTRY_FAR: int;
                readonly VTENTRY_FAR_32: int;
                readonly VTENTRY_FAR_PTR_TO_METACLASS: int;
                readonly VTENTRY_NEAR: int;
                readonly VTENTRY_NEAR_32: int;
                readonly VTENTRY_THIN: int;
              }
              let DebugVC50TypeEnums: _DebugVC50TypeEnums$$static;
              interface _DebugVC50TypeEnums {
              }
              interface DebugVC50TypeEnums extends CombineTypes<[_DebugVC50TypeEnums, java.lang.Object]> {}
              interface _DebugVC50TypeIterator$$static extends ClassLike {
              }
              let DebugVC50TypeIterator: _DebugVC50TypeIterator$$static;
              interface _DebugVC50TypeIterator {
                done(): boolean;
                getArgListCount(): int;
                getArgListType(a0: int): int;
                getArrayElementType(): int;
                getArrayIndexType(): int;
                getArrayLength(): int;
                getArrayName(): string;
                getBClassAttribute(): short;
                getBClassOffset(): int;
                getBClassType(): int;
                getBasicArrayType(): int;
                getBitfieldFieldType(): int;
                getBitfieldLength(): byte;
                getBitfieldPosition(): byte;
                getClassCount(): short;
                getClassDerivationList(): int;
                getClassFieldList(): int;
                getClassFieldListIterator(): DebugVC50TypeIterator;
                getClassName(): string;
                getClassProperty(): short;
                getClassSize(): int;
                getClassVShape(): int;
                getDefaultArgExpression(): string;
                getDefaultArgType(): int;
                getDerivedCount(): int;
                getDerivedType(a0: int): int;
                getDimArrayDimInfo(): int;
                getDimArrayName(): string;
                getDimArrayType(): int;
                getEnumCount(): short;
                getEnumFieldList(): int;
                getEnumFieldListIterator(): DebugVC50TypeIterator;
                getEnumName(): string;
                getEnumProperty(): short;
                getEnumType(): int;
                getEnumerateAttribute(): short;
                getEnumerateName(): string;
                getEnumerateValue(): long;
                getFriendClsType(): int;
                getFriendFcnName(): string;
                getFriendFcnType(): int;
                getIVBClassAttribute(): short;
                getIVBClassBType(): int;
                getIVBClassVBOff(): int;
                getIVBClassVBPOff(): int;
                getIVBClassVBPType(): int;
                getIndexIterator(): DebugVC50TypeIterator;
                getIndexValue(): int;
                getLabelAddressMode(): short;
                getLength(): short;
                getMFunctionArgumentList(): int;
                getMFunctionArgumentListIterator(): DebugVC50TypeIterator;
                getMFunctionCallingConvention(): byte;
                getMFunctionContainingClass(): int;
                getMFunctionNumberOfParameters(): short;
                getMFunctionReturnType(): int;
                getMFunctionThis(): int;
                getMFunctionThisAdjust(): int;
                getMListAttribute(): short;
                getMListLength(): int;
                getMListType(a0: int): int;
                getMListVtabOffset(): int;
                getMemberAttribute(): short;
                getMemberModifyAttribute(): short;
                getMemberModifyName(): string;
                getMemberModifyType(): int;
                getMemberName(): string;
                getMemberOffset(): int;
                getMemberType(): int;
                getMethodCount(): short;
                getMethodList(): int;
                getMethodName(): string;
                getModifierAttribute(): short;
                getModifierIndex(): int;
                getNestedExAttribute(): short;
                getNestedExName(): string;
                getNestedExType(): int;
                getNestedName(): string;
                getNestedType(): int;
                getNumTypes(): int;
                getNumericDataAt(a0: int): byte[];
                getNumericDoubleAt(a0: int): double;
                getNumericFloatAt(a0: int): float;
                getNumericIntAt(a0: int): int;
                getNumericLengthAt(a0: int): int;
                getNumericLongAt(a0: int): long;
                getNumericTypeAt(a0: int): short;
                getOneMethodAttribute(): short;
                getOneMethodName(): string;
                getOneMethodType(): int;
                getOneMethodVBaseOff(): int;
                getPointerAttributes(): int;
                getPointerBasedOnTypeIndex(): int;
                getPointerBasedOnTypeName(): string;
                getPointerToMemberClass(): int;
                getPointerToMemberFormat(): short;
                getPointerType(): int;
                getProcedureArgumentList(): int;
                getProcedureArgumentListIterator(): DebugVC50TypeIterator;
                getProcedureCallingConvention(): byte;
                getProcedureNumberOfParameters(): short;
                getProcedureReturnType(): int;
                getRefSym(): DebugVC50SymbolIterator;
                getSkipIndex(): int;
                getStaticAttribute(): short;
                getStaticName(): string;
                getStaticType(): int;
                getTypeIndex(): int;
                getUnionCount(): short;
                getUnionFieldList(): int;
                getUnionFieldListIterator(): DebugVC50TypeIterator;
                getUnionName(): string;
                getUnionProperty(): short;
                getUnionSize(): int;
                getVBClassAttribute(): short;
                getVBClassBaseClassType(): int;
                getVBClassVBOff(): int;
                getVBClassVBPOff(): int;
                getVBClassVirtualBaseClassType(): int;
                getVFTPathBase(a0: int): int;
                getVFTPathCount(): int;
                getVFuncOffOffset(): int;
                getVFuncOffType(): int;
                getVFuncTabType(): int;
                getVTShapeCount(): short;
                getVTShapeDescriptor(a0: int): int;
                isMListIntroducingVirtual(): boolean;
                isOneMethodIntroducingVirtual(): boolean;
                next(): void;
                typeStringDone(): boolean;
                typeStringLeaf(): int;
                typeStringNext(): void;
                typeStringOffset(): int;
              }
              interface DebugVC50TypeIterator extends CombineTypes<[_DebugVC50TypeIterator, java.lang.Object]> {}
              interface _DebugVC50TypeLeafIndices$$static extends ClassLike {
                readonly LF_ARGLIST: int;
                readonly LF_ARRAY: int;
                readonly LF_BARRAY: int;
                readonly LF_BCLASS: int;
                readonly LF_BITFIELD: int;
                readonly LF_CHAR: int;
                readonly LF_CLASS: int;
                readonly LF_COBOL0: int;
                readonly LF_COBOL1: int;
                readonly LF_COMPLEX128: int;
                readonly LF_COMPLEX32: int;
                readonly LF_COMPLEX64: int;
                readonly LF_COMPLEX80: int;
                readonly LF_DEFARG: int;
                readonly LF_DERIVED: int;
                readonly LF_DIMARRAY: int;
                readonly LF_DIMCONLU: int;
                readonly LF_DIMCONU: int;
                readonly LF_DIMVARLU: int;
                readonly LF_DIMVARU: int;
                readonly LF_ENDPRECOMP: int;
                readonly LF_ENUM: int;
                readonly LF_ENUMERATE: int;
                readonly LF_FIELDLIST: int;
                readonly LF_FRIENDCLS: int;
                readonly LF_FRIENDFCN: int;
                readonly LF_INDEX: int;
                readonly LF_IVBCLASS: int;
                readonly LF_LABEL: int;
                readonly LF_LONG: int;
                readonly LF_MEMBER: int;
                readonly LF_MEMBERMODIFY: int;
                readonly LF_METHOD: int;
                readonly LF_METHODLIST: int;
                readonly LF_MFUNCTION: int;
                readonly LF_MODIFIER: int;
                readonly LF_NESTTYPE: int;
                readonly LF_NESTTYPEEX: int;
                readonly LF_NOTTRAN: int;
                readonly LF_NULL: int;
                readonly LF_NUMERIC: int;
                readonly LF_OEM: int;
                readonly LF_ONEMETHOD: int;
                readonly LF_PAD0: int;
                readonly LF_PAD1: int;
                readonly LF_PAD10: int;
                readonly LF_PAD11: int;
                readonly LF_PAD12: int;
                readonly LF_PAD13: int;
                readonly LF_PAD14: int;
                readonly LF_PAD15: int;
                readonly LF_PAD2: int;
                readonly LF_PAD3: int;
                readonly LF_PAD4: int;
                readonly LF_PAD5: int;
                readonly LF_PAD6: int;
                readonly LF_PAD7: int;
                readonly LF_PAD8: int;
                readonly LF_PAD9: int;
                readonly LF_POINTER: int;
                readonly LF_PRECOMP: int;
                readonly LF_PROCEDURE: int;
                readonly LF_QUADWORD: int;
                readonly LF_REAL128: int;
                readonly LF_REAL32: int;
                readonly LF_REAL48: int;
                readonly LF_REAL64: int;
                readonly LF_REAL80: int;
                readonly LF_REFSYM: int;
                readonly LF_SHORT: int;
                readonly LF_SKIP: int;
                readonly LF_STMEMBER: int;
                readonly LF_STRUCTURE: int;
                readonly LF_TYPESERVER: int;
                readonly LF_ULONG: int;
                readonly LF_UNION: int;
                readonly LF_UQUADWORD: int;
                readonly LF_USHORT: int;
                readonly LF_VARSTRING: int;
                readonly LF_VBCLASS: int;
                readonly LF_VFTPATH: int;
                readonly LF_VFUNCOFF: int;
                readonly LF_VFUNCTAB: int;
                readonly LF_VTSHAPE: int;
              }
              let DebugVC50TypeLeafIndices: _DebugVC50TypeLeafIndices$$static;
              interface _DebugVC50TypeLeafIndices {
              }
              interface DebugVC50TypeLeafIndices extends CombineTypes<[_DebugVC50TypeLeafIndices, java.lang.Object]> {}
              interface _DebugVC50WrongNumericTypeException$$static extends ClassLike {
                new(): DebugVC50WrongNumericTypeException;
                new(message: string): DebugVC50WrongNumericTypeException;
              }
              let DebugVC50WrongNumericTypeException: _DebugVC50WrongNumericTypeException$$static;
              interface _DebugVC50WrongNumericTypeException {
              }
              interface DebugVC50WrongNumericTypeException extends CombineTypes<[_DebugVC50WrongNumericTypeException, java.lang.RuntimeException]> {}
              interface _DebugVC50X86RegisterEnums$$static extends ClassLike {
                readonly AH: int;
                readonly AL: int;
                readonly AX: int;
                readonly BH: int;
                readonly BL: int;
                readonly BP: int;
                readonly BX: int;
                readonly CH: int;
                readonly CL: int;
                readonly CONTROL: int;
                readonly CR0: int;
                readonly CR1: int;
                readonly CR2: int;
                readonly CR3: int;
                readonly CS: int;
                readonly CX: int;
                readonly DH: int;
                readonly DI: int;
                readonly DL: int;
                readonly DR0: int;
                readonly DR1: int;
                readonly DR2: int;
                readonly DR3: int;
                readonly DR4: int;
                readonly DR5: int;
                readonly DR6: int;
                readonly DR7: int;
                readonly DS: int;
                readonly DX: int;
                readonly EAX: int;
                readonly EBP: int;
                readonly EBX: int;
                readonly ECX: int;
                readonly EDI: int;
                readonly EDX: int;
                readonly EFLAGS: int;
                readonly EIP: int;
                readonly ES: int;
                readonly ESI: int;
                readonly ESP: int;
                readonly FLAGS: int;
                readonly FPCS: int;
                readonly FPDO: int;
                readonly FPDS: int;
                readonly FPEDO: int;
                readonly FPEIP: int;
                readonly FPIP: int;
                readonly FS: int;
                readonly GS: int;
                readonly IP: int;
                readonly ISEM: int;
                readonly NONE: int;
                readonly QUOTE: int;
                readonly SI: int;
                readonly SP: int;
                readonly SS: int;
                readonly ST0: int;
                readonly ST1: int;
                readonly ST2: int;
                readonly ST3: int;
                readonly ST4: int;
                readonly ST5: int;
                readonly ST6: int;
                readonly ST7: int;
                readonly STATUS: int;
                readonly TAG: int;
                readonly TEMP: int;
                readonly TEMPH: int;
              }
              let DebugVC50X86RegisterEnums: _DebugVC50X86RegisterEnums$$static;
              interface _DebugVC50X86RegisterEnums {
              }
              interface DebugVC50X86RegisterEnums extends CombineTypes<[_DebugVC50X86RegisterEnums, java.lang.Object]> {}
              interface _DumpExports$$static extends ClassLike {
                main(args: string[]): void;
                _usage(): void;
                new(): DumpExports;
              }
              let DumpExports: _DumpExports$$static;
              interface _DumpExports {
              }
              interface DumpExports extends CombineTypes<[_DumpExports, java.lang.Object]> {}
              interface _ExportDirectoryTable$$static extends ClassLike {
              }
              let ExportDirectoryTable: _ExportDirectoryTable$$static;
              interface _ExportDirectoryTable {
                getDLLName(): string;
                getExportAddress(a0: short): int;
                getExportAddressForwarder(a0: short): string;
                getExportAddressTableRVA(): int;
                getExportFlags(): int;
                getExportName(a0: int): string;
                getExportOrdinal(a0: int): short;
                getMajorVersion(): short;
                getMinorVersion(): short;
                getNamePointerTableRVA(): int;
                getNameRVA(): int;
                getNumberOfAddressTableEntries(): int;
                getNumberOfNamePointers(): int;
                getOrdinalBase(): int;
                getOrdinalTableRVA(): int;
                getTimeDateStamp(): int;
                isExportAddressForwarder(a0: short): boolean;
              }
              interface ExportDirectoryTable extends CombineTypes<[_ExportDirectoryTable, java.lang.Object]> {}
              interface _MachineTypes$$static extends ClassLike {
                readonly IMAGE_FILE_MACHINE_ALPHA: short;
                readonly IMAGE_FILE_MACHINE_ALPHA64: short;
                readonly IMAGE_FILE_MACHINE_ARM: short;
                readonly IMAGE_FILE_MACHINE_I386: short;
                readonly IMAGE_FILE_MACHINE_M68K: short;
                readonly IMAGE_FILE_MACHINE_MIPS16: short;
                readonly IMAGE_FILE_MACHINE_MIPSFPU: short;
                readonly IMAGE_FILE_MACHINE_MIPSFPU16: short;
                readonly IMAGE_FILE_MACHINE_POWERPC: short;
                readonly IMAGE_FILE_MACHINE_R10000: short;
                readonly IMAGE_FILE_MACHINE_R3000: short;
                readonly IMAGE_FILE_MACHINE_R4000: short;
                readonly IMAGE_FILE_MACHINE_SH3: short;
                readonly IMAGE_FILE_MACHINE_SH4: short;
                readonly IMAGE_FILE_MACHINE_THUMB: short;
                readonly IMAGE_FILE_MACHINE_UNKNOWN: short;
              }
              let MachineTypes: _MachineTypes$$static;
              interface _MachineTypes {
              }
              interface MachineTypes extends CombineTypes<[_MachineTypes, java.lang.Object]> {}
              interface _OptionalHeader$$static extends ClassLike {
                readonly MAGIC_PE32: short;
                readonly MAGIC_PE32_PLUS: short;
                readonly MAGIC_ROM_IMAGE: short;
              }
              let OptionalHeader: _OptionalHeader$$static;
              interface _OptionalHeader {
                getDataDirectories(): OptionalHeaderDataDirectories;
                getMagicNumber(): short;
                getStandardFields(): OptionalHeaderStandardFields;
                getWindowsSpecificFields(): OptionalHeaderWindowsSpecificFields;
              }
              interface OptionalHeader extends CombineTypes<[_OptionalHeader, java.lang.Object]> {}
              interface _OptionalHeaderDataDirectories$$static extends ClassLike {
              }
              let OptionalHeaderDataDirectories: _OptionalHeaderDataDirectories$$static;
              interface _OptionalHeaderDataDirectories {
                getArchitecture(): DataDirectory;
                getBaseRelocationTable(): DataDirectory;
                getBoundImportTable(): DataDirectory;
                getCOMPlusRuntimeHeader(): DataDirectory;
                getCertificateTable(): DataDirectory;
                getDebug(): DataDirectory;
                getDebugDirectory(): DebugDirectory;
                getDelayImportDescriptor(): DataDirectory;
                getExceptionTable(): DataDirectory;
                getExportDirectoryTable(): ExportDirectoryTable;
                getExportTable(): DataDirectory;
                getGlobalPtr(): DataDirectory;
                getImportAddressTable(): DataDirectory;
                getImportTable(): DataDirectory;
                getLoadConfigTable(): DataDirectory;
                getResourceTable(): DataDirectory;
                getTLSTable(): DataDirectory;
              }
              interface OptionalHeaderDataDirectories extends CombineTypes<[_OptionalHeaderDataDirectories, java.lang.Object]> {}
              interface _OptionalHeaderStandardFields$$static extends ClassLike {
              }
              let OptionalHeaderStandardFields: _OptionalHeaderStandardFields$$static;
              interface _OptionalHeaderStandardFields {
                getAddressOfEntryPoint(): int;
                getBaseOfCode(): int;
                getBaseOfData(): int;
                getMajorLinkerVersion(): byte;
                getMinorLinkerVersion(): byte;
                getSizeOfCode(): int;
                getSizeOfInitializedData(): int;
                getSizeOfUninitializedData(): int;
              }
              interface OptionalHeaderStandardFields extends CombineTypes<[_OptionalHeaderStandardFields, java.lang.Object]> {}
              interface _OptionalHeaderWindowsSpecificFields$$static extends ClassLike {
              }
              let OptionalHeaderWindowsSpecificFields: _OptionalHeaderWindowsSpecificFields$$static;
              interface _OptionalHeaderWindowsSpecificFields {
                getCheckSum(): int;
                getDLLCharacteristics(): short;
                getFileAlignment(): int;
                getImageBase(): long;
                getLoaderFlags(): int;
                getMajorImageVersion(): short;
                getMajorOperatingSystemVersion(): short;
                getMajorSubsystemVersion(): short;
                getMinorImageVersion(): short;
                getMinorOperatingSystemVersion(): short;
                getMinorSubsystemVersion(): short;
                getNumberOfRvaAndSizes(): int;
                getSectionAlignment(): int;
                getSizeOfHeaders(): int;
                getSizeOfHeapCommit(): long;
                getSizeOfHeapReserve(): long;
                getSizeOfImage(): int;
                getSizeOfStackCommit(): long;
                getSizeOfStackReserve(): long;
                getSubsystem(): short;
              }
              interface OptionalHeaderWindowsSpecificFields extends CombineTypes<[_OptionalHeaderWindowsSpecificFields, java.lang.Object]> {}
              interface _SectionFlags$$static extends ClassLike {
                readonly IMAGE_SCN_ALIGN_1024BYTES: int;
                readonly IMAGE_SCN_ALIGN_128BYTES: int;
                readonly IMAGE_SCN_ALIGN_16BYTES: int;
                readonly IMAGE_SCN_ALIGN_1BYTES: int;
                readonly IMAGE_SCN_ALIGN_2048BYTES: int;
                readonly IMAGE_SCN_ALIGN_256BYTES: int;
                readonly IMAGE_SCN_ALIGN_2BYTES: int;
                readonly IMAGE_SCN_ALIGN_32BYTES: int;
                readonly IMAGE_SCN_ALIGN_4096BYTES: int;
                readonly IMAGE_SCN_ALIGN_4BYTES: int;
                readonly IMAGE_SCN_ALIGN_512BYTES: int;
                readonly IMAGE_SCN_ALIGN_64BYTES: int;
                readonly IMAGE_SCN_ALIGN_8192BYTES: int;
                readonly IMAGE_SCN_ALIGN_8BYTES: int;
                readonly IMAGE_SCN_CNT_CODE: int;
                readonly IMAGE_SCN_CNT_INITIALIZED_DATA: int;
                readonly IMAGE_SCN_CNT_UNINITIALIZED_DATA: int;
                readonly IMAGE_SCN_LNK_COMDAT: int;
                readonly IMAGE_SCN_LNK_INFO: int;
                readonly IMAGE_SCN_LNK_NRELOC_OVFL: int;
                readonly IMAGE_SCN_LNK_OTHER: int;
                readonly IMAGE_SCN_LNK_REMOVE: int;
                readonly IMAGE_SCN_MEM_16BIT: int;
                readonly IMAGE_SCN_MEM_DISCARDABLE: int;
                readonly IMAGE_SCN_MEM_EXECUTE: int;
                readonly IMAGE_SCN_MEM_FARDATA: int;
                readonly IMAGE_SCN_MEM_LOCKED: int;
                readonly IMAGE_SCN_MEM_NOT_CACHED: int;
                readonly IMAGE_SCN_MEM_NOT_PAGED: int;
                readonly IMAGE_SCN_MEM_PRELOAD: int;
                readonly IMAGE_SCN_MEM_PURGEABLE: int;
                readonly IMAGE_SCN_MEM_READ: int;
                readonly IMAGE_SCN_MEM_SHARED: int;
                readonly IMAGE_SCN_MEM_WRITE: int;
                readonly IMAGE_SCN_TYPE_COPY: int;
                readonly IMAGE_SCN_TYPE_DSECT: int;
                readonly IMAGE_SCN_TYPE_GROUP: int;
                readonly IMAGE_SCN_TYPE_NOLOAD: int;
                readonly IMAGE_SCN_TYPE_NO_PAD: int;
                readonly IMAGE_SCN_TYPE_OVER: int;
                readonly IMAGE_SCN_TYPE_REG: int;
              }
              let SectionFlags: _SectionFlags$$static;
              interface _SectionFlags {
              }
              interface SectionFlags extends CombineTypes<[_SectionFlags, java.lang.Object]> {}
              interface _SectionHeader$$static extends ClassLike {
              }
              let SectionHeader: _SectionHeader$$static;
              interface _SectionHeader {
                getCOFFLineNumber(a0: int): COFFLineNumber;
                getCOFFRelocation(a0: int): COFFRelocation;
                getName(): string;
                getNumberOfLineNumbers(): short;
                getNumberOfRelocations(): short;
                getPointerToLineNumbers(): int;
                getPointerToRawData(): int;
                getPointerToRelocations(): int;
                getSectionFlags(): int;
                getSize(): int;
                getSizeOfRawData(): int;
                getVirtualAddress(): int;
                hasSectionFlag(a0: int): boolean;
              }
              interface SectionHeader extends CombineTypes<[_SectionHeader, java.lang.Object]> {}
              interface _TestDebugInfo$$static extends ClassLike {
                _getDebugVC50(file: COFFFile): DebugVC50;
                main(args: string[]): void;
                _printSymbolTable(sec: DebugVC50Subsection): void;
                _printSymbolTable(iter: DebugVC50SymbolIterator): void;
                _printTypeTable(sec: DebugVC50Subsection): void;
                new(): TestDebugInfo;
              }
              let TestDebugInfo: _TestDebugInfo$$static;
              interface _TestDebugInfo {
              }
              interface TestDebugInfo extends CombineTypes<[_TestDebugInfo, sun.jvm.hotspot.debugger.win32.coff.DebugVC50SymbolTypes, java.lang.Object, sun.jvm.hotspot.debugger.win32.coff.DebugVC50SubsectionTypes, sun.jvm.hotspot.debugger.win32.coff.DebugVC50TypeLeafIndices]> {}
              interface _TestParser$$static extends ClassLike {
                main(args: string[]): void;
                new(): TestParser;
              }
              let TestParser: _TestParser$$static;
              interface _TestParser {
              }
              interface TestParser extends CombineTypes<[_TestParser, java.lang.Object]> {}
              interface _TypeIndicators$$static extends ClassLike {
                readonly IMAGE_REL_ALPHA_ABSOLUTE: short;
                readonly IMAGE_REL_ALPHA_BRADDR: short;
                readonly IMAGE_REL_ALPHA_GPDISP: short;
                readonly IMAGE_REL_ALPHA_GPREL32: short;
                readonly IMAGE_REL_ALPHA_GPRELHI: short;
                readonly IMAGE_REL_ALPHA_GPRELLO: short;
                readonly IMAGE_REL_ALPHA_HINT: short;
                readonly IMAGE_REL_ALPHA_INLINE_REFLONG: short;
                readonly IMAGE_REL_ALPHA_LITERAL: short;
                readonly IMAGE_REL_ALPHA_LITUSE: short;
                readonly IMAGE_REL_ALPHA_MATCH: short;
                readonly IMAGE_REL_ALPHA_PAIR: short;
                readonly IMAGE_REL_ALPHA_REFHI: short;
                readonly IMAGE_REL_ALPHA_REFLO: short;
                readonly IMAGE_REL_ALPHA_REFLONG: short;
                readonly IMAGE_REL_ALPHA_REFLONGNB: short;
                readonly IMAGE_REL_ALPHA_REFQ1: short;
                readonly IMAGE_REL_ALPHA_REFQ2: short;
                readonly IMAGE_REL_ALPHA_REFQ3: short;
                readonly IMAGE_REL_ALPHA_REFQUAD: short;
                readonly IMAGE_REL_ALPHA_SECREL: short;
                readonly IMAGE_REL_ALPHA_SECRELHI: short;
                readonly IMAGE_REL_ALPHA_SECRELLO: short;
                readonly IMAGE_REL_ALPHA_SECTION: short;
                readonly IMAGE_REL_ARM_ABSOLUTE: short;
                readonly IMAGE_REL_ARM_ADDR32: short;
                readonly IMAGE_REL_ARM_ADDR32NB: short;
                readonly IMAGE_REL_ARM_BRANCH11: short;
                readonly IMAGE_REL_ARM_BRANCH24: short;
                readonly IMAGE_REL_ARM_SECREL: short;
                readonly IMAGE_REL_ARM_SECTION: short;
                readonly IMAGE_REL_I386_ABSOLUTE: short;
                readonly IMAGE_REL_I386_DIR16: short;
                readonly IMAGE_REL_I386_DIR32: short;
                readonly IMAGE_REL_I386_DIR32NB: short;
                readonly IMAGE_REL_I386_REL16: short;
                readonly IMAGE_REL_I386_REL32: short;
                readonly IMAGE_REL_I386_SECREL: short;
                readonly IMAGE_REL_I386_SECTION: short;
                readonly IMAGE_REL_I386_SEG12: short;
                readonly IMAGE_REL_MIPS_ABSOLUTE: short;
                readonly IMAGE_REL_MIPS_GPREL: short;
                readonly IMAGE_REL_MIPS_JMPADDR: short;
                readonly IMAGE_REL_MIPS_JMPADDR16: short;
                readonly IMAGE_REL_MIPS_LITERAL: short;
                readonly IMAGE_REL_MIPS_PAIR: short;
                readonly IMAGE_REL_MIPS_REFHALF: short;
                readonly IMAGE_REL_MIPS_REFHI: short;
                readonly IMAGE_REL_MIPS_REFLO: short;
                readonly IMAGE_REL_MIPS_REFWORD: short;
                readonly IMAGE_REL_MIPS_REFWORDNB: short;
                readonly IMAGE_REL_MIPS_SECREL: short;
                readonly IMAGE_REL_MIPS_SECRELHI: short;
                readonly IMAGE_REL_MIPS_SECRELLO: short;
                readonly IMAGE_REL_MIPS_SECTION: short;
                readonly IMAGE_REL_PPC_ABSOLUTE: short;
                readonly IMAGE_REL_PPC_ADDR14: short;
                readonly IMAGE_REL_PPC_ADDR16: short;
                readonly IMAGE_REL_PPC_ADDR24: short;
                readonly IMAGE_REL_PPC_ADDR32: short;
                readonly IMAGE_REL_PPC_ADDR32NB: short;
                readonly IMAGE_REL_PPC_ADDR64: short;
                readonly IMAGE_REL_PPC_GPREL: short;
                readonly IMAGE_REL_PPC_PAIR: short;
                readonly IMAGE_REL_PPC_REFHI: short;
                readonly IMAGE_REL_PPC_REFLO: short;
                readonly IMAGE_REL_PPC_REL14: short;
                readonly IMAGE_REL_PPC_REL24: short;
                readonly IMAGE_REL_PPC_SECREL: short;
                readonly IMAGE_REL_PPC_SECREL16: short;
                readonly IMAGE_REL_PPC_SECRELHI: short;
                readonly IMAGE_REL_PPC_SECRELLO: short;
                readonly IMAGE_REL_PPC_SECTION: short;
                readonly IMAGE_REL_SH3_ABSOLUTE: short;
                readonly IMAGE_REL_SH3_DIRECT16: short;
                readonly IMAGE_REL_SH3_DIRECT32: short;
                readonly IMAGE_REL_SH3_DIRECT32_NB: short;
                readonly IMAGE_REL_SH3_DIRECT4: short;
                readonly IMAGE_REL_SH3_DIRECT4_LONG: short;
                readonly IMAGE_REL_SH3_DIRECT4_WORD: short;
                readonly IMAGE_REL_SH3_DIRECT8: short;
                readonly IMAGE_REL_SH3_DIRECT8_LONG: short;
                readonly IMAGE_REL_SH3_DIRECT8_WORD: short;
                readonly IMAGE_REL_SH3_PCREL12_WORD: short;
                readonly IMAGE_REL_SH3_PCREL8_LONG: short;
                readonly IMAGE_REL_SH3_PCREL8_WORD: short;
                readonly IMAGE_REL_SH3_SECREL: short;
                readonly IMAGE_REL_SH3_SECTION: short;
                readonly IMAGE_REL_SH3_SIZEOF_SECTION: short;
                readonly IMAGE_REL_SH3_STARTOF_SECTION: short;
              }
              let TypeIndicators: _TypeIndicators$$static;
              interface _TypeIndicators {
              }
              interface TypeIndicators extends CombineTypes<[_TypeIndicators, java.lang.Object]> {}
              interface _WindowsNTSubsystem$$static extends ClassLike {
                readonly IMAGE_SUBSYSTEM_EFI_APPLICATION: short;
                readonly IMAGE_SUBSYSTEM_EFI_BOOT_SERVICE_DRIVER: short;
                readonly IMAGE_SUBSYSTEM_EFI_RUNTIME_DRIVER: short;
                readonly IMAGE_SUBSYSTEM_NATIVE: short;
                readonly IMAGE_SUBSYSTEM_POSIX_CUI: short;
                readonly IMAGE_SUBSYSTEM_UNKNOWN: short;
                readonly IMAGE_SUBSYSTEM_WINDOWS_CE_GUI: short;
                readonly IMAGE_SUBSYSTEM_WINDOWS_CUI: short;
                readonly IMAGE_SUBSYSTEM_WINDOWS_GUI: short;
              }
              let WindowsNTSubsystem: _WindowsNTSubsystem$$static;
              interface _WindowsNTSubsystem {
              }
              interface WindowsNTSubsystem extends CombineTypes<[_WindowsNTSubsystem, java.lang.Object]> {}
            }
          }
          module windbg {
            module aarch64 {
              interface _WindbgAARCH64Thread$$static extends ClassLike {
                _new(debugger: WindbgDebugger, addr: Address): WindbgAARCH64Thread;
                _new(debugger: WindbgDebugger, sysId: long): WindbgAARCH64Thread;
              }
              let WindbgAARCH64Thread: _WindbgAARCH64Thread$$static;
              interface _WindbgAARCH64Thread {
                canSetContext(): boolean;
                equals(obj: any): boolean;
                getContext(): ThreadContext;
                _getThreadID(): long;
                hashCode(): int;
                setContext(thrCtx: ThreadContext): void;
                toString(): string;
                _debugger: WindbgDebugger;
                _gotID: boolean;
                _id: long;
                _sysId: long;
              }
              interface WindbgAARCH64Thread extends CombineTypes<[_WindbgAARCH64Thread, sun.jvm.hotspot.debugger.ThreadProxy, java.lang.Object]> {}
              interface _WindbgAARCH64ThreadContext$$static extends ClassLike {
                new(debugger: WindbgDebugger): WindbgAARCH64ThreadContext;
              }
              let WindbgAARCH64ThreadContext: _WindbgAARCH64ThreadContext$$static;
              interface _WindbgAARCH64ThreadContext {
                getRegisterAsAddress(index: int): Address;
                setRegisterAsAddress(index: int, value: Address): void;
                _debugger: WindbgDebugger;
              }
              interface WindbgAARCH64ThreadContext extends CombineTypes<[_WindbgAARCH64ThreadContext, sun.jvm.hotspot.debugger.aarch64.AARCH64ThreadContext]> {}
              interface _WindbgAARCH64ThreadFactory$$static extends ClassLike {
                new(debugger: WindbgDebugger): WindbgAARCH64ThreadFactory;
              }
              let WindbgAARCH64ThreadFactory: _WindbgAARCH64ThreadFactory$$static;
              interface _WindbgAARCH64ThreadFactory {
                createThreadWrapper(threadIdentifierAddr: Address): ThreadProxy;
                createThreadWrapper(id: long): ThreadProxy;
                _debugger: WindbgDebugger;
              }
              interface WindbgAARCH64ThreadFactory extends CombineTypes<[_WindbgAARCH64ThreadFactory, sun.jvm.hotspot.debugger.windbg.WindbgThreadFactory, java.lang.Object]> {}
            }
            module amd64 {
              interface _WindbgAMD64Thread$$static extends ClassLike {
                _new(debugger: WindbgDebugger, addr: Address): WindbgAMD64Thread;
                _new(debugger: WindbgDebugger, sysId: long): WindbgAMD64Thread;
              }
              let WindbgAMD64Thread: _WindbgAMD64Thread$$static;
              interface _WindbgAMD64Thread {
                canSetContext(): boolean;
                equals(obj: any): boolean;
                getContext(): ThreadContext;
                _getThreadID(): long;
                hashCode(): int;
                setContext(thrCtx: ThreadContext): void;
                toString(): string;
                _debugger: WindbgDebugger;
                _gotID: boolean;
                _id: long;
                _sysId: long;
              }
              interface WindbgAMD64Thread extends CombineTypes<[_WindbgAMD64Thread, sun.jvm.hotspot.debugger.ThreadProxy, java.lang.Object]> {}
              interface _WindbgAMD64ThreadContext$$static extends ClassLike {
                new(debugger: WindbgDebugger): WindbgAMD64ThreadContext;
              }
              let WindbgAMD64ThreadContext: _WindbgAMD64ThreadContext$$static;
              interface _WindbgAMD64ThreadContext {
                getRegisterAsAddress(index: int): Address;
                setRegisterAsAddress(index: int, value: Address): void;
                _debugger: WindbgDebugger;
              }
              interface WindbgAMD64ThreadContext extends CombineTypes<[_WindbgAMD64ThreadContext, sun.jvm.hotspot.debugger.amd64.AMD64ThreadContext]> {}
              interface _WindbgAMD64ThreadFactory$$static extends ClassLike {
                new(debugger: WindbgDebugger): WindbgAMD64ThreadFactory;
              }
              let WindbgAMD64ThreadFactory: _WindbgAMD64ThreadFactory$$static;
              interface _WindbgAMD64ThreadFactory {
                createThreadWrapper(threadIdentifierAddr: Address): ThreadProxy;
                createThreadWrapper(id: long): ThreadProxy;
                _debugger: WindbgDebugger;
              }
              interface WindbgAMD64ThreadFactory extends CombineTypes<[_WindbgAMD64ThreadFactory, sun.jvm.hotspot.debugger.windbg.WindbgThreadFactory, java.lang.Object]> {}
            }
            module x86 {
              interface _WindbgX86Thread$$static extends ClassLike {
                _new(debugger: WindbgDebugger, addr: Address): WindbgX86Thread;
                _new(debugger: WindbgDebugger, sysId: long): WindbgX86Thread;
              }
              let WindbgX86Thread: _WindbgX86Thread$$static;
              interface _WindbgX86Thread {
                canSetContext(): boolean;
                equals(obj: any): boolean;
                getContext(): ThreadContext;
                _getThreadID(): long;
                hashCode(): int;
                setContext(thrCtx: ThreadContext): void;
                toString(): string;
                _debugger: WindbgDebugger;
                _gotID: boolean;
                _id: long;
                _sysId: long;
              }
              interface WindbgX86Thread extends CombineTypes<[_WindbgX86Thread, sun.jvm.hotspot.debugger.ThreadProxy, java.lang.Object]> {}
              interface _WindbgX86ThreadContext$$static extends ClassLike {
                new(debugger: WindbgDebugger): WindbgX86ThreadContext;
              }
              let WindbgX86ThreadContext: _WindbgX86ThreadContext$$static;
              interface _WindbgX86ThreadContext {
                getRegisterAsAddress(index: int): Address;
                setRegisterAsAddress(index: int, value: Address): void;
                _debugger: WindbgDebugger;
              }
              interface WindbgX86ThreadContext extends CombineTypes<[_WindbgX86ThreadContext, sun.jvm.hotspot.debugger.x86.X86ThreadContext]> {}
              interface _WindbgX86ThreadFactory$$static extends ClassLike {
                new(debugger: WindbgDebugger): WindbgX86ThreadFactory;
              }
              let WindbgX86ThreadFactory: _WindbgX86ThreadFactory$$static;
              interface _WindbgX86ThreadFactory {
                createThreadWrapper(threadIdentifierAddr: Address): ThreadProxy;
                createThreadWrapper(id: long): ThreadProxy;
                _debugger: WindbgDebugger;
              }
              interface WindbgX86ThreadFactory extends CombineTypes<[_WindbgX86ThreadFactory, sun.jvm.hotspot.debugger.windbg.WindbgThreadFactory, java.lang.Object]> {}
            }
            interface _AddressDataSource$$static extends ClassLike {
              new(addr: Address): AddressDataSource;
            }
            let AddressDataSource: _AddressDataSource$$static;
            interface _AddressDataSource {
              close(): void;
              getFilePointer(): long;
              read(b: byte[]): int;
              readByte(): byte;
              readInt(): int;
              readLong(): long;
              readShort(): short;
              seek(pos: long): void;
              _addr: Address;
              _offset: long;
            }
            interface AddressDataSource extends CombineTypes<[_AddressDataSource, sun.jvm.hotspot.debugger.DataSource, java.lang.Object]> {}
            interface _DLL$$static extends ClassLike {
              new(dbg: WindbgDebugger, filename: string, size: long, a3: Address): DLL;
              new(base: Address): DLL;
            }
            let DLL: _DLL$$static;
            interface _DLL {
              close(): void;
              closestSymbolToPC(pcAsAddr: Address): debugger.cdbg.ClosestSymbol;
              debugInfoForPC(pc: Address): debugger.cdbg.BlockSym;
              getBase(): Address;
              getDebugInfoDataBase(): debugger.cdbg.CDebugInfoDataBase;
              _getExportDirectoryTable(): debugger.win32.coff.ExportDirectoryTable;
              _getFile(): debugger.win32.coff.COFFFile;
              getName(): string;
              getSize(): long;
              isDLL(): boolean;
              lineNumberForPC(pc: Address): debugger.cdbg.LineNumberInfo;
              lookupSymbol(symbol: string): Address;
              _lookupSymbol(symbol: string, exports: debugger.win32.coff.ExportDirectoryTable, loIdx: int, hiIdx: int): Address;
              _addr: Address;
              _db: debugger.cdbg.CDebugInfoDataBase;
              _dbg: WindbgDebugger;
              _file: hotspot.utilities.memo.MemoizedObject;
              _fullPathName: string;
              _size: long;
            }
            interface DLL extends CombineTypes<[_DLL, sun.jvm.hotspot.debugger.cdbg.LoadObject, java.lang.Object]> {}
            interface _WindbgAddress$$static extends ClassLike {
              _check(arg: boolean, failMessage: string): void;
              main(args: string[]): void;
              _new(debugger: WindbgDebugger, addr: long): WindbgAddress;
            }
            let WindbgAddress: _WindbgAddress$$static;
            interface _WindbgAddress {
              addOffsetTo(offset: long): Address;
              addOffsetToAsOopHandle(offset: long): OopHandle;
              andWithMask(mask: long): Address;
              asLongValue(): long;
              equals(arg: any): boolean;
              getAddressAt(offset: long): Address;
              getCIntegerAt(offset: long, a1: long, numBytes: boolean): long;
              getCompKlassAddressAt(offset: long): Address;
              getCompOopAddressAt(offset: long): Address;
              getCompOopHandleAt(offset: long): OopHandle;
              getJBooleanAt(offset: long): boolean;
              getJByteAt(offset: long): byte;
              getJCharAt(offset: long): char;
              getJDoubleAt(offset: long): double;
              getJFloatAt(offset: long): float;
              getJIntAt(offset: long): int;
              getJLongAt(offset: long): long;
              getJShortAt(offset: long): short;
              getOopHandleAt(offset: long): OopHandle;
              greaterThan(a: Address): boolean;
              greaterThanOrEqual(a: Address): boolean;
              hashCode(): int;
              lessThan(a: Address): boolean;
              lessThanOrEqual(a: Address): boolean;
              minus(arg: Address): long;
              orWithMask(mask: long): Address;
              setAddressAt(offset: long, a1: Address): void;
              setCIntegerAt(offset: long, a1: long, numBytes: long): void;
              setJBooleanAt(offset: long, a1: boolean): void;
              setJByteAt(offset: long, a1: byte): void;
              setJCharAt(offset: long, a1: char): void;
              setJDoubleAt(offset: long, a1: double): void;
              setJFloatAt(offset: long, a1: float): void;
              setJIntAt(offset: long, a1: int): void;
              setJLongAt(offset: long, a1: long): void;
              setJShortAt(offset: long, a1: short): void;
              setOopHandleAt(offset: long, a1: OopHandle): void;
              toString(): string;
              xorWithMask(mask: long): Address;
              _addr: long;
              _debugger: WindbgDebugger;
            }
            interface WindbgAddress extends CombineTypes<[_WindbgAddress, java.lang.Object, sun.jvm.hotspot.debugger.Address]> {}
            interface _WindbgCDebugInfoBuilder$$static extends ClassLike {
              _getDebugVC50(file: debugger.win32.coff.COFFFile): debugger.win32.coff.DebugVC50;
              _POINTER_SIZE: int;
              _new(dbg: WindbgDebugger): WindbgCDebugInfoBuilder;
            }
            let WindbgCDebugInfoBuilder: _WindbgCDebugInfoBuilder$$static;
            interface _WindbgCDebugInfoBuilder {
              _addBlock(block: debugger.cdbg.BlockSym): void;
              _addGlobalSym(sym: debugger.cdbg.GlobalSym): void;
              _addLocalToCurBlock(local: debugger.cdbg.LocalSym): void;
              _buildDataBase(dllName: string, base: Address): debugger.cdbg.CDebugInfoDataBase;
              _findSubsection(ssType: short): debugger.win32.coff.DebugVC50Subsection;
              _getGlobalSymbols(): debugger.win32.coff.DebugVC50SSGlobalSym;
              _getGlobalTypes(): debugger.win32.coff.DebugVC50SSGlobalTypes;
              _getSegMap(): debugger.win32.coff.DebugVC50SSSegMap;
              _getTypeByIndex(intIndex: int): debugger.cdbg.basic.BasicType;
              _memberAttributeToAccessControl(memberAttribute: short): int;
              _newAddress(offset: int, segment: short): Address;
              _newLazyBlockSym(offset: int): debugger.cdbg.BlockSym;
              _putType(t: debugger.cdbg.Type): void;
              _skipEnd(): void;
              _skipTypeRecord(): void;
              _base: Address;
              _blockStack: java.util.Stack<debugger.cdbg.BlockSym>;
              _db: debugger.cdbg.basic.BasicCDebugInfoDataBase;
              _dbg: WindbgDebugger;
              _endsToSkip: int;
              _file: debugger.win32.coff.COFFFile;
              _iter: debugger.win32.coff.DebugVC50TypeIterator;
              _primIndexToTypeMap: java.util.Map<int,debugger.cdbg.basic.BasicType>;
              _segMap: debugger.win32.coff.DebugVC50SSSegMap;
              _symIter: debugger.win32.coff.DebugVC50SymbolIterator;
              _unnamedEnum: debugger.cdbg.basic.BasicEnumType;
              _vc50: debugger.win32.coff.DebugVC50;
            }
            interface WindbgCDebugInfoBuilder extends CombineTypes<[_WindbgCDebugInfoBuilder, sun.jvm.hotspot.debugger.win32.coff.DebugVC50SymbolTypes, sun.jvm.hotspot.debugger.win32.coff.DebugVC50MemberAttributes, sun.jvm.hotspot.debugger.win32.coff.DebugVC50TypeEnums, java.lang.Object, sun.jvm.hotspot.debugger.win32.coff.DebugVC50SubsectionTypes, sun.jvm.hotspot.debugger.cdbg.AccessControl, sun.jvm.hotspot.debugger.cdbg.CVAttributes, sun.jvm.hotspot.debugger.win32.coff.DebugVC50TypeLeafIndices]> {}
            interface _WindbgCDebugger$$static extends ClassLike {
              _new(dbg: WindbgDebugger): WindbgCDebugger;
            }
            let WindbgCDebugger: _WindbgCDebugger$$static;
            interface _WindbgCDebugger {
              canDemangle(): boolean;
              demangle(sym: string): string;
              getLoadObjectList(): java.util.List<debugger.cdbg.LoadObject>;
              getNameOfFile(fileName: string): string;
              getProcessControl(): debugger.cdbg.ProcessControl;
              getThreadList(): java.util.List<ThreadProxy>;
              loadObjectContainingPC(pc: Address): debugger.cdbg.LoadObject;
              topFrameForThread(thread: ThreadProxy): debugger.cdbg.CFrame;
              _dbg: WindbgDebugger;
            }
            interface WindbgCDebugger extends CombineTypes<[_WindbgCDebugger, sun.jvm.hotspot.debugger.cdbg.CDebugger, java.lang.Object]> {}
            interface _WindbgDebugger$$static extends ClassLike {
            }
            let WindbgDebugger: _WindbgDebugger$$static;
            interface _WindbgDebugger {
              addressValueToString(a0: long): string;
              getAddressSize(): int;
              getLoadObjectList(): java.util.List<debugger.cdbg.LoadObject>;
              getThreadIdFromSysId(a0: long): long;
              getThreadIntegerRegisterSet(a0: long): long[];
              getThreadList(): java.util.List<ThreadProxy>;
              readAddress(a0: long): WindbgAddress;
              readCInteger(a0: long, a1: long, a2: boolean): long;
              readCompKlassAddress(a0: long): WindbgAddress;
              readCompOopAddress(a0: long): WindbgAddress;
              readCompOopHandle(a0: long): WindbgOopHandle;
              readJBoolean(a0: long): boolean;
              readJByte(a0: long): byte;
              readJChar(a0: long): char;
              readJDouble(a0: long): double;
              readJFloat(a0: long): float;
              readJInt(a0: long): int;
              readJLong(a0: long): long;
              readJShort(a0: long): short;
              readOopHandle(a0: long): WindbgOopHandle;
            }
            interface WindbgDebugger extends CombineTypes<[_WindbgDebugger, java.lang.Object, sun.jvm.hotspot.debugger.JVMDebugger]> {}
            interface _WindbgDebuggerLocal$$static extends ClassLike {
              _initIDs(): void;
              _imagePath: string;
              _symbolPath: string;
              _useNativeLookup: boolean;
              new(machDesc: MachineDescription, useCache: boolean): WindbgDebuggerLocal;
            }
            let WindbgDebuggerLocal: _WindbgDebuggerLocal$$static;
            interface _WindbgDebuggerLocal {
              _addLoadObject(file: string, size: long, a2: long): void;
              _addThread(sysId: long): void;
              addressValueToString(address: long): string;
              attach(processID: int): void;
              attach(executableName: string, coreFileName: string): void;
              _attach0(a0: string, a1: string): void;
              _attach0(a0: int): void;
              _attachInit(): void;
              _checkAttached(): void;
              consoleExecuteCommand(cmd: string): string;
              _consoleExecuteCommand0(a0: string): string;
              _createClosestSymbol(symbol: string, diff: long): debugger.cdbg.ClosestSymbol;
              detach(): boolean;
              _detach0(): void;
              _findDLLByName(fullPathName: string): DLL;
              _findFullPath(file: string): string;
              getAddressSize(): int;
              getAddressValue(addr: Address): long;
              getCDebugger(): debugger.cdbg.CDebugger;
              getCPU(): string;
              getConsolePrompt(): string;
              getLoadObjectList(): java.util.List<debugger.cdbg.LoadObject>;
              getMachineDescription(): MachineDescription;
              getOS(): string;
              getProcessList(): java.util.List<ProcessInfo>;
              getThreadForIdentifierAddress(addr: Address): ThreadProxy;
              getThreadForThreadId(handle: long): ThreadProxy;
              getThreadIdFromSysId(sysId: long): long;
              _getThreadIdFromSysId0(a0: long): long;
              getThreadIntegerRegisterSet(threadId: long): long[];
              getThreadList(): java.util.List<ThreadProxy>;
              hasConsole(): boolean;
              hasProcessList(): boolean;
              lookup(objectName: string, symbol: string): Address;
              lookup(address: long): debugger.cdbg.ClosestSymbol;
              _lookupByAddress0(a0: long): debugger.cdbg.ClosestSymbol;
              _lookupByName(objectName: string, symbol: string): long;
              _lookupByName0(a0: string, a1: string): long;
              lookupOop(objectName: string, symbol: string): OopHandle;
              newAddress(value: long): Address;
              parseAddress(addressString: string): Address;
              readAddress(address: long): WindbgAddress;
              readBytesFromProcess(address: long, a1: long): ReadResult;
              _readBytesFromProcess0(a0: long, a1: long): byte[];
              readCompKlassAddress(address: long): WindbgAddress;
              readCompOopAddress(address: long): WindbgAddress;
              readCompOopHandle(address: long): WindbgOopHandle;
              readOopHandle(address: long): WindbgOopHandle;
              _requireAttach(): void;
              _resetNativePointers(): void;
              _setThreadIntegerRegisterSet(threadId: long, a1: long[]): void;
              _attached: boolean;
              _cache: PageCache;
              _cdbg: debugger.cdbg.CDebugger;
              _isCore: boolean;
              _loadObjects: java.util.List<debugger.cdbg.LoadObject>;
              _nameToDllMap: java.util.Map<string,DLL>;
              _ptrIDebugAdvanced: long;
              _ptrIDebugClient: long;
              _ptrIDebugControl: long;
              _ptrIDebugDataSpaces: long;
              _ptrIDebugOutputCallbacks: long;
              _ptrIDebugSymbols: long;
              _ptrIDebugSystemObjects: long;
              _threadFactory: WindbgThreadFactory;
              _threadIntegerRegisterSet: java.util.Map<long,long[]>;
              _threadList: java.util.List<ThreadProxy>;
            }
            interface WindbgDebuggerLocal extends CombineTypes<[_WindbgDebuggerLocal, sun.jvm.hotspot.debugger.DebuggerBase, sun.jvm.hotspot.debugger.windbg.WindbgDebugger]> {}
            interface _WindbgOopHandle$$static extends ClassLike {
              _new(debugger: WindbgDebugger, addr: long): WindbgOopHandle;
            }
            let WindbgOopHandle: _WindbgOopHandle$$static;
            interface _WindbgOopHandle {
              addOffsetTo(offset: long): Address;
              andWithMask(mask: long): Address;
              equals(arg: any): boolean;
              orWithMask(mask: long): Address;
              xorWithMask(mask: long): Address;
            }
            interface WindbgOopHandle extends CombineTypes<[_WindbgOopHandle, sun.jvm.hotspot.debugger.OopHandle, sun.jvm.hotspot.debugger.windbg.WindbgAddress]> {}
            interface _WindbgThreadFactory$$static extends ClassLike {
            }
            let WindbgThreadFactory: _WindbgThreadFactory$$static;
            interface _WindbgThreadFactory {
              createThreadWrapper(a0: Address): ThreadProxy;
              createThreadWrapper(a0: long): ThreadProxy;
            }
            interface WindbgThreadFactory extends CombineTypes<[_WindbgThreadFactory, java.lang.Object]> {}
          }
          module windows {
            module amd64 {
              interface _WindowsAMD64CFrame$$static extends ClassLike {
                _ADDRESS_SIZE: int;
                new(dbg: debugger.windbg.WindbgDebugger, rbp: Address, pc: Address): WindowsAMD64CFrame;
              }
              let WindowsAMD64CFrame: _WindowsAMD64CFrame$$static;
              interface _WindowsAMD64CFrame {
                localVariableBase(): Address;
                pc(): Address;
                sender(thread: ThreadProxy): debugger.cdbg.CFrame;
                _dbg: debugger.windbg.WindbgDebugger;
                _pc: Address;
                _rbp: Address;
              }
              interface WindowsAMD64CFrame extends CombineTypes<[_WindowsAMD64CFrame, sun.jvm.hotspot.debugger.cdbg.basic.BasicCFrame]> {}
            }
            module x86 {
              interface _WindowsX86CFrame$$static extends ClassLike {
                _ADDRESS_SIZE: int;
                new(dbg: debugger.windbg.WindbgDebugger, ebp: Address, pc: Address): WindowsX86CFrame;
              }
              let WindowsX86CFrame: _WindowsX86CFrame$$static;
              interface _WindowsX86CFrame {
                localVariableBase(): Address;
                pc(): Address;
                sender(thread: ThreadProxy): debugger.cdbg.CFrame;
                _dbg: debugger.windbg.WindbgDebugger;
                _ebp: Address;
                _pc: Address;
              }
              interface WindowsX86CFrame extends CombineTypes<[_WindowsX86CFrame, sun.jvm.hotspot.debugger.cdbg.basic.BasicCFrame]> {}
            }
          }
          module x86 {
            interface _X86ThreadContext$$static extends ClassLike {
              readonly CS: int;
              readonly DR0: int;
              readonly DR1: int;
              readonly DR2: int;
              readonly DR3: int;
              readonly DR6: int;
              readonly DR7: int;
              readonly DS: int;
              readonly EAX: int;
              readonly EBP: int;
              readonly EBX: int;
              readonly ECX: int;
              readonly EDI: int;
              readonly EDX: int;
              readonly EFL: int;
              readonly EIP: int;
              readonly ERR: int;
              readonly ES: int;
              readonly ESI: int;
              readonly ESP: int;
              readonly FP: int;
              readonly FS: int;
              readonly GS: int;
              readonly NPRGREG: int;
              readonly PC: int;
              readonly PS: int;
              readonly R0: int;
              readonly R1: int;
              readonly SP: int;
              readonly SS: int;
              readonly TRAPNO: int;
              readonly UESP: int;
              _regNames: string[];
              new(): X86ThreadContext;
            }
            let X86ThreadContext: _X86ThreadContext$$static;
            interface _X86ThreadContext {
              getNumRegisters(): int;
              getRegister(index: int): long;
              getRegisterAsAddress(a0: int): Address;
              getRegisterName(index: int): string;
              getTopFrame(dbg: Debugger): debugger.cdbg.CFrame;
              setRegister(index: int, value: long): void;
              setRegisterAsAddress(a0: int, a1: Address): void;
              _data: long[];
            }
            interface X86ThreadContext extends CombineTypes<[_X86ThreadContext, sun.jvm.hotspot.debugger.ThreadContext, java.lang.Object]> {}
          }
          interface _Address$$static extends ClassLike {
          }
          let Address: _Address$$static;
          interface _Address {
            addOffsetTo(a0: long): Address;
            addOffsetToAsOopHandle(a0: long): OopHandle;
            andWithMask(a0: long): Address;
            asLongValue(): long;
            equals(a0: any): boolean;
            getAddressAt(a0: long): Address;
            getCIntegerAt(a0: long, a1: long, a2: boolean): long;
            getCompKlassAddressAt(a0: long): Address;
            getCompOopAddressAt(a0: long): Address;
            getCompOopHandleAt(a0: long): OopHandle;
            getJBooleanAt(a0: long): boolean;
            getJByteAt(a0: long): byte;
            getJCharAt(a0: long): char;
            getJDoubleAt(a0: long): double;
            getJFloatAt(a0: long): float;
            getJIntAt(a0: long): int;
            getJLongAt(a0: long): long;
            getJShortAt(a0: long): short;
            getOopHandleAt(a0: long): OopHandle;
            greaterThan(a0: Address): boolean;
            greaterThanOrEqual(a0: Address): boolean;
            hashCode(): int;
            lessThan(a0: Address): boolean;
            lessThanOrEqual(a0: Address): boolean;
            minus(a0: Address): long;
            orWithMask(a0: long): Address;
            setAddressAt(a0: long, a1: Address): void;
            setCIntegerAt(a0: long, a1: long, a2: long): void;
            setJBooleanAt(a0: long, a1: boolean): void;
            setJByteAt(a0: long, a1: byte): void;
            setJCharAt(a0: long, a1: char): void;
            setJDoubleAt(a0: long, a1: double): void;
            setJFloatAt(a0: long, a1: float): void;
            setJIntAt(a0: long, a1: int): void;
            setJLongAt(a0: long, a1: long): void;
            setJShortAt(a0: long, a1: short): void;
            setOopHandleAt(a0: long, a1: OopHandle): void;
            xorWithMask(a0: long): Address;
          }
          interface Address extends CombineTypes<[_Address, java.lang.Object]> {}
          interface _AddressException$$static extends ClassLike {
            new(addr: long): AddressException;
            new(message: string, addr: long): AddressException;
          }
          let AddressException: _AddressException$$static;
          interface _AddressException {
            getAddress(): long;
            getMessage(): string;
            _addr: long;
          }
          interface AddressException extends CombineTypes<[_AddressException, java.lang.RuntimeException]> {}
          interface _DataSource$$static extends ClassLike {
          }
          let DataSource: _DataSource$$static;
          interface _DataSource {
            close(): void;
            getFilePointer(): long;
            read(a0: byte[]): int;
            readByte(): byte;
            readInt(): int;
            readLong(): long;
            readShort(): short;
            seek(a0: long): void;
          }
          interface DataSource extends CombineTypes<[_DataSource, java.lang.Object]> {}
          interface _Debugger$$static extends ClassLike {
          }
          let Debugger: _Debugger$$static;
          interface _Debugger {
            attach(a0: int): void;
            attach(a0: string, a1: string): void;
            consoleExecuteCommand(a0: string): string;
            detach(): boolean;
            findSymbol(a0: string): string;
            getAddressValue(a0: Address): long;
            getCDebugger(): debugger.cdbg.CDebugger;
            getCPU(): string;
            getConsolePrompt(): string;
            getHeapOopSize(): long;
            getJBooleanSize(): long;
            getJByteSize(): long;
            getJCharSize(): long;
            getJDoubleSize(): long;
            getJFloatSize(): long;
            getJIntSize(): long;
            getJLongSize(): long;
            getJShortSize(): long;
            getKlassPtrSize(): long;
            getMachineDescription(): MachineDescription;
            getNarrowKlassBase(): long;
            getNarrowKlassShift(): int;
            getNarrowOopBase(): long;
            getNarrowOopShift(): int;
            getOS(): string;
            getProcessList(): java.util.List<ProcessInfo>;
            hasConsole(): boolean;
            hasProcessList(): boolean;
            parseAddress(a0: string): Address;
            readBytesFromProcess(a0: long, a1: long): ReadResult;
          }
          interface Debugger extends CombineTypes<[_Debugger, sun.jvm.hotspot.debugger.ThreadAccess, java.lang.Object, sun.jvm.hotspot.debugger.SymbolLookup]> {}
          interface _DebuggerBase$$static extends ClassLike {
            _new(): DebuggerBase;
          }
          let DebuggerBase: _DebuggerBase$$static;
          interface _DebuggerBase {
            _canUsePageCacheFor64bitRead(address: long): boolean;
            _checkConfigured(): void;
            _checkJavaConfigured(): void;
            _clearCache(): void;
            configureJavaPrimitiveTypeSizes(jbooleanSize: long, a1: long, jbyteSize: long, a3: long, jcharSize: long, a5: long, jdoubleSize: long, a7: long): void;
            _disableCache(): void;
            _enableCache(): void;
            findSymbol(symbol: string): string;
            getHeapOopSize(): long;
            getJBooleanSize(): long;
            getJByteSize(): long;
            getJCharSize(): long;
            getJDoubleSize(): long;
            getJFloatSize(): long;
            getJIntSize(): long;
            getJLongSize(): long;
            getJShortSize(): long;
            getKlassPtrSize(): long;
            getNarrowKlassBase(): long;
            getNarrowKlassShift(): int;
            getNarrowOopBase(): long;
            getNarrowOopShift(): int;
            _initCache(pageSize: long, a1: long): void;
            _invalidatePageCache(startAddress: long, a1: long): void;
            _parseCacheNumPagesProperty(defaultNum: int): int;
            putHeapConst(heapOopSize: long, a1: long, klassPtrSize: long, a3: int, narrowOopBase: long, a5: int): void;
            _readAddressValue(address: long): long;
            _readBytes(address: long, a1: long): byte[];
            readCInteger(address: long, a1: long, numBytes: boolean): long;
            _readCompKlassAddressValue(address: long): long;
            _readCompOopAddressValue(address: long): long;
            readJBoolean(address: long): boolean;
            readJByte(address: long): byte;
            readJChar(address: long): char;
            readJDouble(address: long): double;
            readJFloat(address: long): float;
            readJInt(address: long): int;
            readJLong(address: long): long;
            readJShort(address: long): short;
            _setBigEndian(bigEndian: boolean): void;
            _bigEndian: boolean;
            _cache: PageCache;
            _heapOopSize: long;
            _javaPrimitiveTypesConfigured: boolean;
            _jbooleanSize: long;
            _jbyteSize: long;
            _jcharSize: long;
            _jdoubleSize: long;
            _jfloatSize: long;
            _jintSize: long;
            _jlongSize: long;
            _jshortSize: long;
            _klassPtrSize: long;
            _machDesc: MachineDescription;
            _narrowKlassBase: long;
            _narrowKlassShift: int;
            _narrowOopBase: long;
            _narrowOopShift: int;
            _oopSize: long;
            _pageSize: long;
            _useFastAccessors: boolean;
            _utils: DebuggerUtilities;
          }
          interface DebuggerBase extends CombineTypes<[_DebuggerBase, java.lang.Object, sun.jvm.hotspot.debugger.Debugger]> {}
          interface _DebuggerBase$Fetcher$$static extends ClassLike {
            _new(this$0: DebuggerBase): DebuggerBase$Fetcher;
          }
          let DebuggerBase$Fetcher: _DebuggerBase$Fetcher$$static;
          interface _DebuggerBase$Fetcher {
            fetchPage(pageBaseAddress: long, a1: long): Page;
            _this$0: DebuggerBase;
          }
          interface DebuggerBase$Fetcher extends CombineTypes<[_DebuggerBase$Fetcher, sun.jvm.hotspot.debugger.PageFetcher, java.lang.Object]> {}
          interface _DebuggerException$$static extends ClassLike {
            new(): DebuggerException;
            new(message: string): DebuggerException;
            new(message: string, cause: java.lang.Throwable): DebuggerException;
            new(cause: java.lang.Throwable): DebuggerException;
          }
          let DebuggerException: _DebuggerException$$static;
          interface _DebuggerException {
          }
          interface DebuggerException extends CombineTypes<[_DebuggerException, java.lang.RuntimeException]> {}
          interface _DebuggerUtilities$$static extends ClassLike {
            new(addressSize: long, a1: boolean, isBigEndian: boolean): DebuggerUtilities;
          }
          let DebuggerUtilities: _DebuggerUtilities$$static;
          interface _DebuggerUtilities {
            addressValueToString(address: long): string;
            _byteSwap(data: byte[]): void;
            cIntegerToData(longNumBytes: long, a1: long): byte[];
            charToNibble(ascii: char): int;
            checkAlignment(address: long, a1: long): void;
            _checkDataContents(data: byte[], len: long): void;
            dataToAddressValue(data: byte[]): long;
            dataToCInteger(data: byte[], isUnsigned: boolean): long;
            dataToJBoolean(data: byte[], jbooleanSize: long): boolean;
            dataToJByte(data: byte[], jbyteSize: long): byte;
            dataToJChar(data: byte[], jcharSize: long): char;
            dataToJDouble(data: byte[], jdoubleSize: long): double;
            dataToJFloat(data: byte[], jfloatSize: long): float;
            dataToJInt(data: byte[], jintSize: long): int;
            dataToJLong(data: byte[], jlongSize: long): long;
            dataToJShort(data: byte[], jshortSize: long): short;
            jbooleanToData(value: boolean): byte[];
            jbyteToData(value: byte): byte[];
            jcharToData(value: char): byte[];
            jdoubleToData(value: double): byte[];
            jfloatToData(value: float): byte[];
            jintToData(value: int): byte[];
            jlongToData(value: long): byte[];
            jshortToData(value: short): byte[];
            _rawDataToJLong(data: byte[]): long;
            scanAddress(addrStr: string): long;
            _addressSize: long;
            _isBigEndian: boolean;
            _supports32bitAlignmentOf64bitTypes: boolean;
          }
          interface DebuggerUtilities extends CombineTypes<[_DebuggerUtilities, java.lang.Object]> {}
          interface _InputLexer$$static extends ClassLike {
            new(_in: java.io.BufferedInputStream): InputLexer;
          }
          let InputLexer: _InputLexer$$static;
          interface _InputLexer {
            close(): void;
            _error(): void;
            _isHexDigit(c: char): boolean;
            parseAddress(): long;
            parseBoolean(): boolean;
            parseInt(): int;
            parseLong(): long;
            _pushBack(b: byte): void;
            readByte(): byte;
            _readByteInternal(): byte;
            readByteString(len: int): string;
            readBytes(buf: byte[], off: int, len: int): void;
            readChar(): char;
            readCharString(len: int): string;
            readUnsignedInt(): long;
            skipByte(): void;
            _skipWhitespace(): void;
            _backBuf: byte;
            _in: java.io.BufferedInputStream;
            _pushedBack: boolean;
          }
          interface InputLexer extends CombineTypes<[_InputLexer, java.lang.Object]> {}
          interface _JVMDebugger$$static extends ClassLike {
          }
          let JVMDebugger: _JVMDebugger$$static;
          interface _JVMDebugger {
            configureJavaPrimitiveTypeSizes(a0: long, a1: long, a2: long, a3: long, a4: long, a5: long, a6: long, a7: long): void;
            newAddress(a0: long): Address;
            putHeapConst(a0: long, a1: long, a2: long, a3: int, a4: long, a5: int): void;
          }
          interface JVMDebugger extends CombineTypes<[_JVMDebugger, java.lang.Object, sun.jvm.hotspot.debugger.Debugger]> {}
          interface _LongHashMap$$static extends ClassLike {
            _eq(o1: any, o2: any): boolean;
            new(initialCapacity: int, loadFactor: float): LongHashMap;
            new(initialCapacity: int): LongHashMap;
            new(): LongHashMap;
          }
          let LongHashMap: _LongHashMap$$static;
          interface _LongHashMap {
            _capacity(): int;
            clear(): void;
            containsKey(key: long): boolean;
            containsValue(value: any): boolean;
            get(key: long): any;
            _getEntry(key: long): LongHashMap$Entry;
            isEmpty(): boolean;
            _loadFactor(): float;
            _newEntry(hash: int, key: long, a2: any, value: LongHashMap$Entry): LongHashMap$Entry;
            put(key: long, a1: any): any;
            _rehash(): void;
            remove(key: long): any;
            _removeEntry(doomed: LongHashMap$Entry): void;
            _removeEntryForKey(key: long): LongHashMap$Entry;
            size(): int;
            _loadFactor: float;
            _modCount: int;
            _size: int;
            _table: LongHashMap$Entry[];
            _threshold: int;
          }
          interface LongHashMap extends CombineTypes<[_LongHashMap, java.lang.Object]> {}
          interface _LongHashMap$Entry$$static extends ClassLike {
            _new(hash: int, key: long, a2: any, value: LongHashMap$Entry): LongHashMap$Entry;
          }
          let LongHashMap$Entry: _LongHashMap$Entry$$static;
          interface _LongHashMap$Entry {
            equals(o: any): boolean;
            _getKey(): long;
            _getValue(): any;
            hashCode(): int;
            _setValue(value: any): any;
            _hash: int;
            _key: long;
            _next: LongHashMap$Entry;
            _value: any;
          }
          interface LongHashMap$Entry extends CombineTypes<[_LongHashMap$Entry, java.lang.Object]> {}
          interface _MachineDescription$$static extends ClassLike {
          }
          let MachineDescription: _MachineDescription$$static;
          interface _MachineDescription {
            cIntegerTypeMaxValue(a0: long, a1: boolean): long;
            cIntegerTypeMinValue(a0: long, a1: boolean): long;
            getAddressSize(): long;
            isBigEndian(): boolean;
            isLP64(): boolean;
            supports32bitAlignmentOf64bitTypes(): boolean;
          }
          interface MachineDescription extends CombineTypes<[_MachineDescription, java.lang.Object, java.io.Serializable]> {}
          interface _MachineDescriptionAArch64$$static extends ClassLike {
            new(): MachineDescriptionAArch64;
          }
          let MachineDescriptionAArch64: _MachineDescriptionAArch64$$static;
          interface _MachineDescriptionAArch64 {
            getAddressSize(): long;
            isBigEndian(): boolean;
            isLP64(): boolean;
          }
          interface MachineDescriptionAArch64 extends CombineTypes<[_MachineDescriptionAArch64, sun.jvm.hotspot.debugger.MachineDescriptionTwosComplement, sun.jvm.hotspot.debugger.MachineDescription]> {}
          interface _MachineDescriptionAMD64$$static extends ClassLike {
            new(): MachineDescriptionAMD64;
          }
          let MachineDescriptionAMD64: _MachineDescriptionAMD64$$static;
          interface _MachineDescriptionAMD64 {
            getAddressSize(): long;
            isBigEndian(): boolean;
            isLP64(): boolean;
          }
          interface MachineDescriptionAMD64 extends CombineTypes<[_MachineDescriptionAMD64, sun.jvm.hotspot.debugger.MachineDescriptionTwosComplement, sun.jvm.hotspot.debugger.MachineDescription]> {}
          interface _MachineDescriptionIntelX86$$static extends ClassLike {
            new(): MachineDescriptionIntelX86;
          }
          let MachineDescriptionIntelX86: _MachineDescriptionIntelX86$$static;
          interface _MachineDescriptionIntelX86 {
            getAddressSize(): long;
            isBigEndian(): boolean;
            supports32bitAlignmentOf64bitTypes(): boolean;
          }
          interface MachineDescriptionIntelX86 extends CombineTypes<[_MachineDescriptionIntelX86, sun.jvm.hotspot.debugger.MachineDescriptionTwosComplement, sun.jvm.hotspot.debugger.MachineDescription]> {}
          interface _MachineDescriptionPPC64$$static extends ClassLike {
            new(): MachineDescriptionPPC64;
          }
          let MachineDescriptionPPC64: _MachineDescriptionPPC64$$static;
          interface _MachineDescriptionPPC64 {
            getAddressSize(): long;
            isBigEndian(): boolean;
            isLP64(): boolean;
          }
          interface MachineDescriptionPPC64 extends CombineTypes<[_MachineDescriptionPPC64, sun.jvm.hotspot.debugger.MachineDescriptionTwosComplement, sun.jvm.hotspot.debugger.MachineDescription]> {}
          interface _MachineDescriptionRISCV64$$static extends ClassLike {
            new(): MachineDescriptionRISCV64;
          }
          let MachineDescriptionRISCV64: _MachineDescriptionRISCV64$$static;
          interface _MachineDescriptionRISCV64 {
            getAddressSize(): long;
            isBigEndian(): boolean;
            isLP64(): boolean;
          }
          interface MachineDescriptionRISCV64 extends CombineTypes<[_MachineDescriptionRISCV64, sun.jvm.hotspot.debugger.MachineDescriptionTwosComplement, sun.jvm.hotspot.debugger.MachineDescription]> {}
          interface _MachineDescriptionTwosComplement$$static extends ClassLike {
            _signedMaxValues: long[];
            _signedMinValues: long[];
            _unsignedMaxValues: long[];
            new(): MachineDescriptionTwosComplement;
          }
          let MachineDescriptionTwosComplement: _MachineDescriptionTwosComplement$$static;
          interface _MachineDescriptionTwosComplement {
            cIntegerTypeMaxValue(sizeInBytes: long, a1: boolean): long;
            cIntegerTypeMinValue(sizeInBytes: long, a1: boolean): long;
            isLP64(): boolean;
            _tableLookup(sizeInBytes: long, a1: long[]): long;
          }
          interface MachineDescriptionTwosComplement extends CombineTypes<[_MachineDescriptionTwosComplement, java.lang.Object]> {}
          interface _MappedByteBufferDataSource$$static extends ClassLike {
            new(buf: java.nio.MappedByteBuffer): MappedByteBufferDataSource;
          }
          let MappedByteBufferDataSource: _MappedByteBufferDataSource$$static;
          interface _MappedByteBufferDataSource {
            close(): void;
            getFilePointer(): long;
            read(b: byte[]): int;
            readByte(): byte;
            readInt(): int;
            readLong(): long;
            readShort(): short;
            seek(pos: long): void;
            _buf: java.nio.MappedByteBuffer;
          }
          interface MappedByteBufferDataSource extends CombineTypes<[_MappedByteBufferDataSource, sun.jvm.hotspot.debugger.DataSource, java.lang.Object]> {}
          interface _NoSuchSymbolException$$static extends ClassLike {
            new(symbol: string): NoSuchSymbolException;
            new(symbol: string, cause: java.lang.Throwable): NoSuchSymbolException;
            new(symbol: string, detail: string): NoSuchSymbolException;
            new(symbol: string, detail: string, cause: java.lang.Throwable): NoSuchSymbolException;
          }
          let NoSuchSymbolException: _NoSuchSymbolException$$static;
          interface _NoSuchSymbolException {
            getSymbol(): string;
            _symbol: string;
          }
          interface NoSuchSymbolException extends CombineTypes<[_NoSuchSymbolException, java.lang.RuntimeException]> {}
          interface _NotInHeapException$$static extends ClassLike {
            new(addr: long): NotInHeapException;
            new(detail: string, addr: long): NotInHeapException;
          }
          let NotInHeapException: _NotInHeapException$$static;
          interface _NotInHeapException {
          }
          interface NotInHeapException extends CombineTypes<[_NotInHeapException, sun.jvm.hotspot.debugger.AddressException]> {}
          interface _OopHandle$$static extends ClassLike {
          }
          let OopHandle: _OopHandle$$static;
          interface _OopHandle {
          }
          interface OopHandle extends CombineTypes<[_OopHandle, java.lang.Object, sun.jvm.hotspot.debugger.Address]> {}
          interface _Page$$static extends ClassLike {
            new(baseAddress: long, a1: byte[]): Page;
            new(baseAddress: long, a1: long): Page;
          }
          let Page: _Page$$static;
          interface _Page {
            getBaseAddress(): long;
            getBoolean(address: long): boolean;
            getByte(address: long): byte;
            getChar(address: long, a1: boolean): char;
            getData(startAddress: long, a1: long, numBytes: int[], a3: long): void;
            getDataAsBytes(startAddress: long, a1: long, numBytes: byte[], a3: long): void;
            getDouble(address: long, a1: boolean): double;
            getFloat(address: long, a1: boolean): float;
            getInt(address: long, a1: boolean): int;
            getLong(address: long, a1: boolean): long;
            getNext(): Page;
            getPrev(): Page;
            getShort(address: long, a1: boolean): short;
            getSize(): long;
            isMapped(): boolean;
            setNext(next: Page): void;
            setPrev(prev: Page): void;
            _baseAddress: long;
            _data: byte[];
            _next: Page;
            _prev: Page;
            _unmappedPageLength: long;
          }
          interface Page extends CombineTypes<[_Page, java.lang.Object]> {}
          interface _PageCache$$static extends ClassLike {
            new(pageSize: long, a1: long, maxNumPages: PageFetcher): PageCache;
          }
          let PageCache: _PageCache$$static;
          interface _PageCache {
            _addPageToList(page: Page): void;
            _checkPage(page: Page, startAddress: long): Page;
            _checkPageInfo(pageSize: long, a1: long): void;
            clear(startAddress: long, a1: long): void;
            clear(): void;
            _countPages(): int;
            disable(): void;
            enable(): void;
            _flushPage(pageBaseAddress: long): void;
            getBoolean(address: long): boolean;
            getByte(address: long): byte;
            getChar(address: long, a1: boolean): char;
            getData(startAddress: long, a1: long): byte[];
            getDouble(address: long, a1: boolean): double;
            getFloat(address: long, a1: boolean): float;
            getInt(address: long, a1: boolean): int;
            getLong(address: long, a1: boolean): long;
            _getPage(pageBaseAddress: long): Page;
            getShort(address: long, a1: boolean): short;
            _removePageFromList(page: Page): void;
            _addressToPageMap: LongHashMap;
            _enabled: boolean;
            _fetcher: PageFetcher;
            _lruList: Page;
            _maxNumPages: long;
            _numPages: long;
            _pageMask: long;
            _pageSize: long;
          }
          interface PageCache extends CombineTypes<[_PageCache, java.lang.Object]> {}
          interface _PageFetcher$$static extends ClassLike {
          }
          let PageFetcher: _PageFetcher$$static;
          interface _PageFetcher {
            fetchPage(a0: long, a1: long): Page;
(a0: long, a1: long): Page;
          }
          interface PageFetcher extends CombineTypes<[_PageFetcher, java.lang.Object]> {}
          interface _ProcessInfo$$static extends ClassLike {
            new(name: string, pid: int): ProcessInfo;
          }
          let ProcessInfo: _ProcessInfo$$static;
          interface _ProcessInfo {
            getName(): string;
            getPid(): int;
            _name: string;
            _pid: int;
          }
          interface ProcessInfo extends CombineTypes<[_ProcessInfo, java.lang.Object]> {}
          interface _RandomAccessFileDataSource$$static extends ClassLike {
            new(file: java.io.RandomAccessFile): RandomAccessFileDataSource;
          }
          let RandomAccessFileDataSource: _RandomAccessFileDataSource$$static;
          interface _RandomAccessFileDataSource {
            close(): void;
            getFilePointer(): long;
            read(b: byte[]): int;
            readByte(): byte;
            readInt(): int;
            readLong(): long;
            readShort(): short;
            seek(pos: long): void;
            _file: java.io.RandomAccessFile;
          }
          interface RandomAccessFileDataSource extends CombineTypes<[_RandomAccessFileDataSource, sun.jvm.hotspot.debugger.DataSource, java.lang.Object]> {}
          interface _ReadResult$$static extends ClassLike {
            new(data: byte[]): ReadResult;
            new(failureAddress: long): ReadResult;
          }
          let ReadResult: _ReadResult$$static;
          interface _ReadResult {
            getData(): byte[];
            getFailureAddress(): long;
            _data: byte[];
            _failureAddress: long;
          }
          interface ReadResult extends CombineTypes<[_ReadResult, java.lang.Object, java.io.Serializable]> {}
          interface _SymbolLookup$$static extends ClassLike {
          }
          let SymbolLookup: _SymbolLookup$$static;
          interface _SymbolLookup {
            lookup(a0: string, a1: string): Address;
            lookupOop(a0: string, a1: string): OopHandle;
          }
          interface SymbolLookup extends CombineTypes<[_SymbolLookup, java.lang.Object]> {}
          interface _ThreadAccess$$static extends ClassLike {
          }
          let ThreadAccess: _ThreadAccess$$static;
          interface _ThreadAccess {
            getThreadForIdentifierAddress(a0: Address): ThreadProxy;
            getThreadForThreadId(a0: long): ThreadProxy;
          }
          interface ThreadAccess extends CombineTypes<[_ThreadAccess, java.lang.Object]> {}
          interface _ThreadContext$$static extends ClassLike {
          }
          let ThreadContext: _ThreadContext$$static;
          interface _ThreadContext {
            getNumRegisters(): int;
            getRegister(a0: int): long;
            getRegisterAsAddress(a0: int): Address;
            getRegisterName(a0: int): string;
            getTopFrame(a0: Debugger): debugger.cdbg.CFrame;
            setRegister(a0: int, a1: long): void;
            setRegisterAsAddress(a0: int, a1: Address): void;
          }
          interface ThreadContext extends CombineTypes<[_ThreadContext, java.lang.Object]> {}
          interface _ThreadProxy$$static extends ClassLike {
          }
          let ThreadProxy: _ThreadProxy$$static;
          interface _ThreadProxy {
            canSetContext(): boolean;
            getContext(): ThreadContext;
            setContext(a0: ThreadContext): void;
          }
          interface ThreadProxy extends CombineTypes<[_ThreadProxy, java.lang.Object]> {}
          interface _UnalignedAddressException$$static extends ClassLike {
            new(addr: long): UnalignedAddressException;
            new(detail: string, addr: long): UnalignedAddressException;
          }
          let UnalignedAddressException: _UnalignedAddressException$$static;
          interface _UnalignedAddressException {
          }
          interface UnalignedAddressException extends CombineTypes<[_UnalignedAddressException, sun.jvm.hotspot.debugger.AddressException]> {}
          interface _UnmappedAddressException$$static extends ClassLike {
            new(addr: long): UnmappedAddressException;
            new(detail: string, addr: long): UnmappedAddressException;
          }
          let UnmappedAddressException: _UnmappedAddressException$$static;
          interface _UnmappedAddressException {
          }
          interface UnmappedAddressException extends CombineTypes<[_UnmappedAddressException, sun.jvm.hotspot.debugger.AddressException]> {}
        }
        module gc {
          module epsilon {
            interface _EpsilonHeap$$static extends ClassLike {
              _initialize(db: hotspot.types.TypeDataBase): void;
              _spaceField: hotspot.types.AddressField;
              _virtualSpaceField: hotspot.types.Field;
              new(addr: hotspot.debugger.Address): EpsilonHeap;
            }
            let EpsilonHeap: _EpsilonHeap$$static;
            interface _EpsilonHeap {
              capacity(): long;
              kind(): gc.shared.CollectedHeapName;
              liveRegionsIterate(closure: gc.shared.LiveRegionsClosure): void;
              printOn(tty: java.io.PrintStream): void;
              space(): gc.shared.ContiguousSpace;
              used(): long;
              _space: gc.shared.ContiguousSpace;
              _virtualSpace: hotspot.memory.VirtualSpace;
            }
            interface EpsilonHeap extends CombineTypes<[_EpsilonHeap, sun.jvm.hotspot.gc.shared.CollectedHeap]> {}
          }
          module g1 {
            interface _G1CollectedHeap$$static extends ClassLike {
              _initialize(db: hotspot.types.TypeDataBase): void;
              _g1ReservedFieldOffset: long;
              _hrmFieldOffset: long;
              _humongousSetFieldOffset: long;
              _monitoringSupportField: hotspot.types.AddressField;
              _oldSetFieldOffset: long;
              _summaryBytesUsedField: hotspot.types.CIntegerField;
              new(addr: hotspot.debugger.Address): G1CollectedHeap;
            }
            let G1CollectedHeap: _G1CollectedHeap$$static;
            interface _G1CollectedHeap {
              capacity(): long;
              heapRegionIterate(hrcl: HeapRegionClosure): void;
              _heapRegionIterator(): java.util.Iterator<HeapRegion>;
              hrm(): HeapRegionManager;
              humongousSet(): HeapRegionSetBase;
              kind(): gc.shared.CollectedHeapName;
              liveRegionsIterate(closure: gc.shared.LiveRegionsClosure): void;
              monitoringSupport(): G1MonitoringSupport;
              n_regions(): long;
              oldSet(): HeapRegionSetBase;
              printOn(tty: java.io.PrintStream): void;
              printRegionDetails(tty: java.io.PrintStream): void;
              used(): long;
            }
            interface G1CollectedHeap extends CombineTypes<[_G1CollectedHeap, sun.jvm.hotspot.gc.shared.CollectedHeap]> {}
            interface _G1HeapRegionTable$$static extends ClassLike {
              _initialize(db: hotspot.types.TypeDataBase): void;
              _baseField: hotspot.types.AddressField;
              _biasField: hotspot.types.CIntegerField;
              _biasedBaseField: hotspot.types.AddressField;
              _lengthField: hotspot.types.CIntegerField;
              _shiftByField: hotspot.types.CIntegerField;
              new(addr: hotspot.debugger.Address): G1HeapRegionTable;
            }
            let G1HeapRegionTable: _G1HeapRegionTable$$static;
            interface _G1HeapRegionTable {
              _at(index: long): HeapRegion;
              bias(): long;
              getByAddress(target: hotspot.debugger.Address): HeapRegion;
              heapRegionIterator(committedLength: long): java.util.Iterator<HeapRegion>;
              length(): long;
              shiftBy(): long;
            }
            interface G1HeapRegionTable extends CombineTypes<[_G1HeapRegionTable, sun.jvm.hotspot.runtime.VMObject]> {}
            interface _G1HeapRegionTable$HeapRegionIterator$$static extends ClassLike {
              _new(a0: G1HeapRegionTable, totalLength: long): G1HeapRegionTable$HeapRegionIterator;
            }
            let G1HeapRegionTable$HeapRegionIterator: _G1HeapRegionTable$HeapRegionIterator$$static;
            interface _G1HeapRegionTable$HeapRegionIterator {
              hasNext(): boolean;
              next(): HeapRegion;
              next(): any;
              positionToNext(): HeapRegion;
              remove(): void;
              _index: long;
              _length: long;
              _next: HeapRegion;
              _this$0: G1HeapRegionTable;
            }
            interface G1HeapRegionTable$HeapRegionIterator extends CombineTypes<[_G1HeapRegionTable$HeapRegionIterator, java.util.Iterator<HeapRegion>, java.lang.Object]> {}
            interface _G1MonitoringSupport$$static extends ClassLike {
              _initialize(db: hotspot.types.TypeDataBase): void;
              _edenSpaceCommittedField: hotspot.types.CIntegerField;
              _edenSpaceUsedField: hotspot.types.CIntegerField;
              _oldGenCommittedField: hotspot.types.CIntegerField;
              _oldGenUsedField: hotspot.types.CIntegerField;
              _survivorSpaceCommittedField: hotspot.types.CIntegerField;
              _survivorSpaceUsedField: hotspot.types.CIntegerField;
              new(addr: hotspot.debugger.Address): G1MonitoringSupport;
            }
            let G1MonitoringSupport: _G1MonitoringSupport$$static;
            interface _G1MonitoringSupport {
              edenSpaceCommitted(): long;
              edenSpaceRegionNum(): long;
              edenSpaceUsed(): long;
              oldGenCommitted(): long;
              oldGenUsed(): long;
              survivorSpaceCommitted(): long;
              survivorSpaceRegionNum(): long;
              survivorSpaceUsed(): long;
            }
            interface G1MonitoringSupport extends CombineTypes<[_G1MonitoringSupport, sun.jvm.hotspot.runtime.VMObject]> {}
            interface _HeapRegion$$static extends ClassLike {
              getPointerSize(): long;
              grainBytes(): long;
              _initialize(db: hotspot.types.TypeDataBase): void;
              _bottomField: hotspot.types.AddressField;
              _endField: hotspot.types.AddressField;
              _grainBytesField: hotspot.types.CIntegerField;
              _pointerSize: long;
              _topField: hotspot.types.AddressField;
              _typeFieldOffset: long;
              new(addr: hotspot.debugger.Address): HeapRegion;
            }
            let HeapRegion: _HeapRegion$$static;
            interface _HeapRegion {
              bottom(): hotspot.debugger.Address;
              end(): hotspot.debugger.Address;
              free(): long;
              getLiveRegions(): java.util.List<hotspot.memory.MemRegion>;
              isFree(): boolean;
              isHumongous(): boolean;
              isOld(): boolean;
              isYoung(): boolean;
              printOn(tty: java.io.PrintStream): void;
              top(): hotspot.debugger.Address;
              used(): long;
              usedRegion(): hotspot.memory.MemRegion;
              _type: HeapRegionType;
            }
            interface HeapRegion extends CombineTypes<[_HeapRegion, sun.jvm.hotspot.gc.shared.ContiguousSpace, sun.jvm.hotspot.gc.shared.LiveRegionsProvider]> {}
            interface _HeapRegionClosure$$static extends ClassLike {
            }
            let HeapRegionClosure: _HeapRegionClosure$$static;
            interface _HeapRegionClosure {
              doHeapRegion(a0: HeapRegion): void;
(a0: HeapRegion): void;
            }
            interface HeapRegionClosure extends CombineTypes<[_HeapRegionClosure, java.lang.Object]> {}
            interface _HeapRegionManager$$static extends ClassLike {
              _initialize(db: hotspot.types.TypeDataBase): void;
              _regionsFieldOffset: long;
              new(addr: hotspot.debugger.Address): HeapRegionManager;
            }
            let HeapRegionManager: _HeapRegionManager$$static;
            interface _HeapRegionManager {
              capacity(): long;
              getByAddress(addr: hotspot.debugger.Address): HeapRegion;
              heapRegionIterator(): java.util.Iterator<HeapRegion>;
              length(): long;
              _regions(): G1HeapRegionTable;
            }
            interface HeapRegionManager extends CombineTypes<[_HeapRegionManager, sun.jvm.hotspot.runtime.VMObject]> {}
            interface _HeapRegionSetBase$$static extends ClassLike {
              _initialize(db: hotspot.types.TypeDataBase): void;
              _lengthField: hotspot.types.CIntegerField;
              new(addr: hotspot.debugger.Address): HeapRegionSetBase;
            }
            let HeapRegionSetBase: _HeapRegionSetBase$$static;
            interface _HeapRegionSetBase {
              length(): long;
            }
            interface HeapRegionSetBase extends CombineTypes<[_HeapRegionSetBase, sun.jvm.hotspot.runtime.VMObject]> {}
            interface _HeapRegionType$$static extends ClassLike {
              _initialize(db: hotspot.types.TypeDataBase): void;
              _continuesHumongousTag: int;
              _edenTag: int;
              _freeTag: int;
              _humongousMask: int;
              _oldMask: int;
              _startsHumongousTag: int;
              _survTag: int;
              _tagField: hotspot.types.CIntegerField;
              _youngMask: int;
              new(addr: hotspot.debugger.Address): HeapRegionType;
            }
            let HeapRegionType: _HeapRegionType$$static;
            interface _HeapRegionType {
              isContinuesHumongous(): boolean;
              isEden(): boolean;
              isFree(): boolean;
              isHumongous(): boolean;
              isOld(): boolean;
              isStartsHumongous(): boolean;
              isSurvivor(): boolean;
              isYoung(): boolean;
              typeAnnotation(): string;
              _tag: int;
            }
            interface HeapRegionType extends CombineTypes<[_HeapRegionType, sun.jvm.hotspot.runtime.VMObject]> {}
            interface _PrintRegionClosure$$static extends ClassLike {
              new(tty: java.io.PrintStream): PrintRegionClosure;
            }
            let PrintRegionClosure: _PrintRegionClosure$$static;
            interface _PrintRegionClosure {
              doHeapRegion(hr: HeapRegion): void;
              _tty: java.io.PrintStream;
            }
            interface PrintRegionClosure extends CombineTypes<[_PrintRegionClosure, sun.jvm.hotspot.gc.g1.HeapRegionClosure, java.lang.Object]> {}
          }
          module parallel {
            interface _MutableSpace$$static extends ClassLike {
              _initialize(db: hotspot.types.TypeDataBase): void;
              _bottomField: hotspot.types.AddressField;
              _endField: hotspot.types.AddressField;
              _topField: hotspot.types.AddressField;
              new(addr: hotspot.debugger.Address): MutableSpace;
            }
            let MutableSpace: _MutableSpace$$static;
            interface _MutableSpace {
              bottom(): hotspot.debugger.Address;
              bottomAsOopHandle(): hotspot.debugger.OopHandle;
              capacity(): long;
              contains(p: hotspot.debugger.Address): boolean;
              end(): hotspot.debugger.Address;
              getLiveRegions(): java.util.List<hotspot.memory.MemRegion>;
              print(): void;
              printOn(tty: java.io.PrintStream): void;
              top(): hotspot.debugger.Address;
              used(): long;
              usedRegion(): hotspot.memory.MemRegion;
            }
            interface MutableSpace extends CombineTypes<[_MutableSpace, sun.jvm.hotspot.runtime.VMObject]> {}
            interface _PSOldGen$$static extends ClassLike {
              _initialize(db: hotspot.types.TypeDataBase): void;
              _objectSpaceField: hotspot.types.AddressField;
              new(addr: hotspot.debugger.Address): PSOldGen;
            }
            let PSOldGen: _PSOldGen$$static;
            interface _PSOldGen {
              capacity(): long;
              isIn(a: hotspot.debugger.Address): boolean;
              objectSpace(): MutableSpace;
              printOn(tty: java.io.PrintStream): void;
              used(): long;
            }
            interface PSOldGen extends CombineTypes<[_PSOldGen, sun.jvm.hotspot.runtime.VMObject]> {}
            interface _PSYoungGen$$static extends ClassLike {
              _initialize(db: hotspot.types.TypeDataBase): void;
              _edenSpaceField: hotspot.types.AddressField;
              _fromSpaceField: hotspot.types.AddressField;
              _toSpaceField: hotspot.types.AddressField;
              new(addr: hotspot.debugger.Address): PSYoungGen;
            }
            let PSYoungGen: _PSYoungGen$$static;
            interface _PSYoungGen {
              capacity(): long;
              edenSpace(): MutableSpace;
              fromSpace(): MutableSpace;
              isIn(a: hotspot.debugger.Address): boolean;
              printOn(tty: java.io.PrintStream): void;
              toSpace(): MutableSpace;
              used(): long;
            }
            interface PSYoungGen extends CombineTypes<[_PSYoungGen, sun.jvm.hotspot.runtime.VMObject]> {}
            interface _ParallelScavengeHeap$$static extends ClassLike {
              _initialize(db: hotspot.types.TypeDataBase): void;
              _oldGenField: hotspot.types.AddressField;
              _youngGenField: hotspot.types.AddressField;
              new(addr: hotspot.debugger.Address): ParallelScavengeHeap;
            }
            let ParallelScavengeHeap: _ParallelScavengeHeap$$static;
            interface _ParallelScavengeHeap {
              capacity(): long;
              isIn(a: hotspot.debugger.Address): boolean;
              kind(): gc.shared.CollectedHeapName;
              liveRegionsIterate(closure: gc.shared.LiveRegionsClosure): void;
              oldGen(): PSOldGen;
              printOn(tty: java.io.PrintStream): void;
              used(): long;
              youngGen(): PSYoungGen;
            }
            interface ParallelScavengeHeap extends CombineTypes<[_ParallelScavengeHeap, sun.jvm.hotspot.gc.shared.CollectedHeap]> {}
            interface _ParallelScavengeHeap$LiveRegionProviderImpl$$static extends ClassLike {
              new(a0: ParallelScavengeHeap, name: string, space: MutableSpace): ParallelScavengeHeap$LiveRegionProviderImpl;
            }
            let ParallelScavengeHeap$LiveRegionProviderImpl: _ParallelScavengeHeap$LiveRegionProviderImpl$$static;
            interface _ParallelScavengeHeap$LiveRegionProviderImpl {
              getLiveRegions(): java.util.List<hotspot.memory.MemRegion>;
              toString(): string;
              _name: string;
              _space: MutableSpace;
            }
            interface ParallelScavengeHeap$LiveRegionProviderImpl extends CombineTypes<[_ParallelScavengeHeap$LiveRegionProviderImpl, sun.jvm.hotspot.gc.shared.LiveRegionsProvider, java.lang.Object]> {}
          }
          module serial {
            interface _DefNewGeneration$$static extends ClassLike {
              _initialize(db: hotspot.types.TypeDataBase): void;
              _edenSpaceField: hotspot.types.AddressField;
              _fromSpaceField: hotspot.types.AddressField;
              _toSpaceField: hotspot.types.AddressField;
              new(addr: hotspot.debugger.Address): DefNewGeneration;
            }
            let DefNewGeneration: _DefNewGeneration$$static;
            interface _DefNewGeneration {
              capacity(): long;
              contiguousAvailable(): long;
              eden(): gc.shared.ContiguousSpace;
              free(): long;
              from(): gc.shared.ContiguousSpace;
              kind(): gc.shared.Generation$Name;
              liveRegionsIterate(closure: gc.shared.LiveRegionsClosure): void;
              name(): string;
              printOn(tty: java.io.PrintStream): void;
              spaceIterate(blk: gc.shared.SpaceClosure, usedOnly: boolean): void;
              to(): gc.shared.ContiguousSpace;
              used(): long;
            }
            interface DefNewGeneration extends CombineTypes<[_DefNewGeneration, sun.jvm.hotspot.gc.shared.Generation]> {}
            interface _SerialHeap$$static extends ClassLike {
              new(addr: hotspot.debugger.Address): SerialHeap;
            }
            let SerialHeap: _SerialHeap$$static;
            interface _SerialHeap {
              kind(): gc.shared.CollectedHeapName;
            }
            interface SerialHeap extends CombineTypes<[_SerialHeap, sun.jvm.hotspot.gc.shared.GenCollectedHeap]> {}
            interface _TenuredGeneration$$static extends ClassLike {
              _initialize(db: hotspot.types.TypeDataBase): void;
              _theSpaceField: hotspot.types.AddressField;
              new(addr: hotspot.debugger.Address): TenuredGeneration;
            }
            let TenuredGeneration: _TenuredGeneration$$static;
            interface _TenuredGeneration {
              capacity(): long;
              contiguousAvailable(): long;
              free(): long;
              isIn(p: hotspot.debugger.Address): boolean;
              kind(): gc.shared.Generation$Name;
              liveRegionsIterate(closure: gc.shared.LiveRegionsClosure): void;
              name(): string;
              printOn(tty: java.io.PrintStream): void;
              spaceIterate(blk: gc.shared.SpaceClosure, usedOnly: boolean): void;
              theSpace(): gc.shared.ContiguousSpace;
              used(): long;
            }
            interface TenuredGeneration extends CombineTypes<[_TenuredGeneration, sun.jvm.hotspot.gc.shared.Generation]> {}
          }
          module shared {
            interface _CollectedHeap$$static extends ClassLike {
              _initialize(db: hotspot.types.TypeDataBase): void;
              _reservedFieldOffset: long;
              new(addr: hotspot.debugger.Address): CollectedHeap;
            }
            let CollectedHeap: _CollectedHeap$$static;
            interface _CollectedHeap {
              capacity(): long;
              createBitMap(bits: long): hotspot.utilities.BitMapInterface;
              isIn(a: hotspot.debugger.Address): boolean;
              isInReserved(a: hotspot.debugger.Address): boolean;
              kind(): CollectedHeapName;
              liveRegionsIterate(a0: LiveRegionsClosure): void;
              oopAddressDescription(handle: hotspot.debugger.OopHandle): string;
              oop_load_at(handle: hotspot.debugger.OopHandle, offset: long): hotspot.debugger.OopHandle;
              oop_load_in_native(addr: hotspot.debugger.Address): hotspot.debugger.OopHandle;
              print(): void;
              printOn(tty: java.io.PrintStream): void;
              reservedRegion(): hotspot.memory.MemRegion;
              start(): hotspot.debugger.Address;
              used(): long;
            }
            interface CollectedHeap extends CombineTypes<[_CollectedHeap, sun.jvm.hotspot.runtime.VMObject]> {}
            interface _CollectedHeapName$$static extends ClassLike {
              readonly EPSILON: CollectedHeapName;
              readonly G1: CollectedHeapName;
              readonly PARALLEL: CollectedHeapName;
              readonly SERIAL: CollectedHeapName;
              readonly SHENANDOAH: CollectedHeapName;
              readonly Z: CollectedHeapName;
            }
            let CollectedHeapName: _CollectedHeapName$$static;
            interface _CollectedHeapName {
              toString(): string;
              _name: string;
            }
            interface CollectedHeapName extends CombineTypes<[_CollectedHeapName, java.lang.Object]> {}
            interface _ContiguousSpace$$static extends ClassLike {
              _initialize(db: hotspot.types.TypeDataBase): void;
              _topField: hotspot.types.AddressField;
              new(addr: hotspot.debugger.Address): ContiguousSpace;
            }
            let ContiguousSpace: _ContiguousSpace$$static;
            interface _ContiguousSpace {
              capacity(): long;
              contains(p: hotspot.debugger.Address): boolean;
              free(): long;
              getLiveRegions(): java.util.List<hotspot.memory.MemRegion>;
              printOn(tty: java.io.PrintStream): void;
              top(): hotspot.debugger.Address;
              used(): long;
              usedRegion(): hotspot.memory.MemRegion;
            }
            interface ContiguousSpace extends CombineTypes<[_ContiguousSpace, sun.jvm.hotspot.gc.shared.LiveRegionsProvider, sun.jvm.hotspot.gc.shared.Space]> {}
            interface _G1HeapRegionType$$static extends ClassLike {
              valueOf(name: string): G1HeapRegionType;
              values(): G1HeapRegionType[];
              readonly Archive: G1HeapRegionType;
              readonly ContinuesHumongous: G1HeapRegionType;
              readonly Eden: G1HeapRegionType;
              readonly Free: G1HeapRegionType;
              readonly G1HeapRegionTypeEndSentinel: G1HeapRegionType;
              readonly Old: G1HeapRegionType;
              readonly StartsHumongous: G1HeapRegionType;
              readonly Survivor: G1HeapRegionType;
            }
            let G1HeapRegionType: _G1HeapRegionType$$static;
            interface _G1HeapRegionType {
              value(): string;
              _value: string;
            }
            interface G1HeapRegionType extends CombineTypes<[_G1HeapRegionType]> {}
            interface _GCCause$$static extends ClassLike {
              valueOf(name: string): GCCause;
              values(): GCCause[];
              readonly _adaptive_size_policy: GCCause;
              readonly _allocation_failure: GCCause;
              readonly _allocation_profiler: GCCause;
              readonly _dcmd_gc_run: GCCause;
              readonly _full_gc_alot: GCCause;
              readonly _g1_humongous_allocation: GCCause;
              readonly _g1_inc_collection_pause: GCCause;
              readonly _gc_locker: GCCause;
              readonly _heap_dump: GCCause;
              readonly _heap_inspection: GCCause;
              readonly _java_lang_system_gc: GCCause;
              readonly _jvmti_force_gc: GCCause;
              readonly _last_gc_cause: GCCause;
              readonly _metadata_GC_clear_soft_refs: GCCause;
              readonly _metadata_GC_threshold: GCCause;
              readonly _no_cause_specified: GCCause;
              readonly _no_gc: GCCause;
              readonly _old_generation_expanded_on_last_scavenge: GCCause;
              readonly _old_generation_too_full_to_scavenge: GCCause;
              readonly _scavenge_alot: GCCause;
              readonly _shenandoah_allocation_failure_evac: GCCause;
              readonly _shenandoah_concurrent_gc: GCCause;
              readonly _shenandoah_stop_vm: GCCause;
              readonly _shenandoah_traversal_gc: GCCause;
              readonly _shenandoah_upgrade_to_full_gc: GCCause;
              readonly _tenured_generation_full: GCCause;
              readonly _wb_full_gc: GCCause;
              readonly _wb_young_gc: GCCause;
              readonly _z_allocation_rate: GCCause;
              readonly _z_allocation_stall: GCCause;
              readonly _z_proactive: GCCause;
              readonly _z_timer: GCCause;
              readonly _z_warmup: GCCause;
            }
            let GCCause: _GCCause$$static;
            interface _GCCause {
              value(): string;
              _value: string;
            }
            interface GCCause extends CombineTypes<[_GCCause]> {}
            interface _GCName$$static extends ClassLike {
              valueOf(name: string): GCName;
              values(): GCName[];
              readonly DefNew: GCName;
              readonly G1Full: GCName;
              readonly G1New: GCName;
              readonly G1Old: GCName;
              readonly GCNameEndSentinel: GCName;
              readonly NA: GCName;
              readonly PSMarkSweep: GCName;
              readonly ParallelOld: GCName;
              readonly ParallelScavenge: GCName;
              readonly SerialOld: GCName;
              readonly Shenandoah: GCName;
              readonly Z: GCName;
            }
            let GCName: _GCName$$static;
            interface _GCName {
              value(): string;
              _value: string;
            }
            interface GCName extends CombineTypes<[_GCName]> {}
            interface _GCWhen$$static extends ClassLike {
              valueOf(name: string): GCWhen;
              values(): GCWhen[];
              readonly AfterGC: GCWhen;
              readonly BeforeGC: GCWhen;
              readonly GCWhenEndSentinel: GCWhen;
            }
            let GCWhen: _GCWhen$$static;
            interface _GCWhen {
              value(): string;
              _value: string;
            }
            interface GCWhen extends CombineTypes<[_GCWhen]> {}
            interface _GenCollectedHeap$$static extends ClassLike {
              _initialize(db: hotspot.types.TypeDataBase): void;
              _genFactory: GenerationFactory;
              _oldGenField: hotspot.types.AddressField;
              _oldGenSpecField: hotspot.types.AddressField;
              _youngGenField: hotspot.types.AddressField;
              _youngGenSpecField: hotspot.types.AddressField;
              new(addr: hotspot.debugger.Address): GenCollectedHeap;
            }
            let GenCollectedHeap: _GenCollectedHeap$$static;
            interface _GenCollectedHeap {
              capacity(): long;
              getGen(i: int): Generation;
              isIn(a: hotspot.debugger.Address): boolean;
              liveRegionsIterate(closure: LiveRegionsClosure): void;
              nGens(): int;
              printOn(tty: java.io.PrintStream): void;
              _spec(level: int): GenerationSpec;
              used(): long;
            }
            interface GenCollectedHeap extends CombineTypes<[_GenCollectedHeap, sun.jvm.hotspot.gc.shared.CollectedHeap]> {}
            interface _Generation$$static extends ClassLike {
              _initialize(db: hotspot.types.TypeDataBase): void;
              _nameForEnum(value: int): Generation$Name;
              _K: int;
              _NAME_DEF_NEW: int;
              _NAME_MARK_SWEEP_COMPACT: int;
              _NAME_OTHER: int;
              _NAME_PAR_NEW: int;
              _invocationField: hotspot.types.CIntegerField;
              _reservedFieldOffset: long;
              _statRecordField: hotspot.types.Field;
              _virtualSpaceFieldOffset: long;
              new(addr: hotspot.debugger.Address): Generation;
            }
            let Generation: _Generation$$static;
            interface _Generation {
              capacity(): long;
              contiguousAvailable(): long;
              free(): long;
              _getStatRecord(): Generation$StatRecord;
              invocations(): int;
              isIn(p: hotspot.debugger.Address): boolean;
              isInReserved(p: hotspot.debugger.Address): boolean;
              kind(): Generation$Name;
              liveRegionsIterate(a0: LiveRegionsClosure): void;
              name(): string;
              print(): void;
              printOn(a0: java.io.PrintStream): void;
              reserved(): hotspot.memory.MemRegion;
              spaceIterate(blk: SpaceClosure): void;
              spaceIterate(a0: SpaceClosure, a1: boolean): void;
              used(): long;
              usedRegion(): hotspot.memory.MemRegion;
              _virtualSpace(): hotspot.memory.VirtualSpace;
            }
            interface Generation extends CombineTypes<[_Generation, sun.jvm.hotspot.runtime.VMObject]> {}
            interface _Generation$Name$$static extends ClassLike {
              readonly DEF_NEW: Generation$Name;
              readonly MARK_SWEEP_COMPACT: Generation$Name;
              readonly OTHER: Generation$Name;
            }
            let Generation$Name: _Generation$Name$$static;
            interface _Generation$Name {
              toString(): string;
              _value: string;
            }
            interface Generation$Name extends CombineTypes<[_Generation$Name, java.lang.Object]> {}
            interface _Generation$StatRecord$$static extends ClassLike {
              new(addr: hotspot.debugger.Address): Generation$StatRecord;
            }
            let Generation$StatRecord: _Generation$StatRecord$$static;
            interface _Generation$StatRecord {
              getInvocations(): int;
            }
            interface Generation$StatRecord extends CombineTypes<[_Generation$StatRecord, sun.jvm.hotspot.runtime.VMObject]> {}
            interface _GenerationFactory$$static extends ClassLike {
              _initialize(db: hotspot.types.TypeDataBase): void;
              newObject(addr: hotspot.debugger.Address): Generation;
              _ctor: hotspot.runtime.VirtualConstructor;
              new(): GenerationFactory;
            }
            let GenerationFactory: _GenerationFactory$$static;
            interface _GenerationFactory {
            }
            interface GenerationFactory extends CombineTypes<[_GenerationFactory, java.lang.Object]> {}
            interface _GenerationIsInClosure$$static extends ClassLike {
              _new(p: hotspot.debugger.Address): GenerationIsInClosure;
            }
            let GenerationIsInClosure: _GenerationIsInClosure$$static;
            interface _GenerationIsInClosure {
              doSpace(s: Space): void;
              _space(): Space;
              _p: hotspot.debugger.Address;
              _sp: Space;
            }
            interface GenerationIsInClosure extends CombineTypes<[_GenerationIsInClosure, sun.jvm.hotspot.gc.shared.SpaceClosure, java.lang.Object]> {}
            interface _GenerationSpec$$static extends ClassLike {
              _initialize(db: hotspot.types.TypeDataBase): void;
              _initSizeField: hotspot.types.CIntegerField;
              _maxSizeField: hotspot.types.CIntegerField;
              _nameField: hotspot.types.CIntegerField;
              new(addr: hotspot.debugger.Address): GenerationSpec;
            }
            let GenerationSpec: _GenerationSpec$$static;
            interface _GenerationSpec {
              initSize(): long;
              maxSize(): long;
              name(): Generation$Name;
            }
            interface GenerationSpec extends CombineTypes<[_GenerationSpec, sun.jvm.hotspot.runtime.VMObject]> {}
            interface _LiveRegionsClosure$$static extends ClassLike {
            }
            let LiveRegionsClosure: _LiveRegionsClosure$$static;
            interface _LiveRegionsClosure {
              doLiveRegions(a0: LiveRegionsProvider): void;
(a0: LiveRegionsProvider): void;
            }
            interface LiveRegionsClosure extends CombineTypes<[_LiveRegionsClosure, java.lang.Object]> {}
            interface _LiveRegionsProvider$$static extends ClassLike {
            }
            let LiveRegionsProvider: _LiveRegionsProvider$$static;
            interface _LiveRegionsProvider {
              getLiveRegions(): java.util.List<hotspot.memory.MemRegion>;
(): java.util.List<hotspot.memory.MemRegion>;
            }
            interface LiveRegionsProvider extends CombineTypes<[_LiveRegionsProvider, java.lang.Object]> {}
            interface _OopStorage$$static extends ClassLike {
              _initialize(db: hotspot.types.TypeDataBase): void;
              new(addr: hotspot.debugger.Address): OopStorage;
            }
            let OopStorage: _OopStorage$$static;
            interface _OopStorage {
              findOop(handle: hotspot.debugger.Address): boolean;
              oopsDo(visitor: hotspot.runtime.AddressVisitor): void;
            }
            interface OopStorage extends CombineTypes<[_OopStorage, sun.jvm.hotspot.runtime.VMObject]> {}
            interface _Space$$static extends ClassLike {
              _initialize(db: hotspot.types.TypeDataBase): void;
              _bottomField: hotspot.types.AddressField;
              _endField: hotspot.types.AddressField;
              new(addr: hotspot.debugger.Address): Space;
            }
            let Space: _Space$$static;
            interface _Space {
              bottom(): hotspot.debugger.Address;
              bottomAsOopHandle(): hotspot.debugger.OopHandle;
              capacity(): long;
              contains(p: hotspot.debugger.Address): boolean;
              end(): hotspot.debugger.Address;
              free(): long;
              nextOopHandle(handle: hotspot.debugger.OopHandle, size: long): hotspot.debugger.OopHandle;
              print(): void;
              printOn(tty: java.io.PrintStream): void;
              used(): long;
              usedRegion(): hotspot.memory.MemRegion;
            }
            interface Space extends CombineTypes<[_Space, sun.jvm.hotspot.runtime.VMObject]> {}
            interface _SpaceClosure$$static extends ClassLike {
            }
            let SpaceClosure: _SpaceClosure$$static;
            interface _SpaceClosure {
              doSpace(a0: Space): void;
(a0: Space): void;
            }
            interface SpaceClosure extends CombineTypes<[_SpaceClosure, java.lang.Object]> {}
            interface _TenuredSpace$$static extends ClassLike {
              new(addr: hotspot.debugger.Address): TenuredSpace;
            }
            let TenuredSpace: _TenuredSpace$$static;
            interface _TenuredSpace {
            }
            interface TenuredSpace extends CombineTypes<[_TenuredSpace, sun.jvm.hotspot.gc.shared.ContiguousSpace]> {}
          }
          module shenandoah {
            interface _ShenandoahBitMap$$static extends ClassLike {
              _new(heap: ShenandoahHeap): ShenandoahBitMap;
            }
            let ShenandoahBitMap: _ShenandoahBitMap$$static;
            interface _ShenandoahBitMap {
              at(offset: long): boolean;
              atPut(offset: long, a1: boolean): void;
              clear(): void;
              _getOrAddBitMap(region: ShenandoahHeapRegion): hotspot.utilities.BitMap;
              _toBitMapOffset(offset: long, a1: ShenandoahHeapRegion): int;
              _heap: ShenandoahHeap;
              _regionToBitMap: java.util.HashMap<ShenandoahHeapRegion,hotspot.utilities.BitMap>;
            }
            interface ShenandoahBitMap extends CombineTypes<[_ShenandoahBitMap, sun.jvm.hotspot.utilities.BitMapInterface, java.lang.Object]> {}
            interface _ShenandoahHeap$$static extends ClassLike {
              _initialize(db: hotspot.types.TypeDataBase): void;
              _committed: hotspot.types.CIntegerField;
              _logMinObjAlignmentInBytes: hotspot.types.CIntegerField;
              _numRegions: hotspot.types.CIntegerField;
              _regionPtrFieldSize: long;
              _regions: hotspot.types.AddressField;
              _used: hotspot.types.CIntegerField;
              new(addr: hotspot.debugger.Address): ShenandoahHeap;
            }
            let ShenandoahHeap: _ShenandoahHeap$$static;
            interface _ShenandoahHeap {
              capacity(): long;
              committed(): long;
              createBitMap(bits: long): hotspot.utilities.BitMapInterface;
              getLogMinObjAlignmentInBytes(): int;
              getRegion(index: long): ShenandoahHeapRegion;
              kind(): gc.shared.CollectedHeapName;
              liveRegionsIterate(closure: gc.shared.LiveRegionsClosure): void;
              numOfRegions(): long;
              printOn(tty: java.io.PrintStream): void;
              regionAtOffset(offset: long): ShenandoahHeapRegion;
              used(): long;
            }
            interface ShenandoahHeap extends CombineTypes<[_ShenandoahHeap, sun.jvm.hotspot.gc.shared.CollectedHeap]> {}
            interface _ShenandoahHeapRegion$$static extends ClassLike {
              _initialize(db: hotspot.types.TypeDataBase): void;
              regionSizeBytes(): long;
              regionSizeBytesShift(): int;
              _BottomField: hotspot.types.AddressField;
              _CSet: int;
              _EmptyCommitted: int;
              _EmptyUncommitted: int;
              _EndField: hotspot.types.AddressField;
              _HumongousCont: int;
              _HumongousStart: int;
              _Pinned: int;
              _PinnedCSet: int;
              _PinnedHumongousStart: int;
              _RegionIndexField: hotspot.types.CIntegerField;
              _RegionSizeBytesField: hotspot.types.CIntegerField;
              _RegionSizeBytesShiftField: hotspot.types.CIntegerField;
              _RegionStateField: hotspot.types.Field;
              _Regular: int;
              _TopField: hotspot.types.AddressField;
              _Trash: int;
              new(addr: hotspot.debugger.Address): ShenandoahHeapRegion;
            }
            let ShenandoahHeapRegion: _ShenandoahHeapRegion$$static;
            interface _ShenandoahHeapRegion {
              bottom(): hotspot.debugger.Address;
              end(): hotspot.debugger.Address;
              equals(other: any): boolean;
              getLiveRegions(): java.util.List<hotspot.memory.MemRegion>;
              _getObjectSize(rawPtr: hotspot.debugger.Address): long;
              _handleCSetRegion(res: java.util.List<hotspot.memory.MemRegion>): void;
              _handleHumongousRegion(res: java.util.List<hotspot.memory.MemRegion>): void;
              _handleRegularRegion(res: java.util.List<hotspot.memory.MemRegion>): void;
              _hasForwardee(rawPtr: hotspot.debugger.Address): boolean;
              hashCode(): int;
              index(): long;
              _regionState(): int;
              setHeap(heap: ShenandoahHeap): void;
              top(): hotspot.debugger.Address;
              _heap: ShenandoahHeap;
            }
            interface ShenandoahHeapRegion extends CombineTypes<[_ShenandoahHeapRegion, sun.jvm.hotspot.gc.shared.LiveRegionsProvider, sun.jvm.hotspot.runtime.VMObject]> {}
          }
          module x {
            interface _XAddress$$static extends ClassLike {
              _as_long(value: hotspot.debugger.Address): long;
              _good(value: hotspot.debugger.Address): hotspot.debugger.Address;
              _good_or_null(value: hotspot.debugger.Address): hotspot.debugger.Address;
              _isIn(addr: hotspot.debugger.Address): boolean;
              _isPowerOf2(value: long): boolean;
              _is_null(value: hotspot.debugger.Address): boolean;
              _is_weak_bad(value: hotspot.debugger.Address): boolean;
              _is_weak_good(value: hotspot.debugger.Address): boolean;
              _is_weak_good_or_null(value: hotspot.debugger.Address): boolean;
              _offset(address: hotspot.debugger.Address): long;
              _new(): XAddress;
            }
            let XAddress: _XAddress$$static;
            interface _XAddress {
            }
            interface XAddress extends CombineTypes<[_XAddress, java.lang.Object]> {}
            interface _XAttachedArrayForForwarding$$static extends ClassLike {
              _initialize(db: hotspot.types.TypeDataBase): void;
              _lengthField: hotspot.types.CIntegerField;
              new(addr: hotspot.debugger.Address): XAttachedArrayForForwarding;
            }
            let XAttachedArrayForForwarding: _XAttachedArrayForForwarding$$static;
            interface _XAttachedArrayForForwarding {
              get(obj: XForwarding): XForwardingEntry;
              length(): long;
              _objectSize(): long;
            }
            interface XAttachedArrayForForwarding extends CombineTypes<[_XAttachedArrayForForwarding, sun.jvm.hotspot.runtime.VMObject]> {}
            interface _XBarrier$$static extends ClassLike {
              _during_relocate(): boolean;
              _is_weak_good_or_null_fast_path(addr: hotspot.debugger.Address): boolean;
              _relocate(addr: hotspot.debugger.Address): hotspot.debugger.Address;
              _relocate_or_remap(addr: hotspot.debugger.Address): hotspot.debugger.Address;
              _remap(addr: hotspot.debugger.Address): hotspot.debugger.Address;
              _weak_barrier(o: hotspot.debugger.Address): hotspot.debugger.Address;
              _weak_load_barrier_on_oop_slow_path(addr: hotspot.debugger.Address): hotspot.debugger.Address;
              _zheap(): XHeap;
              _new(): XBarrier;
            }
            let XBarrier: _XBarrier$$static;
            interface _XBarrier {
            }
            interface XBarrier extends CombineTypes<[_XBarrier, java.lang.Object]> {}
            interface _XCollectedHeap$$static extends ClassLike {
              _initialize(db: hotspot.types.TypeDataBase): void;
              _zHeapFieldOffset: long;
              new(addr: hotspot.debugger.Address): XCollectedHeap;
            }
            let XCollectedHeap: _XCollectedHeap$$static;
            interface _XCollectedHeap {
              capacity(): long;
              createBitMap(size: long): hotspot.utilities.BitMapInterface;
              heap(): XHeap;
              isInReserved(a: hotspot.debugger.Address): boolean;
              kind(): gc.shared.CollectedHeapName;
              liveRegionsIterate(closure: gc.shared.LiveRegionsClosure): void;
              oopAddressDescription(handle: hotspot.debugger.OopHandle): string;
              oop_load_at(handle: hotspot.debugger.OopHandle, offset: long): hotspot.debugger.OopHandle;
              _oop_load_barrier(oopAddress: hotspot.debugger.Address): hotspot.debugger.OopHandle;
              oop_load_in_native(addr: hotspot.debugger.Address): hotspot.debugger.OopHandle;
              printOn(tty: java.io.PrintStream): void;
              used(): long;
            }
            interface XCollectedHeap extends CombineTypes<[_XCollectedHeap, sun.jvm.hotspot.gc.shared.CollectedHeap]> {}
            interface _XExternalBitMap$$static extends ClassLike {
              new(collectedHeap: XCollectedHeap): XExternalBitMap;
            }
            let XExternalBitMap: _XExternalBitMap$$static;
            interface _XExternalBitMap {
              at(offset: long): boolean;
              atPut(offset: long, a1: boolean): void;
              clear(): void;
              _convertToZOffset(offset: long): long;
              _getOrAddBitMap(page: XPage): hotspot.utilities.BitMap;
              _getPage(zOffset: long): XPage;
              _pageLocalBitMapIndex(page: XPage, zOffset: long): int;
              _oopSize: long;
              _pageTable: XPageTable;
              _pageToBitMap: java.util.HashMap<XPage,hotspot.utilities.BitMap>;
            }
            interface XExternalBitMap extends CombineTypes<[_XExternalBitMap, sun.jvm.hotspot.utilities.BitMapInterface, java.lang.Object]> {}
            interface _XForwarding$$static extends ClassLike {
              getSize(): long;
              _initialize(db: hotspot.types.TypeDataBase): void;
              _entriesFieldOffset: long;
              _objectAlignmentShiftField: hotspot.types.CIntegerField;
              _refCountField: hotspot.types.CIntegerField;
              _type: hotspot.types.Type;
              _virtualFieldOffset: long;
              new(addr: hotspot.debugger.Address): XForwarding;
            }
            let XForwarding: _XForwarding$$static;
            interface _XForwarding {
              _at(cursor: long): XForwardingEntry;
              _entries(): XAttachedArrayForForwarding;
              find(fromIndex: long): XForwardingEntry;
              objectAlignmentShift(): int;
              retainPage(): boolean;
              start(): long;
              _virtual(): XVirtualMemory;
            }
            interface XForwarding extends CombineTypes<[_XForwarding, sun.jvm.hotspot.runtime.VMObject]> {}
            interface _XForwarding$XForwardEntryIterator$$static extends ClassLike {
              new(a0: XForwarding, fromIndex: long): XForwarding$XForwardEntryIterator;
            }
            let XForwarding$XForwardEntryIterator: _XForwarding$XForwardEntryIterator$$static;
            interface _XForwarding$XForwardEntryIterator {
              hasNext(): boolean;
              next(): XForwardingEntry;
              next(): any;
              peak(): XForwardingEntry;
              _cursor: long;
              _nextEntry: XForwardingEntry;
              _this$0: XForwarding;
            }
            interface XForwarding$XForwardEntryIterator extends CombineTypes<[_XForwarding$XForwardEntryIterator, java.lang.Object, java.util.Iterator<XForwardingEntry>]> {}
            interface _XForwardingEntry$$static extends ClassLike {
              getSize(): long;
              _initialize(db: hotspot.types.TypeDataBase): void;
              _entryField: hotspot.types.CIntegerField;
              _type: hotspot.types.Type;
              new(addr: hotspot.debugger.Address): XForwardingEntry;
            }
            let XForwardingEntry: _XForwardingEntry$$static;
            interface _XForwardingEntry {
              entry(): long;
              _fieldFromIndexDecode(value: long): long;
              _fieldPopulatedDecode(value: long): boolean;
              _fieldToOffsetDecode(value: long): long;
              fromIndex(): long;
              populated(): boolean;
              toOffset(): long;
            }
            interface XForwardingEntry extends CombineTypes<[_XForwardingEntry, sun.jvm.hotspot.runtime.VMObject]> {}
            interface _XForwardingTable$$static extends ClassLike {
              _initialize(db: hotspot.types.TypeDataBase): void;
              _mapFieldOffset: long;
              new(addr: hotspot.debugger.Address): XForwardingTable;
            }
            let XForwardingTable: _XForwardingTable$$static;
            interface _XForwardingTable {
              get(o: hotspot.debugger.Address): XForwarding;
              _map(): XGranuleMapForForwarding;
            }
            interface XForwardingTable extends CombineTypes<[_XForwardingTable, sun.jvm.hotspot.runtime.VMObject]> {}
            interface _XForwardingTableCursor$$static extends ClassLike {
              _new(): XForwardingTableCursor;
            }
            let XForwardingTableCursor: _XForwardingTableCursor$$static;
            interface _XForwardingTableCursor {
              __value: long;
            }
            interface XForwardingTableCursor extends CombineTypes<[_XForwardingTableCursor, java.lang.Object]> {}
            interface _XForwardingTableEntry$$static extends ClassLike {
              _empty(): long;
              _new(addr: hotspot.debugger.Address): XForwardingTableEntry;
            }
            let XForwardingTableEntry: _XForwardingTableEntry$$static;
            interface _XForwardingTableEntry {
              _from_index(): long;
              _is_empty(): boolean;
              toString(): string;
              _to_offset(): hotspot.debugger.Address;
              _entry: hotspot.debugger.Address;
            }
            interface XForwardingTableEntry extends CombineTypes<[_XForwardingTableEntry, java.lang.Object]> {}
            interface _XGlobals$$static extends ClassLike {
              XAddressBadMask(): long;
              XAddressGoodMask(): long;
              XAddressMetadataFinalizable(): long;
              XAddressMetadataMask(): long;
              XAddressOffsetMask(): long;
              XAddressWeakBadMask(): long;
              XGlobalPhase(): int;
              XGlobalSeqNum(): int;
              XObjectAlignmentSmall(): int;
              XObjectAlignmentSmallShift(): int;
              _initialize(db: hotspot.types.TypeDataBase): void;
              _instance(): XGlobalsForVMStructs;
              XAddressOffsetBits: long;
              XAddressOffsetMax: long;
              XAddressOffsetShift: long;
              XGranuleSizeShift: long;
              XObjectAlignmentLargeShift: int;
              XObjectAlignmentMediumShift: int;
              XPageSizeMediumShift: long;
              XPageSizeSmallShift: long;
              XPageTypeLarge: byte;
              XPageTypeMedium: byte;
              XPageTypeSmall: byte;
              XPhaseRelocate: int;
              _instanceField: hotspot.types.Field;
              new(): XGlobals;
            }
            let XGlobals: _XGlobals$$static;
            interface _XGlobals {
            }
            interface XGlobals extends CombineTypes<[_XGlobals, java.lang.Object]> {}
            interface _XGlobalsForVMStructs$$static extends ClassLike {
              _initialize(db: hotspot.types.TypeDataBase): void;
              _XAddressBadMaskField: hotspot.types.AddressField;
              _XAddressGoodMaskField: hotspot.types.AddressField;
              _XAddressMetadataFinalizableField: hotspot.types.AddressField;
              _XAddressMetadataMaskField: hotspot.types.AddressField;
              _XAddressOffsetMaskField: hotspot.types.AddressField;
              _XAddressWeakBadMaskField: hotspot.types.AddressField;
              _XGlobalPhaseField: hotspot.types.AddressField;
              _XGlobalSeqNumField: hotspot.types.AddressField;
              _XObjectAlignmentSmallField: hotspot.types.AddressField;
              _XObjectAlignmentSmallShiftField: hotspot.types.AddressField;
              _new(addr: hotspot.debugger.Address): XGlobalsForVMStructs;
            }
            let XGlobalsForVMStructs: _XGlobalsForVMStructs$$static;
            interface _XGlobalsForVMStructs {
              _XAddressBadMask(): long;
              _XAddressGoodMask(): long;
              _XAddressMetadataFinalizable(): long;
              _XAddressMetadataMask(): long;
              _XAddressOffsetMask(): long;
              _XAddressWeakBadMask(): long;
              _XGlobalPhase(): int;
              _XGlobalSeqNum(): int;
              _XObjectAlignmentSmall(): int;
              _XObjectAlignmentSmallShift(): int;
            }
            interface XGlobalsForVMStructs extends CombineTypes<[_XGlobalsForVMStructs, sun.jvm.hotspot.runtime.VMObject]> {}
            interface _XGranuleMapForForwarding$$static extends ClassLike {
              _initialize(db: hotspot.types.TypeDataBase): void;
              _mapField: hotspot.types.AddressField;
              new(addr: hotspot.debugger.Address): XGranuleMapForForwarding;
            }
            let XGranuleMapForForwarding: _XGranuleMapForForwarding$$static;
            interface _XGranuleMapForForwarding {
              _at(index: long): hotspot.debugger.Address;
              _get(offset: long): hotspot.debugger.Address;
              _index_for_offset(offset: long): long;
              _map(): hotspot.debugger.Address;
              size(): long;
            }
            interface XGranuleMapForForwarding extends CombineTypes<[_XGranuleMapForForwarding, sun.jvm.hotspot.runtime.VMObject]> {}
            interface _XGranuleMapForForwarding$Iterator$$static extends ClassLike {
              new(this$0: XGranuleMapForForwarding): XGranuleMapForForwarding$Iterator;
            }
            let XGranuleMapForForwarding$Iterator: _XGranuleMapForForwarding$Iterator$$static;
            interface _XGranuleMapForForwarding$Iterator {
              _hasNext(): boolean;
              _next(): hotspot.debugger.Address;
              _next: long;
              _this$0: XGranuleMapForForwarding;
            }
            interface XGranuleMapForForwarding$Iterator extends CombineTypes<[_XGranuleMapForForwarding$Iterator, java.lang.Object]> {}
            interface _XGranuleMapForPageTable$$static extends ClassLike {
              _initialize(db: hotspot.types.TypeDataBase): void;
              _mapField: hotspot.types.AddressField;
              new(addr: hotspot.debugger.Address): XGranuleMapForPageTable;
            }
            let XGranuleMapForPageTable: _XGranuleMapForPageTable$$static;
            interface _XGranuleMapForPageTable {
              _at(index: long): hotspot.debugger.Address;
              _get(addr: hotspot.debugger.Address): hotspot.debugger.Address;
              _index_for_addr(addr: hotspot.debugger.Address): long;
              _map(): hotspot.debugger.Address;
              size(): long;
            }
            interface XGranuleMapForPageTable extends CombineTypes<[_XGranuleMapForPageTable, sun.jvm.hotspot.runtime.VMObject]> {}
            interface _XGranuleMapForPageTable$Iterator$$static extends ClassLike {
              new(this$0: XGranuleMapForPageTable): XGranuleMapForPageTable$Iterator;
            }
            let XGranuleMapForPageTable$Iterator: _XGranuleMapForPageTable$Iterator$$static;
            interface _XGranuleMapForPageTable$Iterator {
              _hasNext(): boolean;
              _next(): hotspot.debugger.Address;
              _next: long;
              _this$0: XGranuleMapForPageTable;
            }
            interface XGranuleMapForPageTable$Iterator extends CombineTypes<[_XGranuleMapForPageTable$Iterator, java.lang.Object]> {}
            interface _XHash$$static extends ClassLike {
              _uint32(value: long): long;
              _uint32_to_uint32(key: long): long;
              _new(): XHash;
            }
            let XHash: _XHash$$static;
            interface _XHash {
            }
            interface XHash extends CombineTypes<[_XHash, java.lang.Object]> {}
            interface _XHeap$$static extends ClassLike {
              _initialize(db: hotspot.types.TypeDataBase): void;
              _forwardingTableFieldOffset: long;
              _pageAllocatorFieldOffset: long;
              _pageTableFieldOffset: long;
              _relocateFieldOffset: long;
              new(addr: hotspot.debugger.Address): XHeap;
            }
            let XHeap: _XHeap$$static;
            interface _XHeap {
              capacity(): long;
              _forwardingTable(): XForwardingTable;
              isIn(addr: hotspot.debugger.Address): boolean;
              _is_relocating(o: hotspot.debugger.Address): boolean;
              maxCapacity(): long;
              _pageAllocator(): XPageAllocator;
              _pageTable(): XPageTable;
              printOn(tty: java.io.PrintStream): void;
              _relocate(): XRelocate;
              _relocate_object(addr: hotspot.debugger.Address): hotspot.debugger.Address;
              remapObject(o: hotspot.debugger.Address): hotspot.debugger.Address;
              used(): long;
            }
            interface XHeap extends CombineTypes<[_XHeap, sun.jvm.hotspot.runtime.VMObject]> {}
            interface _XOop$$static extends ClassLike {
              _to_address(oop: hotspot.debugger.OopHandle): hotspot.debugger.Address;
              _new(): XOop;
            }
            let XOop: _XOop$$static;
            interface _XOop {
            }
            interface XOop extends CombineTypes<[_XOop, java.lang.Object]> {}
            interface _XPage$$static extends ClassLike {
              _initialize(db: hotspot.types.TypeDataBase): void;
              _seqnumField: hotspot.types.CIntegerField;
              _topField: hotspot.types.AddressField;
              _typeField: hotspot.types.CIntegerField;
              _virtualFieldOffset: long;
              new(addr: hotspot.debugger.Address): XPage;
            }
            let XPage: _XPage$$static;
            interface _XPage {
              getLiveRegions(): java.util.List<hotspot.memory.MemRegion>;
              _getObjectSize(good: hotspot.debugger.Address): long;
              isIn(addr: hotspot.debugger.Address): boolean;
              _is_relocatable(): boolean;
              _objectAlignmentSize(): long;
              _object_alignment_shift(): long;
              _seqnum(): int;
              _size(): long;
              _start(): long;
              _top(): hotspot.debugger.Address;
              _type(): byte;
              _virtual(): XVirtualMemory;
            }
            interface XPage extends CombineTypes<[_XPage, sun.jvm.hotspot.gc.shared.LiveRegionsProvider, sun.jvm.hotspot.runtime.VMObject]> {}
            interface _XPageAllocator$$static extends ClassLike {
              _initialize(db: hotspot.types.TypeDataBase): void;
              _capacityField: hotspot.types.CIntegerField;
              _maxCapacityField: hotspot.types.CIntegerField;
              _usedField: hotspot.types.CIntegerField;
              new(addr: hotspot.debugger.Address): XPageAllocator;
            }
            let XPageAllocator: _XPageAllocator$$static;
            interface _XPageAllocator {
              capacity(): long;
              maxCapacity(): long;
              used(): long;
            }
            interface XPageAllocator extends CombineTypes<[_XPageAllocator, sun.jvm.hotspot.runtime.VMObject]> {}
            interface _XPageTable$$static extends ClassLike {
              _initialize(db: hotspot.types.TypeDataBase): void;
              _mapFieldOffset: long;
              new(addr: hotspot.debugger.Address): XPageTable;
            }
            let XPageTable: _XPageTable$$static;
            interface _XPageTable {
              activePagesIterator(): java.util.Iterator<XPage>;
              _get(o: hotspot.debugger.Address): XPage;
              _getEntry(o: hotspot.debugger.Address): XPageTableEntry;
              _is_relocating(o: hotspot.debugger.Address): boolean;
              iterator(): java.util.Iterator<XPage>;
              _map(): XGranuleMapForPageTable;
            }
            interface XPageTable extends CombineTypes<[_XPageTable, sun.jvm.hotspot.runtime.VMObject]> {}
            interface _XPageTable$XPageFilter$$static extends ClassLike {
              _new(this$0: XPageTable): XPageTable$XPageFilter;
            }
            let XPageTable$XPageFilter: _XPageTable$XPageFilter$$static;
            interface _XPageTable$XPageFilter {
              accept(a0: XPage): boolean;
(a0: XPage): boolean;
            }
            interface XPageTable$XPageFilter extends CombineTypes<[_XPageTable$XPageFilter, java.lang.Object]> {}
            interface _XPageTable$XPagesFilteredIterator$$static extends ClassLike {
              _new(this$0: XPageTable, filter: XPageTable$XPageFilter): XPageTable$XPagesFilteredIterator;
            }
            let XPageTable$XPagesFilteredIterator: _XPageTable$XPagesFilteredIterator$$static;
            interface _XPageTable$XPagesFilteredIterator {
              hasNext(): boolean;
              next(): XPage;
              next(): any;
              positionToNext(): XPage;
              remove(): void;
              _filter: XPageTable$XPageFilter;
              _iter: XPageTable$XPagesIterator;
              _next: XPage;
              _this$0: XPageTable;
            }
            interface XPageTable$XPagesFilteredIterator extends CombineTypes<[_XPageTable$XPagesFilteredIterator, java.util.Iterator<XPage>, java.lang.Object]> {}
            interface _XPageTable$XPagesIterator$$static extends ClassLike {
              _new(a0: XPageTable): XPageTable$XPagesIterator;
            }
            let XPageTable$XPagesIterator: _XPageTable$XPagesIterator$$static;
            interface _XPageTable$XPagesIterator {
              hasNext(): boolean;
              next(): XPage;
              next(): any;
              _positionToNext(): XPage;
              remove(): void;
              _mapIter: XGranuleMapForPageTable$Iterator;
              _next: XPage;
            }
            interface XPageTable$XPagesIterator extends CombineTypes<[_XPageTable$XPagesIterator, java.util.Iterator<XPage>, java.lang.Object]> {}
            interface _XPageTableEntry$$static extends ClassLike {
              _new(address: hotspot.debugger.Address): XPageTableEntry;
            }
            let XPageTableEntry: _XPageTableEntry$$static;
            interface _XPageTableEntry {
              _isEmpty(): boolean;
              _page(): XPage;
              _relocating(): boolean;
              _zPageBits(): hotspot.debugger.Address;
              _entry: hotspot.debugger.Address;
            }
            interface XPageTableEntry extends CombineTypes<[_XPageTableEntry, java.lang.Object]> {}
            interface _XRelocate$$static extends ClassLike {
              _initialize(db: hotspot.types.TypeDataBase): void;
              new(addr: hotspot.debugger.Address): XRelocate;
            }
            let XRelocate: _XRelocate$$static;
            interface _XRelocate {
              forwardObject(forwarding: XForwarding, from: hotspot.debugger.Address): hotspot.debugger.Address;
              _forwardingFind(forwarding: XForwarding, from: hotspot.debugger.Address): hotspot.debugger.Address;
              _forwardingIndex(forwarding: XForwarding, from: hotspot.debugger.Address): long;
              relocateObject(forwarding: XForwarding, o: hotspot.debugger.Address): hotspot.debugger.Address;
            }
            interface XRelocate extends CombineTypes<[_XRelocate, sun.jvm.hotspot.runtime.VMObject]> {}
            interface _XUtils$$static extends ClassLike {
              _alignUp(size: long, a1: long): long;
              _longToAddress(value: long): hotspot.debugger.Address;
              _new(): XUtils;
            }
            let XUtils: _XUtils$$static;
            interface _XUtils {
            }
            interface XUtils extends CombineTypes<[_XUtils, java.lang.Object]> {}
            interface _XVirtualMemory$$static extends ClassLike {
              _initialize(db: hotspot.types.TypeDataBase): void;
              _endField: hotspot.types.CIntegerField;
              _startField: hotspot.types.CIntegerField;
              new(addr: hotspot.debugger.Address): XVirtualMemory;
            }
            let XVirtualMemory: _XVirtualMemory$$static;
            interface _XVirtualMemory {
              _end(): long;
              _start(): long;
            }
            interface XVirtualMemory extends CombineTypes<[_XVirtualMemory, sun.jvm.hotspot.runtime.VMObject]> {}
          }
          module z {
            interface _ZCollectedHeap$$static extends ClassLike {
              _initialize(db: hotspot.types.TypeDataBase): void;
              _zHeapFieldOffset: long;
              new(addr: hotspot.debugger.Address): ZCollectedHeap;
            }
            let ZCollectedHeap: _ZCollectedHeap$$static;
            interface _ZCollectedHeap {
              capacity(): long;
              createBitMap(size: long): hotspot.utilities.BitMapInterface;
              heap(): ZHeap;
              isInReserved(a: hotspot.debugger.Address): boolean;
              kind(): gc.shared.CollectedHeapName;
              liveRegionsIterate(closure: gc.shared.LiveRegionsClosure): void;
              oopAddressDescription(handle: hotspot.debugger.OopHandle): string;
              oop_load_at(handle: hotspot.debugger.OopHandle, offset: long): hotspot.debugger.OopHandle;
              _oop_load_barrier(oopAddress: hotspot.debugger.Address): hotspot.debugger.OopHandle;
              oop_load_in_native(addr: hotspot.debugger.Address): hotspot.debugger.OopHandle;
              printOn(tty: java.io.PrintStream): void;
              used(): long;
            }
            interface ZCollectedHeap extends CombineTypes<[_ZCollectedHeap, sun.jvm.hotspot.gc.shared.CollectedHeap]> {}
            interface _ZHeap$$static extends ClassLike {
              _initialize(db: hotspot.types.TypeDataBase): void;
              _pageAllocatorFieldOffset: long;
              new(addr: hotspot.debugger.Address): ZHeap;
            }
            let ZHeap: _ZHeap$$static;
            interface _ZHeap {
              capacity(): long;
              maxCapacity(): long;
              _pageAllocator(): ZPageAllocator;
              printOn(tty: java.io.PrintStream): void;
              used(): long;
            }
            interface ZHeap extends CombineTypes<[_ZHeap, sun.jvm.hotspot.runtime.VMObject]> {}
            interface _ZPageAllocator$$static extends ClassLike {
              _initialize(db: hotspot.types.TypeDataBase): void;
              _capacityField: hotspot.types.CIntegerField;
              _maxCapacityField: hotspot.types.CIntegerField;
              _usedField: hotspot.types.CIntegerField;
              new(addr: hotspot.debugger.Address): ZPageAllocator;
            }
            let ZPageAllocator: _ZPageAllocator$$static;
            interface _ZPageAllocator {
              capacity(): long;
              maxCapacity(): long;
              used(): long;
            }
            interface ZPageAllocator extends CombineTypes<[_ZPageAllocator, sun.jvm.hotspot.runtime.VMObject]> {}
          }
        }
        module interpreter {
          interface _Bytecode$$static extends ClassLike {
            _can_use_native_byte_order(bc: int, is_wide: boolean): boolean;
            _comma: string;
            _jintSize: int;
            _spaces: string;
            _new(method: hotspot.oops.Method, bci: int): Bytecode;
          }
          let Bytecode: _Bytecode$$static;
          interface _Bytecode {
            _alignedOffset(offset: int): int;
            bci(): int;
            code(): int;
            getBytecodeName(): string;
            getIndexU1(): int;
            getIndexU1Cpcache(): int;
            getIndexU2(bc: int, isWide: boolean): int;
            getIndexU2Cpcache(): int;
            getIndexU4(): int;
            getJavaBytecodeName(): string;
            getJavaLength(): int;
            getLength(): int;
            hasIndexU4(): boolean;
            _javaByteAt(offset: int): byte;
            javaCode(): int;
            _javaShortAt(offset: int): short;
            _javaSignedWordAt(offset: int): int;
            method(): hotspot.oops.Method;
            toString(): string;
            _bci: int;
            _method: hotspot.oops.Method;
          }
          interface Bytecode extends CombineTypes<[_Bytecode, java.lang.Object]> {}
          interface _BytecodeANewArray$$static extends ClassLike {
            at(method: hotspot.oops.Method, bci: int): BytecodeANewArray;
            at(bcs: BytecodeStream): BytecodeANewArray;
            atCheck(method: hotspot.oops.Method, bci: int): BytecodeANewArray;
            _new(method: hotspot.oops.Method, bci: int): BytecodeANewArray;
          }
          let BytecodeANewArray: _BytecodeANewArray$$static;
          interface _BytecodeANewArray {
            getKlass(): hotspot.oops.Klass;
            isValid(): boolean;
            verify(): void;
          }
          interface BytecodeANewArray extends CombineTypes<[_BytecodeANewArray, sun.jvm.hotspot.interpreter.BytecodeWithKlass]> {}
          interface _BytecodeBipush$$static extends ClassLike {
            at(method: hotspot.oops.Method, bci: int): BytecodeBipush;
            at(bcs: BytecodeStream): BytecodeBipush;
            atCheck(method: hotspot.oops.Method, bci: int): BytecodeBipush;
            _new(method: hotspot.oops.Method, bci: int): BytecodeBipush;
          }
          let BytecodeBipush: _BytecodeBipush$$static;
          interface _BytecodeBipush {
            getValue(): byte;
            isValid(): boolean;
            toString(): string;
            verify(): void;
          }
          interface BytecodeBipush extends CombineTypes<[_BytecodeBipush, sun.jvm.hotspot.interpreter.Bytecode]> {}
          interface _BytecodeCheckCast$$static extends ClassLike {
            at(method: hotspot.oops.Method, bci: int): BytecodeCheckCast;
            at(bcs: BytecodeStream): BytecodeCheckCast;
            atCheck(method: hotspot.oops.Method, bci: int): BytecodeCheckCast;
            _new(method: hotspot.oops.Method, bci: int): BytecodeCheckCast;
          }
          let BytecodeCheckCast: _BytecodeCheckCast$$static;
          interface _BytecodeCheckCast {
            getCheckCastKlass(): hotspot.oops.InstanceKlass;
            isValid(): boolean;
            verify(): void;
          }
          interface BytecodeCheckCast extends CombineTypes<[_BytecodeCheckCast, sun.jvm.hotspot.interpreter.BytecodeWithKlass]> {}
          interface _BytecodeDisassembler$$static extends ClassLike {
            _addBytecodeClass(bytecode: int, clazz: java.lang.Class): void;
            _getBytecodeClass(bytecode: int): java.lang.Class;
            _bytecode2Class: java.util.Map<int,java.lang.Class>;
            new(method: hotspot.oops.Method): BytecodeDisassembler;
          }
          let BytecodeDisassembler: _BytecodeDisassembler$$static;
          interface _BytecodeDisassembler {
            decode(visitor: BytecodeVisitor): void;
            getMethod(): hotspot.oops.Method;
            _method: hotspot.oops.Method;
          }
          interface BytecodeDisassembler extends CombineTypes<[_BytecodeDisassembler, java.lang.Object]> {}
          interface _BytecodeGetField$$static extends ClassLike {
            at(method: hotspot.oops.Method, bci: int): BytecodeGetField;
            at(bcs: BytecodeStream): BytecodeGetField;
            atCheck(method: hotspot.oops.Method, bci: int): BytecodeGetField;
            _new(method: hotspot.oops.Method, bci: int): BytecodeGetField;
          }
          let BytecodeGetField: _BytecodeGetField$$static;
          interface _BytecodeGetField {
            isStatic(): boolean;
            isValid(): boolean;
            verify(): void;
          }
          interface BytecodeGetField extends CombineTypes<[_BytecodeGetField, sun.jvm.hotspot.interpreter.BytecodeGetPut]> {}
          interface _BytecodeGetPut$$static extends ClassLike {
            _new(method: hotspot.oops.Method, bci: int): BytecodeGetPut;
          }
          let BytecodeGetPut: _BytecodeGetPut$$static;
          interface _BytecodeGetPut {
            getField(): hotspot.oops.Field;
            isStatic(): boolean;
(): boolean;
            name(): hotspot.oops.Symbol;
            signature(): hotspot.oops.Symbol;
            toString(): string;
          }
          interface BytecodeGetPut extends CombineTypes<[_BytecodeGetPut, sun.jvm.hotspot.interpreter.BytecodeWithCPIndex]> {}
          interface _BytecodeGetStatic$$static extends ClassLike {
            at(method: hotspot.oops.Method, bci: int): BytecodeGetStatic;
            at(bcs: BytecodeStream): BytecodeGetStatic;
            atCheck(method: hotspot.oops.Method, bci: int): BytecodeGetStatic;
            _new(method: hotspot.oops.Method, bci: int): BytecodeGetStatic;
          }
          let BytecodeGetStatic: _BytecodeGetStatic$$static;
          interface _BytecodeGetStatic {
            isStatic(): boolean;
            isValid(): boolean;
            verify(): void;
          }
          interface BytecodeGetStatic extends CombineTypes<[_BytecodeGetStatic, sun.jvm.hotspot.interpreter.BytecodeGetPut]> {}
          interface _BytecodeGoto$$static extends ClassLike {
            at(method: hotspot.oops.Method, bci: int): BytecodeGoto;
            at(bcs: BytecodeStream): BytecodeGoto;
            atCheck(method: hotspot.oops.Method, bci: int): BytecodeGoto;
            _new(method: hotspot.oops.Method, bci: int): BytecodeGoto;
          }
          let BytecodeGoto: _BytecodeGoto$$static;
          interface _BytecodeGoto {
            getTargetBCI(): int;
            isValid(): boolean;
            verify(): void;
          }
          interface BytecodeGoto extends CombineTypes<[_BytecodeGoto, sun.jvm.hotspot.interpreter.BytecodeJmp]> {}
          interface _BytecodeGotoW$$static extends ClassLike {
            at(method: hotspot.oops.Method, bci: int): BytecodeGotoW;
            at(bcs: BytecodeStream): BytecodeGotoW;
            atCheck(method: hotspot.oops.Method, bci: int): BytecodeGotoW;
            _new(method: hotspot.oops.Method, bci: int): BytecodeGotoW;
          }
          let BytecodeGotoW: _BytecodeGotoW$$static;
          interface _BytecodeGotoW {
            getTargetBCI(): int;
            isValid(): boolean;
            verify(): void;
          }
          interface BytecodeGotoW extends CombineTypes<[_BytecodeGotoW, sun.jvm.hotspot.interpreter.BytecodeJmp]> {}
          interface _BytecodeIf$$static extends ClassLike {
            at(method: hotspot.oops.Method, bci: int): BytecodeIf;
            at(bcs: BytecodeStream): BytecodeIf;
            atCheck(method: hotspot.oops.Method, bci: int): BytecodeIf;
            _new(method: hotspot.oops.Method, bci: int): BytecodeIf;
          }
          let BytecodeIf: _BytecodeIf$$static;
          interface _BytecodeIf {
            getTargetBCI(): int;
            isValid(): boolean;
            verify(): void;
          }
          interface BytecodeIf extends CombineTypes<[_BytecodeIf, sun.jvm.hotspot.interpreter.BytecodeJmp]> {}
          interface _BytecodeIinc$$static extends ClassLike {
            at(method: hotspot.oops.Method, bci: int): BytecodeIinc;
            at(bcs: BytecodeStream): BytecodeIinc;
            atCheck(method: hotspot.oops.Method, bci: int): BytecodeIinc;
            _new(method: hotspot.oops.Method, bci: int): BytecodeIinc;
          }
          let BytecodeIinc: _BytecodeIinc$$static;
          interface _BytecodeIinc {
            getIncrement(): int;
            isValid(): boolean;
            toString(): string;
            verify(): void;
          }
          interface BytecodeIinc extends CombineTypes<[_BytecodeIinc, sun.jvm.hotspot.interpreter.BytecodeWideable]> {}
          interface _BytecodeInstanceOf$$static extends ClassLike {
            at(method: hotspot.oops.Method, bci: int): BytecodeInstanceOf;
            at(bcs: BytecodeStream): BytecodeInstanceOf;
            atCheck(method: hotspot.oops.Method, bci: int): BytecodeInstanceOf;
            _new(method: hotspot.oops.Method, bci: int): BytecodeInstanceOf;
          }
          let BytecodeInstanceOf: _BytecodeInstanceOf$$static;
          interface _BytecodeInstanceOf {
            getInstanceOfKlass(): hotspot.oops.InstanceKlass;
            isValid(): boolean;
            verify(): void;
          }
          interface BytecodeInstanceOf extends CombineTypes<[_BytecodeInstanceOf, sun.jvm.hotspot.interpreter.BytecodeWithKlass]> {}
          interface _BytecodeInvoke$$static extends ClassLike {
            at(method: hotspot.oops.Method, bci: int): BytecodeInvoke;
            at(bcs: BytecodeStream): BytecodeInvoke;
            atCheck(method: hotspot.oops.Method, bci: int): BytecodeInvoke;
            _new(method: hotspot.oops.Method, bci: int): BytecodeInvoke;
          }
          let BytecodeInvoke: _BytecodeInvoke$$static;
          interface _BytecodeInvoke {
            adjustedInvokeCode(): int;
            getInvokedMethod(): hotspot.oops.Method;
            isInvokedynamic(): boolean;
            isInvokeinterface(): boolean;
            isInvokespecial(): boolean;
            isInvokestatic(): boolean;
            isInvokevirtual(): boolean;
            isValid(): boolean;
            name(): hotspot.oops.Symbol;
            resultType(): int;
            signature(): hotspot.oops.Symbol;
            toString(): string;
            verify(): void;
          }
          interface BytecodeInvoke extends CombineTypes<[_BytecodeInvoke, sun.jvm.hotspot.interpreter.BytecodeWithCPIndex]> {}
          interface _BytecodeJmp$$static extends ClassLike {
            _new(method: hotspot.oops.Method, bci: int): BytecodeJmp;
          }
          let BytecodeJmp: _BytecodeJmp$$static;
          interface _BytecodeJmp {
            getTargetBCI(): int;
(): int;
            toString(): string;
          }
          interface BytecodeJmp extends CombineTypes<[_BytecodeJmp, sun.jvm.hotspot.interpreter.Bytecode]> {}
          interface _BytecodeJsr$$static extends ClassLike {
            at(method: hotspot.oops.Method, bci: int): BytecodeJsr;
            at(bcs: BytecodeStream): BytecodeJsr;
            atCheck(method: hotspot.oops.Method, bci: int): BytecodeJsr;
            _new(method: hotspot.oops.Method, bci: int): BytecodeJsr;
          }
          let BytecodeJsr: _BytecodeJsr$$static;
          interface _BytecodeJsr {
            getTargetBCI(): int;
            isValid(): boolean;
            verify(): void;
          }
          interface BytecodeJsr extends CombineTypes<[_BytecodeJsr, sun.jvm.hotspot.interpreter.BytecodeJmp]> {}
          interface _BytecodeJsrW$$static extends ClassLike {
            at(method: hotspot.oops.Method, bci: int): BytecodeJsrW;
            at(bcs: BytecodeStream): BytecodeJsrW;
            atCheck(method: hotspot.oops.Method, bci: int): BytecodeJsrW;
            _new(method: hotspot.oops.Method, bci: int): BytecodeJsrW;
          }
          let BytecodeJsrW: _BytecodeJsrW$$static;
          interface _BytecodeJsrW {
            getTargetBCI(): int;
            isValid(): boolean;
            verify(): void;
          }
          interface BytecodeJsrW extends CombineTypes<[_BytecodeJsrW, sun.jvm.hotspot.interpreter.BytecodeJmp]> {}
          interface _BytecodeLoad$$static extends ClassLike {
            at(method: hotspot.oops.Method, bci: int): BytecodeLoad;
            at(bcs: BytecodeStream): BytecodeLoad;
            atCheck(method: hotspot.oops.Method, bci: int): BytecodeLoad;
            _new(method: hotspot.oops.Method, bci: int): BytecodeLoad;
          }
          let BytecodeLoad: _BytecodeLoad$$static;
          interface _BytecodeLoad {
            isValid(): boolean;
            verify(): void;
          }
          interface BytecodeLoad extends CombineTypes<[_BytecodeLoad, sun.jvm.hotspot.interpreter.BytecodeLoadStore]> {}
          interface _BytecodeLoadConstant$$static extends ClassLike {
            at(method: hotspot.oops.Method, bci: int): BytecodeLoadConstant;
            at(bcs: BytecodeStream): BytecodeLoadConstant;
            atCheck(method: hotspot.oops.Method, bci: int): BytecodeLoadConstant;
            _new(method: hotspot.oops.Method, bci: int): BytecodeLoadConstant;
          }
          let BytecodeLoadConstant: _BytecodeLoadConstant$$static;
          interface _BytecodeLoadConstant {
            cacheIndex(): int;
            _getCachedConstant(): hotspot.oops.Oop;
            getConstantValue(): string;
            getKlass(): any;
            hasCacheIndex(): boolean;
            isKlassConstant(): boolean;
            isValid(): boolean;
            poolIndex(): int;
            _rawIndex(): int;
            resultType(): hotspot.runtime.BasicType;
            toString(): string;
            verify(): void;
          }
          interface BytecodeLoadConstant extends CombineTypes<[_BytecodeLoadConstant, sun.jvm.hotspot.interpreter.Bytecode]> {}
          interface _BytecodeLoadStore$$static extends ClassLike {
            _new(method: hotspot.oops.Method, bci: int): BytecodeLoadStore;
          }
          let BytecodeLoadStore: _BytecodeLoadStore$$static;
          interface _BytecodeLoadStore {
            toString(): string;
          }
          interface BytecodeLoadStore extends CombineTypes<[_BytecodeLoadStore, sun.jvm.hotspot.interpreter.BytecodeWideable]> {}
          interface _BytecodeLookupswitch$$static extends ClassLike {
            at(method: hotspot.oops.Method, bci: int): BytecodeLookupswitch;
            at(bcs: BytecodeStream): BytecodeLookupswitch;
            atCheck(method: hotspot.oops.Method, bci: int): BytecodeLookupswitch;
            _new(method: hotspot.oops.Method, bci: int): BytecodeLookupswitch;
          }
          let BytecodeLookupswitch: _BytecodeLookupswitch$$static;
          interface _BytecodeLookupswitch {
            defaultOffset(): int;
            isValid(): boolean;
            numberOfPairs(): int;
            pairAt(i: int): LookupswitchPair;
            toString(): string;
            verify(): void;
          }
          interface BytecodeLookupswitch extends CombineTypes<[_BytecodeLookupswitch, sun.jvm.hotspot.interpreter.Bytecode]> {}
          interface _BytecodeMultiANewArray$$static extends ClassLike {
            at(method: hotspot.oops.Method, bci: int): BytecodeMultiANewArray;
            at(bcs: BytecodeStream): BytecodeMultiANewArray;
            atCheck(method: hotspot.oops.Method, bci: int): BytecodeMultiANewArray;
            _new(method: hotspot.oops.Method, bci: int): BytecodeMultiANewArray;
          }
          let BytecodeMultiANewArray: _BytecodeMultiANewArray$$static;
          interface _BytecodeMultiANewArray {
            getDimension(): int;
            getKlass(): hotspot.oops.Klass;
            isValid(): boolean;
            toString(): string;
            verify(): void;
          }
          interface BytecodeMultiANewArray extends CombineTypes<[_BytecodeMultiANewArray, sun.jvm.hotspot.interpreter.BytecodeWithKlass]> {}
          interface _BytecodeNew$$static extends ClassLike {
            at(method: hotspot.oops.Method, bci: int): BytecodeNew;
            at(bcs: BytecodeStream): BytecodeNew;
            atCheck(method: hotspot.oops.Method, bci: int): BytecodeNew;
            _new(method: hotspot.oops.Method, bci: int): BytecodeNew;
          }
          let BytecodeNew: _BytecodeNew$$static;
          interface _BytecodeNew {
            getNewKlass(): hotspot.oops.InstanceKlass;
            isValid(): boolean;
            verify(): void;
          }
          interface BytecodeNew extends CombineTypes<[_BytecodeNew, sun.jvm.hotspot.interpreter.BytecodeWithKlass]> {}
          interface _BytecodeNewArray$$static extends ClassLike {
            at(method: hotspot.oops.Method, bci: int): BytecodeNewArray;
            at(bcs: BytecodeStream): BytecodeNewArray;
            atCheck(method: hotspot.oops.Method, bci: int): BytecodeNewArray;
            _new(method: hotspot.oops.Method, bci: int): BytecodeNewArray;
          }
          let BytecodeNewArray: _BytecodeNewArray$$static;
          interface _BytecodeNewArray {
            getType(): int;
            getTypeName(): string;
            isValid(): boolean;
            toString(): string;
            verify(): void;
          }
          interface BytecodeNewArray extends CombineTypes<[_BytecodeNewArray, sun.jvm.hotspot.interpreter.Bytecode]> {}
          interface _BytecodePutField$$static extends ClassLike {
            at(method: hotspot.oops.Method, bci: int): BytecodePutField;
            at(bcs: BytecodeStream): BytecodePutField;
            atCheck(method: hotspot.oops.Method, bci: int): BytecodePutField;
            _new(method: hotspot.oops.Method, bci: int): BytecodePutField;
          }
          let BytecodePutField: _BytecodePutField$$static;
          interface _BytecodePutField {
            isStatic(): boolean;
            isValid(): boolean;
            verify(): void;
          }
          interface BytecodePutField extends CombineTypes<[_BytecodePutField, sun.jvm.hotspot.interpreter.BytecodeGetPut]> {}
          interface _BytecodePutStatic$$static extends ClassLike {
            at(method: hotspot.oops.Method, bci: int): BytecodePutStatic;
            at(bcs: BytecodeStream): BytecodePutStatic;
            atCheck(method: hotspot.oops.Method, bci: int): BytecodePutStatic;
            _new(method: hotspot.oops.Method, bci: int): BytecodePutStatic;
          }
          let BytecodePutStatic: _BytecodePutStatic$$static;
          interface _BytecodePutStatic {
            isStatic(): boolean;
            isValid(): boolean;
            verify(): void;
          }
          interface BytecodePutStatic extends CombineTypes<[_BytecodePutStatic, sun.jvm.hotspot.interpreter.BytecodeGetPut]> {}
          interface _BytecodeRet$$static extends ClassLike {
            at(method: hotspot.oops.Method, bci: int): BytecodeRet;
            at(bcs: BytecodeStream): BytecodeRet;
            atCheck(method: hotspot.oops.Method, bci: int): BytecodeRet;
            _new(method: hotspot.oops.Method, bci: int): BytecodeRet;
          }
          let BytecodeRet: _BytecodeRet$$static;
          interface _BytecodeRet {
            isValid(): boolean;
            toString(): string;
            verify(): void;
          }
          interface BytecodeRet extends CombineTypes<[_BytecodeRet, sun.jvm.hotspot.interpreter.BytecodeWideable]> {}
          interface _BytecodeSipush$$static extends ClassLike {
            at(method: hotspot.oops.Method, bci: int): BytecodeSipush;
            at(bcs: BytecodeStream): BytecodeSipush;
            atCheck(method: hotspot.oops.Method, bci: int): BytecodeSipush;
            _new(method: hotspot.oops.Method, bci: int): BytecodeSipush;
          }
          let BytecodeSipush: _BytecodeSipush$$static;
          interface _BytecodeSipush {
            getValue(): short;
            isValid(): boolean;
            toString(): string;
            verify(): void;
          }
          interface BytecodeSipush extends CombineTypes<[_BytecodeSipush, sun.jvm.hotspot.interpreter.Bytecode]> {}
          interface _BytecodeStore$$static extends ClassLike {
            at(method: hotspot.oops.Method, bci: int): BytecodeStore;
            at(bcs: BytecodeStream): BytecodeStore;
            atCheck(method: hotspot.oops.Method, bci: int): BytecodeStore;
            _new(method: hotspot.oops.Method, bci: int): BytecodeStore;
          }
          let BytecodeStore: _BytecodeStore$$static;
          interface _BytecodeStore {
            isValid(): boolean;
            verify(): void;
          }
          interface BytecodeStore extends CombineTypes<[_BytecodeStore, sun.jvm.hotspot.interpreter.BytecodeLoadStore]> {}
          interface _BytecodeStream$$static extends ClassLike {
            new(method: hotspot.oops.Method): BytecodeStream;
          }
          let BytecodeStream: _BytecodeStream$$static;
          interface _BytecodeStream {
            bci(): int;
            code(): int;
            codeAt(bci: int): int;
            dest(): int;
            dest_w(): int;
            endBCI(): int;
            getIndex(): int;
            getIndexU1(): int;
            getIndexU1Cpcache(): int;
            getIndexU2(): int;
            getIndexU2Cpcache(): int;
            getIndexU4(): int;
            hasIndexU4(): boolean;
            isActiveBreakpoint(): boolean;
            isLastBytecode(): boolean;
            isWide(): boolean;
            method(): hotspot.oops.Method;
            next(): int;
            nextBCI(): int;
            setInterval(beg_bci: int, end_bci: int): void;
            setNextBCI(bci: int): void;
            setStart(beg_bci: int): void;
            __bci: int;
            __code: int;
            __end_bci: int;
            __is_wide: boolean;
            __method: hotspot.oops.Method;
            __next_bci: int;
          }
          interface BytecodeStream extends CombineTypes<[_BytecodeStream, java.lang.Object]> {}
          interface _BytecodeTableswitch$$static extends ClassLike {
            at(method: hotspot.oops.Method, bci: int): BytecodeTableswitch;
            at(bcs: BytecodeStream): BytecodeTableswitch;
            atCheck(method: hotspot.oops.Method, bci: int): BytecodeTableswitch;
            _new(method: hotspot.oops.Method, bci: int): BytecodeTableswitch;
          }
          let BytecodeTableswitch: _BytecodeTableswitch$$static;
          interface _BytecodeTableswitch {
            defaultOffset(): int;
            destOffsetAt(i: int): int;
            highKey(): int;
            isValid(): boolean;
            length(): int;
            lowKey(): int;
            toString(): string;
            verify(): void;
          }
          interface BytecodeTableswitch extends CombineTypes<[_BytecodeTableswitch, sun.jvm.hotspot.interpreter.Bytecode]> {}
          interface _BytecodeVisitor$$static extends ClassLike {
          }
          let BytecodeVisitor: _BytecodeVisitor$$static;
          interface _BytecodeVisitor {
            epilogue(): void;
            prologue(a0: hotspot.oops.Method): void;
            visit(a0: Bytecode): void;
          }
          interface BytecodeVisitor extends CombineTypes<[_BytecodeVisitor, java.lang.Object]> {}
          interface _BytecodeWideable$$static extends ClassLike {
            _new(method: hotspot.oops.Method, bci: int): BytecodeWideable;
          }
          let BytecodeWideable: _BytecodeWideable$$static;
          interface _BytecodeWideable {
            getLocalVarIndex(): int;
            isWide(): boolean;
          }
          interface BytecodeWideable extends CombineTypes<[_BytecodeWideable, sun.jvm.hotspot.interpreter.Bytecode]> {}
          interface _BytecodeWithCPIndex$$static extends ClassLike {
            _new(method: hotspot.oops.Method, bci: int): BytecodeWithCPIndex;
          }
          let BytecodeWithCPIndex: _BytecodeWithCPIndex$$static;
          interface _BytecodeWithCPIndex {
            index(): int;
            _indexForFieldOrMethod(): int;
          }
          interface BytecodeWithCPIndex extends CombineTypes<[_BytecodeWithCPIndex, sun.jvm.hotspot.interpreter.Bytecode]> {}
          interface _BytecodeWithKlass$$static extends ClassLike {
            _new(method: hotspot.oops.Method, bci: int): BytecodeWithKlass;
          }
          let BytecodeWithKlass: _BytecodeWithKlass$$static;
          interface _BytecodeWithKlass {
            getClassName(): hotspot.oops.Symbol;
            _getKlass(): hotspot.oops.Klass;
            toString(): string;
          }
          interface BytecodeWithKlass extends CombineTypes<[_BytecodeWithKlass, sun.jvm.hotspot.interpreter.BytecodeWithCPIndex]> {}
          interface _Bytecodes$$static extends ClassLike {
            canRewrite(code: int): boolean;
            canTrap(code: int): boolean;
            check(code: int): void;
            codeAt(method: hotspot.oops.Method, bci: int): int;
            codeOrBPAt(method: hotspot.oops.Method, bci: int): int;
            _compute_flags(format: string): char;
            _compute_flags(format: string, more_flags: int): char;
            _def(code: int, name: string, format: string, wide_format: string, result_type: int, depth: int, can_trap: boolean): void;
            _def(code: int, name: string, format: string, wide_format: string, result_type: int, depth: int, can_trap: boolean, java_code: int): void;
            depth(code: int): int;
            _flags(code: int, is_wide: boolean): int;
            format(code: int): string;
            _format_bits(code: int, is_wide: boolean): int;
            _has_all_flags(code: int, test_flags: int, is_wide: boolean): boolean;
            _initialize(): void;
            isActiveBreakpointAt(method: hotspot.oops.Method, bci: int): boolean;
            isAload(code: int): boolean;
            isAstore(code: int): boolean;
            isDefined(code: int): boolean;
            isFastCode(code: int): boolean;
            isJavaCode(code: int): boolean;
            isZeroConst(code: int): boolean;
            javaCode(code: int): int;
            javaLengthAt(method: hotspot.oops.Method, bci: int): int;
            lengthAt(method: hotspot.oops.Method, bci: int): int;
            lengthFor(code: int): int;
            name(code: int): string;
            native_byte_order(code: int): boolean;
            resultType(code: int): int;
            specialLengthAt(method: hotspot.oops.Method, bci: int): int;
            uses_cp_cache(code: int): boolean;
            wideCheck(code: int): void;
            wideFormat(code: int): string;
            wideIsDefined(code: int): boolean;
            wideLengthFor(code: int): int;
            readonly _aaload: int;
            readonly _aastore: int;
            readonly _aconst_null: int;
            __all_fmt_bits: int;
            readonly _aload: int;
            readonly _aload_0: int;
            readonly _aload_1: int;
            readonly _aload_2: int;
            readonly _aload_3: int;
            readonly _anewarray: int;
            readonly _areturn: int;
            readonly _arraylength: int;
            readonly _astore: int;
            readonly _astore_0: int;
            readonly _astore_1: int;
            readonly _astore_2: int;
            readonly _astore_3: int;
            readonly _athrow: int;
            readonly _baload: int;
            readonly _bastore: int;
            __bc_can_rewrite: int;
            __bc_can_trap: int;
            readonly _bipush: int;
            readonly _breakpoint: int;
            readonly _caload: int;
            readonly _castore: int;
            readonly _checkcast: int;
            readonly _d2f: int;
            readonly _d2i: int;
            readonly _d2l: int;
            readonly _dadd: int;
            readonly _daload: int;
            readonly _dastore: int;
            readonly _dcmpg: int;
            readonly _dcmpl: int;
            readonly _dconst_0: int;
            readonly _dconst_1: int;
            readonly _ddiv: int;
            __depth: byte[];
            readonly _dload: int;
            readonly _dload_0: int;
            readonly _dload_1: int;
            readonly _dload_2: int;
            readonly _dload_3: int;
            readonly _dmul: int;
            readonly _dneg: int;
            readonly _drem: int;
            readonly _dreturn: int;
            readonly _dstore: int;
            readonly _dstore_0: int;
            readonly _dstore_1: int;
            readonly _dstore_2: int;
            readonly _dstore_3: int;
            readonly _dsub: int;
            readonly _dup: int;
            readonly _dup2: int;
            readonly _dup2_x1: int;
            readonly _dup2_x2: int;
            readonly _dup_x1: int;
            readonly _dup_x2: int;
            readonly _f2d: int;
            readonly _f2i: int;
            readonly _f2l: int;
            readonly _fadd: int;
            readonly _faload: int;
            readonly _fast_aaccess_0: int;
            readonly _fast_agetfield: int;
            readonly _fast_aldc: int;
            readonly _fast_aldc_w: int;
            readonly _fast_aload_0: int;
            readonly _fast_aputfield: int;
            readonly _fast_bgetfield: int;
            readonly _fast_binaryswitch: int;
            readonly _fast_bputfield: int;
            readonly _fast_cgetfield: int;
            readonly _fast_cputfield: int;
            readonly _fast_dgetfield: int;
            readonly _fast_dputfield: int;
            readonly _fast_faccess_0: int;
            readonly _fast_fgetfield: int;
            readonly _fast_fputfield: int;
            readonly _fast_iaccess_0: int;
            readonly _fast_icaload: int;
            readonly _fast_igetfield: int;
            readonly _fast_iload: int;
            readonly _fast_iload2: int;
            readonly _fast_invokevfinal: int;
            readonly _fast_iputfield: int;
            readonly _fast_lgetfield: int;
            readonly _fast_linearswitch: int;
            readonly _fast_lputfield: int;
            readonly _fast_sgetfield: int;
            readonly _fast_sputfield: int;
            readonly _fast_zputfield: int;
            readonly _fastore: int;
            readonly _fcmpg: int;
            readonly _fcmpl: int;
            readonly _fconst_0: int;
            readonly _fconst_1: int;
            readonly _fconst_2: int;
            readonly _fdiv: int;
            __flags: char[];
            readonly _fload: int;
            readonly _fload_0: int;
            readonly _fload_1: int;
            readonly _fload_2: int;
            readonly _fload_3: int;
            __fmt_b: int;
            __fmt_bJJ: int;
            __fmt_bc: int;
            __fmt_bi: int;
            __fmt_bkk: int;
            __fmt_bo2: int;
            __fmt_bo4: int;
            __fmt_has_c: int;
            __fmt_has_i: int;
            __fmt_has_j: int;
            __fmt_has_k: int;
            __fmt_has_nbo: int;
            __fmt_has_o: int;
            __fmt_has_u2: int;
            __fmt_has_u4: int;
            __fmt_not_simple: int;
            __fmt_not_variable: int;
            readonly _fmul: int;
            readonly _fneg: int;
            __format: string[];
            readonly _frem: int;
            readonly _freturn: int;
            readonly _fstore: int;
            readonly _fstore_0: int;
            readonly _fstore_1: int;
            readonly _fstore_2: int;
            readonly _fstore_3: int;
            readonly _fsub: int;
            readonly _getfield: int;
            readonly _getstatic: int;
            readonly _goto: int;
            readonly _goto_w: int;
            readonly _i2b: int;
            readonly _i2c: int;
            readonly _i2d: int;
            readonly _i2f: int;
            readonly _i2l: int;
            readonly _i2s: int;
            readonly _iadd: int;
            readonly _iaload: int;
            readonly _iand: int;
            readonly _iastore: int;
            readonly _iconst_0: int;
            readonly _iconst_1: int;
            readonly _iconst_2: int;
            readonly _iconst_3: int;
            readonly _iconst_4: int;
            readonly _iconst_5: int;
            readonly _iconst_m1: int;
            readonly _idiv: int;
            readonly _if_acmpeq: int;
            readonly _if_acmpne: int;
            readonly _if_icmpeq: int;
            readonly _if_icmpge: int;
            readonly _if_icmpgt: int;
            readonly _if_icmple: int;
            readonly _if_icmplt: int;
            readonly _if_icmpne: int;
            readonly _ifeq: int;
            readonly _ifge: int;
            readonly _ifgt: int;
            readonly _ifle: int;
            readonly _iflt: int;
            readonly _ifne: int;
            readonly _ifnonnull: int;
            readonly _ifnull: int;
            readonly _iinc: int;
            readonly _illegal: int;
            readonly _iload: int;
            readonly _iload_0: int;
            readonly _iload_1: int;
            readonly _iload_2: int;
            readonly _iload_3: int;
            readonly _imul: int;
            readonly _ineg: int;
            readonly _instanceof: int;
            readonly _invokedynamic: int;
            readonly _invokehandle: int;
            readonly _invokeinterface: int;
            readonly _invokespecial: int;
            readonly _invokestatic: int;
            readonly _invokevirtual: int;
            readonly _ior: int;
            readonly _irem: int;
            readonly _ireturn: int;
            readonly _ishl: int;
            readonly _ishr: int;
            readonly _istore: int;
            readonly _istore_0: int;
            readonly _istore_1: int;
            readonly _istore_2: int;
            readonly _istore_3: int;
            readonly _isub: int;
            readonly _iushr: int;
            readonly _ixor: int;
            __java_code: int[];
            readonly _jsr: int;
            readonly _jsr_w: int;
            readonly _l2d: int;
            readonly _l2f: int;
            readonly _l2i: int;
            readonly _ladd: int;
            readonly _laload: int;
            readonly _land: int;
            readonly _lastore: int;
            readonly _lcmp: int;
            readonly _lconst_0: int;
            readonly _lconst_1: int;
            readonly _ldc: int;
            readonly _ldc2_w: int;
            readonly _ldc_w: int;
            readonly _ldiv: int;
            __lengths: byte[];
            readonly _lload: int;
            readonly _lload_0: int;
            readonly _lload_1: int;
            readonly _lload_2: int;
            readonly _lload_3: int;
            readonly _lmul: int;
            readonly _lneg: int;
            readonly _lookupswitch: int;
            readonly _lor: int;
            readonly _lrem: int;
            readonly _lreturn: int;
            readonly _lshl: int;
            readonly _lshr: int;
            readonly _lstore: int;
            readonly _lstore_0: int;
            readonly _lstore_1: int;
            readonly _lstore_2: int;
            readonly _lstore_3: int;
            readonly _lsub: int;
            readonly _lushr: int;
            readonly _lxor: int;
            readonly _monitorenter: int;
            readonly _monitorexit: int;
            readonly _multianewarray: int;
            __name: string[];
            readonly _new: int;
            readonly _newarray: int;
            readonly _nofast_aload_0: int;
            readonly _nofast_getfield: int;
            readonly _nofast_iload: int;
            readonly _nofast_putfield: int;
            readonly _nop: int;
            readonly _pop: int;
            readonly _pop2: int;
            readonly _putfield: int;
            readonly _putstatic: int;
            __result_type: int[];
            readonly _ret: int;
            readonly _return: int;
            readonly _return_register_finalizer: int;
            readonly _saload: int;
            readonly _sastore: int;
            readonly _shouldnotreachhere: int;
            readonly _sipush: int;
            readonly _swap: int;
            readonly _tableswitch: int;
            readonly _wide: int;
            __wide_format: string[];
            _jintSize: int;
            readonly number_of_codes: int;
            readonly number_of_java_codes: int;
            new(): Bytecodes;
          }
          let Bytecodes: _Bytecodes$$static;
          interface _Bytecodes {
          }
          interface Bytecodes extends CombineTypes<[_Bytecodes, java.lang.Object]> {}
          interface _Interpreter$$static extends ClassLike {
            _initialize(db: hotspot.types.TypeDataBase): void;
            _codeField: hotspot.types.AddressField;
            new(): Interpreter;
          }
          let Interpreter: _Interpreter$$static;
          interface _Interpreter {
            contains(pc: hotspot.debugger.Address): boolean;
            getCode(): hotspot.code.StubQueue;
            getCodeletContaining(pc: hotspot.debugger.Address): InterpreterCodelet;
          }
          interface Interpreter extends CombineTypes<[_Interpreter, java.lang.Object]> {}
          interface _InterpreterCodelet$$static extends ClassLike {
            _initialize(db: hotspot.types.TypeDataBase): void;
            _bytecodeField: hotspot.types.CIntegerField;
            _descriptionField: hotspot.types.AddressField;
            _instanceSize: long;
            _sizeField: hotspot.types.CIntegerField;
            new(addr: hotspot.debugger.Address): InterpreterCodelet;
          }
          let InterpreterCodelet: _InterpreterCodelet$$static;
          interface _InterpreterCodelet {
            codeBegin(): hotspot.debugger.Address;
            codeEnd(): hotspot.debugger.Address;
            codeSize(): long;
            getDescription(): string;
            getSize(): long;
            printOn(tty: java.io.PrintStream): void;
            verify(): void;
          }
          interface InterpreterCodelet extends CombineTypes<[_InterpreterCodelet, sun.jvm.hotspot.code.Stub]> {}
          interface _LookupswitchPair$$static extends ClassLike {
            _new(method: hotspot.oops.Method, bci: int): LookupswitchPair;
          }
          let LookupswitchPair: _LookupswitchPair$$static;
          interface _LookupswitchPair {
            match(): int;
            offset(): int;
          }
          interface LookupswitchPair extends CombineTypes<[_LookupswitchPair, sun.jvm.hotspot.interpreter.Bytecode]> {}
          interface _MaskFillerForNative$$static extends ClassLike {
            _new(method: hotspot.oops.Method, mask: hotspot.utilities.BitMap, maskSize: int): MaskFillerForNative;
          }
          let MaskFillerForNative: _MaskFillerForNative$$static;
          interface _MaskFillerForNative {
            generate(): void;
            passDouble(): void;
            passFloat(): void;
            passInt(): void;
            passLong(): void;
            passObject(): void;
            _mask: hotspot.utilities.BitMap;
            _size: int;
          }
          interface MaskFillerForNative extends CombineTypes<[_MaskFillerForNative, sun.jvm.hotspot.runtime.NativeSignatureIterator]> {}
          interface _OffsetClosure$$static extends ClassLike {
          }
          let OffsetClosure: _OffsetClosure$$static;
          interface _OffsetClosure {
            offsetDo(a0: int): void;
(a0: int): void;
          }
          interface OffsetClosure extends CombineTypes<[_OffsetClosure, java.lang.Object]> {}
          interface _OopMapCacheEntry$$static extends ClassLike {
            new(): OopMapCacheEntry;
          }
          let OopMapCacheEntry: _OopMapCacheEntry$$static;
          interface _OopMapCacheEntry {
            _allocateBitMask(): void;
            _bci(): int;
            _entryAt(offset: int): boolean;
            fill(method: hotspot.oops.Method, bci: int): void;
            _fillForNative(): void;
            isOop(offset: int): boolean;
            isValue(offset: int): boolean;
            iterateOop(oopClosure: OffsetClosure): void;
            _method(): hotspot.oops.Method;
            _numberOfEntries(): int;
            _setEmptyMask(): void;
            setMask(vars: hotspot.oops.CellTypeStateList, stack: hotspot.oops.CellTypeStateList, stackTop: int): void;
            _verifyMask(vars: hotspot.oops.CellTypeStateList, stack: hotspot.oops.CellTypeStateList, maxLocals: int, stackTop: int): boolean;
            _bci: int;
            _mask: hotspot.utilities.BitMap;
            _maskSize: int;
            _method: hotspot.oops.Method;
          }
          interface OopMapCacheEntry extends CombineTypes<[_OopMapCacheEntry, java.lang.Object]> {}
          interface _OopMapCacheEntry$VerifyClosure$$static extends ClassLike {
            _new(entry: OopMapCacheEntry): OopMapCacheEntry$VerifyClosure;
          }
          let OopMapCacheEntry$VerifyClosure: _OopMapCacheEntry$VerifyClosure$$static;
          interface _OopMapCacheEntry$VerifyClosure {
            _failed(): boolean;
            offsetDo(offset: int): void;
            _entry: OopMapCacheEntry;
            _failed: boolean;
          }
          interface OopMapCacheEntry$VerifyClosure extends CombineTypes<[_OopMapCacheEntry$VerifyClosure, sun.jvm.hotspot.interpreter.OffsetClosure, java.lang.Object]> {}
          interface _OopMapForCacheEntry$$static extends ClassLike {
            _new(method: hotspot.oops.Method, bci: int, entry: OopMapCacheEntry): OopMapForCacheEntry;
          }
          let OopMapForCacheEntry: _OopMapForCacheEntry$$static;
          interface _OopMapForCacheEntry {
            computeMap(): void;
            fillInitVars(initVars: java.util.List<int>): void;
            fillStackmapEpilog(): void;
            fillStackmapForOpcodes(bcs: BytecodeStream, vars: hotspot.oops.CellTypeStateList, stack: hotspot.oops.CellTypeStateList, stackTop: int): void;
            fillStackmapProlog(nof_gc_points: int): void;
            possibleGCPoint(bcs: BytecodeStream): boolean;
            reportResults(): boolean;
            size(): int;
            _bci: int;
            _entry: OopMapCacheEntry;
            _stackTop: int;
          }
          interface OopMapForCacheEntry extends CombineTypes<[_OopMapForCacheEntry, sun.jvm.hotspot.oops.GenerateOopMap]> {}
        }
        module memory {
          interface _CodeHeap$$static extends ClassLike {
            _initialize(db: hotspot.types.TypeDataBase): void;
            _log2SegmentSizeField: hotspot.types.CIntegerField;
            _memoryField: hotspot.types.Field;
            _segmapField: hotspot.types.Field;
            new(addr: hotspot.debugger.Address): CodeHeap;
          }
          let CodeHeap: _CodeHeap$$static;
          interface _CodeHeap {
            begin(): hotspot.debugger.Address;
            _blockBase(p: hotspot.debugger.Address): hotspot.debugger.Address;
            _blockStart(p: hotspot.debugger.Address): HeapBlock;
            contains(p: hotspot.debugger.Address): boolean;
            end(): hotspot.debugger.Address;
            findStart(p: hotspot.debugger.Address): hotspot.debugger.Address;
            _getBlockAt(addr: hotspot.debugger.Address): HeapBlock;
            _getLog2SegmentSize(): int;
            _getMemory(): VirtualSpace;
            _getSegmentMap(): VirtualSpace;
            iterate(visitor: hotspot.code.CodeCacheVisitor, cache: hotspot.code.CodeCache): void;
            _nextBlock(ptr: hotspot.debugger.Address): hotspot.debugger.Address;
            _segmentFor(p: hotspot.debugger.Address): long;
            _log2SegmentSize: int;
            _memory: VirtualSpace;
            _segmentMap: VirtualSpace;
          }
          interface CodeHeap extends CombineTypes<[_CodeHeap, sun.jvm.hotspot.runtime.VMObject]> {}
          interface _FileMapInfo$$static extends ClassLike {
            _getStatic_AddressField(type: hotspot.types.Type, fieldName: string): hotspot.debugger.Address;
            _get_AddressField(type: hotspot.types.Type, instance: hotspot.debugger.Address, fieldName: string): hotspot.debugger.Address;
            _get_CDSFileMapRegion(FileMapHeader_type: hotspot.types.Type, header: hotspot.debugger.Address, index: int): hotspot.debugger.Address;
            _get_CIntegerField(type: hotspot.types.Type, instance: hotspot.debugger.Address, fieldName: string): long;
            _initialize(db: hotspot.types.TypeDataBase): void;
            _populateMetadataTypeArray(db: hotspot.types.TypeDataBase): void;
            _headerObj: FileMapInfo$FileMapHeader;
            _metadataTypeArray: hotspot.types.Type[];
            _rwRegionBaseAddress: hotspot.debugger.Address;
            _rwRegionEndAddress: hotspot.debugger.Address;
            _vTableTypeMap: java.util.Map<hotspot.debugger.Address,hotspot.types.Type>;
            _vtablesIndex: hotspot.debugger.Address;
            new(): FileMapInfo;
          }
          let FileMapInfo: _FileMapInfo$$static;
          interface _FileMapInfo {
            getHeader(): FileMapInfo$FileMapHeader;
            getTypeForVptrAddress(vptrAddress: hotspot.debugger.Address): hotspot.types.Type;
            inCopiedVtableSpace(vptrAddress: hotspot.debugger.Address): boolean;
          }
          interface FileMapInfo extends CombineTypes<[_FileMapInfo, java.lang.Object]> {}
          interface _FileMapInfo$FileMapHeader$$static extends ClassLike {
            new(addr: hotspot.debugger.Address): FileMapInfo$FileMapHeader;
          }
          let FileMapInfo$FileMapHeader: _FileMapInfo$FileMapHeader$$static;
          interface _FileMapInfo$FileMapHeader {
            createVtableTypeMapping(): void;
            inCopiedVtableSpace(vptrAddress: hotspot.debugger.Address): boolean;
          }
          interface FileMapInfo$FileMapHeader extends CombineTypes<[_FileMapInfo$FileMapHeader, sun.jvm.hotspot.runtime.VMObject]> {}
          interface _HeapBlock$$static extends ClassLike {
            _initialize(db: hotspot.types.TypeDataBase): void;
            _headerField: hotspot.types.Field;
            _headerLengthField: hotspot.types.CIntegerField;
            _headerUsedField: hotspot.types.CIntegerField;
            _heapBlockSize: long;
            new(addr: hotspot.debugger.Address): HeapBlock;
          }
          let HeapBlock: _HeapBlock$$static;
          interface _HeapBlock {
            getAllocatedSpace(): hotspot.debugger.Address;
            _getHeader(): HeapBlock$Header;
            getLength(): long;
            isFree(): boolean;
          }
          interface HeapBlock extends CombineTypes<[_HeapBlock, sun.jvm.hotspot.runtime.VMObject]> {}
          interface _HeapBlock$Header$$static extends ClassLike {
            new(addr: hotspot.debugger.Address): HeapBlock$Header;
          }
          let HeapBlock$Header: _HeapBlock$Header$$static;
          interface _HeapBlock$Header {
            getLength(): long;
            isFree(): boolean;
          }
          interface HeapBlock$Header extends CombineTypes<[_HeapBlock$Header, sun.jvm.hotspot.runtime.VMObject]> {}
          interface _MemRegion$$static extends ClassLike {
            _initialize(db: hotspot.types.TypeDataBase): void;
            _startField: hotspot.types.AddressField;
            _wordSizeField: hotspot.types.CIntegerField;
            new(): MemRegion;
            new(memRegionAddr: hotspot.debugger.Address): MemRegion;
            new(start: hotspot.debugger.Address, wordSize: long): MemRegion;
            new(start: hotspot.debugger.Address, limit: hotspot.debugger.Address): MemRegion;
          }
          let MemRegion: _MemRegion$$static;
          interface _MemRegion {
            byteSize(): long;
            clone(): any;
            contains(mr2: MemRegion): boolean;
            contains(addr: hotspot.debugger.Address): boolean;
            copy(): MemRegion;
            end(): hotspot.debugger.Address;
            endAsOopHandle(): hotspot.debugger.OopHandle;
            intersection(mr2: MemRegion): MemRegion;
            setEnd(end: hotspot.debugger.Address): void;
            setStart(start: hotspot.debugger.Address): void;
            setWordSize(wordSize: long): void;
            start(): hotspot.debugger.Address;
            startAsOopHandle(): hotspot.debugger.OopHandle;
            union(mr2: MemRegion): MemRegion;
            wordSize(): long;
            _byteSize: long;
            _start: hotspot.debugger.Address;
          }
          interface MemRegion extends CombineTypes<[_MemRegion, java.lang.Cloneable, java.lang.Object]> {}
          interface _MetaspaceObj$$static extends ClassLike {
            _initialize(db: hotspot.types.TypeDataBase): void;
            isShared(addr: hotspot.debugger.Address): boolean;
            _sharedMetaspaceBaseAddr: hotspot.debugger.Address;
            _sharedMetaspaceTopAddr: hotspot.debugger.Address;
            new(): MetaspaceObj;
          }
          let MetaspaceObj: _MetaspaceObj$$static;
          interface _MetaspaceObj {
          }
          interface MetaspaceObj extends CombineTypes<[_MetaspaceObj, java.lang.Object]> {}
          interface _ReferenceType$$static extends ClassLike {
            valueOf(name: string): ReferenceType;
            values(): ReferenceType[];
            readonly REF_FINAL: ReferenceType;
            readonly REF_NONE: ReferenceType;
            readonly REF_PHANTOM: ReferenceType;
            readonly REF_SOFT: ReferenceType;
            readonly REF_WEAK: ReferenceType;
          }
          let ReferenceType: _ReferenceType$$static;
          interface _ReferenceType {
            value(): string;
            _value: string;
          }
          interface ReferenceType extends CombineTypes<[_ReferenceType]> {}
          interface _SystemDictionary$$static extends ClassLike {
            _VM_CLASS_AT(name: string): string;
            _VM_CLASS_ID(kname: string): string;
            __VM_CLASS_ENUM(kname: string): string;
            getClassLoaderKlass(): hotspot.oops.InstanceKlass;
            getMethodHandleKlass(): hotspot.oops.InstanceKlass;
            getObjectKlass(): hotspot.oops.InstanceKlass;
            getStringKlass(): hotspot.oops.InstanceKlass;
            getSystemKlass(): hotspot.oops.InstanceKlass;
            getThreadFieldHolderKlass(): hotspot.oops.InstanceKlass;
            getThreadKlass(): hotspot.oops.InstanceKlass;
            _initialize(db: hotspot.types.TypeDataBase): void;
            _newOop(handle: hotspot.debugger.OopHandle): hotspot.oops.Oop;
            _classLoaderKlassField: hotspot.types.AddressField;
            _methodHandleKlassField: hotspot.types.AddressField;
            _objectKlassField: hotspot.types.AddressField;
            _stringKlassField: hotspot.types.AddressField;
            _systemKlassField: hotspot.types.AddressField;
            _threadFieldHolderKlassField: hotspot.types.AddressField;
            _threadKlassField: hotspot.types.AddressField;
            new(): SystemDictionary;
          }
          let SystemDictionary: _SystemDictionary$$static;
          interface _SystemDictionary {
            getAbstractOwnableSynchronizerKlass(): hotspot.oops.InstanceKlass;
          }
          interface SystemDictionary extends CombineTypes<[_SystemDictionary, java.lang.Object]> {}
          interface _Universe$$static extends ClassLike {
            _addHeapTypeIfInDB(db: hotspot.types.TypeDataBase, heapClass: java.lang.Class<hotspot.runtime.VMObject>): void;
            elementTypeShouldBeAligned(type: hotspot.runtime.BasicType): boolean;
            fieldTypeShouldBeAligned(type: hotspot.runtime.BasicType): boolean;
            _initialize(db: hotspot.types.TypeDataBase): void;
            _typeExists(db: hotspot.types.TypeDataBase, type: string): boolean;
            _collectedHeapField: hotspot.types.AddressField;
            _heapConstructor: hotspot.runtime.VirtualConstructor;
            new(): Universe;
          }
          let Universe: _Universe$$static;
          interface _Universe {
            heap(): hotspot.gc.shared.CollectedHeap;
            isIn(p: hotspot.debugger.Address): boolean;
            isInReserved(p: hotspot.debugger.Address): boolean;
            print(): void;
            printOn(tty: java.io.PrintStream): void;
          }
          interface Universe extends CombineTypes<[_Universe, java.lang.Object]> {}
          interface _UniverseExt$$static extends ClassLike {
            initialize(heapConstructor: hotspot.runtime.VirtualConstructor): void;
            new(): UniverseExt;
          }
          let UniverseExt: _UniverseExt$$static;
          interface _UniverseExt {
          }
          interface UniverseExt extends CombineTypes<[_UniverseExt, java.lang.Object]> {}
          interface _VirtualSpace$$static extends ClassLike {
            _initialize(db: hotspot.types.TypeDataBase): void;
            _highBoundaryField: hotspot.types.AddressField;
            _highField: hotspot.types.AddressField;
            _lowBoundaryField: hotspot.types.AddressField;
            _lowField: hotspot.types.AddressField;
            new(addr: hotspot.debugger.Address): VirtualSpace;
          }
          let VirtualSpace: _VirtualSpace$$static;
          interface _VirtualSpace {
            committedSize(): long;
            contains(addr: hotspot.debugger.Address): boolean;
            high(): hotspot.debugger.Address;
            highBoundary(): hotspot.debugger.Address;
            low(): hotspot.debugger.Address;
            lowBoundary(): hotspot.debugger.Address;
            reservedSize(): long;
            uncommittedSize(): long;
          }
          interface VirtualSpace extends CombineTypes<[_VirtualSpace, sun.jvm.hotspot.runtime.VMObject]> {}
        }
        module oops {
          interface _AccessFlags$$static extends ClassLike {
            new(flags: long): AccessFlags;
          }
          let AccessFlags: _AccessFlags$$static;
          interface _AccessFlags {
            getStandardFlags(): int;
            getValue(): long;
            hasFinalizer(): boolean;
            isAbstract(): boolean;
            isAnnotation(): boolean;
            isBridge(): boolean;
            isCloneable(): boolean;
            isEnum(): boolean;
            isFinal(): boolean;
            isInterface(): boolean;
            isNative(): boolean;
            isPrivate(): boolean;
            isProtected(): boolean;
            isPublic(): boolean;
            isStatic(): boolean;
            isStrict(): boolean;
            isSuper(): boolean;
            isSynchronized(): boolean;
            isSynthetic(): boolean;
            isTransient(): boolean;
            isVarArgs(): boolean;
            isVolatile(): boolean;
            printOn(tty: java.io.PrintStream): void;
            _flags: long;
          }
          interface AccessFlags extends CombineTypes<[_AccessFlags, sun.jvm.hotspot.runtime.ClassConstants, java.lang.Object]> {}
          interface _ArgInfoData$$static extends ClassLike {
            new(layout: DataLayout): ArgInfoData;
          }
          let ArgInfoData: _ArgInfoData$$static;
          interface _ArgInfoData {
            _argModified(arg: int): int;
            cellCount(): int;
            _numberOfArgs(): int;
            printDataOn(st: java.io.PrintStream): void;
          }
          interface ArgInfoData extends CombineTypes<[_ArgInfoData, sun.jvm.hotspot.oops.ArrayData]> {}
          interface _Array$$static extends ClassLike {
            baseOffsetInBytes(type: hotspot.runtime.BasicType): long;
            _headerSize(type: hotspot.runtime.BasicType): long;
            _headerSizeInBytes(): long;
            _initialize(db: hotspot.types.TypeDataBase): void;
            _headerSize: long;
            _lengthOffsetInBytes: long;
            _typeSize: long;
            _new(handle: hotspot.debugger.OopHandle, heap: ObjectHeap): Array;
          }
          let Array: _Array$$static;
          interface _Array {
            getLength(): long;
            getObjectSize(): long;
            isArray(): boolean;
            iterateFields(visitor: OopVisitor, doVMFields: boolean): void;
            _lengthOffsetInBytes(): long;
          }
          interface Array extends CombineTypes<[_Array, sun.jvm.hotspot.oops.Oop]> {}
          interface _ArrayData$$static extends ClassLike {
            _arrayElementOffset(index: int): int;
            _arrayLenOffset(): int;
            _arrayStartOffset(): int;
            _staticCellCount(): int;
            _arrayLenOffSet: int;
            _arrayStartOffSet: int;
            _new(layout: DataLayout): ArrayData;
          }
          let ArrayData: _ArrayData$$static;
          interface _ArrayData {
            _arrayIntAt(index: int): int;
            _arrayLen(): int;
            _arrayUintAt(index: int): int;
            cellCount(): int;
          }
          interface ArrayData extends CombineTypes<[_ArrayData, sun.jvm.hotspot.oops.ProfileData]> {}
          interface _ArrayKlass$$static extends ClassLike {
            _initialize(db: hotspot.types.TypeDataBase): void;
            _javaIoSerializableName(): string;
            _javaLangCloneableName(): string;
            _javaLangObjectName(): string;
            _dimension: CIntField;
            _higherDimension: MetadataField;
            _javaIoSerializableName: string;
            _javaLangCloneableName: string;
            _javaLangObjectName: string;
            _lowerDimension: MetadataField;
            new(addr: hotspot.debugger.Address): ArrayKlass;
          }
          let ArrayKlass: _ArrayKlass$$static;
          interface _ArrayKlass {
            computeModifierFlags(): long;
            _computeSubtypeOf(k: Klass): boolean;
            getArrayHeaderInBytes(): long;
            getClassStatus(): int;
            getDimension(): long;
            getElementType(): int;
            getHigherDimension(): Klass;
            getJavaSuper(): Klass;
            getLog2ElementSize(): int;
            getLowerDimension(): Klass;
            isArrayKlass(): boolean;
            iterateFields(visitor: MetadataVisitor): void;
            printValueOn(tty: java.io.PrintStream): void;
          }
          interface ArrayKlass extends CombineTypes<[_ArrayKlass, sun.jvm.hotspot.oops.Klass]> {}
          interface _BitData$$static extends ClassLike {
            _bitDataSize(): int;
            _staticCellCount(): int;
            _bitCellCount: int;
            _nullSeenFlag: int;
            new(layout: DataLayout): BitData;
          }
          let BitData: _BitData$$static;
          interface _BitData {
            cellCount(): int;
            _nullSeen(): boolean;
            printDataOn(st: java.io.PrintStream): void;
          }
          interface BitData extends CombineTypes<[_BitData, sun.jvm.hotspot.oops.ProfileData]> {}
          interface _BooleanField$$static extends ClassLike {
            new(id: FieldIdentifier, offset: long, a2: boolean): BooleanField;
            new(vmField: hotspot.types.JBooleanField, startOffset: long): BooleanField;
            new(holder: InstanceKlass, fieldArrayIndex: int): BooleanField;
          }
          let BooleanField: _BooleanField$$static;
          interface _BooleanField {
            getValue(obj: Oop): boolean;
            getValue(obj: hotspot.runtime.VMObject): boolean;
            setValue(obj: Oop, value: boolean): void;
          }
          interface BooleanField extends CombineTypes<[_BooleanField, sun.jvm.hotspot.oops.Field]> {}
          interface _BranchData$$static extends ClassLike {
            _branchDataSize(): int;
            _notTakenOffset(): int;
            _staticCellCount(): int;
            _branchCellCount: int;
            _notTakenOffSet: int;
            new(layout: DataLayout): BranchData;
          }
          let BranchData: _BranchData$$static;
          interface _BranchData {
            cellCount(): int;
            _notTaken(): int;
            printDataOn(st: java.io.PrintStream): void;
          }
          interface BranchData extends CombineTypes<[_BranchData, sun.jvm.hotspot.oops.JumpData]> {}
          interface _BreakpointInfo$$static extends ClassLike {
            _initialize(db: hotspot.types.TypeDataBase): void;
            _bciField: hotspot.types.CIntegerField;
            _nameIndexField: hotspot.types.CIntegerField;
            _nextField: hotspot.types.AddressField;
            _origBytecodeField: hotspot.types.CIntegerField;
            _signatureIndexField: hotspot.types.CIntegerField;
            new(addr: hotspot.debugger.Address): BreakpointInfo;
          }
          let BreakpointInfo: _BreakpointInfo$$static;
          interface _BreakpointInfo {
            getBCI(): int;
            getNameIndex(): long;
            getNext(): BreakpointInfo;
            getOrigBytecode(): int;
            getSignatureIndex(): long;
            match(m: Method, bci: int): boolean;
            match(m: Method): boolean;
          }
          interface BreakpointInfo extends CombineTypes<[_BreakpointInfo, sun.jvm.hotspot.runtime.VMObject]> {}
          interface _ByteField$$static extends ClassLike {
            new(id: FieldIdentifier, offset: long, a2: boolean): ByteField;
            new(vmField: hotspot.types.JByteField, startOffset: long): ByteField;
            new(holder: InstanceKlass, fieldArrayIndex: int): ByteField;
          }
          let ByteField: _ByteField$$static;
          interface _ByteField {
            getValue(obj: Oop): byte;
            getValue(obj: hotspot.runtime.VMObject): byte;
            setValue(obj: Oop, value: char): void;
          }
          interface ByteField extends CombineTypes<[_ByteField, sun.jvm.hotspot.oops.Field]> {}
          interface _CIntField$$static extends ClassLike {
            new(vmField: hotspot.types.CIntegerField, startOffset: long): CIntField;
          }
          let CIntField: _CIntField$$static;
          interface _CIntField {
            getValue(obj: Oop): long;
            getValue(obj: hotspot.runtime.VMObject): long;
            getValue(addr: hotspot.debugger.Address): long;
            setValue(obj: Oop, value: long): void;
            _isUnsigned: boolean;
            _size: long;
          }
          interface CIntField extends CombineTypes<[_CIntField, sun.jvm.hotspot.oops.Field]> {}
          interface _CallTypeData$$static<K,M> extends ClassLike {
            _staticCellCount(): int;
            new(methodData: MethodDataInterface<K,M>, layout: DataLayout): CallTypeData<K,M>;
          }
          let CallTypeData: _CallTypeData$$static<K,M>;
          interface _CallTypeData<K,M> {
            argumentType(i: int): K;
            argumentTypeIndex(i: int): int;
            cellCount(): int;
            _cellCountGlobalOffset(): int;
            _cellCountNoHeader(): int;
            hasArguments(): boolean;
            hasReturn(): boolean;
            numberOfArguments(): int;
            printDataOn(st: java.io.PrintStream): void;
            returnType(): K;
            returnTypeIndex(): int;
            _args: TypeStackSlotEntries<K,M>;
            _ret: ReturnTypeEntry<K,M>;
          }
          interface CallTypeData<K,M> extends CombineTypes<[_CallTypeData<K,M>, CounterData, CallTypeDataInterface<K>]> {}
          interface _CallTypeDataInterface$$static<K> extends ClassLike {
          }
          let CallTypeDataInterface: _CallTypeDataInterface$$static<K>;
          interface _CallTypeDataInterface<K> {
            argumentType(a0: int): K;
            argumentTypeIndex(a0: int): int;
            hasArguments(): boolean;
            hasReturn(): boolean;
            numberOfArguments(): int;
            returnType(): K;
            returnTypeIndex(): int;
          }
          interface CallTypeDataInterface<K> extends CombineTypes<[_CallTypeDataInterface<K>, java.lang.Object]> {}
          interface _CellTypeState$$static extends ClassLike {
            makeAddr(bci: int): CellTypeState;
            makeAny(state: int): CellTypeState;
            makeBottom(): CellTypeState;
            makeLineRef(bci: int): CellTypeState;
            makeLockRef(bci: int): CellTypeState;
            makeSlotRef(slot_num: int): CellTypeState;
            makeTop(): CellTypeState;
            addr: CellTypeState;
            _addr_bit: int;
            _addr_conflict: int;
            _addr_value: int;
            _bits_mask: int;
            bottom: CellTypeState;
            _bottom_value: int;
            _info_conflict: int;
            _info_data_mask: int;
            _info_mask: int;
            _live_bits_mask: int;
            _not_bottom_info_bit: int;
            ref: CellTypeState;
            refUninit: CellTypeState;
            _ref_bit: int;
            _ref_conflict: int;
            _ref_data_mask: int;
            _ref_not_lock_bit: int;
            _ref_slot_bit: int;
            _ref_value: int;
            top: CellTypeState;
            _top_info_bit: int;
            uninit: CellTypeState;
            _uninit_bit: int;
            _uninit_value: int;
            _val_bit: int;
            _val_value: int;
            value: CellTypeState;
          }
          let CellTypeState: _CellTypeState$$static;
          interface _CellTypeState {
            canBeAddress(): boolean;
            canBeReference(): boolean;
            canBeUninit(): boolean;
            canBeValue(): boolean;
            copy(): CellTypeState;
            equal(a: CellTypeState): boolean;
            equalKind(a: CellTypeState): boolean;
            getInfo(): int;
            getMonitorSource(): int;
            isAddress(): boolean;
            isBottom(): boolean;
            isGoodAddress(): boolean;
            isInfoBottom(): boolean;
            isInfoTop(): boolean;
            isLive(): boolean;
            isLockReference(): boolean;
            isNonlockReference(): boolean;
            isReference(): boolean;
            isUninit(): boolean;
            isValidState(): boolean;
            isValue(): boolean;
            merge(cts: CellTypeState, slot: int): CellTypeState;
            print(tty: java.io.PrintStream): void;
            set(cts: CellTypeState): void;
            toChar(): char;
            __state: int;
          }
          interface CellTypeState extends CombineTypes<[_CellTypeState, java.lang.Object]> {}
          interface _CellTypeStateList$$static extends ClassLike {
            new(size: int): CellTypeStateList;
          }
          let CellTypeStateList: _CellTypeStateList$$static;
          interface _CellTypeStateList {
            get(i: int): CellTypeState;
            size(): int;
            subList(fromIndex: int, toIndex: int): CellTypeStateList;
            _list: java.util.List<CellTypeState>;
          }
          interface CellTypeStateList extends CombineTypes<[_CellTypeStateList, java.lang.Object]> {}
          interface _CharField$$static extends ClassLike {
            new(id: FieldIdentifier, offset: long, a2: boolean): CharField;
            new(vmField: hotspot.types.JCharField, startOffset: long): CharField;
            new(holder: InstanceKlass, fieldArrayIndex: int): CharField;
          }
          let CharField: _CharField$$static;
          interface _CharField {
            getValue(obj: Oop): char;
            getValue(obj: hotspot.runtime.VMObject): char;
            setValue(obj: Oop, value: char): void;
          }
          interface CharField extends CombineTypes<[_CharField, sun.jvm.hotspot.oops.Field]> {}
          interface _CheckedExceptionElement$$static extends ClassLike {
            _initialize(db: hotspot.types.TypeDataBase): void;
            _offsetOfClassCPIndex: long;
            new(handle: hotspot.debugger.Address, offset: long): CheckedExceptionElement;
          }
          let CheckedExceptionElement: _CheckedExceptionElement$$static;
          interface _CheckedExceptionElement {
            getClassCPIndex(): int;
            _handle: hotspot.debugger.Address;
            _offset: long;
          }
          interface CheckedExceptionElement extends CombineTypes<[_CheckedExceptionElement, java.lang.Object]> {}
          interface _CompiledICHolder$$static extends ClassLike {
            _initialize(db: hotspot.types.TypeDataBase): void;
            _headerSize: long;
            _holderKlass: MetadataField;
            _holderMetadata: MetadataField;
            new(addr: hotspot.debugger.Address): CompiledICHolder;
          }
          let CompiledICHolder: _CompiledICHolder$$static;
          interface _CompiledICHolder {
            getHolderKlass(): Klass;
            getHolderMetadata(): Metadata;
            isCompiledICHolder(): boolean;
            printValueOn(tty: java.io.PrintStream): void;
          }
          interface CompiledICHolder extends CombineTypes<[_CompiledICHolder, sun.jvm.hotspot.runtime.VMObject]> {}
          interface _CompressedKlassPointers$$static extends ClassLike {
            getBase(): long;
            getShift(): int;
            _initialize(db: hotspot.types.TypeDataBase): void;
            _typeExists(db: hotspot.types.TypeDataBase, type: string): boolean;
            _baseField: hotspot.types.AddressField;
            _shiftField: hotspot.types.CIntegerField;
            new(): CompressedKlassPointers;
          }
          let CompressedKlassPointers: _CompressedKlassPointers$$static;
          interface _CompressedKlassPointers {
          }
          interface CompressedKlassPointers extends CombineTypes<[_CompressedKlassPointers, java.lang.Object]> {}
          interface _CompressedLineNumberReadStream$$static extends ClassLike {
            new(buffer: hotspot.debugger.Address): CompressedLineNumberReadStream;
            new(buffer: hotspot.debugger.Address, position: int): CompressedLineNumberReadStream;
          }
          let CompressedLineNumberReadStream: _CompressedLineNumberReadStream$$static;
          interface _CompressedLineNumberReadStream {
            bci(): int;
            line(): int;
            readPair(): boolean;
            _bci: int;
            _line: int;
          }
          interface CompressedLineNumberReadStream extends CombineTypes<[_CompressedLineNumberReadStream, sun.jvm.hotspot.code.CompressedReadStream]> {}
          interface _CompressedOops$$static extends ClassLike {
            getBase(): long;
            getShift(): int;
            _initialize(db: hotspot.types.TypeDataBase): void;
            modeToString(mode: CompressedOops$Mode): string;
            _typeExists(db: hotspot.types.TypeDataBase, type: string): boolean;
            _baseField: hotspot.types.AddressField;
            _shiftField: hotspot.types.CIntegerField;
            new(): CompressedOops;
          }
          let CompressedOops: _CompressedOops$$static;
          interface _CompressedOops {
          }
          interface CompressedOops extends CombineTypes<[_CompressedOops, java.lang.Object]> {}
          interface _CompressedOops$Mode$$static extends ClassLike {
            valueOf(name: string): CompressedOops$Mode;
            values(): CompressedOops$Mode[];
            readonly HeapBasedNarrowOop: CompressedOops$Mode;
            readonly UnscaledNarrowOop: CompressedOops$Mode;
            readonly ZeroBasedNarrowOop: CompressedOops$Mode;
          }
          let CompressedOops$Mode: _CompressedOops$Mode$$static;
          interface _CompressedOops$Mode {
          }
          interface CompressedOops$Mode extends CombineTypes<[_CompressedOops$Mode]> {}
          interface _ConstMethod$$static extends ClassLike {
            _initialize(db: hotspot.types.TypeDataBase): void;
            _HAS_CHECKED_EXCEPTIONS: int;
            _HAS_DEFAULT_ANNOTATIONS: int;
            _HAS_EXCEPTION_TABLE: int;
            _HAS_GENERIC_SIGNATURE: int;
            _HAS_LINENUMBER_TABLE: int;
            _HAS_LOCALVARIABLE_TABLE: int;
            _HAS_METHOD_ANNOTATIONS: int;
            _HAS_METHOD_PARAMETERS: int;
            _HAS_PARAMETER_ANNOTATIONS: int;
            _HAS_TYPE_ANNOTATIONS: int;
            _bytecodeOffset: long;
            _checkedExceptionElementSize: long;
            _codeSize: CIntField;
            _constMethodSize: CIntField;
            _constants: MetadataField;
            _exceptionTableElementSize: long;
            _flags: CIntField;
            _idnum: CIntField;
            _localVariableTableElementSize: long;
            _maxLocals: CIntField;
            _maxStack: CIntField;
            _methodParametersElementSize: long;
            _nameIndex: CIntField;
            _signatureIndex: CIntField;
            _sizeOfParameters: CIntField;
            _sizeofShort: int;
            new(addr: hotspot.debugger.Address): ConstMethod;
          }
          let ConstMethod: _ConstMethod$$static;
          interface _ConstMethod {
            getByteCode(): byte[];
            getBytecodeByteArg(bci: int): byte;
            getBytecodeIntArg(bci: int): int;
            getBytecodeOrBPAt(bci: int): int;
            getBytecodeShortArg(bci: int): short;
            getCheckedExceptions(): CheckedExceptionElement[];
            _getCheckedExceptionsLength(): int;
            getCodeSize(): long;
            getConstMethodSize(): long;
            getConstants(): ConstantPool;
            getExceptionTable(): ExceptionTableElement[];
            _getExceptionTableLength(): int;
            getFlags(): long;
            getGenericSignature(): Symbol;
            getGenericSignatureIndex(): long;
            getIdNum(): long;
            getLineNumberFromBCI(bci: int): int;
            getLineNumberTable(): LineNumberTableElement[];
            _getLineNumberTableLength(): int;
            getLocalVariableName(bci: int, slot: int): Symbol;
            getLocalVariableTable(): LocalVariableTableElement[];
            _getLocalVariableTableLength(): int;
            getMaxLocals(): long;
            getMaxStack(): long;
            getMethod(): Method;
            _getMethodParametersLength(): int;
            getName(): Symbol;
            getNameIndex(): long;
            getNativeIntArg(bci: int): int;
            getNativeShortArg(bci: int): short;
            getSignature(): Symbol;
            getSignatureIndex(): long;
            getSize(): long;
            getSizeOfParameters(): long;
            hasCheckedExceptions(): boolean;
            _hasDefaultAnnotations(): boolean;
            hasExceptionTable(): boolean;
            _hasGenericSignature(): boolean;
            hasLineNumberTable(): boolean;
            hasLocalVariableTable(): boolean;
            _hasMethodAnnotations(): boolean;
            _hasMethodParameters(): boolean;
            _hasParameterAnnotations(): boolean;
            _hasTypeAnnotations(): boolean;
            isAddressInMethod(bcp: hotspot.debugger.Address): boolean;
            _isNative(): boolean;
            iterateFields(visitor: MetadataVisitor): void;
            _offsetOfCheckedExceptions(): long;
            _offsetOfCheckedExceptionsLength(): long;
            _offsetOfCodeEnd(): long;
            _offsetOfCompressedLineNumberTable(): long;
            _offsetOfExceptionTable(): long;
            _offsetOfExceptionTableLength(): long;
            _offsetOfGenericSignatureIndex(): long;
            _offsetOfLastU2Element(): long;
            _offsetOfLocalVariableTable(): long;
            _offsetOfLocalVariableTableLength(): long;
            _offsetOfMethodParameters(): long;
            _offsetOfMethodParametersLength(): long;
            printValueOn(tty: java.io.PrintStream): void;
          }
          interface ConstMethod extends CombineTypes<[_ConstMethod, sun.jvm.hotspot.oops.Metadata]> {}
          interface _ConstantPool$$static extends ClassLike {
            decodeInvokedynamicIndex(i: int): int;
            _extractHighShortFromInt(val: int): int;
            _extractLowShortFromInt(val: int): int;
            _initialize(db: hotspot.types.TypeDataBase): void;
            isInvokedynamicIndex(i: int): boolean;
            _DEBUG: boolean;
            _INDY_ARGC_OFFSET: int;
            _INDY_ARGV_OFFSET: int;
            _INDY_BSM_OFFSET: int;
            _cache: hotspot.types.AddressField;
            _elementSize: long;
            _genericSignatureIndex: CIntField;
            _headerSize: long;
            _length: CIntField;
            _majorVersion: CIntField;
            _minorVersion: CIntField;
            _nameForTag: string[];
            _operands: hotspot.types.AddressField;
            _poolHolder: MetadataField;
            _resolved_klasses: hotspot.types.AddressField;
            _sourceFileNameIndex: CIntField;
            _tags: hotspot.types.AddressField;
            new(addr: hotspot.debugger.Address): ConstantPool;
          }
          let ConstantPool: _ConstantPool$$static;
          interface _ConstantPool {
            _debugMessage(message: string): void;
            getAddressAtRaw(index: long): hotspot.debugger.Address;
            getBootstrapSpecifierAt(i: int): short[];
            getCache(): ConstantPoolCache;
            getDoubleAt(index: long): double;
            _getElementSize(): long;
            getFieldOrMethodAt(which: int): int;
            getFieldOrMethodKlassRefAt(which: int): Klass;
            getFieldRefAt(which: int): Field;
            getFloatAt(index: long): float;
            getGenericSignature(): Symbol;
            getIntAt(index: long): int;
            getKlassAt(which: int): Klass;
            getKlassNameAt(which: int): Symbol;
            getKlassSlotAt(index: long): ConstantPool$CPKlassSlot;
            getLength(): int;
            getLongAt(index: long): long;
            getMethodHandleIndexAt(i: int): int;
            getMethodHandleRefKindAt(i: int): int;
            getMethodRefAt(which: int): Method;
            getMethodTypeIndexAt(i: int): int;
            getNameAndTypeAt(which: int): int[];
            getNameAndTypeRefIndexAt(index: int): int;
            getNameRefAt(which: int): Symbol;
            getNameRefIndexAt(index: int): int;
            getOperands(): hotspot.utilities.U2Array;
            getPoolHolder(): InstanceKlass;
            getResolvedKlasses(): hotspot.utilities.KlassArray;
            getResolvedReferences(): Oop;
            getSignatureRefAt(which: int): Symbol;
            getSignatureRefIndexAt(index: int): int;
            getSize(): long;
            getSlotAt(index: long): ConstantPool$CPSlot;
            getSourceFileName(): Symbol;
            getSymbolAt(index: long): Symbol;
            getTagAt(index: long): hotspot.utilities.ConstantTag;
            getTags(): hotspot.utilities.U1Array;
            getUnresolvedStringAt(which: int): Symbol;
            _implGetNameRefAt(which: int, uncached: boolean): Symbol;
            _implGetSignatureRefAt(which: int, uncached: boolean): Symbol;
            _implNameAndTypeRefIndexAt(which: int, uncached: boolean): int;
            _indexOffset(index: long): long;
            invokeDynamicNameAndTypeRefIndexAt(which: int): int;
            _invokedynamicCPCacheEntryAt(index: int): ConstantPoolCacheEntry;
            invokedynamicCPCacheIndex(index: int): int;
            isConstantPool(): boolean;
            iterateFields(visitor: MetadataVisitor): void;
            majorVersion(): long;
            minorVersion(): long;
            _nameForTag(tag: int): string;
            objectToCPIndex(index: int): int;
            printValueOn(tty: java.io.PrintStream): void;
            referenceMap(): hotspot.utilities.U2Array;
            _remapInstructionOperandFromCache(operand: int): int;
            uncachedGetNameRefAt(which: int): Symbol;
            uncachedGetSignatureRefAt(which: int): Symbol;
            writeBytes(os: java.io.OutputStream): void;
          }
          interface ConstantPool extends CombineTypes<[_ConstantPool, sun.jvm.hotspot.runtime.ClassConstants, sun.jvm.hotspot.oops.Metadata]> {}
          interface _ConstantPool$CPKlassSlot$$static extends ClassLike {
            _temp_resolved_klass_index: int;
            new(a0: ConstantPool, n: int, rk: int): ConstantPool$CPKlassSlot;
          }
          let ConstantPool$CPKlassSlot: _ConstantPool$CPKlassSlot$$static;
          interface _ConstantPool$CPKlassSlot {
            getNameIndex(): int;
            getResolvedKlassIndex(): int;
            _name_index: int;
            _resolved_klass_index: int;
          }
          interface ConstantPool$CPKlassSlot extends CombineTypes<[_ConstantPool$CPKlassSlot, java.lang.Object]> {}
          interface _ConstantPool$CPSlot$$static extends ClassLike {
            _new(a0: ConstantPool, ptr: hotspot.debugger.Address): ConstantPool$CPSlot;
          }
          let ConstantPool$CPSlot: _ConstantPool$CPSlot$$static;
          interface _ConstantPool$CPSlot {
            getSymbol(): Symbol;
            _ptr: hotspot.debugger.Address;
          }
          interface ConstantPool$CPSlot extends CombineTypes<[_ConstantPool$CPSlot, java.lang.Object]> {}
          interface _ConstantPoolCache$$static extends ClassLike {
            _initialize(db: hotspot.types.TypeDataBase): void;
            _baseOffset: long;
            _constants: MetadataField;
            _elementSize: long;
            _intSize: long;
            _length: CIntField;
            _referenceMap: hotspot.types.AddressField;
            _resolvedIndyArray: hotspot.types.AddressField;
            _resolvedReferences: hotspot.types.AddressField;
            new(addr: hotspot.debugger.Address): ConstantPoolCache;
          }
          let ConstantPoolCache: _ConstantPoolCache$$static;
          interface _ConstantPoolCache {
            getConstants(): ConstantPool;
            getEntryAt(i: int): ConstantPoolCacheEntry;
            getIndyEntryAt(i: int): ResolvedIndyEntry;
            getIntAt(entry: int, fld: int): int;
            getLength(): int;
            getResolvedReferences(): Oop;
            getSize(): long;
            isConstantPoolCache(): boolean;
            iterateFields(visitor: MetadataVisitor): void;
            printValueOn(tty: java.io.PrintStream): void;
            referenceMap(): hotspot.utilities.U2Array;
          }
          interface ConstantPoolCache extends CombineTypes<[_ConstantPoolCache, sun.jvm.hotspot.oops.Metadata]> {}
          interface _ConstantPoolCacheEntry$$static extends ClassLike {
            _initialize(db: hotspot.types.TypeDataBase): void;
            _baseOffset: long;
            _f1: hotspot.types.AddressField;
            _f1FieldName: NamedFieldIdentifier;
            _f2: hotspot.types.CIntegerField;
            _f2FieldName: NamedFieldIdentifier;
            _flags: hotspot.types.CIntegerField;
            _flagsFieldName: NamedFieldIdentifier;
            _indices: hotspot.types.CIntegerField;
            _size: long;
            _new(cp: ConstantPoolCache, index: int): ConstantPoolCacheEntry;
          }
          let ConstantPoolCacheEntry: _ConstantPoolCacheEntry$$static;
          interface _ConstantPoolCacheEntry {
            getConstantPoolIndex(): int;
            getF1(): Metadata;
            getF2(): int;
            getFlags(): int;
            _getIndices(): long;
            iterateFields(visitor: MetadataVisitor): void;
            _cp: ConstantPoolCache;
            _offset: long;
          }
          interface ConstantPoolCacheEntry extends CombineTypes<[_ConstantPoolCacheEntry, java.lang.Object]> {}
          interface _CounterData$$static extends ClassLike {
            _countOffset(): int;
            _counterDataSize(): int;
            _staticCellCount(): int;
            _countOff: int;
            _counterCellCount: int;
            new(layout: DataLayout): CounterData;
          }
          let CounterData: _CounterData$$static;
          interface _CounterData {
            cellCount(): int;
            _count(): int;
            printDataOn(st: java.io.PrintStream): void;
          }
          interface CounterData extends CombineTypes<[_CounterData, sun.jvm.hotspot.oops.BitData]> {}
          interface _DataLayout$$static extends ClassLike {
            _bciOffset(): int;
            cellOffset(index: int): int;
            computeSizeInBytes(cellCount: int): int;
            _flagsOffset(): int;
            _headerOffset(): int;
            _headerSizeInBytes(): int;
            _headerSizeInCells(): int;
            _needsArrayLen(tag: int): boolean;
            _tagOffset(): int;
            readonly argInfoDataTag: int;
            readonly bitDataTag: int;
            readonly branchDataTag: int;
            readonly callTypeDataTag: int;
            readonly counterDataTag: int;
            readonly counterIncrement: int;
            readonly firstFlag: int;
            readonly jumpDataTag: int;
            readonly multiBranchDataTag: int;
            readonly noTag: int;
            readonly parametersTypeDataTag: int;
            readonly receiverTypeDataTag: int;
            readonly retDataTag: int;
            readonly speculativeTrapDataTag: int;
            readonly trapBits: int;
            readonly trapMask: int;
            readonly virtualCallDataTag: int;
            readonly virtualCallTypeDataTag: int;
            new(d: MethodData, o: int): DataLayout;
            new(d: hotspot.debugger.Address, o: int): DataLayout;
          }
          let DataLayout: _DataLayout$$static;
          interface _DataLayout {
            addressAt(index: int): hotspot.debugger.Address;
            _bci(): int;
            _cellAt(index: int): long;
            dp(): int;
            _flagAt(flagNumber: int): boolean;
            _flags(): int;
            _getU11(at: int): int;
            _getU22(at: int): int;
            tag(): int;
            _trapState(): int;
            _data: hotspot.debugger.Address;
            _offset: int;
          }
          interface DataLayout extends CombineTypes<[_DataLayout, java.lang.Object]> {}
          interface _DefaultHeapVisitor$$static extends ClassLike {
            new(): DefaultHeapVisitor;
          }
          let DefaultHeapVisitor: _DefaultHeapVisitor$$static;
          interface _DefaultHeapVisitor {
            doObj(obj: Oop): boolean;
            epilogue(): void;
            prologue(usedSize: long): void;
          }
          interface DefaultHeapVisitor extends CombineTypes<[_DefaultHeapVisitor, java.lang.Object, sun.jvm.hotspot.oops.HeapVisitor]> {}
          interface _DefaultMetadataVisitor$$static extends ClassLike {
            new(): DefaultMetadataVisitor;
          }
          let DefaultMetadataVisitor: _DefaultMetadataVisitor$$static;
          interface _DefaultMetadataVisitor {
            doBoolean(field: BooleanField, isVMField: boolean): void;
            doByte(field: ByteField, isVMField: boolean): void;
            doCInt(field: CIntField, isVMField: boolean): void;
            doChar(field: CharField, isVMField: boolean): void;
            doDouble(field: DoubleField, isVMField: boolean): void;
            doFloat(field: FloatField, isVMField: boolean): void;
            doInt(field: IntField, isVMField: boolean): void;
            doLong(field: LongField, isVMField: boolean): void;
            doMetadata(a0: MetadataField, a1: boolean): void;
(a0: MetadataField, a1: boolean): void;
            doOop(field: OopField, isVMField: boolean): void;
            doOop(field: NarrowOopField, isVMField: boolean): void;
            doShort(field: ShortField, isVMField: boolean): void;
            epilogue(): void;
            getObj(): Metadata;
            prologue(): void;
            setObj(obj: Metadata): void;
            _obj: Metadata;
          }
          interface DefaultMetadataVisitor extends CombineTypes<[_DefaultMetadataVisitor, sun.jvm.hotspot.oops.MetadataVisitor, java.lang.Object]> {}
          interface _DefaultOopVisitor$$static extends ClassLike {
            new(): DefaultOopVisitor;
          }
          let DefaultOopVisitor: _DefaultOopVisitor$$static;
          interface _DefaultOopVisitor {
            doBoolean(field: BooleanField, isVMField: boolean): void;
            doByte(field: ByteField, isVMField: boolean): void;
            doCInt(field: CIntField, isVMField: boolean): void;
            doChar(field: CharField, isVMField: boolean): void;
            doDouble(field: DoubleField, isVMField: boolean): void;
            doFloat(field: FloatField, isVMField: boolean): void;
            doInt(field: IntField, isVMField: boolean): void;
            doLong(field: LongField, isVMField: boolean): void;
            doMetadata(field: MetadataField, isVMField: boolean): void;
            doOop(field: OopField, isVMField: boolean): void;
            doOop(field: NarrowOopField, isVMField: boolean): void;
            doShort(field: ShortField, isVMField: boolean): void;
            epilogue(): void;
            getObj(): Oop;
            prologue(): void;
            setObj(obj: Oop): void;
            _obj: Oop;
          }
          interface DefaultOopVisitor extends CombineTypes<[_DefaultOopVisitor, sun.jvm.hotspot.oops.OopVisitor, java.lang.Object]> {}
          interface _DoubleField$$static extends ClassLike {
            new(id: FieldIdentifier, offset: long, a2: boolean): DoubleField;
            new(vmField: hotspot.types.JDoubleField, startOffset: long): DoubleField;
            new(holder: InstanceKlass, fieldArrayIndex: int): DoubleField;
          }
          let DoubleField: _DoubleField$$static;
          interface _DoubleField {
            getValue(obj: Oop): double;
            getValue(obj: hotspot.runtime.VMObject): double;
            setValue(obj: Oop, value: double): void;
          }
          interface DoubleField extends CombineTypes<[_DoubleField, sun.jvm.hotspot.oops.Field]> {}
          interface _ExceptionTableElement$$static extends ClassLike {
            _initialize(db: hotspot.types.TypeDataBase): void;
            _offsetOfCatchTypeIndex: long;
            _offsetOfEndPC: long;
            _offsetOfHandlerPC: long;
            _offsetOfStartPC: long;
            new(handle: hotspot.debugger.Address, offset: long): ExceptionTableElement;
          }
          let ExceptionTableElement: _ExceptionTableElement$$static;
          interface _ExceptionTableElement {
            getCatchTypeIndex(): int;
            getEndPC(): int;
            getHandlerPC(): int;
            getStartPC(): int;
            _handle: hotspot.debugger.Address;
            _offset: long;
          }
          interface ExceptionTableElement extends CombineTypes<[_ExceptionTableElement, java.lang.Object]> {}
          interface _Field$$static extends ClassLike {
            _fieldIsContended(flags: int): boolean;
            _fieldIsGeneric(flags: int): boolean;
            _fieldIsInitialized(flags: int): boolean;
            _fieldIsInjected(flags: int): boolean;
            _fieldIsStable(flags: int): boolean;
            getFields(kls: InstanceKlass): Field[];
            _readFieldInfoValues(crs: hotspot.code.CompressedReadStream): Field$FieldInfoValues;
            _new(id: FieldIdentifier, offset: long, a2: boolean): Field;
            _new(holder: InstanceKlass, fieldIndex: int): Field;
          }
          let Field: _Field$$static;
          interface _Field {
            equals(obj: any): boolean;
            getAccessFlags(): long;
            getAccessFlagsObj(): AccessFlags;
            getFieldHolder(): InstanceKlass;
            getFieldIndex(): int;
            getFieldType(): FieldType;
            getGenericSignature(): Symbol;
            getGenericSignatureIndex(): int;
            getID(): FieldIdentifier;
            getInitialValueIndex(): int;
            getName(): Symbol;
            getNameIndex(): int;
            getOffset(): long;
            getSignature(): Symbol;
            getSignatureIndex(): int;
            hasInitialValue(): boolean;
            hashCode(): int;
            isContended(): boolean;
            isEnumConstant(): boolean;
            isFinal(): boolean;
            isGeneric(): boolean;
            isInitialized(): boolean;
            isInjected(): boolean;
            isNamedField(): boolean;
            isPackagePrivate(): boolean;
            isPrivate(): boolean;
            isProtected(): boolean;
            isPublic(): boolean;
            isStable(): boolean;
            isStatic(): boolean;
            isSynthetic(): boolean;
            isTransient(): boolean;
            isVMField(): boolean;
            isVolatile(): boolean;
            printOn(tty: java.io.PrintStream): void;
            _accessFlags: AccessFlags;
            _fieldIndex: int;
            _fieldType: FieldType;
            _genericSignature: Symbol;
            _holder: InstanceKlass;
            _id: FieldIdentifier;
            _isVMField: boolean;
            _name: Symbol;
            _offset: long;
            _signature: Symbol;
            _values: Field$FieldInfoValues;
          }
          interface Field extends CombineTypes<[_Field, java.lang.Object]> {}
          interface _Field$FieldInfoValues$$static extends ClassLike {
            _new(): Field$FieldInfoValues;
          }
          let Field$FieldInfoValues: _Field$FieldInfoValues$$static;
          interface _Field$FieldInfoValues {
            _accessFlags: int;
            _contendedGroup: int;
            _fieldFlags: int;
            _genericSignatureIndex: int;
            _initialValueIndex: int;
            _nameIndex: int;
            _offset: int;
            _signatureIndex: int;
          }
          interface Field$FieldInfoValues extends CombineTypes<[_Field$FieldInfoValues, java.lang.Object]> {}
          interface _FieldIdentifier$$static extends ClassLike {
            new(): FieldIdentifier;
          }
          let FieldIdentifier: _FieldIdentifier$$static;
          interface _FieldIdentifier {
            getName(): string;
            printOn(tty: java.io.PrintStream): void;
          }
          interface FieldIdentifier extends CombineTypes<[_FieldIdentifier, java.lang.Object]> {}
          interface _FieldType$$static extends ClassLike {
            new(signature: Symbol): FieldType;
          }
          let FieldType: _FieldType$$static;
          interface _FieldType {
            getArrayInfo(): FieldType$ArrayInfo;
            getSignature(): Symbol;
            isArray(): boolean;
            isBoolean(): boolean;
            isByte(): boolean;
            isChar(): boolean;
            isDouble(): boolean;
            isFloat(): boolean;
            isInt(): boolean;
            isLong(): boolean;
            isObject(): boolean;
            isOop(): boolean;
            isShort(): boolean;
            _skipOptionalSize(sig: Symbol, index: int): int;
            _first: char;
            _signature: Symbol;
          }
          interface FieldType extends CombineTypes<[_FieldType, java.lang.Object]> {}
          interface _FieldType$ArrayInfo$$static extends ClassLike {
            new(dimension: int, elementBasicType: int): FieldType$ArrayInfo;
          }
          let FieldType$ArrayInfo: _FieldType$ArrayInfo$$static;
          interface _FieldType$ArrayInfo {
            dimension(): int;
            elementBasicType(): int;
            _dimension: int;
            _elementBasicType: int;
          }
          interface FieldType$ArrayInfo extends CombineTypes<[_FieldType$ArrayInfo, java.lang.Object]> {}
          interface _FieldVisitor$$static extends ClassLike {
          }
          let FieldVisitor: _FieldVisitor$$static;
          interface _FieldVisitor {
            doBoolean(a0: BooleanField, a1: boolean): void;
            doByte(a0: ByteField, a1: boolean): void;
            doCInt(a0: CIntField, a1: boolean): void;
            doChar(a0: CharField, a1: boolean): void;
            doDouble(a0: DoubleField, a1: boolean): void;
            doFloat(a0: FloatField, a1: boolean): void;
            doInt(a0: IntField, a1: boolean): void;
            doLong(a0: LongField, a1: boolean): void;
            doMetadata(a0: MetadataField, a1: boolean): void;
            doOop(a0: OopField, a1: boolean): void;
            doOop(a0: NarrowOopField, a1: boolean): void;
            doShort(a0: ShortField, a1: boolean): void;
          }
          interface FieldVisitor extends CombineTypes<[_FieldVisitor, java.lang.Object]> {}
          interface _FloatField$$static extends ClassLike {
            new(id: FieldIdentifier, offset: long, a2: boolean): FloatField;
            new(vmField: hotspot.types.JFloatField, startOffset: long): FloatField;
            new(holder: InstanceKlass, fieldArrayIndex: int): FloatField;
          }
          let FloatField: _FloatField$$static;
          interface _FloatField {
            getValue(obj: Oop): float;
            getValue(obj: hotspot.runtime.VMObject): float;
            setValue(obj: Oop, value: float): void;
          }
          interface FloatField extends CombineTypes<[_FloatField, sun.jvm.hotspot.oops.Field]> {}
          interface _GenerateOopMap$$static extends ClassLike {
            _DEBUG: boolean;
            _MAXARGSIZE: int;
            _MAX_LOCAL_VARS: int;
            _TraceMonitorMismatch: boolean;
            _TraceOopMapRewrites: boolean;
            _bad_monitors: int;
            _epsilonCTS: CellTypeState[];
            _rCTS: CellTypeState[];
            _refCTS: CellTypeState;
            _rrCTS: CellTypeState[];
            _rvrCTS: CellTypeState[];
            _vCTS: CellTypeState[];
            _valCTS: CellTypeState;
            _vrCTS: CellTypeState[];
            _vvCTS: CellTypeState[];
            _vvrCTS: CellTypeState[];
            _vvvCTS: CellTypeState[];
            _vvvrCTS: CellTypeState[];
            _vvvvCTS: CellTypeState[];
            new(method: Method): GenerateOopMap;
          }
          let GenerateOopMap: _GenerateOopMap$$static;
          interface _GenerateOopMap {
            _addToRefInitSet(localNo: int): void;
            allowRewrites(): boolean;
            _bbCount(): int;
            _bbIndex(bb: GenerateOopMap$BasicBlock): int;
            _checkType(expected: CellTypeState, actual: CellTypeState): void;
            _clear_bbmark_bit(bci: int): void;
            computeMap(): void;
            _copyCTS(dst: CellTypeState[], src: CellTypeState[]): int;
            _copyState(dst: CellTypeStateList, src: CellTypeStateList): void;
            _doAstore(idx: int): void;
            _doCheckcast(): void;
            _doExceptionEdge(itr: hotspot.interpreter.BytecodeStream): void;
            _doField(is_get: boolean, is_static: boolean, idx: int, bci: int): void;
            _doInterpretation(): void;
            _doJsr(targBCI: int): void;
            _doLdc(bci: int): void;
            _doMethod(is_static: boolean, is_interface: boolean, idx: int, bci: int): void;
            _doMonitorenter(bci: int): void;
            _doMonitorexit(bci: int): void;
            _doMultianewarray(dims: int, bci: int): void;
            _doReturnMonitorCheck(): void;
            fillInitVars(init_vars: java.util.List<int>): void;
            fillStackmapEpilog(): void;
            fillStackmapForOpcodes(bcs: hotspot.interpreter.BytecodeStream, vars: CellTypeStateList, stack: CellTypeStateList, stackTop: int): void;
            fillStackmapProlog(nofGCPoints: int): void;
            _gcPoints(): int;
            _getBasicBlockAt(bci: int): GenerateOopMap$BasicBlock;
            _getBasicBlockContaining(bci: int): GenerateOopMap$BasicBlock;
            getMonitorMatch(bci: int): int;
            _getVar(localNo: int): CellTypeState;
            _initBasicBlocks(): void;
            _initState(): void;
            _initializeBB(): void;
            _initializeVars(): void;
            _interp1(itr: hotspot.interpreter.BytecodeStream): void;
            _interpAll(): void;
            _interpBB(bb: GenerateOopMap$BasicBlock): void;
            _isBBHeader(bci: int): boolean;
            _jumpTargetsDo(bcs: hotspot.interpreter.BytecodeStream, closure: GenerateOopMap$JumpClosure, data: int[]): boolean;
            _makeContextUninitialized(): void;
            _markBB(bci: int, data: int[]): void;
            _markBBHeadersAndCountGCPoints(): void;
            _markReachableCode(): void;
            maxLocals(): int;
            _mergeState(bci: int, data: int[]): void;
            _mergeStateIntoBB(bb: GenerateOopMap$BasicBlock): void;
            _mergeStateVectors(cts: CellTypeStateList, bbts: CellTypeStateList): boolean;
            method(): Method;
            _methodsigToEffect(signature: Symbol, isStatic: boolean, effect: CellTypeStateList): int;
            _monitorPop(): CellTypeState;
            _monitorPush(cts: CellTypeState): void;
            monitorSafe(): boolean;
            _monitors(): CellTypeStateList;
            _nextBBStartPC(bb: GenerateOopMap$BasicBlock): int;
            _pop(): CellTypeState;
            possibleGCPoint(bcs: hotspot.interpreter.BytecodeStream): boolean;
            _pp(_in: CellTypeState[], out: CellTypeState[]): void;
            _ppNewRef(_in: CellTypeState[], bci: int): void;
            _ppdupswap(poplen: int, out: string): void;
            _ppload(out: CellTypeState[], loc_no: int): void;
            _ppop(out: CellTypeState[]): void;
            _ppop1(out: CellTypeState): void;
            _ppopAny(poplen: int): void;
            _ppstore(_in: CellTypeState[], loc_no: int): void;
            _ppush(_in: CellTypeState[]): void;
            _ppush(_in: CellTypeStateList): void;
            _ppush1(_in: CellTypeState): void;
            _printCurrentState(tty: java.io.PrintStream, currentBC: hotspot.interpreter.BytecodeStream, detailed: boolean): void;
            _printStates(tty: java.io.PrintStream, vector: CellTypeStateList, num: int): void;
            _push(cts: CellTypeState): void;
            _reachableBasicblock(bci: int, data: int[]): void;
            _recordRefvalConflict(varNo: int): void;
            _replaceAllCTSMatches(match: CellTypeState, replace: CellTypeState): void;
            reportInitVars(): boolean;
            _reportMonitorMismatch(msg: string): void;
            _reportResult(): void;
            reportResults(): boolean;
            _restoreState(bb: GenerateOopMap$BasicBlock): void;
            resultForBasicblock(bci: int): void;
            _retJumpTargetsDo(bcs: hotspot.interpreter.BytecodeStream, closure: GenerateOopMap$JumpClosure, varNo: int, data: int[]): void;
            _rewriteRefvalConflicts(): void;
            _setBBMarkBit(bci: int): void;
            _setVar(localNo: int, cts: CellTypeState): void;
            _setupMethodEntryState(): void;
            _sigcharToEffect(sigch: char, bci: int, out: CellTypeState[]): CellTypeState[];
            _stack(): CellTypeStateList;
            _stateVecToString(vec: CellTypeStateList, len: int): string;
            _updateBasicBlocks(bci: int, delta: int): void;
            _vars(): CellTypeStateList;
            __basic_blocks: GenerateOopMap$BasicBlock[];
            __bb_count: int;
            __bb_hdr_bits: hotspot.utilities.BitMap;
            __conflict: boolean;
            __error_msg: string;
            __gc_points: int;
            __got_error: boolean;
            __has_exceptions: boolean;
            __init_vars: java.util.List<int>;
            __itr_send: hotspot.interpreter.BytecodeStream;
            __matching_enter_bci: int;
            __max_locals: int;
            __max_monitors: int;
            __max_stack: int;
            __method: Method;
            __monitor_safe: boolean;
            __monitor_top: int;
            __new_var_map: int[];
            __nof_refval_conflicts: int;
            __report_for_exit_bci: int;
            __report_result: boolean;
            __report_result_for_send: boolean;
            __rt: GenerateOopMap$RetTable;
            __stack_top: int;
            __state: CellTypeStateList;
            __state_len: int;
            __state_vec_buf: char[];
          }
          interface GenerateOopMap extends CombineTypes<[_GenerateOopMap, java.lang.Object]> {}
          interface _GenerateOopMap$BasicBlock$$static extends ClassLike {
            __dead_basic_block: int;
            __unreached: int;
            _new(): GenerateOopMap$BasicBlock;
          }
          let GenerateOopMap$BasicBlock: _GenerateOopMap$BasicBlock$$static;
          interface _GenerateOopMap$BasicBlock {
            _changed(): boolean;
            _isAlive(): boolean;
            _isDead(): boolean;
            _isReachable(): boolean;
            _markAsAlive(): void;
            _setChanged(s: boolean): void;
            _stack(): CellTypeStateList;
            _vars(): CellTypeStateList;
            __bci: int;
            __changed: boolean;
            __end_bci: int;
            __max_locals: int;
            __max_stack: int;
            __monitor_top: int;
            __stack_top: int;
            __state: CellTypeStateList;
          }
          interface GenerateOopMap$BasicBlock extends CombineTypes<[_GenerateOopMap$BasicBlock, java.lang.Object]> {}
          interface _GenerateOopMap$ComputeCallStack$$static extends ClassLike {
            _new(signature: Symbol): GenerateOopMap$ComputeCallStack;
          }
          let GenerateOopMap$ComputeCallStack: _GenerateOopMap$ComputeCallStack$$static;
          interface _GenerateOopMap$ComputeCallStack {
            _computeForParameters(is_static: boolean, effect: CellTypeStateList): int;
            _computeForReturntype(effect: CellTypeStateList): int;
            doArray(begin: int, end: int): void;
            doBool(): void;
            doByte(): void;
            doChar(): void;
            doDouble(): void;
            doFloat(): void;
            doInt(): void;
            doLong(): void;
            doObject(begin: int, end: int): void;
            doShort(): void;
            doVoid(): void;
            _length(): int;
            _set(state: CellTypeState): void;
            __effect: CellTypeStateList;
            __idx: int;
          }
          interface GenerateOopMap$ComputeCallStack extends CombineTypes<[_GenerateOopMap$ComputeCallStack, sun.jvm.hotspot.runtime.SignatureIterator]> {}
          interface _GenerateOopMap$ComputeEntryStack$$static extends ClassLike {
            _new(signature: Symbol): GenerateOopMap$ComputeEntryStack;
          }
          let GenerateOopMap$ComputeEntryStack: _GenerateOopMap$ComputeEntryStack$$static;
          interface _GenerateOopMap$ComputeEntryStack {
            _computeForParameters(is_static: boolean, effect: CellTypeStateList): int;
            _computeForReturntype(effect: CellTypeStateList): int;
            doArray(begin: int, end: int): void;
            doBool(): void;
            doByte(): void;
            doChar(): void;
            doDouble(): void;
            doFloat(): void;
            doInt(): void;
            doLong(): void;
            doObject(begin: int, end: int): void;
            doShort(): void;
            doVoid(): void;
            _length(): int;
            _set(state: CellTypeState): void;
            __effect: CellTypeStateList;
            __idx: int;
          }
          interface GenerateOopMap$ComputeEntryStack extends CombineTypes<[_GenerateOopMap$ComputeEntryStack, sun.jvm.hotspot.runtime.SignatureIterator]> {}
          interface _GenerateOopMap$JumpClosure$$static extends ClassLike {
          }
          let GenerateOopMap$JumpClosure: _GenerateOopMap$JumpClosure$$static;
          interface _GenerateOopMap$JumpClosure {
            process(a0: GenerateOopMap, a1: int, a2: int[]): void;
(a0: GenerateOopMap, a1: int, a2: int[]): void;
          }
          interface GenerateOopMap$JumpClosure extends CombineTypes<[_GenerateOopMap$JumpClosure, java.lang.Object]> {}
          interface _GenerateOopMap$RetTable$$static extends ClassLike {
            __init_nof_entries: int;
            _new(): GenerateOopMap$RetTable;
          }
          let GenerateOopMap$RetTable: _GenerateOopMap$RetTable$$static;
          interface _GenerateOopMap$RetTable {
            _addJsr(return_bci: int, target_bci: int): void;
            _computeRetTable(method: Method): void;
            _findJsrsForTarget(targBci: int): GenerateOopMap$RetTableEntry;
            _updateRetTable(bci: int, delta: int): void;
            __first: GenerateOopMap$RetTableEntry;
          }
          interface GenerateOopMap$RetTable extends CombineTypes<[_GenerateOopMap$RetTable, java.lang.Object]> {}
          interface _GenerateOopMap$RetTableEntry$$static extends ClassLike {
            __init_nof_jsrs: int;
            _new(target: int, next: GenerateOopMap$RetTableEntry): GenerateOopMap$RetTableEntry;
          }
          let GenerateOopMap$RetTableEntry: _GenerateOopMap$RetTableEntry$$static;
          interface _GenerateOopMap$RetTableEntry {
            _addDelta(bci: int, delta: int): void;
            _addJsr(return_bci: int): void;
            _jsrs(i: int): int;
            _next(): GenerateOopMap$RetTableEntry;
            _nofJsrs(): int;
            _targetBci(): int;
            __jsrs: java.util.List<int>;
            __next: GenerateOopMap$RetTableEntry;
            __target_bci: int;
          }
          interface GenerateOopMap$RetTableEntry extends CombineTypes<[_GenerateOopMap$RetTableEntry, java.lang.Object]> {}
          interface _HeapPrinter$$static extends ClassLike {
            new(tty: java.io.PrintStream): HeapPrinter;
          }
          let HeapPrinter: _HeapPrinter$$static;
          interface _HeapPrinter {
            doObj(obj: Oop): boolean;
            epilogue(): void;
            prologue(size: long): void;
            _oopPrinter: OopPrinter;
          }
          interface HeapPrinter extends CombineTypes<[_HeapPrinter, java.lang.Object, sun.jvm.hotspot.oops.HeapVisitor]> {}
          interface _HeapVisitor$$static extends ClassLike {
          }
          let HeapVisitor: _HeapVisitor$$static;
          interface _HeapVisitor {
            doObj(a0: Oop): boolean;
            epilogue(): void;
            prologue(a0: long): void;
          }
          interface HeapVisitor extends CombineTypes<[_HeapVisitor, java.lang.Object]> {}
          interface _IndexableFieldIdentifier$$static extends ClassLike {
            new(index: int): IndexableFieldIdentifier;
          }
          let IndexableFieldIdentifier: _IndexableFieldIdentifier$$static;
          interface _IndexableFieldIdentifier {
            equals(obj: any): boolean;
            getIndex(): int;
            getName(): string;
            hashCode(): int;
            printOn(tty: java.io.PrintStream): void;
            _index: int;
          }
          interface IndexableFieldIdentifier extends CombineTypes<[_IndexableFieldIdentifier, sun.jvm.hotspot.oops.FieldIdentifier]> {}
          interface _Instance$$static extends ClassLike {
            getHeaderSize(): long;
            _initialize(db: hotspot.types.TypeDataBase): void;
            _typeSize: long;
            _new(handle: hotspot.debugger.OopHandle, heap: ObjectHeap): Instance;
          }
          let Instance: _Instance$$static;
          interface _Instance {
            isInstance(): boolean;
            iterateFields(visitor: OopVisitor, doVMFields: boolean): void;
            printValueOn(tty: java.io.PrintStream): void;
          }
          interface Instance extends CombineTypes<[_Instance, sun.jvm.hotspot.oops.Oop]> {}
          interface _InstanceClassLoaderKlass$$static extends ClassLike {
            _initialize(db: hotspot.types.TypeDataBase): void;
            new(addr: hotspot.debugger.Address): InstanceClassLoaderKlass;
          }
          let InstanceClassLoaderKlass: _InstanceClassLoaderKlass$$static;
          interface _InstanceClassLoaderKlass {
          }
          interface InstanceClassLoaderKlass extends CombineTypes<[_InstanceClassLoaderKlass, sun.jvm.hotspot.oops.InstanceKlass]> {}
          interface _InstanceKlass$$static extends ClassLike {
            _findMethod(methods: hotspot.utilities.MethodArray, name: string, signature: string): Method;
            getHeaderSize(): long;
            _initialize(db: hotspot.types.TypeDataBase): void;
            _linearSearch(methods: hotspot.utilities.MethodArray, name: string, signature: string): int;
            _CLASS_STATE_ALLOCATED: int;
            _CLASS_STATE_BEING_INITIALIZED: int;
            _CLASS_STATE_FULLY_INITIALIZED: int;
            _CLASS_STATE_INITIALIZATION_ERROR: int;
            _CLASS_STATE_LINKED: int;
            _CLASS_STATE_LOADED: int;
            _FIELD_FLAG_IS_CONTENDED: int;
            _FIELD_FLAG_IS_GENERIC: int;
            _FIELD_FLAG_IS_INITIALIZED: int;
            _FIELD_FLAG_IS_INJECTED: int;
            _FIELD_FLAG_IS_STABLE: int;
            _arrayKlasses: MetadataField;
            _breakpoints: hotspot.types.AddressField;
            _constants: MetadataField;
            _defaultMethods: hotspot.types.AddressField;
            _fieldinfoStream: hotspot.types.AddressField;
            _fieldsCache: java.util.Map<hotspot.debugger.Address,Field[]>;
            _headerSize: long;
            _initState: CIntField;
            _innerClasses: hotspot.types.AddressField;
            _itableLen: CIntField;
            _localInterfaces: hotspot.types.AddressField;
            _methodOrdering: hotspot.types.AddressField;
            _methods: hotspot.types.AddressField;
            _nonstaticFieldSize: CIntField;
            _nonstaticOopMapSize: CIntField;
            _sourceDebugExtension: hotspot.types.AddressField;
            _staticFieldSize: CIntField;
            _staticOopFieldCount: CIntField;
            _transitiveInterfaces: hotspot.types.AddressField;
            new(addr: hotspot.debugger.Address): InstanceKlass;
          }
          let InstanceKlass: _InstanceKlass$$static;
          interface _InstanceKlass {
            arrayKlassImpl(orNull: boolean, n: int): Klass;
            arrayKlassImpl(orNull: boolean): Klass;
            computeModifierFlags(): long;
            _computeSubtypeOf(k: Klass): boolean;
            dumpReplayData(out: java.io.PrintStream): void;
            findField(name: string, sig: string): Field;
            findFieldDbg(name: string, sig: string): Field;
            findInterfaceField(name: string, sig: string): Field;
            findLocalField(name: string, sig: string): Field;
            findMethod(name: string, sig: string): Method;
            getAllFields(): java.util.List<Field>;
            getAllFieldsCount(): int;
            getArrayKlasses(): Klass;
            getBreakpoints(): BreakpointInfo;
            getClassStatus(): int;
            getConstants(): ConstantPool;
            getDefaultMethods(): hotspot.utilities.MethodArray;
            getDirectImplementedInterfaces(): java.util.List<Klass>;
            _getField(index: int): Field;
            getFieldAccessFlags(index: int): short;
            getFieldByIndex(fieldIndex: int): Field;
            getFieldGenericSignature(index: int): Symbol;
            getFieldGenericSignatureIndex(index: int): int;
            getFieldInfoStream(): hotspot.utilities.U1Array;
            getFieldInitialValueIndex(index: int): int;
            getFieldName(index: int): Symbol;
            getFieldNameIndex(index: int): int;
            getFieldOffset(index: int): int;
            getFieldSignature(index: int): Symbol;
            getFieldSignatureIndex(index: int): int;
            getGenericSignature(): Symbol;
            getImmediateFields(): java.util.List<Field>;
            getImmediateMethods(): java.util.List<Method>;
            getInitState(): InstanceKlass$ClassState;
            getInitStateAsInt(): int;
            getInnerClasses(): hotspot.utilities.U2Array;
            getItableLen(): long;
            getJavaFieldsCount(): int;
            getJavaSuper(): Klass;
            getLocalInterfaces(): hotspot.utilities.KlassArray;
            getMethodOrdering(): hotspot.utilities.IntArray;
            getMethods(): hotspot.utilities.MethodArray;
            getNonstaticFieldSize(): long;
            getNonstaticOopMapSize(): long;
            getObjectSize(object: Oop): long;
            getSize(): long;
            getSizeHelper(): long;
            getSourceDebugExtension(): string;
            getSourceFileName(): Symbol;
            getStaticFields(): Field[];
            getStaticOopFieldCount(): long;
            getSymbolFromIndex(cpIndex: int, injected: boolean): Symbol;
            getTransitiveInterfaces(): hotspot.utilities.KlassArray;
            implementsInterface(k: Klass): boolean;
            _initFieldCounts(): void;
            isBeingInitialized(): boolean;
            isInErrorState(): boolean;
            _isInInnerClasses(sym: Symbol, includeLocals: boolean): boolean;
            isInitialized(): boolean;
            isInnerClassName(sym: Symbol): boolean;
            isInnerOrLocalClassName(sym: Symbol): boolean;
            isLinked(): boolean;
            isLoaded(): boolean;
            isNotInitialized(): boolean;
            iterateFields(visitor: MetadataVisitor): void;
            iterateNonStaticFields(visitor: OopVisitor, obj: Oop): void;
            iterateStaticFields(visitor: OopVisitor): void;
            _iterateStaticFieldsInternal(visitor: OopVisitor): void;
            majorVersion(): long;
            minorVersion(): long;
            _newField(index: int): Field;
            printValueOn(tty: java.io.PrintStream): void;
            signature(): string;
            _visitField(visitor: OopVisitor, type: FieldType, index: int): void;
            _allFieldsCount: int;
            _fields: Field[];
            _javaFieldsCount: int;
          }
          interface InstanceKlass extends CombineTypes<[_InstanceKlass, sun.jvm.hotspot.oops.Klass]> {}
          interface _InstanceKlass$ClassState$$static extends ClassLike {
            readonly ALLOCATED: InstanceKlass$ClassState;
            readonly BEING_INITIALIZED: InstanceKlass$ClassState;
            readonly FULLY_INITIALIZED: InstanceKlass$ClassState;
            readonly INITIALIZATION_ERROR: InstanceKlass$ClassState;
            readonly LINKED: InstanceKlass$ClassState;
            readonly LOADED: InstanceKlass$ClassState;
          }
          let InstanceKlass$ClassState: _InstanceKlass$ClassState$$static;
          interface _InstanceKlass$ClassState {
            toString(): string;
            _value: string;
          }
          interface InstanceKlass$ClassState extends CombineTypes<[_InstanceKlass$ClassState, java.lang.Object]> {}
          interface _InstanceKlass$EnclosingMethodAttributeOffset$$static extends ClassLike {
            _initialize(db: hotspot.types.TypeDataBase): void;
            enclosingMethodAttributeSize: int;
          }
          let InstanceKlass$EnclosingMethodAttributeOffset: _InstanceKlass$EnclosingMethodAttributeOffset$$static;
          interface _InstanceKlass$EnclosingMethodAttributeOffset {
          }
          interface InstanceKlass$EnclosingMethodAttributeOffset extends CombineTypes<[_InstanceKlass$EnclosingMethodAttributeOffset, java.lang.Object]> {}
          interface _InstanceKlass$InnerClassAttributeOffset$$static extends ClassLike {
            _initialize(db: hotspot.types.TypeDataBase): void;
            innerClassAccessFlagsOffset: int;
            innerClassInnerClassInfoOffset: int;
            innerClassInnerNameOffset: int;
            innerClassNextOffset: int;
            innerClassOuterClassInfoOffset: int;
          }
          let InstanceKlass$InnerClassAttributeOffset: _InstanceKlass$InnerClassAttributeOffset$$static;
          interface _InstanceKlass$InnerClassAttributeOffset {
          }
          interface InstanceKlass$InnerClassAttributeOffset extends CombineTypes<[_InstanceKlass$InnerClassAttributeOffset, java.lang.Object]> {}
          interface _InstanceKlass$StaticField$$static extends ClassLike {
            _new(field: Field, flags: AccessFlags): InstanceKlass$StaticField;
          }
          let InstanceKlass$StaticField: _InstanceKlass$StaticField$$static;
          interface _InstanceKlass$StaticField {
            field: Field;
            flags: AccessFlags;
          }
          interface InstanceKlass$StaticField extends CombineTypes<[_InstanceKlass$StaticField, java.lang.Object]> {}
          interface _InstanceMirrorKlass$$static extends ClassLike {
            _initialize(db: hotspot.types.TypeDataBase): void;
            new(addr: hotspot.debugger.Address): InstanceMirrorKlass;
          }
          let InstanceMirrorKlass: _InstanceMirrorKlass$$static;
          interface _InstanceMirrorKlass {
            getObjectSize(o: Oop): long;
            iterateNonStaticFields(visitor: OopVisitor, obj: Oop): void;
          }
          interface InstanceMirrorKlass extends CombineTypes<[_InstanceMirrorKlass, sun.jvm.hotspot.oops.InstanceKlass]> {}
          interface _InstanceRefKlass$$static extends ClassLike {
            _initialize(db: hotspot.types.TypeDataBase): void;
            new(addr: hotspot.debugger.Address): InstanceRefKlass;
          }
          let InstanceRefKlass: _InstanceRefKlass$$static;
          interface _InstanceRefKlass {
          }
          interface InstanceRefKlass extends CombineTypes<[_InstanceRefKlass, sun.jvm.hotspot.oops.InstanceKlass]> {}
          interface _InstanceStackChunkKlass$$static extends ClassLike {
            _initialize(db: hotspot.types.TypeDataBase): void;
            new(addr: hotspot.debugger.Address): InstanceStackChunkKlass;
          }
          let InstanceStackChunkKlass: _InstanceStackChunkKlass$$static;
          interface _InstanceStackChunkKlass {
          }
          interface InstanceStackChunkKlass extends CombineTypes<[_InstanceStackChunkKlass, sun.jvm.hotspot.oops.InstanceKlass]> {}
          interface _IntField$$static extends ClassLike {
            new(id: FieldIdentifier, offset: long, a2: boolean): IntField;
            new(vmField: hotspot.types.JIntField, startOffset: long): IntField;
            new(holder: InstanceKlass, fieldArrayIndex: int): IntField;
          }
          let IntField: _IntField$$static;
          interface _IntField {
            getValue(obj: Oop): int;
            getValue(obj: hotspot.runtime.VMObject): int;
            setValue(obj: Oop, value: int): void;
          }
          interface IntField extends CombineTypes<[_IntField, sun.jvm.hotspot.oops.Field]> {}
          interface _JVMDIClassStatus$$static extends ClassLike {
            readonly ERROR: int;
            readonly INITIALIZED: int;
            readonly PREPARED: int;
            readonly VERIFIED: int;
          }
          let JVMDIClassStatus: _JVMDIClassStatus$$static;
          interface _JVMDIClassStatus {
          }
          interface JVMDIClassStatus extends CombineTypes<[_JVMDIClassStatus, java.lang.Object]> {}
          interface _JumpData$$static extends ClassLike {
            _displacementOffset(): int;
            _staticCellCount(): int;
            _takenOffset(): int;
            _displacementOffSet: int;
            _jumpCellCount: int;
            _takenOffSet: int;
            new(layout: DataLayout): JumpData;
          }
          let JumpData: _JumpData$$static;
          interface _JumpData {
            cellCount(): int;
            _displacement(): int;
            printDataOn(st: java.io.PrintStream): void;
            _taken(): int;
          }
          interface JumpData extends CombineTypes<[_JumpData, sun.jvm.hotspot.oops.ProfileData]> {}
          interface _Klass$$static extends ClassLike {
            _initialize(db: hotspot.types.TypeDataBase): void;
            LH_ARRAY_TAG_OBJ_VALUE: int;
            LH_ARRAY_TAG_SHIFT: int;
            LH_ARRAY_TAG_TYPE_VALUE: int;
            LH_ELEMENT_TYPE_SHIFT: int;
            LH_HEADER_SIZE_SHIFT: int;
            LH_INSTANCE_SLOW_PATH_BIT: int;
            LH_LOG2_ELEMENT_SIZE_SHIFT: int;
            _accessFlags: CIntField;
            _classLoaderData: hotspot.types.AddressField;
            _javaMirrorFieldOffset: long;
            _layoutHelper: IntField;
            _name: hotspot.types.AddressField;
            _nextLink: MetadataField;
            _nextSibling: MetadataField;
            _subklass: MetadataField;
            _superField: MetadataField;
            _traceIDField: hotspot.types.Field;
            _vtableLen: CIntField;
            new(addr: hotspot.debugger.Address): Klass;
          }
          let Klass: _Klass$$static;
          interface _Klass {
            arrayKlass(rank: int): Klass;
            arrayKlass(): Klass;
            arrayKlassImpl(orNull: boolean, rank: int): Klass;
            arrayKlassImpl(orNull: boolean): Klass;
            arrayKlassOrNull(rank: int): Klass;
            arrayKlassOrNull(): Klass;
            computeModifierFlags(): long;
            _computeSubtypeOf(k: Klass): boolean;
            getAccessFlags(): long;
            getAccessFlagsObj(): AccessFlags;
            getClassLoader(): Oop;
            getClassLoaderData(): hotspot.classfile.ClassLoaderData;
            getClassModifiers(): long;
            getClassStatus(): int;
            getJavaMirror(): Instance;
            getJavaSuper(): Klass;
            getLayoutHelper(): int;
            getName(): Symbol;
            getNextLinkKlass(): Klass;
            getNextSiblingKlass(): Klass;
            getObjectSize(): long;
            getSubklassKlass(): Klass;
            getSuper(): Klass;
            _getSymbol(field: hotspot.types.AddressField): Symbol;
            getVtableLen(): long;
            hasFinalizer(): boolean;
            isAbstract(): boolean;
            isArrayKlass(): boolean;
            isCloneable(): boolean;
            isFinal(): boolean;
            isInterface(): boolean;
            isKlass(): boolean;
            isPublic(): boolean;
            isSubclassOf(k: Klass): boolean;
            isSubtypeOf(k: Klass): boolean;
            isSuper(): boolean;
            isSynthetic(): boolean;
            iterateFields(visitor: MetadataVisitor): void;
            lca(k2: Klass): Klass;
            printValueOn(tty: java.io.PrintStream): void;
            signature(): string;
            traceID(): long;
          }
          interface Klass extends CombineTypes<[_Klass, sun.jvm.hotspot.runtime.ClassConstants, sun.jvm.hotspot.oops.Metadata]> {}
          interface _LineNumberTableElement$$static extends ClassLike {
            new(start_bci: int, line_number: int): LineNumberTableElement;
          }
          let LineNumberTableElement: _LineNumberTableElement$$static;
          interface _LineNumberTableElement {
            getLineNumber(): int;
            getStartBCI(): int;
            _line_number: int;
            _start_bci: int;
          }
          interface LineNumberTableElement extends CombineTypes<[_LineNumberTableElement, java.lang.Object]> {}
          interface _LocalVariableTableElement$$static extends ClassLike {
            _initialize(db: hotspot.types.TypeDataBase): void;
            _offsetOfDescriptorCPIndex: long;
            _offsetOfLength: long;
            _offsetOfNameCPIndex: long;
            _offsetOfSignatureCPIndex: long;
            _offsetOfSlot: long;
            _offsetOfStartBCI: long;
            new(handle: hotspot.debugger.Address, offset: long): LocalVariableTableElement;
          }
          let LocalVariableTableElement: _LocalVariableTableElement$$static;
          interface _LocalVariableTableElement {
            getDescriptorCPIndex(): int;
            getLength(): int;
            getNameCPIndex(): int;
            getSignatureCPIndex(): int;
            getSlot(): int;
            getStartBCI(): int;
            _handle: hotspot.debugger.Address;
            _offset: long;
          }
          interface LocalVariableTableElement extends CombineTypes<[_LocalVariableTableElement, java.lang.Object]> {}
          interface _LongField$$static extends ClassLike {
            new(id: FieldIdentifier, offset: long, a2: boolean): LongField;
            new(vmField: hotspot.types.JLongField, startOffset: long): LongField;
            new(holder: InstanceKlass, fieldArrayIndex: int): LongField;
          }
          let LongField: _LongField$$static;
          interface _LongField {
            getValue(obj: Oop): long;
            getValue(obj: hotspot.runtime.VMObject): long;
            setValue(obj: Oop, value: long): void;
          }
          interface LongField extends CombineTypes<[_LongField, sun.jvm.hotspot.oops.Field]> {}
          interface _Mark$$static extends ClassLike {
            _initialize(db: hotspot.types.TypeDataBase): void;
            _ageBits: long;
            _ageMask: long;
            _ageMaskInPlace: long;
            _ageShift: long;
            _hashBits: long;
            _hashMask: long;
            _hashMaskInPlace: long;
            _hashShift: long;
            _lockBits: long;
            _lockMask: long;
            _lockMaskInPlace: long;
            _lockShift: long;
            _lockedValue: long;
            _markField: hotspot.types.CIntegerField;
            _markedValue: long;
            _maxAge: long;
            _maxHashBits: long;
            _monitorValue: long;
            _noHash: long;
            _noHashInPlace: long;
            _noLockInPlace: long;
            _unlockedValue: long;
            new(addr: hotspot.debugger.Address): Mark;
          }
          let Mark: _Mark$$static;
          interface _Mark {
            age(): int;
            displacedMarkHelper(): Mark;
            getSize(): long;
            hasDisplacedMarkHelper(): boolean;
            hasLocker(): boolean;
            hasMonitor(): boolean;
            hasNoHash(): boolean;
            hash(): long;
            isBeingInflated(): boolean;
            isLocked(): boolean;
            isMarked(): boolean;
            isUnlocked(): boolean;
            locker(): hotspot.runtime.BasicLock;
            monitor(): hotspot.runtime.ObjectMonitor;
            mustBePreserved(): boolean;
            printOn(tty: java.io.PrintStream): void;
            value(): long;
            valueAsAddress(): hotspot.debugger.Address;
          }
          interface Mark extends CombineTypes<[_Mark, sun.jvm.hotspot.runtime.VMObject]> {}
          interface _Metadata$$static extends ClassLike {
            alignSize(size: long): long;
            _initialize(db: hotspot.types.TypeDataBase): void;
            instantiateWrapperFor(addr: hotspot.debugger.Address): Metadata;
            _metadataConstructor: hotspot.runtime.VirtualBaseConstructor<Metadata>;
            new(addr: hotspot.debugger.Address): Metadata;
          }
          let Metadata: _Metadata$$static;
          interface _Metadata {
            dumpReplayData(out: java.io.PrintStream): void;
            isShared(): boolean;
            iterate(visitor: MetadataVisitor): void;
            _iterateFields(visitor: MetadataVisitor): void;
            printValueOn(a0: java.io.PrintStream): void;
(a0: java.io.PrintStream): void;
          }
          interface Metadata extends CombineTypes<[_Metadata, sun.jvm.hotspot.runtime.VMObject]> {}
          interface _MetadataField$$static extends ClassLike {
            new(vmField: hotspot.types.AddressField, startOffset: long): MetadataField;
          }
          let MetadataField: _MetadataField$$static;
          interface _MetadataField {
            getValue(obj: Oop): Metadata;
            getValue(obj: hotspot.runtime.VMObject): Metadata;
            getValue(addr: hotspot.debugger.Address): Metadata;
            setValue(obj: Oop, value: long): void;
          }
          interface MetadataField extends CombineTypes<[_MetadataField, sun.jvm.hotspot.oops.Field]> {}
          interface _MetadataVisitor$$static extends ClassLike {
          }
          let MetadataVisitor: _MetadataVisitor$$static;
          interface _MetadataVisitor {
            epilogue(): void;
            getObj(): Metadata;
            prologue(): void;
            setObj(a0: Metadata): void;
          }
          interface MetadataVisitor extends CombineTypes<[_MetadataVisitor, sun.jvm.hotspot.oops.FieldVisitor, java.lang.Object]> {}
          interface _Method$$static extends ClassLike {
            _classInitializerName(): string;
            _initialize(db: hotspot.types.TypeDataBase): void;
            _objectInitializerName(): string;
            _accessFlags: CIntField;
            _classInitializerName: string;
            _code: hotspot.types.AddressField;
            _constMethod: hotspot.types.AddressField;
            _methodCounters: hotspot.types.AddressField;
            _methodData: hotspot.types.AddressField;
            _objectInitializerName: string;
            _type: hotspot.types.Type;
            _vtableIndex: CIntField;
            new(addr: hotspot.debugger.Address): Method;
          }
          let Method: _Method$$static;
          interface _Method {
            dumpReplayData(out: java.io.PrintStream): void;
            externalNameAndSignature(): string;
            getAccessFlags(): long;
            getAccessFlagsObj(): AccessFlags;
            getBackedgeCount(): long;
            getByteCode(): byte[];
            getBytecodeByteArg(bci: int): byte;
            getBytecodeIntArg(bci: int): int;
            getBytecodeOrBPAt(bci: int): int;
            getBytecodeShortArg(bci: int): short;
            getCheckedExceptions(): CheckedExceptionElement[];
            getCodeSize(): long;
            getConstMethod(): ConstMethod;
            getConstants(): ConstantPool;
            getExceptionTable(): ExceptionTableElement[];
            getGenericSignature(): Symbol;
            getGenericSignatureIndex(): long;
            getInvocationCount(): long;
            getLineNumberFromBCI(bci: int): int;
            getLineNumberTable(): LineNumberTableElement[];
            getLocalVariableName(bci: int, slot: int): Symbol;
            getLocalVariableTable(): LocalVariableTableElement[];
            getMaskFor(bci: int): hotspot.interpreter.OopMapCacheEntry;
            getMaxLocals(): long;
            getMaxStack(): long;
            getMethodCounters(): MethodCounters;
            getMethodData(): MethodData;
            getMethodHolder(): InstanceKlass;
            getName(): Symbol;
            getNameIndex(): long;
            getNativeIntArg(bci: int): int;
            getNativeMethod(): hotspot.code.NMethod;
            getNativeShortArg(bci: int): short;
            getOrigBytecodeAt(bci: int): int;
            getSignature(): Symbol;
            getSignatureIndex(): long;
            getSize(): long;
            getSizeOfParameters(): long;
            getVtableIndex(): long;
            hasCheckedExceptions(): boolean;
            hasExceptionTable(): boolean;
            hasLineNumberTable(): boolean;
            hasLocalVariableTable(): boolean;
            interpreterInvocationCount(): long;
            interpreterThrowoutCount(): int;
            isAbstract(): boolean;
            isBridge(): boolean;
            isConstructor(): boolean;
            isFinal(): boolean;
            isMethod(): boolean;
            isNative(): boolean;
            isPackagePrivate(): boolean;
            isPrivate(): boolean;
            isProtected(): boolean;
            isPublic(): boolean;
            isStatic(): boolean;
            isStaticInitializer(): boolean;
            isStrict(): boolean;
            isSynchronized(): boolean;
            isSynthetic(): boolean;
            isVarArgs(): boolean;
            iterateFields(visitor: MetadataVisitor): void;
            nameAsAscii(): string;
            printValueOn(tty: java.io.PrintStream): void;
          }
          interface Method extends CombineTypes<[_Method, sun.jvm.hotspot.oops.Metadata]> {}
          interface _MethodCounters$$static extends ClassLike {
            _initialize(db: hotspot.types.TypeDataBase): void;
            _backedgeCounter: CIntField;
            _interpreterThrowoutCountField: CIntField;
            _invocationCounter: CIntField;
            new(addr: hotspot.debugger.Address): MethodCounters;
          }
          let MethodCounters: _MethodCounters$$static;
          interface _MethodCounters {
            getBackedgeCounter(): long;
            getInvocationCounter(): long;
            interpreterThrowoutCount(): int;
            printValueOn(tty: java.io.PrintStream): void;
          }
          interface MethodCounters extends CombineTypes<[_MethodCounters, sun.jvm.hotspot.oops.Metadata]> {}
          interface _MethodData$$static extends ClassLike {
            extraNbCells(dataLayout: DataLayout): int;
            _formatTrapState(trapState: int): string;
            _initialize(db: hotspot.types.TypeDataBase): void;
            _reasonIsRecordedPerBytecode(reason: int): boolean;
            _trapReasonName(reason: int): string;
            _trapStateAddReason(trapState: int, reason: int): int;
            _trapStateIsRecompiled(trapState: int): boolean;
            _trapStateReason(trapState: int): int;
            _trapStateSetRecompiled(trapState: int, z: boolean): int;
            _BciProfileWidth: int;
            _CompileThreshold: int;
            _Reason_LIMIT: int;
            _Reason_RECORDED_LIMIT: int;
            _Reason_many: int;
            _Reason_none: int;
            _TypeProfileWidth: int;
            _baseOffset: long;
            cellSize: int;
            _data: hotspot.types.AddressField;
            _dataSize: CIntField;
            _dsReasonMask: int;
            _dsRecompileBit: int;
            _method: MetadataField;
            _parametersTypeDataDi: CIntField;
            _size: CIntField;
            sizeofMethodDataOopDesc: int;
            _trapReasonName: string[];
            new(addr: hotspot.debugger.Address): MethodData;
          }
          let MethodData: _MethodData$$static;
          interface _MethodData {
            currentMileage(): int;
            data(): long[];
            _dataAt(dataIndex: int): ProfileData;
            _dataSize(): int;
            _dpToDi(dp: int): int;
            dumpReplayData(out: java.io.PrintStream): void;
            _dumpReplayDataCallTypeHelper(out: java.io.PrintStream, round: int, count: int, callTypeData: CallTypeDataInterface<Klass>): int;
            _dumpReplayDataExtraDataHelper(out: java.io.PrintStream, round: int, count: int): int;
            _dumpReplayDataReceiverTypeHelper(out: java.io.PrintStream, round: int, count: int, vdata: ReceiverTypeData<Klass,Method>): int;
            _dumpReplayDataTypeHelper(out: java.io.PrintStream, round: int, count: int, index: int, pdata: ProfileData, k: Klass): int;
            _extraDataBase(): DataLayout;
            _extraDataLimit(): DataLayout;
            _fetchDataAt(base: hotspot.debugger.Address, offset: long, a2: long): byte[];
            firstData(): ProfileData;
            _firstDi(): int;
            getKlassAtAddress(addr: hotspot.debugger.Address): Klass;
            getKlassAtAddress(a0: hotspot.debugger.Address): any;
            getMethod(): Method;
            getMethodAtAddress(addr: hotspot.debugger.Address): Method;
            getMethodAtAddress(a0: hotspot.debugger.Address): any;
            isMethodData(): boolean;
            _isValid(current: ProfileData): boolean;
            iterateFields(visitor: MetadataVisitor): void;
            _limitDataPosition(): DataLayout;
            _mileageOf(method: Method): int;
            nextData(current: ProfileData): ProfileData;
            _nextExtra(dataLayout: DataLayout): DataLayout;
            orig(): byte[];
            _outOfBounds(dataIndex: int): boolean;
            _parametersTypeData(): ParametersTypeData<Klass,Method>;
            printDataOn(st: java.io.PrintStream): void;
            printKlassValueOn(klass: Klass, st: java.io.PrintStream): void;
            printKlassValueOn(a0: any, a1: java.io.PrintStream): void;
            printMethodValueOn(method: Method, st: java.io.PrintStream): void;
            printMethodValueOn(a0: any, a1: java.io.PrintStream): void;
            printValueOn(tty: java.io.PrintStream): void;
            _size(): int;
            _sizeInBytes(): int;
          }
          interface MethodData extends CombineTypes<[_MethodData, MethodDataInterface<Klass,Method>, Metadata]> {}
          interface _MethodDataInterface$$static<K,M> extends ClassLike {
          }
          let MethodDataInterface: _MethodDataInterface$$static<K,M>;
          interface _MethodDataInterface<K,M> {
            getKlassAtAddress(a0: hotspot.debugger.Address): K;
            getMethodAtAddress(a0: hotspot.debugger.Address): M;
            printKlassValueOn(a0: K, a1: java.io.PrintStream): void;
            printMethodValueOn(a0: M, a1: java.io.PrintStream): void;
          }
          interface MethodDataInterface<K,M> extends CombineTypes<[_MethodDataInterface<K,M>, java.lang.Object]> {}
          interface _MultiBranchData$$static extends ClassLike {
            _caseArrayOffset(): int;
            _caseCountOffset(index: int): int;
            _defaultCountOffset(): int;
            _defaultDisplacementOffset(): int;
            _perCaseSize(): int;
            _relativeCountOffset(): int;
            _relativeDisplacementOffset(): int;
            _caseArrayStart: int;
            _defaultCountOffSet: int;
            _defaultDisaplacementOffSet: int;
            _perCaseCellCount: int;
            _relativeCountOffSet: int;
            _relativeDisplacementOffSet: int;
            new(layout: DataLayout): MultiBranchData;
          }
          let MultiBranchData: _MultiBranchData$$static;
          interface _MultiBranchData {
            cellCount(): int;
            _countAt(index: int): int;
            _defaultCount(): int;
            _defaultDisplacement(): int;
            _displacementAt(index: int): int;
            _numberOfCases(): int;
            printDataOn(st: java.io.PrintStream): void;
          }
          interface MultiBranchData extends CombineTypes<[_MultiBranchData, sun.jvm.hotspot.oops.ArrayData]> {}
          interface _MutationException$$static extends ClassLike {
            new(): MutationException;
            new(detail: string): MutationException;
          }
          let MutationException: _MutationException$$static;
          interface _MutationException {
          }
          interface MutationException extends CombineTypes<[_MutationException, java.lang.RuntimeException]> {}
          interface _NamedFieldIdentifier$$static extends ClassLike {
            new(name: string): NamedFieldIdentifier;
          }
          let NamedFieldIdentifier: _NamedFieldIdentifier$$static;
          interface _NamedFieldIdentifier {
            equals(obj: any): boolean;
            getName(): string;
            hashCode(): int;
            printOn(tty: java.io.PrintStream): void;
            _name: string;
          }
          interface NamedFieldIdentifier extends CombineTypes<[_NamedFieldIdentifier, sun.jvm.hotspot.oops.FieldIdentifier]> {}
          interface _NarrowKlassField$$static extends ClassLike {
            new(vmField: hotspot.types.AddressField, startOffset: long): NarrowKlassField;
          }
          let NarrowKlassField: _NarrowKlassField$$static;
          interface _NarrowKlassField {
            getValue(addr: hotspot.debugger.Address): Metadata;
            setValue(obj: Oop, value: long): void;
          }
          interface NarrowKlassField extends CombineTypes<[_NarrowKlassField, sun.jvm.hotspot.oops.MetadataField]> {}
          interface _NarrowOopField$$static extends ClassLike {
            new(id: FieldIdentifier, offset: long, a2: boolean): NarrowOopField;
            new(vmField: hotspot.types.OopField, startOffset: long): NarrowOopField;
            new(holder: InstanceKlass, fieldArrayIndex: int): NarrowOopField;
          }
          let NarrowOopField: _NarrowOopField$$static;
          interface _NarrowOopField {
            getValue(obj: Oop): Oop;
            getValueAsOopHandle(obj: Oop): hotspot.debugger.OopHandle;
            setValue(obj: Oop): void;
          }
          interface NarrowOopField extends CombineTypes<[_NarrowOopField, sun.jvm.hotspot.oops.OopField]> {}
          interface _ObjArray$$static extends ClassLike {
            _initialize(db: hotspot.types.TypeDataBase): void;
            _elementSize: long;
            _new(handle: hotspot.debugger.OopHandle, heap: ObjectHeap): ObjArray;
          }
          let ObjArray: _ObjArray$$static;
          interface _ObjArray {
            getObjAt(index: long): Oop;
            getOopHandleAt(index: long): hotspot.debugger.OopHandle;
            isObjArray(): boolean;
            iterateFields(visitor: OopVisitor, doVMFields: boolean): void;
            printValueOn(tty: java.io.PrintStream): void;
          }
          interface ObjArray extends CombineTypes<[_ObjArray, sun.jvm.hotspot.oops.Array]> {}
          interface _ObjArrayKlass$$static extends ClassLike {
            _initialize(db: hotspot.types.TypeDataBase): void;
            _bottomKlass: MetadataField;
            _elementKlass: MetadataField;
            new(addr: hotspot.debugger.Address): ObjArrayKlass;
          }
          let ObjArrayKlass: _ObjArrayKlass$$static;
          interface _ObjArrayKlass {
            arrayKlassImpl(orNull: boolean, n: int): Klass;
            arrayKlassImpl(orNull: boolean): Klass;
            computeModifierFlags(): long;
            getBottomKlass(): Klass;
            getElementKlass(): Klass;
            iterateFields(visitor: MetadataVisitor): void;
            printValueOn(tty: java.io.PrintStream): void;
          }
          interface ObjArrayKlass extends CombineTypes<[_ObjArrayKlass, sun.jvm.hotspot.oops.ArrayKlass]> {}
          interface _ObjectHeap$$static extends ClassLike {
            _DEBUG: boolean;
            new(db: hotspot.types.TypeDataBase): ObjectHeap;
          }
          let ObjectHeap: _ObjectHeap$$static;
          interface _ObjectHeap {
            _collectLiveRegions(): java.util.List<hotspot.debugger.Address>;
            equal(o1: Oop, o2: Oop): boolean;
            getBooleanSize(): int;
            getByteSize(): int;
            getCharSize(): int;
            getDoubleSize(): int;
            getFloatSize(): int;
            getIntSize(): int;
            getLongSize(): int;
            getOopSize(): int;
            getShortSize(): int;
            isValidMethod(handle: hotspot.debugger.Address): boolean;
            iterate(visitor: HeapVisitor): void;
            iterate(visitor: HeapVisitor, of: ObjectHeap$ObjectFilter): void;
            _iterateExact(visitor: HeapVisitor, k: Klass): void;
            _iterateLiveRegions(liveRegions: java.util.List<hotspot.debugger.Address>, visitor: HeapVisitor, of: ObjectHeap$ObjectFilter): void;
            iterateObjectsOfKlass(visitor: HeapVisitor, k: Klass, includeSubtypes: boolean): void;
            iterateObjectsOfKlass(visitor: HeapVisitor, k: Klass): void;
            iterateRaw(visitor: RawHeapVisitor): void;
            _iterateSubtypes(visitor: HeapVisitor, k: Klass): void;
            newOop(handle: hotspot.debugger.OopHandle): Oop;
            print(): void;
            _sortLiveRegions(liveRegions: java.util.List<hotspot.debugger.Address>): void;
            _booleanSize: int;
            _byteSize: int;
            _charSize: int;
            _doubleSize: int;
            _floatSize: int;
            _intSize: int;
            _longSize: int;
            _oopSize: int;
            _shortSize: int;
          }
          interface ObjectHeap extends CombineTypes<[_ObjectHeap, java.lang.Object]> {}
          interface _ObjectHeap$LiveRegionsCollector$$static extends ClassLike {
            _new(l: java.util.List<hotspot.debugger.Address>): ObjectHeap$LiveRegionsCollector;
          }
          let ObjectHeap$LiveRegionsCollector: _ObjectHeap$LiveRegionsCollector$$static;
          interface _ObjectHeap$LiveRegionsCollector {
            doLiveRegions(lrp: hotspot.gc.shared.LiveRegionsProvider): void;
            _liveRegions: java.util.List<hotspot.debugger.Address>;
          }
          interface ObjectHeap$LiveRegionsCollector extends CombineTypes<[_ObjectHeap$LiveRegionsCollector, sun.jvm.hotspot.gc.shared.LiveRegionsClosure, java.lang.Object]> {}
          interface _ObjectHeap$ObjectFilter$$static extends ClassLike {
          }
          let ObjectHeap$ObjectFilter: _ObjectHeap$ObjectFilter$$static;
          interface _ObjectHeap$ObjectFilter {
            canInclude(a0: Oop): boolean;
(a0: Oop): boolean;
          }
          interface ObjectHeap$ObjectFilter extends CombineTypes<[_ObjectHeap$ObjectFilter, java.lang.Object]> {}
          interface _ObjectHistogram$$static extends ClassLike {
            new(): ObjectHistogram;
          }
          let ObjectHistogram: _ObjectHistogram$$static;
          interface _ObjectHistogram {
            doObj(obj: Oop): boolean;
            epilogue(): void;
            getElements(): java.util.List<ObjectHistogramElement>;
            print(): void;
            printOn(tty: java.io.PrintStream): void;
            prologue(size: long): void;
            _map: java.util.HashMap<Klass,ObjectHistogramElement>;
          }
          interface ObjectHistogram extends CombineTypes<[_ObjectHistogram, java.lang.Object, sun.jvm.hotspot.oops.HeapVisitor]> {}
          interface _ObjectHistogramElement$$static extends ClassLike {
            titleOn(tty: java.io.PrintStream): void;
            new(k: Klass): ObjectHistogramElement;
          }
          let ObjectHistogramElement: _ObjectHistogramElement$$static;
          interface _ObjectHistogramElement {
            compare(other: ObjectHistogramElement): int;
            getCount(): long;
            getDescription(): string;
            _getInternalName(k: Klass): string;
            getKlass(): Klass;
            getSize(): long;
            printOn(tty: java.io.PrintStream): void;
            updateWith(obj: Oop): void;
            _count: long;
            _klass: Klass;
            _size: long;
          }
          interface ObjectHistogramElement extends CombineTypes<[_ObjectHistogramElement, java.lang.Object]> {}
          interface _Oop$$static extends ClassLike {
            alignObjectOffset(offset: long): long;
            alignObjectSize(size: long): long;
            getHeaderSize(): long;
            getKlassForOopHandle(handle: hotspot.debugger.OopHandle): Klass;
            _initialize(db: hotspot.types.TypeDataBase): void;
            printOopAddressOn(obj: Oop, tty: java.io.PrintStream): void;
            printOopValueOn(obj: Oop, tty: java.io.PrintStream): void;
            _compressedKlass: NarrowKlassField;
            _headerSize: long;
            _klass: MetadataField;
            _mark: CIntField;
            _new(handle: hotspot.debugger.OopHandle, heap: ObjectHeap): Oop;
          }
          let Oop: _Oop$$static;
          interface _Oop {
            equals(obj: any): boolean;
            getHandle(): hotspot.debugger.OopHandle;
            _getHeap(): ObjectHeap;
            getKlass(): Klass;
            getMark(): Mark;
            getObjectSize(): long;
            hashCode(): int;
            identityHash(): long;
            isA(k: Klass): boolean;
            isArray(): boolean;
            isInstance(): boolean;
            isInstanceRef(): boolean;
            isObjArray(): boolean;
            isThread(): boolean;
            isTypeArray(): boolean;
            iterate(visitor: OopVisitor, doVMFields: boolean): void;
            _iterateFields(visitor: OopVisitor, doVMFields: boolean): void;
            print(): void;
            printOn(tty: java.io.PrintStream): void;
            printRaw(): void;
            printRawOn(tty: java.io.PrintStream): void;
            printValue(): void;
            printValueOn(tty: java.io.PrintStream): void;
            slowIdentityHash(): long;
            verify(): boolean;
            _handle: hotspot.debugger.OopHandle;
            _heap: ObjectHeap;
          }
          interface Oop extends CombineTypes<[_Oop, java.lang.Object]> {}
          interface _OopField$$static extends ClassLike {
            new(id: FieldIdentifier, offset: long, a2: boolean): OopField;
            new(vmField: hotspot.types.OopField, startOffset: long): OopField;
            new(holder: InstanceKlass, fieldArrayIndex: int): OopField;
          }
          let OopField: _OopField$$static;
          interface _OopField {
            getValue(obj: Oop): Oop;
            getValue(obj: hotspot.runtime.VMObject): Oop;
            getValueAsOopHandle(obj: Oop): hotspot.debugger.OopHandle;
            getValueAsOopHandle(obj: hotspot.runtime.VMObject): hotspot.debugger.OopHandle;
            setValue(obj: Oop): void;
          }
          interface OopField extends CombineTypes<[_OopField, sun.jvm.hotspot.oops.Field]> {}
          interface _OopPrinter$$static extends ClassLike {
            new(tty: java.io.PrintStream): OopPrinter;
          }
          let OopPrinter: _OopPrinter$$static;
          interface _OopPrinter {
            doBoolean(field: BooleanField, isVMField: boolean): void;
            doByte(field: ByteField, isVMField: boolean): void;
            doCInt(field: CIntField, isVMField: boolean): void;
            doChar(field: CharField, isVMField: boolean): void;
            doDouble(field: DoubleField, isVMField: boolean): void;
            doFloat(field: FloatField, isVMField: boolean): void;
            doInt(field: IntField, isVMField: boolean): void;
            doLong(field: LongField, isVMField: boolean): void;
            doMetadata(field: MetadataField, isVMField: boolean): void;
            doOop(field: OopField, isVMField: boolean): void;
            doOop(field: NarrowOopField, isVMField: boolean): void;
            doShort(field: ShortField, isVMField: boolean): void;
            epilogue(): void;
            getObj(): Oop;
            _printField(field: Field): void;
            prologue(): void;
            setObj(obj: Oop): void;
            _obj: Oop;
            _tty: java.io.PrintStream;
          }
          interface OopPrinter extends CombineTypes<[_OopPrinter, sun.jvm.hotspot.oops.OopVisitor, java.lang.Object]> {}
          interface _OopUtilities$$static extends ClassLike {
            abstractOwnableSynchronizerGetOwnerThread(oop: Oop): Oop;
            byteArrayToString(byteArray: TypeArray, coder: byte): string;
            charArrayToString(charArray: TypeArray): string;
            escapeString(s: string): string;
            _initAbsOwnSyncFields(): void;
            _initThreadFields(): void;
            _initialize(db: hotspot.types.TypeDataBase): void;
            stringOopToEscapedString(stringOop: Oop): string;
            stringOopToString(stringOop: Oop): string;
            threadOopGetDaemon(threadOop: Oop): boolean;
            threadOopGetJavaThread(threadOop: Oop): hotspot.runtime.JavaThread;
            threadOopGetName(threadOop: Oop): string;
            threadOopGetParkBlocker(threadOop: Oop): Oop;
            threadOopGetPriority(threadOop: Oop): int;
            threadOopGetTID(threadOop: Oop): long;
            threadOopGetThreadStatus(threadOop: Oop): int;
            threadOopGetThreadStatusName(threadOop: Oop): string;
            _JVMTI_THREAD_STATE_ALIVE: int;
            THREAD_STATUS_BLOCKED_ON_MONITOR_ENTER: int;
            THREAD_STATUS_IN_OBJECT_WAIT: int;
            THREAD_STATUS_IN_OBJECT_WAIT_TIMED: int;
            THREAD_STATUS_NEW: int;
            THREAD_STATUS_PARKED: int;
            THREAD_STATUS_PARKED_TIMED: int;
            THREAD_STATUS_RUNNABLE: int;
            THREAD_STATUS_SLEEPING: int;
            THREAD_STATUS_TERMINATED: int;
            _absOwnSyncOwnerThreadField: OopField;
            _coderField: ByteField;
            _threadDaemonField: BooleanField;
            _threadEETopField: LongField;
            _threadHolderField: OopField;
            _threadNameField: OopField;
            _threadParkBlockerField: OopField;
            _threadPriorityField: IntField;
            _threadStatusField: IntField;
            _threadTIDField: LongField;
            _valueField: OopField;
            new(): OopUtilities;
          }
          let OopUtilities: _OopUtilities$$static;
          interface _OopUtilities {
          }
          interface OopUtilities extends CombineTypes<[_OopUtilities, java.lang.Object]> {}
          interface _OopVisitor$$static extends ClassLike {
          }
          let OopVisitor: _OopVisitor$$static;
          interface _OopVisitor {
            epilogue(): void;
            getObj(): Oop;
            prologue(): void;
            setObj(a0: Oop): void;
          }
          interface OopVisitor extends CombineTypes<[_OopVisitor, sun.jvm.hotspot.oops.FieldVisitor, java.lang.Object]> {}
          interface _ParametersTypeData$$static<K,M> extends ClassLike {
            _stackSlotLocalOffset(i: int): int;
            typeIndex(i: int): int;
            _typeLocalOffset(i: int): int;
            new(methodData: MethodDataInterface<K,M>, layout: DataLayout): ParametersTypeData<K,M>;
          }
          let ParametersTypeData: _ParametersTypeData$$static<K,M>;
          interface _ParametersTypeData<K,M> {
            cellCount(): int;
            numberOfParameters(): int;
            printDataOn(st: java.io.PrintStream): void;
            _stackSlot(i: int): int;
            type(i: int): K;
            _parameters: TypeStackSlotEntries<K,M>;
          }
          interface ParametersTypeData<K,M> extends CombineTypes<[_ParametersTypeData<K,M>, ArrayData]> {}
          interface _ProfileData$$static extends ClassLike {
            cellOffset(index: int): int;
            new(data: DataLayout): ProfileData;
            _new(): ProfileData;
          }
          let ProfileData: _ProfileData$$static;
          interface _ProfileData {
            addressAt(index: int): hotspot.debugger.Address;
            _bci(): int;
            cellCount(): int;
            data(): DataLayout;
            dp(): int;
            _flagAt(flagNumber: int): boolean;
            _intAt(index: int): int;
            _intptrAt(index: int): long;
            printDataOn(a0: java.io.PrintStream): void;
            _printShared(st: java.io.PrintStream, name: string): void;
            sizeInBytes(): int;
            _tab(st: java.io.PrintStream): void;
            toString(): string;
            _trapState(): int;
            _uintAt(index: int): int;
            __data: DataLayout;
          }
          interface ProfileData extends CombineTypes<[_ProfileData, java.lang.Object]> {}
          interface _RawHeapVisitor$$static extends ClassLike {
          }
          let RawHeapVisitor: _RawHeapVisitor$$static;
          interface _RawHeapVisitor {
            epilogue(): void;
            prologue(a0: long): void;
          }
          interface RawHeapVisitor extends CombineTypes<[_RawHeapVisitor, sun.jvm.hotspot.runtime.AddressVisitor, java.lang.Object]> {}
          interface _ReceiverTypeData$$static<K,M> extends ClassLike {
            receiverCellIndex(row: int): int;
            receiverCountCellIndex(row: int): int;
            _receiverCountOffset(row: int): int;
            _receiverOffset(row: int): int;
            _receiverTypeDataSize(): int;
            rowLimit(): int;
            _staticCellCount(): int;
            _INCLUDE_JVMCI: int;
            _count0Offset: int;
            _nonProfiledCountOffset: int;
            _receiver0Offset: int;
            _receiverTypeRowCellCount: int;
            new(methodData: MethodDataInterface<K,M>, layout: DataLayout): ReceiverTypeData<K,M>;
          }
          let ReceiverTypeData: _ReceiverTypeData$$static<K,M>;
          interface _ReceiverTypeData<K,M> {
            cellCount(): int;
            _isReceivertypedata(): boolean;
            printDataOn(st: java.io.PrintStream): void;
            _printReceiverDataOn(st: java.io.PrintStream): void;
            receiver(row: int): K;
            receiverCount(row: int): int;
            _receiverUnchecked(row: int): K;
            _methodData: MethodDataInterface<K,M>;
          }
          interface ReceiverTypeData<K,M> extends CombineTypes<[_ReceiverTypeData<K,M>, CounterData]> {}
          interface _ResolvedIndyArray$$static extends ClassLike {
            _initialize(db: hotspot.types.TypeDataBase): void;
            _dataFieldOffset: long;
            _elemType: hotspot.types.Type;
            new(addr: hotspot.debugger.Address): ResolvedIndyArray;
          }
          let ResolvedIndyArray: _ResolvedIndyArray$$static;
          interface _ResolvedIndyArray {
            getAt(index: int): ResolvedIndyEntry;
            getElemType(): hotspot.types.Type;
          }
          interface ResolvedIndyArray extends CombineTypes<[_ResolvedIndyArray, sun.jvm.hotspot.utilities.GenericArray]> {}
          interface _ResolvedIndyEntry$$static extends ClassLike {
            _initialize(db: hotspot.types.TypeDataBase): void;
            _baseOffset: long;
            _cpIndex: hotspot.types.CIntegerField;
            _size: long;
            _new(addr: hotspot.debugger.Address): ResolvedIndyEntry;
          }
          let ResolvedIndyEntry: _ResolvedIndyEntry$$static;
          interface _ResolvedIndyEntry {
            getConstantPoolIndex(): int;
            iterateFields(visitor: MetadataVisitor): void;
          }
          interface ResolvedIndyEntry extends CombineTypes<[_ResolvedIndyEntry, sun.jvm.hotspot.runtime.VMObject]> {}
          interface _RetData$$static extends ClassLike {
            _bciCellIndex(row: int): int;
            _bciCountCellIndex(row: int): int;
            _bciCountOffset(row: int): int;
            _bciDisplacementCellIndex(row: int): int;
            _bciDisplacementOffset(row: int): int;
            _bciOffset(row: int): int;
            _rowLimit(): int;
            _staticCellCount(): int;
            _bci0Offset: int;
            _count0Offset: int;
            _displacement0Offset: int;
            _noBci: int;
            _retRowCellCount: int;
            new(layout: DataLayout): RetData;
          }
          let RetData: _RetData$$static;
          interface _RetData {
            _bci(row: int): int;
            _bciCount(row: int): int;
            _bciDisplacement(row: int): int;
            cellCount(): int;
            printDataOn(st: java.io.PrintStream): void;
          }
          interface RetData extends CombineTypes<[_RetData, sun.jvm.hotspot.oops.CounterData]> {}
          interface _ReturnTypeEntry$$static<K,M> extends ClassLike {
            _staticCellCount(): int;
            _cellCount: int;
            _new(methodData: MethodDataInterface<K,M>, pd: ProfileData, baseOff: int): ReturnTypeEntry<K,M>;
          }
          let ReturnTypeEntry: _ReturnTypeEntry$$static<K,M>;
          interface _ReturnTypeEntry<K,M> {
            _printDataOn(st: java.io.PrintStream): void;
            _type(): K;
            _typeIndex(): int;
          }
          interface ReturnTypeEntry<K,M> extends CombineTypes<[_ReturnTypeEntry<K,M>, TypeEntries<K,M>]> {}
          interface _ShortField$$static extends ClassLike {
            new(id: FieldIdentifier, offset: long, a2: boolean): ShortField;
            new(vmField: hotspot.types.JShortField, startOffset: long): ShortField;
            new(holder: InstanceKlass, fieldArrayIndex: int): ShortField;
          }
          let ShortField: _ShortField$$static;
          interface _ShortField {
            getValue(obj: Oop): short;
            getValue(obj: hotspot.runtime.VMObject): short;
            setValue(obj: Oop, value: short): void;
          }
          interface ShortField extends CombineTypes<[_ShortField, sun.jvm.hotspot.oops.Field]> {}
          interface _SpeculativeTrapData$$static<K,M> extends ClassLike {
            methodIndex(): int;
            _staticCellCount(): int;
            _speculativeTrapCellCount: int;
            _speculativeTrapMethod: int;
            new(methodData: MethodDataInterface<K,M>, layout: DataLayout): SpeculativeTrapData<K,M>;
          }
          let SpeculativeTrapData: _SpeculativeTrapData$$static<K,M>;
          interface _SpeculativeTrapData<K,M> {
            cellCount(): int;
            method(): M;
            printDataOn(st: java.io.PrintStream): void;
            _methodData: MethodDataInterface<K,M>;
          }
          interface SpeculativeTrapData<K,M> extends CombineTypes<[_SpeculativeTrapData<K,M>, ProfileData]> {}
          interface _Symbol$$static extends ClassLike {
            create(addr: hotspot.debugger.Address): Symbol;
            _initialize(db: hotspot.types.TypeDataBase): void;
            _readModifiedUTF8(buf: byte[]): string;
            _baseOffset: long;
            _idHashAndRefcount: hotspot.types.CIntegerField;
            _lengthField: hotspot.types.CIntegerField;
            _new(addr: hotspot.debugger.Address): Symbol;
          }
          let Symbol: _Symbol$$static;
          interface _Symbol {
            asByteArray(): byte[];
            asString(): string;
            equals(modUTF8Chars: byte[]): boolean;
            equals(string: string): boolean;
            fastCompare(other: Symbol): long;
            getByteAt(index: long): byte;
            getLength(): long;
            isSymbol(): boolean;
            printValueOn(tty: java.io.PrintStream): void;
            startsWith(str: string): boolean;
          }
          interface Symbol extends CombineTypes<[_Symbol, sun.jvm.hotspot.runtime.VMObject]> {}
          interface _TypeArray$$static extends ClassLike {
            _initialize(db: hotspot.types.TypeDataBase): void;
            _new(handle: hotspot.debugger.OopHandle, heap: ObjectHeap): TypeArray;
          }
          let TypeArray: _TypeArray$$static;
          interface _TypeArray {
            getBooleanAt(index: long): boolean;
            getByteAt(index: long): byte;
            getCharAt(index: long): char;
            getDoubleAt(index: long): double;
            getFloatAt(index: long): float;
            getIntAt(index: long): int;
            getLongAt(index: long): long;
            getShortAt(index: long): short;
            isTypeArray(): boolean;
            iterateFields(visitor: OopVisitor, doVMFields: boolean): void;
            printValueOn(tty: java.io.PrintStream): void;
          }
          interface TypeArray extends CombineTypes<[_TypeArray, sun.jvm.hotspot.oops.Array]> {}
          interface _TypeArrayKlass$$static extends ClassLike {
            _initialize(db: hotspot.types.TypeDataBase): void;
            readonly T_BOOLEAN: int;
            readonly T_BYTE: int;
            readonly T_CHAR: int;
            readonly T_DOUBLE: int;
            readonly T_FLOAT: int;
            readonly T_INT: int;
            readonly T_LONG: int;
            readonly T_SHORT: int;
            _maxLength: IntField;
            new(addr: hotspot.debugger.Address): TypeArrayKlass;
          }
          let TypeArrayKlass: _TypeArrayKlass$$static;
          interface _TypeArrayKlass {
            arrayKlassImpl(orNull: boolean, n: int): Klass;
            arrayKlassImpl(orNull: boolean): Klass;
            getElementTypeName(): string;
            getMaxLength(): long;
            getTypeName(): string;
            iterateFields(visitor: MetadataVisitor): void;
            printValueOn(tty: java.io.PrintStream): void;
          }
          interface TypeArrayKlass extends CombineTypes<[_TypeArrayKlass, sun.jvm.hotspot.oops.ArrayKlass]> {}
          interface _TypeEntries$$static<K,M> extends ClassLike {
            _nullSeen: int;
            _statusBits: int;
            _typeKlassMask: int;
            _typeMask: int;
            _typeUnknown: int;
            _new(methodData: MethodDataInterface<K,M>, pd: ProfileData, baseOff: int): TypeEntries<K,M>;
          }
          let TypeEntries: _TypeEntries$$static<K,M>;
          interface _TypeEntries<K,M> {
            _intptrAt(index: int): long;
            _isTypeNone(index: int): boolean;
            _isTypeUnknown(index: int): boolean;
            _printKlass(st: java.io.PrintStream, index: int): void;
            _validKlass(index: int): K;
            _wasNullSeen(index: int): boolean;
            _baseOff: int;
            _methodData: MethodDataInterface<K,M>;
            _pd: ProfileData;
          }
          interface TypeEntries<K,M> extends CombineTypes<[_TypeEntries<K,M>, java.lang.Object]> {}
          interface _TypeEntriesAtCall$$static extends ClassLike {
            _argumentTypeLocalOffset(i: int): int;
            _cellCountLocalOffset(): int;
            _headerCellCount(): int;
            _stackSlotLocalOffset(i: int): int;
            new(): TypeEntriesAtCall;
          }
          let TypeEntriesAtCall: _TypeEntriesAtCall$$static;
          interface _TypeEntriesAtCall {
          }
          interface TypeEntriesAtCall extends CombineTypes<[_TypeEntriesAtCall, java.lang.Object]> {}
          interface _TypeStackSlotEntries$$static<K,M> extends ClassLike {
            _perArgCount(): int;
            _stackSlotLocalOffset(i: int): int;
            _typeLocalOffset(i: int): int;
            _perArgCellCount: int;
            _stackSlotEntry: int;
            _typeEntry: int;
            _new(methodData: MethodDataInterface<K,M>, pd: ProfileData, baseOff: int, nbEntries: int): TypeStackSlotEntries<K,M>;
          }
          let TypeStackSlotEntries: _TypeStackSlotEntries$$static<K,M>;
          interface _TypeStackSlotEntries<K,M> {
            _printDataOn(st: java.io.PrintStream): void;
            _stackSlot(i: int): int;
            _stackSlotOffset(i: int): int;
            _type(i: int): K;
            _typeIndex(i: int): int;
            _typeOffsetInCells(i: int): int;
            _numberOfEntries: int;
          }
          interface TypeStackSlotEntries<K,M> extends CombineTypes<[_TypeStackSlotEntries<K,M>, TypeEntries<K,M>]> {}
          interface _UnknownOopException$$static extends ClassLike {
            new(): UnknownOopException;
            new(detail: string): UnknownOopException;
          }
          let UnknownOopException: _UnknownOopException$$static;
          interface _UnknownOopException {
          }
          interface UnknownOopException extends CombineTypes<[_UnknownOopException, java.lang.RuntimeException]> {}
          interface _VMOopHandle$$static extends ClassLike {
            _initialize(db: hotspot.types.TypeDataBase): void;
            _objField: hotspot.types.AddressField;
            new(addr: hotspot.debugger.Address): VMOopHandle;
          }
          let VMOopHandle: _VMOopHandle$$static;
          interface _VMOopHandle {
            getObj(): hotspot.debugger.Address;
            resolve(): Instance;
          }
          interface VMOopHandle extends CombineTypes<[_VMOopHandle, sun.jvm.hotspot.runtime.VMObject]> {}
          interface _VirtualCallData$$static<K,M> extends ClassLike {
            _staticCellCount(): int;
            _virtualCallDataSize(): int;
            new(methodData: MethodDataInterface<K,M>, layout: DataLayout): VirtualCallData<K,M>;
          }
          let VirtualCallData: _VirtualCallData$$static<K,M>;
          interface _VirtualCallData<K,M> {
            cellCount(): int;
            printDataOn(st: java.io.PrintStream): void;
          }
          interface VirtualCallData<K,M> extends CombineTypes<[_VirtualCallData<K,M>, ReceiverTypeData<K,M>]> {}
          interface _VirtualCallTypeData$$static<K,M> extends ClassLike {
            _staticCellCount(): int;
            new(methodData: MethodDataInterface<K,M>, layout: DataLayout): VirtualCallTypeData<K,M>;
          }
          let VirtualCallTypeData: _VirtualCallTypeData$$static<K,M>;
          interface _VirtualCallTypeData<K,M> {
            argumentType(i: int): K;
            argumentTypeIndex(i: int): int;
            cellCount(): int;
            _cellCountGlobalOffset(): int;
            _cellCountNoHeader(): int;
            hasArguments(): boolean;
            hasReturn(): boolean;
            numberOfArguments(): int;
            printDataOn(st: java.io.PrintStream): void;
            returnType(): K;
            returnTypeIndex(): int;
            _args: TypeStackSlotEntries<K,M>;
            _ret: ReturnTypeEntry<K,M>;
          }
          interface VirtualCallTypeData<K,M> extends CombineTypes<[_VirtualCallTypeData<K,M>, VirtualCallData<K,M>, CallTypeDataInterface<K>]> {}
          interface _java_lang_Class$$static extends ClassLike {
            asExternalName(aClass: Oop): string;
            asKlass(aClass: Oop): Klass;
            getOopSize(aClass: Oop): long;
            _initialize(db: hotspot.types.TypeDataBase): void;
            _arrayKlassOffset: int;
            _klassOffset: int;
            _oopSizeField: IntField;
            new(): java_lang_Class;
          }
          let java_lang_Class: _java_lang_Class$$static;
          interface _java_lang_Class {
          }
          interface java_lang_Class extends CombineTypes<[_java_lang_Class, java.lang.Object]> {}
        }
        module opto {
          interface _Block$$static extends ClassLike {
            _initialize(db: hotspot.types.TypeDataBase): void;
            _domDepthField: hotspot.oops.CIntField;
            _freqField: hotspot.types.JDoubleField;
            _idomField: hotspot.types.AddressField;
            _nodesField: hotspot.types.AddressField;
            _numSuccsField: hotspot.oops.CIntField;
            _preOrderField: hotspot.oops.CIntField;
            _succsField: hotspot.types.AddressField;
            new(addr: hotspot.debugger.Address): Block;
          }
          let Block: _Block$$static;
          interface _Block {
            dump(out: java.io.PrintStream): void;
            freq(): double;
            nodes(): Node_List;
            preOrder(): int;
          }
          interface Block extends CombineTypes<[_Block, sun.jvm.hotspot.runtime.VMObject]> {}
          interface _Block_Array$$static extends ClassLike {
            _initialize(db: hotspot.types.TypeDataBase): void;
            _arenaField: hotspot.types.AddressField;
            _blocksField: hotspot.types.AddressField;
            _sizeField: hotspot.oops.CIntField;
            new(addr: hotspot.debugger.Address): Block_Array;
          }
          let Block_Array: _Block_Array$$static;
          interface _Block_Array {
            Max(): int;
            at(i: int): Block;
          }
          interface Block_Array extends CombineTypes<[_Block_Array, sun.jvm.hotspot.runtime.VMObject]> {}
          interface _Block_List$$static extends ClassLike {
            _initialize(db: hotspot.types.TypeDataBase): void;
            _cntField: hotspot.oops.CIntField;
            new(addr: hotspot.debugger.Address): Block_List;
          }
          let Block_List: _Block_List$$static;
          interface _Block_List {
            size(): int;
          }
          interface Block_List extends CombineTypes<[_Block_List, sun.jvm.hotspot.opto.Block_Array]> {}
          interface _CallDynamicJavaNode$$static extends ClassLike {
            _initialize(db: hotspot.types.TypeDataBase): void;
            new(addr: hotspot.debugger.Address): CallDynamicJavaNode;
          }
          let CallDynamicJavaNode: _CallDynamicJavaNode$$static;
          interface _CallDynamicJavaNode {
          }
          interface CallDynamicJavaNode extends CombineTypes<[_CallDynamicJavaNode, sun.jvm.hotspot.opto.CallJavaNode]> {}
          interface _CallJavaNode$$static extends ClassLike {
            _initialize(db: hotspot.types.TypeDataBase): void;
            _methodField: hotspot.types.AddressField;
            new(addr: hotspot.debugger.Address): CallJavaNode;
          }
          let CallJavaNode: _CallJavaNode$$static;
          interface _CallJavaNode {
            dumpSpec(out: java.io.PrintStream): void;
            method(): hotspot.ci.ciMethod;
          }
          interface CallJavaNode extends CombineTypes<[_CallJavaNode, sun.jvm.hotspot.opto.CallNode]> {}
          interface _CallNode$$static extends ClassLike {
            _initialize(db: hotspot.types.TypeDataBase): void;
            _entryPointField: hotspot.types.AddressField;
            new(addr: hotspot.debugger.Address): CallNode;
          }
          let CallNode: _CallNode$$static;
          interface _CallNode {
            dumpSpec(out: java.io.PrintStream): void;
            entryPoint(): hotspot.debugger.Address;
          }
          interface CallNode extends CombineTypes<[_CallNode, sun.jvm.hotspot.opto.SafePointNode]> {}
          interface _CallRuntimeNode$$static extends ClassLike {
            _initialize(db: hotspot.types.TypeDataBase): void;
            _nameField: hotspot.types.AddressField;
            new(addr: hotspot.debugger.Address): CallRuntimeNode;
          }
          let CallRuntimeNode: _CallRuntimeNode$$static;
          interface _CallRuntimeNode {
            dumpSpec(out: java.io.PrintStream): void;
            name(): string;
          }
          interface CallRuntimeNode extends CombineTypes<[_CallRuntimeNode, sun.jvm.hotspot.opto.CallNode]> {}
          interface _CallStaticJavaNode$$static extends ClassLike {
            _initialize(db: hotspot.types.TypeDataBase): void;
            _nameField: hotspot.types.AddressField;
            new(addr: hotspot.debugger.Address): CallStaticJavaNode;
          }
          let CallStaticJavaNode: _CallStaticJavaNode$$static;
          interface _CallStaticJavaNode {
            dumpSpec(out: java.io.PrintStream): void;
            name(): string;
          }
          interface CallStaticJavaNode extends CombineTypes<[_CallStaticJavaNode, sun.jvm.hotspot.opto.CallJavaNode]> {}
          interface _Compile$$static extends ClassLike {
            _initialize(db: hotspot.types.TypeDataBase): void;
            _cfgField: hotspot.types.AddressField;
            _entryBciField: hotspot.oops.CIntField;
            _iltField: hotspot.types.AddressField;
            _methodField: hotspot.types.AddressField;
            _regallocField: hotspot.types.AddressField;
            _rootField: hotspot.types.AddressField;
            _topField: hotspot.types.AddressField;
            _uniqueField: hotspot.oops.CIntField;
            new(addr: hotspot.debugger.Address): Compile;
          }
          let Compile: _Compile$$static;
          interface _Compile {
            cfg(): PhaseCFG;
            dumpInlineData(out: java.io.PrintStream): void;
            entryBci(): int;
            ilt(): InlineTree;
            method(): hotspot.ci.ciMethod;
            root(): Node;
          }
          interface Compile extends CombineTypes<[_Compile, sun.jvm.hotspot.runtime.VMObject]> {}
          interface _CompilerPhaseType$$static extends ClassLike {
            valueOf(name: string): CompilerPhaseType;
            values(): CompilerPhaseType[];
            readonly PHASE_AFTER_BEAUTIFY_LOOPS: CompilerPhaseType;
            readonly PHASE_AFTER_CLOOPS: CompilerPhaseType;
            readonly PHASE_AFTER_EA: CompilerPhaseType;
            readonly PHASE_AFTER_PARSING: CompilerPhaseType;
            readonly PHASE_AFTER_STRINGOPTS: CompilerPhaseType;
            readonly PHASE_BEFORE_BEAUTIFY_LOOPS: CompilerPhaseType;
            readonly PHASE_BEFORE_CLOOPS: CompilerPhaseType;
            readonly PHASE_BEFORE_MATCHING: CompilerPhaseType;
            readonly PHASE_BEFORE_REMOVEUSELESS: CompilerPhaseType;
            readonly PHASE_BEFORE_STRINGOPTS: CompilerPhaseType;
            readonly PHASE_CCP1: CompilerPhaseType;
            readonly PHASE_END: CompilerPhaseType;
            readonly PHASE_FAILURE: CompilerPhaseType;
            readonly PHASE_FINAL_CODE: CompilerPhaseType;
            readonly PHASE_GLOBAL_CODE_MOTION: CompilerPhaseType;
            readonly PHASE_INCREMENTAL_BOXING_INLINE: CompilerPhaseType;
            readonly PHASE_INCREMENTAL_INLINE: CompilerPhaseType;
            readonly PHASE_ITER_GVN1: CompilerPhaseType;
            readonly PHASE_ITER_GVN2: CompilerPhaseType;
            readonly PHASE_ITER_GVN_AFTER_EA: CompilerPhaseType;
            readonly PHASE_ITER_GVN_AFTER_ELIMINATION: CompilerPhaseType;
            readonly PHASE_NUM_TYPES: CompilerPhaseType;
            readonly PHASE_OPTIMIZE_FINISHED: CompilerPhaseType;
            readonly PHASE_PHASEIDEALLOOP1: CompilerPhaseType;
            readonly PHASE_PHASEIDEALLOOP2: CompilerPhaseType;
            readonly PHASE_PHASEIDEALLOOP3: CompilerPhaseType;
            readonly PHASE_PHASEIDEALLOOP_ITERATIONS: CompilerPhaseType;
            readonly PHASE_PHASEIDEAL_BEFORE_EA: CompilerPhaseType;
          }
          let CompilerPhaseType: _CompilerPhaseType$$static;
          interface _CompilerPhaseType {
            value(): string;
            _value: string;
          }
          interface CompilerPhaseType extends CombineTypes<[_CompilerPhaseType]> {}
          interface _HaltNode$$static extends ClassLike {
            _initialize(db: hotspot.types.TypeDataBase): void;
            new(addr: hotspot.debugger.Address): HaltNode;
          }
          let HaltNode: _HaltNode$$static;
          interface _HaltNode {
          }
          interface HaltNode extends CombineTypes<[_HaltNode, sun.jvm.hotspot.opto.Node]> {}
          interface _InlineTree$$static extends ClassLike {
            _initialize(db: hotspot.types.TypeDataBase): void;
            _callerJvmsField: hotspot.types.AddressField;
            _callerTreeField: hotspot.types.AddressField;
            _inlineTreeConstructor: hotspot.runtime.StaticBaseConstructor<InlineTree>;
            _methodField: hotspot.types.AddressField;
            _subtreesField: hotspot.types.AddressField;
            new(addr: hotspot.debugger.Address): InlineTree;
          }
          let InlineTree: _InlineTree$$static;
          interface _InlineTree {
            callerBci(): int;
            callerJvms(): JVMState;
            callerTree(): InlineTree;
            count(): int;
            dumpReplayData(out: java.io.PrintStream): void;
            inlineLevel(): int;
            method(): hotspot.ci.ciMethod;
            print(st: java.io.PrintStream): void;
            printImpl(st: java.io.PrintStream, indent: int): void;
            subtrees(): hotspot.utilities.GrowableArray<InlineTree>;
          }
          interface InlineTree extends CombineTypes<[_InlineTree, sun.jvm.hotspot.runtime.VMObject]> {}
          interface _JVMState$$static extends ClassLike {
            create(addr: hotspot.debugger.Address): JVMState;
            _initialize(db: hotspot.types.TypeDataBase): void;
            _bciField: hotspot.oops.CIntField;
            _callerField: hotspot.types.AddressField;
            _depthField: hotspot.oops.CIntField;
            _endoffField: hotspot.oops.CIntField;
            _locoffField: hotspot.oops.CIntField;
            _mapField: hotspot.types.AddressField;
            _methodField: hotspot.types.AddressField;
            _monoffField: hotspot.oops.CIntField;
            _scloffField: hotspot.oops.CIntField;
            _spField: hotspot.oops.CIntField;
            _stkoffField: hotspot.oops.CIntField;
            new(addr: hotspot.debugger.Address): JVMState;
          }
          let JVMState: _JVMState$$static;
          interface _JVMState {
            bci(): int;
            caller(): JVMState;
            depth(): int;
            dumpSpec(out: java.io.PrintStream): void;
            method(): hotspot.ci.ciMethod;
          }
          interface JVMState extends CombineTypes<[_JVMState, sun.jvm.hotspot.runtime.VMObject]> {}
          interface _LoopNode$$static extends ClassLike {
            _initialize(db: hotspot.types.TypeDataBase): void;
            new(addr: hotspot.debugger.Address): LoopNode;
          }
          let LoopNode: _LoopNode$$static;
          interface _LoopNode {
          }
          interface LoopNode extends CombineTypes<[_LoopNode, sun.jvm.hotspot.opto.RegionNode]> {}
          interface _MachCallJavaNode$$static extends ClassLike {
            _initialize(db: hotspot.types.TypeDataBase): void;
            _bciField: hotspot.oops.CIntField;
            _methodField: hotspot.types.AddressField;
            new(addr: hotspot.debugger.Address): MachCallJavaNode;
          }
          let MachCallJavaNode: _MachCallJavaNode$$static;
          interface _MachCallJavaNode {
            dumpSpec(st: java.io.PrintStream): void;
            method(): hotspot.ci.ciMethod;
          }
          interface MachCallJavaNode extends CombineTypes<[_MachCallJavaNode, sun.jvm.hotspot.opto.MachCallNode]> {}
          interface _MachCallNode$$static extends ClassLike {
            _initialize(db: hotspot.types.TypeDataBase): void;
            new(addr: hotspot.debugger.Address): MachCallNode;
          }
          let MachCallNode: _MachCallNode$$static;
          interface _MachCallNode {
            dumpSpec(st: java.io.PrintStream): void;
          }
          interface MachCallNode extends CombineTypes<[_MachCallNode, sun.jvm.hotspot.opto.MachSafePointNode]> {}
          interface _MachCallRuntimeNode$$static extends ClassLike {
            _initialize(db: hotspot.types.TypeDataBase): void;
            _nameField: hotspot.types.AddressField;
            new(addr: hotspot.debugger.Address): MachCallRuntimeNode;
          }
          let MachCallRuntimeNode: _MachCallRuntimeNode$$static;
          interface _MachCallRuntimeNode {
            dumpSpec(out: java.io.PrintStream): void;
            name(): string;
          }
          interface MachCallRuntimeNode extends CombineTypes<[_MachCallRuntimeNode, sun.jvm.hotspot.opto.MachCallJavaNode]> {}
          interface _MachCallStaticJavaNode$$static extends ClassLike {
            _initialize(db: hotspot.types.TypeDataBase): void;
            _nameField: hotspot.types.AddressField;
            new(addr: hotspot.debugger.Address): MachCallStaticJavaNode;
          }
          let MachCallStaticJavaNode: _MachCallStaticJavaNode$$static;
          interface _MachCallStaticJavaNode {
            dumpSpec(st: java.io.PrintStream): void;
            name(): string;
          }
          interface MachCallStaticJavaNode extends CombineTypes<[_MachCallStaticJavaNode, sun.jvm.hotspot.opto.MachCallJavaNode]> {}
          interface _MachIfNode$$static extends ClassLike {
            _initialize(db: hotspot.types.TypeDataBase): void;
            _fcntField: hotspot.types.JFloatField;
            _probField: hotspot.types.JFloatField;
            new(addr: hotspot.debugger.Address): MachIfNode;
          }
          let MachIfNode: _MachIfNode$$static;
          interface _MachIfNode {
            _cnt(): float;
            dumpSpec(out: java.io.PrintStream): void;
            _prob(): float;
          }
          interface MachIfNode extends CombineTypes<[_MachIfNode, sun.jvm.hotspot.opto.MachNode]> {}
          interface _MachNode$$static extends ClassLike {
            _initialize(db: hotspot.types.TypeDataBase): void;
            new(addr: hotspot.debugger.Address): MachNode;
          }
          let MachNode: _MachNode$$static;
          interface _MachNode {
          }
          interface MachNode extends CombineTypes<[_MachNode, sun.jvm.hotspot.opto.Node]> {}
          interface _MachReturnNode$$static extends ClassLike {
            _initialize(db: hotspot.types.TypeDataBase): void;
            new(addr: hotspot.debugger.Address): MachReturnNode;
          }
          let MachReturnNode: _MachReturnNode$$static;
          interface _MachReturnNode {
          }
          interface MachReturnNode extends CombineTypes<[_MachReturnNode, sun.jvm.hotspot.opto.MachNode]> {}
          interface _MachSafePointNode$$static extends ClassLike {
            _initialize(db: hotspot.types.TypeDataBase): void;
            _jvmadjField: hotspot.oops.CIntField;
            _jvmsField: hotspot.types.AddressField;
            new(addr: hotspot.debugger.Address): MachSafePointNode;
          }
          let MachSafePointNode: _MachSafePointNode$$static;
          interface _MachSafePointNode {
            dumpSpec(out: java.io.PrintStream): void;
            jvms(): JVMState;
          }
          interface MachSafePointNode extends CombineTypes<[_MachSafePointNode, sun.jvm.hotspot.opto.MachReturnNode]> {}
          interface _MultiNode$$static extends ClassLike {
            _initialize(db: hotspot.types.TypeDataBase): void;
            new(addr: hotspot.debugger.Address): MultiNode;
          }
          let MultiNode: _MultiNode$$static;
          interface _MultiNode {
          }
          interface MultiNode extends CombineTypes<[_MultiNode, sun.jvm.hotspot.opto.Node]> {}
          interface _Node$$static extends ClassLike {
            create(addr: hotspot.debugger.Address): Node;
            _initialize(db: hotspot.types.TypeDataBase): void;
            _cntField: hotspot.oops.CIntField;
            _constructors: java.util.HashMap;
            _idxField: hotspot.oops.CIntField;
            _inField: hotspot.types.AddressField;
            _maxField: hotspot.oops.CIntField;
            _nodeType: hotspot.types.Type;
            _nodes: java.util.HashMap<hotspot.debugger.Address,Node>;
            _outField: hotspot.types.AddressField;
            _outcntField: hotspot.oops.CIntField;
            _outmaxField: hotspot.oops.CIntField;
            _virtualConstructor: hotspot.runtime.VirtualBaseConstructor<Node>;
            new(addr: hotspot.debugger.Address): Node;
          }
          let Node: _Node$$static;
          interface _Node {
            Name(): string;
            collect(d: int, onlyCtrl: boolean): java.util.ArrayList<Node>;
            dump(depth: int, out: java.io.PrintStream): void;
            dump(out: java.io.PrintStream): void;
            _dumpNodes(s: Node, d: int, onlyCtrl: boolean, out: java.io.PrintStream): void;
            _dumpOut(out: java.io.PrintStream): void;
            dumpSpec(out: java.io.PrintStream): void;
            idx(): int;
            in(i: int): Node;
            len(): int;
            outcnt(): int;
            rawOut(i: int): Node;
            req(): int;
            __in: Node[];
            __out: Node[];
          }
          interface Node extends CombineTypes<[_Node, sun.jvm.hotspot.runtime.VMObject]> {}
          interface _Node$Instantiator$$static extends ClassLike {
            _new(): Node$Instantiator;
          }
          let Node$Instantiator: _Node$Instantiator$$static;
          interface _Node$Instantiator {
            _create(a0: hotspot.debugger.Address): Node;
(a0: hotspot.debugger.Address): Node;
          }
          interface Node$Instantiator extends CombineTypes<[_Node$Instantiator, java.lang.Object]> {}
          interface _Node_Array$$static extends ClassLike {
            _initialize(db: hotspot.types.TypeDataBase): void;
            _aField: hotspot.types.AddressField;
            _maxField: hotspot.oops.CIntField;
            _nodesField: hotspot.types.AddressField;
            new(addr: hotspot.debugger.Address): Node_Array;
          }
          let Node_Array: _Node_Array$$static;
          interface _Node_Array {
            Size(): int;
            at(i: int): Node;
          }
          interface Node_Array extends CombineTypes<[_Node_Array, sun.jvm.hotspot.runtime.VMObject]> {}
          interface _Node_List$$static extends ClassLike {
            _initialize(db: hotspot.types.TypeDataBase): void;
            _cntField: hotspot.oops.CIntField;
            new(addr: hotspot.debugger.Address): Node_List;
          }
          let Node_List: _Node_List$$static;
          interface _Node_List {
            size(): int;
          }
          interface Node_List extends CombineTypes<[_Node_List, sun.jvm.hotspot.opto.Node_Array]> {}
          interface _Phase$$static extends ClassLike {
            _initialize(db: hotspot.types.TypeDataBase): void;
            new(addr: hotspot.debugger.Address): Phase;
          }
          let Phase: _Phase$$static;
          interface _Phase {
          }
          interface Phase extends CombineTypes<[_Phase, sun.jvm.hotspot.runtime.VMObject]> {}
          interface _PhaseCFG$$static extends ClassLike {
            _initialize(db: hotspot.types.TypeDataBase): void;
            _bbsField: hotspot.types.AddressField;
            _blocksField: hotspot.types.AddressField;
            _brootField: hotspot.types.AddressField;
            _numBlocksField: hotspot.oops.CIntField;
            new(addr: hotspot.debugger.Address): PhaseCFG;
          }
          let PhaseCFG: _PhaseCFG$$static;
          interface _PhaseCFG {
            dump(out: java.io.PrintStream): void;
          }
          interface PhaseCFG extends CombineTypes<[_PhaseCFG, sun.jvm.hotspot.opto.Phase]> {}
          interface _PhaseRegAlloc$$static extends ClassLike {
            _initialize(db: hotspot.types.TypeDataBase): void;
            _framesizeField: hotspot.oops.CIntField;
            _maxRegField: hotspot.oops.CIntField;
            _nodeRegsField: hotspot.types.AddressField;
            _nodeRegsMaxIndexField: hotspot.oops.CIntField;
            new(addr: hotspot.debugger.Address): PhaseRegAlloc;
          }
          let PhaseRegAlloc: _PhaseRegAlloc$$static;
          interface _PhaseRegAlloc {
          }
          interface PhaseRegAlloc extends CombineTypes<[_PhaseRegAlloc, sun.jvm.hotspot.opto.Phase]> {}
          interface _PhiNode$$static extends ClassLike {
            _initialize(db: hotspot.types.TypeDataBase): void;
            new(addr: hotspot.debugger.Address): PhiNode;
          }
          let PhiNode: _PhiNode$$static;
          interface _PhiNode {
          }
          interface PhiNode extends CombineTypes<[_PhiNode, sun.jvm.hotspot.opto.TypeNode]> {}
          interface _ProjNode$$static extends ClassLike {
            _initialize(db: hotspot.types.TypeDataBase): void;
            new(addr: hotspot.debugger.Address): ProjNode;
          }
          let ProjNode: _ProjNode$$static;
          interface _ProjNode {
          }
          interface ProjNode extends CombineTypes<[_ProjNode, sun.jvm.hotspot.opto.Node]> {}
          interface _RegionNode$$static extends ClassLike {
            _initialize(db: hotspot.types.TypeDataBase): void;
            new(addr: hotspot.debugger.Address): RegionNode;
          }
          let RegionNode: _RegionNode$$static;
          interface _RegionNode {
          }
          interface RegionNode extends CombineTypes<[_RegionNode, sun.jvm.hotspot.opto.Node]> {}
          interface _RootNode$$static extends ClassLike {
            _initialize(db: hotspot.types.TypeDataBase): void;
            new(addr: hotspot.debugger.Address): RootNode;
          }
          let RootNode: _RootNode$$static;
          interface _RootNode {
          }
          interface RootNode extends CombineTypes<[_RootNode, sun.jvm.hotspot.opto.LoopNode]> {}
          interface _SafePointNode$$static extends ClassLike {
            _initialize(db: hotspot.types.TypeDataBase): void;
            _jvmsField: hotspot.types.AddressField;
            new(addr: hotspot.debugger.Address): SafePointNode;
          }
          let SafePointNode: _SafePointNode$$static;
          interface _SafePointNode {
            dumpSpec(out: java.io.PrintStream): void;
            jvms(): JVMState;
          }
          interface SafePointNode extends CombineTypes<[_SafePointNode, sun.jvm.hotspot.opto.MultiNode]> {}
          interface _TypeNode$$static extends ClassLike {
            _initialize(db: hotspot.types.TypeDataBase): void;
            new(addr: hotspot.debugger.Address): TypeNode;
          }
          let TypeNode: _TypeNode$$static;
          interface _TypeNode {
          }
          interface TypeNode extends CombineTypes<[_TypeNode, sun.jvm.hotspot.opto.Node]> {}
        }
        module prims {
          interface _JvmtiExport$$static extends ClassLike {
            canAccessLocalVariables(): boolean;
            canHotswapOrPostBreakpoint(): boolean;
            canPostOnExceptions(): boolean;
            _initialize(db: hotspot.types.TypeDataBase): void;
            _canAccessLocalVariables: hotspot.types.CIntegerField;
            _canHotswapOrPostBreakpoint: hotspot.types.CIntegerField;
            _canPostOnExceptions: hotspot.types.CIntegerField;
            new(): JvmtiExport;
          }
          let JvmtiExport: _JvmtiExport$$static;
          interface _JvmtiExport {
          }
          interface JvmtiExport extends CombineTypes<[_JvmtiExport, java.lang.Object]> {}
        }
        module runtime {
          module aarch64 {
            interface _AARCH64CurrentFrameGuess$$static extends ClassLike {
              _DEBUG: boolean;
              new(context: hotspot.debugger.aarch64.AARCH64ThreadContext, thread: JavaThread): AARCH64CurrentFrameGuess;
            }
            let AARCH64CurrentFrameGuess: _AARCH64CurrentFrameGuess$$static;
            interface _AARCH64CurrentFrameGuess {
              getFP(): hotspot.debugger.Address;
              getPC(): hotspot.debugger.Address;
              getSP(): hotspot.debugger.Address;
              run(regionInBytesToSearch: long): boolean;
              _setValues(sp: hotspot.debugger.Address, fp: hotspot.debugger.Address, pc: hotspot.debugger.Address): void;
              _context: hotspot.debugger.aarch64.AARCH64ThreadContext;
              _fpFound: hotspot.debugger.Address;
              _pcFound: hotspot.debugger.Address;
              _spFound: hotspot.debugger.Address;
              _thread: JavaThread;
            }
            interface AARCH64CurrentFrameGuess extends CombineTypes<[_AARCH64CurrentFrameGuess, java.lang.Object]> {}
            interface _AARCH64Frame$$static extends ClassLike {
              _initialize(db: hotspot.types.TypeDataBase): void;
              _DEBUG: boolean;
              _ENTRY_FRAME_CALL_WRAPPER_OFFSET: int;
              _INTERPRETER_FRAME_BCX_OFFSET: int;
              _INTERPRETER_FRAME_CACHE_OFFSET: int;
              _INTERPRETER_FRAME_INITIAL_SP_OFFSET: int;
              _INTERPRETER_FRAME_LAST_SP_OFFSET: int;
              _INTERPRETER_FRAME_LOCALS_OFFSET: int;
              _INTERPRETER_FRAME_MDX_OFFSET: int;
              _INTERPRETER_FRAME_METHOD_OFFSET: int;
              _INTERPRETER_FRAME_MIRROR_OFFSET: int;
              _INTERPRETER_FRAME_MONITOR_BLOCK_BOTTOM_OFFSET: int;
              _INTERPRETER_FRAME_MONITOR_BLOCK_TOP_OFFSET: int;
              _INTERPRETER_FRAME_PADDING_OFFSET: int;
              _INTERPRETER_FRAME_SENDER_SP_OFFSET: int;
              _LINK_OFFSET: int;
              _NATIVE_FRAME_INITIAL_PARAM_OFFSET: int;
              _RETURN_ADDR_OFFSET: int;
              _SENDER_SP_OFFSET: int;
              _fp: VMReg;
              _pacMaskField: hotspot.types.CIntegerField;
              _ropProtectionField: hotspot.types.CIntegerField;
              new(raw_sp: hotspot.debugger.Address, raw_fp: hotspot.debugger.Address, pc: hotspot.debugger.Address): AARCH64Frame;
              new(raw_sp: hotspot.debugger.Address, raw_fp: hotspot.debugger.Address): AARCH64Frame;
              new(raw_sp: hotspot.debugger.Address, raw_unextendedSp: hotspot.debugger.Address, raw_fp: hotspot.debugger.Address, pc: hotspot.debugger.Address): AARCH64Frame;
            }
            let AARCH64Frame: _AARCH64Frame$$static;
            interface _AARCH64Frame {
              _addressOfInterpreterFrameBCX(): hotspot.debugger.Address;
              addressOfInterpreterFrameCPCache(): hotspot.debugger.Address;
              addressOfInterpreterFrameExpressionStack(): hotspot.debugger.Address;
              addressOfInterpreterFrameLocals(): hotspot.debugger.Address;
              addressOfInterpreterFrameMDX(): hotspot.debugger.Address;
              addressOfInterpreterFrameMethod(): hotspot.debugger.Address;
              addressOfInterpreterFrameTOS(): hotspot.debugger.Address;
              addressOfInterpreterFrameTOSAt(slot: int): hotspot.debugger.Address;
              _addressOfSavedOopResult(): hotspot.debugger.Address;
              _addressOfSavedReceiver(): hotspot.debugger.Address;
              _adjustForDeopt(): void;
              _adjustUnextendedSP(): void;
              clone(): any;
              _dumpStack(): void;
              equals(arg: any): boolean;
              frameSize(): long;
              getEntryFrameCallWrapper(): JavaCallWrapper;
              getFP(): hotspot.debugger.Address;
              getID(): hotspot.debugger.Address;
              getInterpreterFrameBCI(): int;
              getInterpreterFrameExpressionStackDirection(): int;
              getInterpreterFrameSenderSP(): hotspot.debugger.Address;
              getLink(): hotspot.debugger.Address;
              getNativeParamAddr(idx: int): hotspot.debugger.Address;
              getSP(): hotspot.debugger.Address;
              getSenderPC(): hotspot.debugger.Address;
              getSenderPCAddr(): hotspot.debugger.Address;
              getSenderSP(): hotspot.debugger.Address;
              getSignalNameDbg(): string;
              getSignalNumberDbg(): int;
              getUnextendedSP(): hotspot.debugger.Address;
              _hasSenderPD(): boolean;
              hashCode(): int;
              interpreterFrameMonitorBegin(): BasicObjectLock;
              interpreterFrameMonitorEnd(): BasicObjectLock;
              interpreterFrameMonitorSize(): int;
              isInterpretedFrameValid(): boolean;
              isSignalHandlerFrameDbg(): boolean;
              sender(regMap: RegisterMap, cb: hotspot.code.CodeBlob): Frame;
              _senderForCompiledFrame(map: AARCH64RegisterMap, cb: hotspot.code.CodeBlob): Frame;
              _senderForEntryFrame(map: AARCH64RegisterMap): Frame;
              _senderForInterpreterFrame(map: AARCH64RegisterMap): Frame;
              _stripPAC(addr: hotspot.debugger.Address): hotspot.debugger.Address;
              toString(): string;
              _updateMapWithSavedLink(map: RegisterMap, savedFPAddr: hotspot.debugger.Address): void;
              _raw_fp: hotspot.debugger.Address;
              _raw_unextendedSP: hotspot.debugger.Address;
            }
            interface AARCH64Frame extends CombineTypes<[_AARCH64Frame, sun.jvm.hotspot.runtime.Frame]> {}
            interface _AARCH64JavaCallWrapper$$static extends ClassLike {
              _initialize(db: hotspot.types.TypeDataBase): void;
              _lastJavaFPField: hotspot.types.AddressField;
              new(addr: hotspot.debugger.Address): AARCH64JavaCallWrapper;
            }
            let AARCH64JavaCallWrapper: _AARCH64JavaCallWrapper$$static;
            interface _AARCH64JavaCallWrapper {
              getLastJavaFP(): hotspot.debugger.Address;
            }
            interface AARCH64JavaCallWrapper extends CombineTypes<[_AARCH64JavaCallWrapper, sun.jvm.hotspot.runtime.JavaCallWrapper]> {}
            interface _AARCH64RegisterMap$$static extends ClassLike {
              new(thread: JavaThread, updateMap: boolean): AARCH64RegisterMap;
              _new(map: RegisterMap): AARCH64RegisterMap;
            }
            let AARCH64RegisterMap: _AARCH64RegisterMap$$static;
            interface _AARCH64RegisterMap {
              _clearPD(): void;
              clone(): any;
              _getLocationPD(reg: VMReg): hotspot.debugger.Address;
              _initializeFromPD(map: RegisterMap): void;
              _initializePD(): void;
            }
            interface AARCH64RegisterMap extends CombineTypes<[_AARCH64RegisterMap, sun.jvm.hotspot.runtime.RegisterMap]> {}
          }
          module amd64 {
            interface _AMD64CurrentFrameGuess$$static extends ClassLike {
              _DEBUG: boolean;
              new(context: hotspot.debugger.amd64.AMD64ThreadContext, thread: JavaThread): AMD64CurrentFrameGuess;
            }
            let AMD64CurrentFrameGuess: _AMD64CurrentFrameGuess$$static;
            interface _AMD64CurrentFrameGuess {
              _checkLastJavaSP(): boolean;
              getFP(): hotspot.debugger.Address;
              getPC(): hotspot.debugger.Address;
              getSP(): hotspot.debugger.Address;
              run(regionInBytesToSearch: long): boolean;
              _setValues(sp: hotspot.debugger.Address, fp: hotspot.debugger.Address, pc: hotspot.debugger.Address): void;
              _validateInterpreterFrame(sp: hotspot.debugger.Address, fp: hotspot.debugger.Address, pc: hotspot.debugger.Address): boolean;
              _context: hotspot.debugger.amd64.AMD64ThreadContext;
              _fpFound: hotspot.debugger.Address;
              _pcFound: hotspot.debugger.Address;
              _spFound: hotspot.debugger.Address;
              _thread: JavaThread;
            }
            interface AMD64CurrentFrameGuess extends CombineTypes<[_AMD64CurrentFrameGuess, java.lang.Object]> {}
            interface _AMD64JavaCallWrapper$$static extends ClassLike {
              _initialize(db: hotspot.types.TypeDataBase): void;
              _lastJavaFPField: hotspot.types.AddressField;
              new(addr: hotspot.debugger.Address): AMD64JavaCallWrapper;
            }
            let AMD64JavaCallWrapper: _AMD64JavaCallWrapper$$static;
            interface _AMD64JavaCallWrapper {
              getLastJavaFP(): hotspot.debugger.Address;
            }
            interface AMD64JavaCallWrapper extends CombineTypes<[_AMD64JavaCallWrapper, sun.jvm.hotspot.runtime.JavaCallWrapper]> {}
          }
          module bsd {
            interface _BsdSignals$$static extends ClassLike {
              getSignalName(sigNum: int): string;
              _signalNames: string[];
              new(): BsdSignals;
            }
            let BsdSignals: _BsdSignals$$static;
            interface _BsdSignals {
            }
            interface BsdSignals extends CombineTypes<[_BsdSignals, java.lang.Object]> {}
          }
          module bsd_aarch64 {
            interface _BsdAARCH64JavaThreadPDAccess$$static extends ClassLike {
              _initialize(db: hotspot.types.TypeDataBase): void;
              _GUESS_SCAN_RANGE: long;
              _lastJavaFPField: hotspot.types.AddressField;
              _osThreadField: hotspot.types.AddressField;
              _osThreadThreadIDField: hotspot.types.CIntegerField;
              _osThreadUniqueThreadIDField: hotspot.types.CIntegerField;
              new(): BsdAARCH64JavaThreadPDAccess;
            }
            let BsdAARCH64JavaThreadPDAccess: _BsdAARCH64JavaThreadPDAccess$$static;
            interface _BsdAARCH64JavaThreadPDAccess {
              getBaseOfStackPointer(addr: hotspot.debugger.Address): hotspot.debugger.Address;
              getCurrentFrameGuess(thread: JavaThread, addr: hotspot.debugger.Address): Frame;
              getLastFramePD(thread: JavaThread, addr: hotspot.debugger.Address): Frame;
              getLastJavaFP(addr: hotspot.debugger.Address): hotspot.debugger.Address;
              getLastJavaPC(addr: hotspot.debugger.Address): hotspot.debugger.Address;
              getLastSP(addr: hotspot.debugger.Address): hotspot.debugger.Address;
              getThreadProxy(addr: hotspot.debugger.Address): hotspot.debugger.ThreadProxy;
              newRegisterMap(thread: JavaThread, updateMap: boolean): RegisterMap;
              printInfoOn(threadAddr: hotspot.debugger.Address, tty: java.io.PrintStream): void;
              printThreadIDOn(addr: hotspot.debugger.Address, tty: java.io.PrintStream): void;
            }
            interface BsdAARCH64JavaThreadPDAccess extends CombineTypes<[_BsdAARCH64JavaThreadPDAccess, sun.jvm.hotspot.runtime.JavaThreadPDAccess, java.lang.Object]> {}
          }
          module bsd_amd64 {
            interface _BsdAMD64JavaThreadPDAccess$$static extends ClassLike {
              _initialize(db: hotspot.types.TypeDataBase): void;
              _GUESS_SCAN_RANGE: long;
              _lastJavaFPField: hotspot.types.AddressField;
              _osThreadField: hotspot.types.AddressField;
              _osThreadThreadIDField: hotspot.types.CIntegerField;
              _osThreadUniqueThreadIDField: hotspot.types.CIntegerField;
              new(): BsdAMD64JavaThreadPDAccess;
            }
            let BsdAMD64JavaThreadPDAccess: _BsdAMD64JavaThreadPDAccess$$static;
            interface _BsdAMD64JavaThreadPDAccess {
              getBaseOfStackPointer(addr: hotspot.debugger.Address): hotspot.debugger.Address;
              getCurrentFrameGuess(thread: JavaThread, addr: hotspot.debugger.Address): Frame;
              getLastFramePD(thread: JavaThread, addr: hotspot.debugger.Address): Frame;
              getLastJavaFP(addr: hotspot.debugger.Address): hotspot.debugger.Address;
              getLastJavaPC(addr: hotspot.debugger.Address): hotspot.debugger.Address;
              getLastSP(addr: hotspot.debugger.Address): hotspot.debugger.Address;
              getThreadProxy(addr: hotspot.debugger.Address): hotspot.debugger.ThreadProxy;
              newRegisterMap(thread: JavaThread, updateMap: boolean): RegisterMap;
              printInfoOn(threadAddr: hotspot.debugger.Address, tty: java.io.PrintStream): void;
              printThreadIDOn(addr: hotspot.debugger.Address, tty: java.io.PrintStream): void;
            }
            interface BsdAMD64JavaThreadPDAccess extends CombineTypes<[_BsdAMD64JavaThreadPDAccess, sun.jvm.hotspot.runtime.JavaThreadPDAccess, java.lang.Object]> {}
          }
          module bsd_x86 {
            interface _BsdSignals$$static extends ClassLike {
              getSignalName(sigNum: int): string;
              _signalNames: string[];
              new(): BsdSignals;
            }
            let BsdSignals: _BsdSignals$$static;
            interface _BsdSignals {
            }
            interface BsdSignals extends CombineTypes<[_BsdSignals, java.lang.Object]> {}
            interface _BsdX86JavaThreadPDAccess$$static extends ClassLike {
              _initialize(db: hotspot.types.TypeDataBase): void;
              _GUESS_SCAN_RANGE: long;
              _lastJavaFPField: hotspot.types.AddressField;
              _osThreadField: hotspot.types.AddressField;
              _osThreadThreadIDField: hotspot.types.CIntegerField;
              new(): BsdX86JavaThreadPDAccess;
            }
            let BsdX86JavaThreadPDAccess: _BsdX86JavaThreadPDAccess$$static;
            interface _BsdX86JavaThreadPDAccess {
              getBaseOfStackPointer(addr: hotspot.debugger.Address): hotspot.debugger.Address;
              getCurrentFrameGuess(thread: JavaThread, addr: hotspot.debugger.Address): Frame;
              getLastFramePD(thread: JavaThread, addr: hotspot.debugger.Address): Frame;
              getLastJavaFP(addr: hotspot.debugger.Address): hotspot.debugger.Address;
              getLastJavaPC(addr: hotspot.debugger.Address): hotspot.debugger.Address;
              getLastSP(addr: hotspot.debugger.Address): hotspot.debugger.Address;
              getThreadProxy(addr: hotspot.debugger.Address): hotspot.debugger.ThreadProxy;
              newRegisterMap(thread: JavaThread, updateMap: boolean): RegisterMap;
              printInfoOn(threadAddr: hotspot.debugger.Address, tty: java.io.PrintStream): void;
              printThreadIDOn(addr: hotspot.debugger.Address, tty: java.io.PrintStream): void;
            }
            interface BsdX86JavaThreadPDAccess extends CombineTypes<[_BsdX86JavaThreadPDAccess, sun.jvm.hotspot.runtime.JavaThreadPDAccess, java.lang.Object]> {}
          }
          module linux {
            interface _LinuxSignals$$static extends ClassLike {
              getSignalName(sigNum: int): string;
              _signalNames: string[];
              new(): LinuxSignals;
            }
            let LinuxSignals: _LinuxSignals$$static;
            interface _LinuxSignals {
            }
            interface LinuxSignals extends CombineTypes<[_LinuxSignals, java.lang.Object]> {}
          }
          module linux_aarch64 {
            interface _LinuxAARCH64JavaThreadPDAccess$$static extends ClassLike {
              _initialize(db: hotspot.types.TypeDataBase): void;
              _GUESS_SCAN_RANGE: long;
              _lastJavaFPField: hotspot.types.AddressField;
              _osThreadField: hotspot.types.AddressField;
              _osThreadThreadIDField: hotspot.types.CIntegerField;
              new(): LinuxAARCH64JavaThreadPDAccess;
            }
            let LinuxAARCH64JavaThreadPDAccess: _LinuxAARCH64JavaThreadPDAccess$$static;
            interface _LinuxAARCH64JavaThreadPDAccess {
              getBaseOfStackPointer(addr: hotspot.debugger.Address): hotspot.debugger.Address;
              getCurrentFrameGuess(thread: JavaThread, addr: hotspot.debugger.Address): Frame;
              getLastFramePD(thread: JavaThread, addr: hotspot.debugger.Address): Frame;
              getLastJavaFP(addr: hotspot.debugger.Address): hotspot.debugger.Address;
              getLastJavaPC(addr: hotspot.debugger.Address): hotspot.debugger.Address;
              getLastSP(addr: hotspot.debugger.Address): hotspot.debugger.Address;
              getThreadProxy(addr: hotspot.debugger.Address): hotspot.debugger.ThreadProxy;
              newRegisterMap(thread: JavaThread, updateMap: boolean): RegisterMap;
              printInfoOn(threadAddr: hotspot.debugger.Address, tty: java.io.PrintStream): void;
              printThreadIDOn(addr: hotspot.debugger.Address, tty: java.io.PrintStream): void;
            }
            interface LinuxAARCH64JavaThreadPDAccess extends CombineTypes<[_LinuxAARCH64JavaThreadPDAccess, sun.jvm.hotspot.runtime.JavaThreadPDAccess, java.lang.Object]> {}
          }
          module linux_amd64 {
            interface _LinuxAMD64JavaThreadPDAccess$$static extends ClassLike {
              _initialize(db: hotspot.types.TypeDataBase): void;
              _GUESS_SCAN_RANGE: long;
              _lastJavaFPField: hotspot.types.AddressField;
              _osThreadField: hotspot.types.AddressField;
              _osThreadThreadIDField: hotspot.types.CIntegerField;
              new(): LinuxAMD64JavaThreadPDAccess;
            }
            let LinuxAMD64JavaThreadPDAccess: _LinuxAMD64JavaThreadPDAccess$$static;
            interface _LinuxAMD64JavaThreadPDAccess {
              getBaseOfStackPointer(addr: hotspot.debugger.Address): hotspot.debugger.Address;
              getCurrentFrameGuess(thread: JavaThread, addr: hotspot.debugger.Address): Frame;
              getLastFramePD(thread: JavaThread, addr: hotspot.debugger.Address): Frame;
              getLastJavaFP(addr: hotspot.debugger.Address): hotspot.debugger.Address;
              getLastJavaPC(addr: hotspot.debugger.Address): hotspot.debugger.Address;
              getLastSP(addr: hotspot.debugger.Address): hotspot.debugger.Address;
              getThreadProxy(addr: hotspot.debugger.Address): hotspot.debugger.ThreadProxy;
              newRegisterMap(thread: JavaThread, updateMap: boolean): RegisterMap;
              printInfoOn(threadAddr: hotspot.debugger.Address, tty: java.io.PrintStream): void;
              printThreadIDOn(addr: hotspot.debugger.Address, tty: java.io.PrintStream): void;
            }
            interface LinuxAMD64JavaThreadPDAccess extends CombineTypes<[_LinuxAMD64JavaThreadPDAccess, sun.jvm.hotspot.runtime.JavaThreadPDAccess, java.lang.Object]> {}
          }
          module linux_ppc64 {
            interface _LinuxPPC64JavaThreadPDAccess$$static extends ClassLike {
              _initialize(db: hotspot.types.TypeDataBase): void;
              _GUESS_SCAN_RANGE: long;
              _osThreadField: hotspot.types.AddressField;
              _osThreadThreadIDField: hotspot.types.CIntegerField;
              new(): LinuxPPC64JavaThreadPDAccess;
            }
            let LinuxPPC64JavaThreadPDAccess: _LinuxPPC64JavaThreadPDAccess$$static;
            interface _LinuxPPC64JavaThreadPDAccess {
              getBaseOfStackPointer(addr: hotspot.debugger.Address): hotspot.debugger.Address;
              getCurrentFrameGuess(thread: JavaThread, addr: hotspot.debugger.Address): Frame;
              getLastFP(addr: hotspot.debugger.Address): hotspot.debugger.Address;
              getLastFramePD(thread: JavaThread, addr: hotspot.debugger.Address): Frame;
              getLastJavaFP(addr: hotspot.debugger.Address): hotspot.debugger.Address;
              getLastJavaPC(addr: hotspot.debugger.Address): hotspot.debugger.Address;
              getLastSP(addr: hotspot.debugger.Address): hotspot.debugger.Address;
              getThreadProxy(addr: hotspot.debugger.Address): hotspot.debugger.ThreadProxy;
              newRegisterMap(thread: JavaThread, updateMap: boolean): RegisterMap;
              printInfoOn(threadAddr: hotspot.debugger.Address, tty: java.io.PrintStream): void;
              printThreadIDOn(addr: hotspot.debugger.Address, tty: java.io.PrintStream): void;
            }
            interface LinuxPPC64JavaThreadPDAccess extends CombineTypes<[_LinuxPPC64JavaThreadPDAccess, sun.jvm.hotspot.runtime.JavaThreadPDAccess, java.lang.Object]> {}
          }
          module linux_riscv64 {
            interface _LinuxRISCV64JavaThreadPDAccess$$static extends ClassLike {
              _initialize(db: hotspot.types.TypeDataBase): void;
              _GUESS_SCAN_RANGE: long;
              _lastJavaFPField: hotspot.types.AddressField;
              _osThreadField: hotspot.types.AddressField;
              _osThreadThreadIDField: hotspot.types.CIntegerField;
              new(): LinuxRISCV64JavaThreadPDAccess;
            }
            let LinuxRISCV64JavaThreadPDAccess: _LinuxRISCV64JavaThreadPDAccess$$static;
            interface _LinuxRISCV64JavaThreadPDAccess {
              getBaseOfStackPointer(addr: hotspot.debugger.Address): hotspot.debugger.Address;
              getCurrentFrameGuess(thread: JavaThread, addr: hotspot.debugger.Address): Frame;
              getLastFramePD(thread: JavaThread, addr: hotspot.debugger.Address): Frame;
              getLastJavaFP(addr: hotspot.debugger.Address): hotspot.debugger.Address;
              getLastJavaPC(addr: hotspot.debugger.Address): hotspot.debugger.Address;
              getLastSP(addr: hotspot.debugger.Address): hotspot.debugger.Address;
              getThreadProxy(addr: hotspot.debugger.Address): hotspot.debugger.ThreadProxy;
              newRegisterMap(thread: JavaThread, updateMap: boolean): RegisterMap;
              printInfoOn(threadAddr: hotspot.debugger.Address, tty: java.io.PrintStream): void;
              printThreadIDOn(addr: hotspot.debugger.Address, tty: java.io.PrintStream): void;
            }
            interface LinuxRISCV64JavaThreadPDAccess extends CombineTypes<[_LinuxRISCV64JavaThreadPDAccess, sun.jvm.hotspot.runtime.JavaThreadPDAccess, java.lang.Object]> {}
          }
          module linux_x86 {
            interface _LinuxSignals$$static extends ClassLike {
              getSignalName(sigNum: int): string;
              _signalNames: string[];
              new(): LinuxSignals;
            }
            let LinuxSignals: _LinuxSignals$$static;
            interface _LinuxSignals {
            }
            interface LinuxSignals extends CombineTypes<[_LinuxSignals, java.lang.Object]> {}
            interface _LinuxX86JavaThreadPDAccess$$static extends ClassLike {
              _initialize(db: hotspot.types.TypeDataBase): void;
              _GUESS_SCAN_RANGE: long;
              _lastJavaFPField: hotspot.types.AddressField;
              _osThreadField: hotspot.types.AddressField;
              _osThreadThreadIDField: hotspot.types.CIntegerField;
              new(): LinuxX86JavaThreadPDAccess;
            }
            let LinuxX86JavaThreadPDAccess: _LinuxX86JavaThreadPDAccess$$static;
            interface _LinuxX86JavaThreadPDAccess {
              getBaseOfStackPointer(addr: hotspot.debugger.Address): hotspot.debugger.Address;
              getCurrentFrameGuess(thread: JavaThread, addr: hotspot.debugger.Address): Frame;
              getLastFramePD(thread: JavaThread, addr: hotspot.debugger.Address): Frame;
              getLastJavaFP(addr: hotspot.debugger.Address): hotspot.debugger.Address;
              getLastJavaPC(addr: hotspot.debugger.Address): hotspot.debugger.Address;
              getLastSP(addr: hotspot.debugger.Address): hotspot.debugger.Address;
              getThreadProxy(addr: hotspot.debugger.Address): hotspot.debugger.ThreadProxy;
              newRegisterMap(thread: JavaThread, updateMap: boolean): RegisterMap;
              printInfoOn(threadAddr: hotspot.debugger.Address, tty: java.io.PrintStream): void;
              printThreadIDOn(addr: hotspot.debugger.Address, tty: java.io.PrintStream): void;
            }
            interface LinuxX86JavaThreadPDAccess extends CombineTypes<[_LinuxX86JavaThreadPDAccess, sun.jvm.hotspot.runtime.JavaThreadPDAccess, java.lang.Object]> {}
          }
          module posix {
            interface _POSIXSignals$$static extends ClassLike {
              getSignalName(sigNum: int): string;
              _signalNames: string[];
              new(): POSIXSignals;
            }
            let POSIXSignals: _POSIXSignals$$static;
            interface _POSIXSignals {
            }
            interface POSIXSignals extends CombineTypes<[_POSIXSignals, java.lang.Object]> {}
          }
          module ppc64 {
            interface _PPC64CurrentFrameGuess$$static extends ClassLike {
              _DEBUG: boolean;
              new(context: hotspot.debugger.ppc64.PPC64ThreadContext, thread: JavaThread): PPC64CurrentFrameGuess;
            }
            let PPC64CurrentFrameGuess: _PPC64CurrentFrameGuess$$static;
            interface _PPC64CurrentFrameGuess {
              getFP(): hotspot.debugger.Address;
              getPC(): hotspot.debugger.Address;
              getSP(): hotspot.debugger.Address;
              run(regionInBytesToSearch: long): boolean;
              _setValues(sp: hotspot.debugger.Address, fp: hotspot.debugger.Address, pc: hotspot.debugger.Address): void;
              _context: hotspot.debugger.ppc64.PPC64ThreadContext;
              _fpFound: hotspot.debugger.Address;
              _pcFound: hotspot.debugger.Address;
              _spFound: hotspot.debugger.Address;
              _thread: JavaThread;
            }
            interface PPC64CurrentFrameGuess extends CombineTypes<[_PPC64CurrentFrameGuess, java.lang.Object]> {}
            interface _PPC64Frame$$static extends ClassLike {
              _initialize(db: hotspot.types.TypeDataBase): void;
              _DEBUG: boolean;
              _ENTRY_FRAME_CALL_WRAPPER_OFFSET: int;
              _INTERPRETER_FRAME_BCX_OFFSET: int;
              _INTERPRETER_FRAME_CACHE_OFFSET: int;
              _INTERPRETER_FRAME_ESP_OFFSET: int;
              _INTERPRETER_FRAME_LAST_SP_OFFSET: int;
              _INTERPRETER_FRAME_LOCALS_OFFSET: int;
              _INTERPRETER_FRAME_MDX_OFFSET: int;
              _INTERPRETER_FRAME_METHOD_OFFSET: int;
              _INTERPRETER_FRAME_MIRROR_OFFSET: int;
              _INTERPRETER_FRAME_MONITORS_OFFSET: int;
              _INTERPRETER_FRAME_MONITOR_BLOCK_BOTTOM_OFFSET: int;
              _INTERPRETER_FRAME_SENDER_SP_OFFSET: int;
              _SENDER_SP_OFFSET: int;
              new(raw_sp: hotspot.debugger.Address, raw_fp: hotspot.debugger.Address, pc: hotspot.debugger.Address): PPC64Frame;
              new(raw_sp: hotspot.debugger.Address, raw_fp: hotspot.debugger.Address): PPC64Frame;
              new(raw_sp: hotspot.debugger.Address, raw_unextendedSp: hotspot.debugger.Address, raw_fp: hotspot.debugger.Address, pc: hotspot.debugger.Address): PPC64Frame;
            }
            let PPC64Frame: _PPC64Frame$$static;
            interface _PPC64Frame {
              _addressOfInterpreterFrameBCX(): hotspot.debugger.Address;
              addressOfInterpreterFrameCPCache(): hotspot.debugger.Address;
              addressOfInterpreterFrameExpressionStack(): hotspot.debugger.Address;
              addressOfInterpreterFrameLocals(): hotspot.debugger.Address;
              addressOfInterpreterFrameMDX(): hotspot.debugger.Address;
              addressOfInterpreterFrameMethod(): hotspot.debugger.Address;
              addressOfInterpreterFrameTOS(): hotspot.debugger.Address;
              addressOfInterpreterFrameTOSAt(slot: int): hotspot.debugger.Address;
              _addressOfSavedOopResult(): hotspot.debugger.Address;
              _addressOfSavedReceiver(): hotspot.debugger.Address;
              _adjustForDeopt(): void;
              _adjustUnextendedSP(): void;
              clone(): any;
              _dumpStack(): void;
              equals(arg: any): boolean;
              frameSize(): long;
              getEntryFrameCallWrapper(): JavaCallWrapper;
              getFP(): hotspot.debugger.Address;
              getID(): hotspot.debugger.Address;
              getInterpreterFrameBCI(): int;
              getInterpreterFrameExpressionStackDirection(): int;
              getInterpreterFrameSenderSP(): hotspot.debugger.Address;
              getLink(): hotspot.debugger.Address;
              getSP(): hotspot.debugger.Address;
              getSenderPC(): hotspot.debugger.Address;
              getSenderSP(): hotspot.debugger.Address;
              getSignalNameDbg(): string;
              getSignalNumberDbg(): int;
              getUnextendedSP(): hotspot.debugger.Address;
              _hasSenderPD(): boolean;
              hashCode(): int;
              interpreterFrameMonitorBegin(): BasicObjectLock;
              interpreterFrameMonitorEnd(): BasicObjectLock;
              interpreterFrameMonitorSize(): int;
              isInterpretedFrameValid(): boolean;
              isSignalHandlerFrameDbg(): boolean;
              sender(regMap: RegisterMap, cb: hotspot.code.CodeBlob): Frame;
              _senderForCompiledFrame(map: PPC64RegisterMap, cb: hotspot.code.CodeBlob): Frame;
              _senderForEntryFrame(map: PPC64RegisterMap): Frame;
              _senderForInterpreterFrame(map: PPC64RegisterMap): Frame;
              toString(): string;
              _raw_fp: hotspot.debugger.Address;
              _raw_unextendedSP: hotspot.debugger.Address;
            }
            interface PPC64Frame extends CombineTypes<[_PPC64Frame, sun.jvm.hotspot.runtime.Frame]> {}
            interface _PPC64JavaCallWrapper$$static extends ClassLike {
              new(addr: hotspot.debugger.Address): PPC64JavaCallWrapper;
            }
            let PPC64JavaCallWrapper: _PPC64JavaCallWrapper$$static;
            interface _PPC64JavaCallWrapper {
              getLastJavaFP(): hotspot.debugger.Address;
            }
            interface PPC64JavaCallWrapper extends CombineTypes<[_PPC64JavaCallWrapper, sun.jvm.hotspot.runtime.JavaCallWrapper]> {}
            interface _PPC64RegisterMap$$static extends ClassLike {
              new(thread: JavaThread, updateMap: boolean): PPC64RegisterMap;
              _new(map: RegisterMap): PPC64RegisterMap;
            }
            let PPC64RegisterMap: _PPC64RegisterMap$$static;
            interface _PPC64RegisterMap {
              _clearPD(): void;
              clone(): any;
              _getLocationPD(reg: VMReg): hotspot.debugger.Address;
              _initializeFromPD(map: RegisterMap): void;
              _initializePD(): void;
            }
            interface PPC64RegisterMap extends CombineTypes<[_PPC64RegisterMap, sun.jvm.hotspot.runtime.RegisterMap]> {}
          }
          module riscv64 {
            interface _RISCV64CurrentFrameGuess$$static extends ClassLike {
              _DEBUG: boolean;
              new(context: hotspot.debugger.riscv64.RISCV64ThreadContext, thread: JavaThread): RISCV64CurrentFrameGuess;
            }
            let RISCV64CurrentFrameGuess: _RISCV64CurrentFrameGuess$$static;
            interface _RISCV64CurrentFrameGuess {
              getFP(): hotspot.debugger.Address;
              getPC(): hotspot.debugger.Address;
              getSP(): hotspot.debugger.Address;
              run(regionInBytesToSearch: long): boolean;
              _setValues(sp: hotspot.debugger.Address, fp: hotspot.debugger.Address, pc: hotspot.debugger.Address): void;
              _context: hotspot.debugger.riscv64.RISCV64ThreadContext;
              _fpFound: hotspot.debugger.Address;
              _pcFound: hotspot.debugger.Address;
              _spFound: hotspot.debugger.Address;
              _thread: JavaThread;
            }
            interface RISCV64CurrentFrameGuess extends CombineTypes<[_RISCV64CurrentFrameGuess, java.lang.Object]> {}
            interface _RISCV64Frame$$static extends ClassLike {
              _initialize(db: hotspot.types.TypeDataBase): void;
              _DEBUG: boolean;
              _ENTRY_FRAME_CALL_WRAPPER_OFFSET: int;
              _INTERPRETER_FRAME_BCX_OFFSET: int;
              _INTERPRETER_FRAME_CACHE_OFFSET: int;
              _INTERPRETER_FRAME_INITIAL_SP_OFFSET: int;
              _INTERPRETER_FRAME_LAST_SP_OFFSET: int;
              _INTERPRETER_FRAME_LOCALS_OFFSET: int;
              _INTERPRETER_FRAME_MDX_OFFSET: int;
              _INTERPRETER_FRAME_METHOD_OFFSET: int;
              _INTERPRETER_FRAME_MIRROR_OFFSET: int;
              _INTERPRETER_FRAME_MONITOR_BLOCK_BOTTOM_OFFSET: int;
              _INTERPRETER_FRAME_MONITOR_BLOCK_TOP_OFFSET: int;
              _INTERPRETER_FRAME_PADDING_OFFSET: int;
              _INTERPRETER_FRAME_SENDER_SP_OFFSET: int;
              _LINK_OFFSET: int;
              _NATIVE_FRAME_INITIAL_PARAM_OFFSET: int;
              _RETURN_ADDR_OFFSET: int;
              _SENDER_SP_OFFSET: int;
              _fp: VMReg;
              new(raw_sp: hotspot.debugger.Address, raw_fp: hotspot.debugger.Address, pc: hotspot.debugger.Address): RISCV64Frame;
              new(raw_sp: hotspot.debugger.Address, raw_fp: hotspot.debugger.Address): RISCV64Frame;
              new(raw_sp: hotspot.debugger.Address, raw_unextendedSp: hotspot.debugger.Address, raw_fp: hotspot.debugger.Address, pc: hotspot.debugger.Address): RISCV64Frame;
            }
            let RISCV64Frame: _RISCV64Frame$$static;
            interface _RISCV64Frame {
              _addressOfInterpreterFrameBCX(): hotspot.debugger.Address;
              addressOfInterpreterFrameCPCache(): hotspot.debugger.Address;
              addressOfInterpreterFrameExpressionStack(): hotspot.debugger.Address;
              addressOfInterpreterFrameLocals(): hotspot.debugger.Address;
              addressOfInterpreterFrameMDX(): hotspot.debugger.Address;
              addressOfInterpreterFrameMethod(): hotspot.debugger.Address;
              addressOfInterpreterFrameTOS(): hotspot.debugger.Address;
              addressOfInterpreterFrameTOSAt(slot: int): hotspot.debugger.Address;
              _addressOfSavedOopResult(): hotspot.debugger.Address;
              _addressOfSavedReceiver(): hotspot.debugger.Address;
              _adjustForDeopt(): void;
              _adjustUnextendedSP(): void;
              clone(): any;
              _dumpStack(): void;
              equals(arg: any): boolean;
              frameSize(): long;
              getEntryFrameCallWrapper(): JavaCallWrapper;
              getFP(): hotspot.debugger.Address;
              getID(): hotspot.debugger.Address;
              getInterpreterFrameBCI(): int;
              getInterpreterFrameExpressionStackDirection(): int;
              getInterpreterFrameSenderSP(): hotspot.debugger.Address;
              getLink(): hotspot.debugger.Address;
              getNativeParamAddr(idx: int): hotspot.debugger.Address;
              getSP(): hotspot.debugger.Address;
              getSenderPC(): hotspot.debugger.Address;
              getSenderPCAddr(): hotspot.debugger.Address;
              getSenderSP(): hotspot.debugger.Address;
              getSignalNameDbg(): string;
              getSignalNumberDbg(): int;
              getUnextendedSP(): hotspot.debugger.Address;
              _hasSenderPD(): boolean;
              hashCode(): int;
              interpreterFrameMonitorBegin(): BasicObjectLock;
              interpreterFrameMonitorEnd(): BasicObjectLock;
              interpreterFrameMonitorSize(): int;
              isInterpretedFrameValid(): boolean;
              isSignalHandlerFrameDbg(): boolean;
              sender(regMap: RegisterMap, cb: hotspot.code.CodeBlob): Frame;
              _senderForCompiledFrame(map: RISCV64RegisterMap, cb: hotspot.code.CodeBlob): Frame;
              _senderForEntryFrame(map: RISCV64RegisterMap): Frame;
              _senderForInterpreterFrame(map: RISCV64RegisterMap): Frame;
              toString(): string;
              _updateMapWithSavedLink(map: RegisterMap, savedFPAddr: hotspot.debugger.Address): void;
              _raw_fp: hotspot.debugger.Address;
              _raw_unextendedSP: hotspot.debugger.Address;
            }
            interface RISCV64Frame extends CombineTypes<[_RISCV64Frame, sun.jvm.hotspot.runtime.Frame]> {}
            interface _RISCV64JavaCallWrapper$$static extends ClassLike {
              _initialize(db: hotspot.types.TypeDataBase): void;
              _lastJavaFPField: hotspot.types.AddressField;
              new(addr: hotspot.debugger.Address): RISCV64JavaCallWrapper;
            }
            let RISCV64JavaCallWrapper: _RISCV64JavaCallWrapper$$static;
            interface _RISCV64JavaCallWrapper {
              getLastJavaFP(): hotspot.debugger.Address;
            }
            interface RISCV64JavaCallWrapper extends CombineTypes<[_RISCV64JavaCallWrapper, sun.jvm.hotspot.runtime.JavaCallWrapper]> {}
            interface _RISCV64RegisterMap$$static extends ClassLike {
              new(thread: JavaThread, updateMap: boolean): RISCV64RegisterMap;
              _new(map: RegisterMap): RISCV64RegisterMap;
            }
            let RISCV64RegisterMap: _RISCV64RegisterMap$$static;
            interface _RISCV64RegisterMap {
              _clearPD(): void;
              clone(): any;
              _getLocationPD(reg: VMReg): hotspot.debugger.Address;
              _initializeFromPD(map: RegisterMap): void;
              _initializePD(): void;
            }
            interface RISCV64RegisterMap extends CombineTypes<[_RISCV64RegisterMap, sun.jvm.hotspot.runtime.RegisterMap]> {}
          }
          module win32_aarch64 {
            interface _Win32AARCH64JavaThreadPDAccess$$static extends ClassLike {
              _initialize(db: hotspot.types.TypeDataBase): void;
              _GUESS_SCAN_RANGE: long;
              _lastJavaFPField: hotspot.types.AddressField;
              _osThreadField: hotspot.types.AddressField;
              _osThreadThreadIDField: hotspot.types.Field;
              new(): Win32AARCH64JavaThreadPDAccess;
            }
            let Win32AARCH64JavaThreadPDAccess: _Win32AARCH64JavaThreadPDAccess$$static;
            interface _Win32AARCH64JavaThreadPDAccess {
              getBaseOfStackPointer(addr: hotspot.debugger.Address): hotspot.debugger.Address;
              getCurrentFrameGuess(thread: JavaThread, addr: hotspot.debugger.Address): Frame;
              getLastFramePD(thread: JavaThread, addr: hotspot.debugger.Address): Frame;
              getLastJavaFP(addr: hotspot.debugger.Address): hotspot.debugger.Address;
              getLastJavaPC(addr: hotspot.debugger.Address): hotspot.debugger.Address;
              getLastSP(addr: hotspot.debugger.Address): hotspot.debugger.Address;
              getThreadProxy(addr: hotspot.debugger.Address): hotspot.debugger.ThreadProxy;
              newRegisterMap(thread: JavaThread, updateMap: boolean): RegisterMap;
              printInfoOn(threadAddr: hotspot.debugger.Address, tty: java.io.PrintStream): void;
              printThreadIDOn(addr: hotspot.debugger.Address, tty: java.io.PrintStream): void;
            }
            interface Win32AARCH64JavaThreadPDAccess extends CombineTypes<[_Win32AARCH64JavaThreadPDAccess, sun.jvm.hotspot.runtime.JavaThreadPDAccess, java.lang.Object]> {}
          }
          module win32_amd64 {
            interface _Win32AMD64JavaThreadPDAccess$$static extends ClassLike {
              _initialize(db: hotspot.types.TypeDataBase): void;
              _GUESS_SCAN_RANGE: long;
              _lastJavaFPField: hotspot.types.AddressField;
              _osThreadField: hotspot.types.AddressField;
              _threadIdField: hotspot.types.Field;
              new(): Win32AMD64JavaThreadPDAccess;
            }
            let Win32AMD64JavaThreadPDAccess: _Win32AMD64JavaThreadPDAccess$$static;
            interface _Win32AMD64JavaThreadPDAccess {
              getBaseOfStackPointer(addr: hotspot.debugger.Address): hotspot.debugger.Address;
              getCurrentFrameGuess(thread: JavaThread, addr: hotspot.debugger.Address): Frame;
              getLastFramePD(thread: JavaThread, addr: hotspot.debugger.Address): Frame;
              getLastJavaFP(addr: hotspot.debugger.Address): hotspot.debugger.Address;
              getLastJavaPC(addr: hotspot.debugger.Address): hotspot.debugger.Address;
              getLastSP(addr: hotspot.debugger.Address): hotspot.debugger.Address;
              getThreadProxy(addr: hotspot.debugger.Address): hotspot.debugger.ThreadProxy;
              newRegisterMap(thread: JavaThread, updateMap: boolean): RegisterMap;
              printInfoOn(threadAddr: hotspot.debugger.Address, tty: java.io.PrintStream): void;
              printThreadIDOn(addr: hotspot.debugger.Address, tty: java.io.PrintStream): void;
            }
            interface Win32AMD64JavaThreadPDAccess extends CombineTypes<[_Win32AMD64JavaThreadPDAccess, sun.jvm.hotspot.runtime.JavaThreadPDAccess, java.lang.Object]> {}
          }
          module win32_x86 {
            interface _Win32X86JavaThreadPDAccess$$static extends ClassLike {
              _initialize(db: hotspot.types.TypeDataBase): void;
              _GUESS_SCAN_RANGE: long;
              _lastJavaFPField: hotspot.types.AddressField;
              _osThreadField: hotspot.types.AddressField;
              _threadIdField: hotspot.types.Field;
              new(): Win32X86JavaThreadPDAccess;
            }
            let Win32X86JavaThreadPDAccess: _Win32X86JavaThreadPDAccess$$static;
            interface _Win32X86JavaThreadPDAccess {
              getBaseOfStackPointer(addr: hotspot.debugger.Address): hotspot.debugger.Address;
              getCurrentFrameGuess(thread: JavaThread, addr: hotspot.debugger.Address): Frame;
              getLastFramePD(thread: JavaThread, addr: hotspot.debugger.Address): Frame;
              getLastJavaFP(addr: hotspot.debugger.Address): hotspot.debugger.Address;
              getLastJavaPC(addr: hotspot.debugger.Address): hotspot.debugger.Address;
              getLastSP(addr: hotspot.debugger.Address): hotspot.debugger.Address;
              getThreadProxy(addr: hotspot.debugger.Address): hotspot.debugger.ThreadProxy;
              newRegisterMap(thread: JavaThread, updateMap: boolean): RegisterMap;
              printInfoOn(threadAddr: hotspot.debugger.Address, tty: java.io.PrintStream): void;
              printThreadIDOn(addr: hotspot.debugger.Address, tty: java.io.PrintStream): void;
            }
            interface Win32X86JavaThreadPDAccess extends CombineTypes<[_Win32X86JavaThreadPDAccess, sun.jvm.hotspot.runtime.JavaThreadPDAccess, java.lang.Object]> {}
          }
          module x86 {
            interface _X86CurrentFrameGuess$$static extends ClassLike {
              _DEBUG: boolean;
              new(context: hotspot.debugger.x86.X86ThreadContext, thread: JavaThread): X86CurrentFrameGuess;
            }
            let X86CurrentFrameGuess: _X86CurrentFrameGuess$$static;
            interface _X86CurrentFrameGuess {
              getFP(): hotspot.debugger.Address;
              getPC(): hotspot.debugger.Address;
              getSP(): hotspot.debugger.Address;
              run(regionInBytesToSearch: long): boolean;
              _setValues(sp: hotspot.debugger.Address, fp: hotspot.debugger.Address, pc: hotspot.debugger.Address): void;
              _context: hotspot.debugger.x86.X86ThreadContext;
              _fpFound: hotspot.debugger.Address;
              _pcFound: hotspot.debugger.Address;
              _spFound: hotspot.debugger.Address;
              _thread: JavaThread;
            }
            interface X86CurrentFrameGuess extends CombineTypes<[_X86CurrentFrameGuess, java.lang.Object]> {}
            interface _X86Frame$$static extends ClassLike {
              _initialize(db: hotspot.types.TypeDataBase): void;
              _DEBUG: boolean;
              _ENTRY_FRAME_CALL_WRAPPER_OFFSET: int;
              _INTERPRETER_FRAME_BCX_OFFSET: int;
              _INTERPRETER_FRAME_CACHE_OFFSET: int;
              _INTERPRETER_FRAME_INITIAL_SP_OFFSET: int;
              _INTERPRETER_FRAME_LAST_SP_OFFSET: int;
              _INTERPRETER_FRAME_LOCALS_OFFSET: int;
              _INTERPRETER_FRAME_MDX_OFFSET: int;
              _INTERPRETER_FRAME_METHOD_OFFSET: int;
              _INTERPRETER_FRAME_MIRROR_OFFSET: int;
              _INTERPRETER_FRAME_MONITOR_BLOCK_BOTTOM_OFFSET: int;
              _INTERPRETER_FRAME_MONITOR_BLOCK_TOP_OFFSET: int;
              _INTERPRETER_FRAME_SENDER_SP_OFFSET: int;
              _LINK_OFFSET: int;
              _RETURN_ADDR_OFFSET: int;
              _SENDER_SP_OFFSET: int;
              _rbp: VMReg;
              new(raw_sp: hotspot.debugger.Address, raw_fp: hotspot.debugger.Address, pc: hotspot.debugger.Address): X86Frame;
              new(raw_sp: hotspot.debugger.Address, raw_fp: hotspot.debugger.Address): X86Frame;
              new(raw_sp: hotspot.debugger.Address, raw_unextendedSp: hotspot.debugger.Address, raw_fp: hotspot.debugger.Address, pc: hotspot.debugger.Address): X86Frame;
              new(raw_sp: hotspot.debugger.Address, raw_fp: hotspot.debugger.Address, pc: hotspot.debugger.Address, raw_unextendedSp: hotspot.debugger.Address, live_bcp: hotspot.debugger.Address): X86Frame;
            }
            let X86Frame: _X86Frame$$static;
            interface _X86Frame {
              _addressOfInterpreterFrameBCX(): hotspot.debugger.Address;
              addressOfInterpreterFrameCPCache(): hotspot.debugger.Address;
              addressOfInterpreterFrameExpressionStack(): hotspot.debugger.Address;
              addressOfInterpreterFrameLocals(): hotspot.debugger.Address;
              addressOfInterpreterFrameMDX(): hotspot.debugger.Address;
              addressOfInterpreterFrameMethod(): hotspot.debugger.Address;
              addressOfInterpreterFrameTOS(): hotspot.debugger.Address;
              addressOfInterpreterFrameTOSAt(slot: int): hotspot.debugger.Address;
              _addressOfSavedOopResult(): hotspot.debugger.Address;
              _addressOfSavedReceiver(): hotspot.debugger.Address;
              _adjustForDeopt(): void;
              _adjustUnextendedSP(): void;
              clone(): any;
              _dumpStack(): void;
              equals(arg: any): boolean;
              frameSize(): long;
              getEntryFrameCallWrapper(): JavaCallWrapper;
              getFP(): hotspot.debugger.Address;
              getID(): hotspot.debugger.Address;
              getInterpreterFrameBCI(): int;
              getInterpreterFrameBCP(): hotspot.debugger.Address;
              getInterpreterFrameExpressionStackDirection(): int;
              getInterpreterFrameSenderSP(): hotspot.debugger.Address;
              getLink(): hotspot.debugger.Address;
              getSP(): hotspot.debugger.Address;
              getSenderPC(): hotspot.debugger.Address;
              getSenderPCAddr(): hotspot.debugger.Address;
              getSenderSP(): hotspot.debugger.Address;
              getSignalNameDbg(): string;
              getSignalNumberDbg(): int;
              getUnextendedSP(): hotspot.debugger.Address;
              _hasSenderPD(): boolean;
              hashCode(): int;
              _initFrame(raw_sp: hotspot.debugger.Address, raw_fp: hotspot.debugger.Address, pc: hotspot.debugger.Address, raw_unextendedSp: hotspot.debugger.Address, live_bcp: hotspot.debugger.Address): void;
              interpreterFrameMonitorBegin(): BasicObjectLock;
              interpreterFrameMonitorEnd(): BasicObjectLock;
              interpreterFrameMonitorSize(): int;
              isInterpretedFrameValid(): boolean;
              isSignalHandlerFrameDbg(): boolean;
              sender(regMap: RegisterMap, cb: hotspot.code.CodeBlob): Frame;
              _senderForCompiledFrame(map: X86RegisterMap, cb: hotspot.code.CodeBlob): Frame;
              _senderForEntryFrame(map: X86RegisterMap): Frame;
              _senderForInterpreterFrame(map: X86RegisterMap): Frame;
              toString(): string;
              _updateMapWithSavedLink(map: RegisterMap, savedFPAddr: hotspot.debugger.Address): void;
              _live_bcp: hotspot.debugger.Address;
              _raw_fp: hotspot.debugger.Address;
              _raw_unextendedSP: hotspot.debugger.Address;
            }
            interface X86Frame extends CombineTypes<[_X86Frame, sun.jvm.hotspot.runtime.Frame]> {}
            interface _X86JavaCallWrapper$$static extends ClassLike {
              _initialize(db: hotspot.types.TypeDataBase): void;
              _lastJavaFPField: hotspot.types.AddressField;
              new(addr: hotspot.debugger.Address): X86JavaCallWrapper;
            }
            let X86JavaCallWrapper: _X86JavaCallWrapper$$static;
            interface _X86JavaCallWrapper {
              getLastJavaFP(): hotspot.debugger.Address;
            }
            interface X86JavaCallWrapper extends CombineTypes<[_X86JavaCallWrapper, sun.jvm.hotspot.runtime.JavaCallWrapper]> {}
            interface _X86RegisterMap$$static extends ClassLike {
              new(thread: JavaThread, updateMap: boolean): X86RegisterMap;
              _new(map: RegisterMap): X86RegisterMap;
            }
            let X86RegisterMap: _X86RegisterMap$$static;
            interface _X86RegisterMap {
              _clearPD(): void;
              clone(): any;
              _getLocationPD(reg: VMReg): hotspot.debugger.Address;
              _initializeFromPD(map: RegisterMap): void;
              _initializePD(): void;
            }
            interface X86RegisterMap extends CombineTypes<[_X86RegisterMap, sun.jvm.hotspot.runtime.RegisterMap]> {}
          }
          interface _AddressVisitor$$static extends ClassLike {
          }
          let AddressVisitor: _AddressVisitor$$static;
          interface _AddressVisitor {
            visitAddress(a0: hotspot.debugger.Address): void;
            visitCompOopAddress(a0: hotspot.debugger.Address): void;
          }
          interface AddressVisitor extends CombineTypes<[_AddressVisitor, java.lang.Object]> {}
          interface _ArgumentOopFinder$$static extends ClassLike {
            new(signature: hotspot.oops.Symbol, isStatic: boolean, fr: Frame, f: AddressVisitor): ArgumentOopFinder;
          }
          let ArgumentOopFinder: _ArgumentOopFinder$$static;
          interface _ArgumentOopFinder {
            _oopOffsetDo(): void;
            oopsDo(): void;
            _set(size: int, type: int): void;
            _f: AddressVisitor;
            _fr: Frame;
            _isStatic: boolean;
            _offset: int;
          }
          interface ArgumentOopFinder extends CombineTypes<[_ArgumentOopFinder, sun.jvm.hotspot.runtime.SignatureInfo]> {}
          interface _ArgumentSizeComputer$$static extends ClassLike {
            new(signature: hotspot.oops.Symbol): ArgumentSizeComputer;
          }
          let ArgumentSizeComputer: _ArgumentSizeComputer$$static;
          interface _ArgumentSizeComputer {
            _set(size: int, type: int): void;
          }
          interface ArgumentSizeComputer extends CombineTypes<[_ArgumentSizeComputer, sun.jvm.hotspot.runtime.SignatureInfo]> {}
          interface _Arguments$$static extends ClassLike {
            _buildString(arrayField: hotspot.types.AddressField, count: long): string;
            getJVMArgs(): string;
            getJVMFlags(): string;
            getJavaCommand(): string;
            _getString(field: hotspot.types.AddressField): string;
            _getStringAt(field: hotspot.types.AddressField, index: long): string;
            _initialize(db: hotspot.types.TypeDataBase): void;
            _javaCommandField: hotspot.types.AddressField;
            _jvmArgsArrayField: hotspot.types.AddressField;
            _jvmFlagsArrayField: hotspot.types.AddressField;
            _numJvmArgs: long;
            _numJvmFlags: long;
            new(): Arguments;
          }
          let Arguments: _Arguments$$static;
          interface _Arguments {
          }
          interface Arguments extends CombineTypes<[_Arguments, java.lang.Object]> {}
          interface _BasicLock$$static extends ClassLike {
            _initialize(db: hotspot.types.TypeDataBase): void;
            _displacedHeaderField: hotspot.types.CIntegerField;
            new(addr: hotspot.debugger.Address): BasicLock;
          }
          let BasicLock: _BasicLock$$static;
          interface _BasicLock {
            displacedHeader(): hotspot.oops.Mark;
          }
          interface BasicLock extends CombineTypes<[_BasicLock, sun.jvm.hotspot.runtime.VMObject]> {}
          interface _BasicObjectLock$$static extends ClassLike {
            _initialize(db: hotspot.types.TypeDataBase): void;
            size(): int;
            _lockField: hotspot.types.Field;
            _objField: hotspot.types.OopField;
            _size: int;
            new(addr: hotspot.debugger.Address): BasicObjectLock;
          }
          let BasicObjectLock: _BasicObjectLock$$static;
          interface _BasicObjectLock {
            address(): hotspot.debugger.Address;
            lock(): BasicLock;
            obj(): hotspot.debugger.OopHandle;
          }
          interface BasicObjectLock extends CombineTypes<[_BasicObjectLock, sun.jvm.hotspot.runtime.VMObject]> {}
          interface _BasicType$$static extends ClassLike {
            charToBasicType(c: char): BasicType;
            charToType(c: char): int;
            getTAddress(): int;
            getTArray(): int;
            getTBoolean(): int;
            getTByte(): int;
            getTChar(): int;
            getTConflict(): int;
            getTDouble(): int;
            getTFloat(): int;
            getTIllegal(): int;
            getTInt(): int;
            getTLong(): int;
            getTMetadata(): int;
            getTNarrowKlass(): int;
            getTNarrowOop(): int;
            getTObject(): int;
            getTShort(): int;
            getTVoid(): int;
            _initialize(db: hotspot.types.TypeDataBase): void;
            intToBasicType(i: int): BasicType;
            readonly T_ADDRESS: BasicType;
            readonly T_ARRAY: BasicType;
            readonly T_BOOLEAN: BasicType;
            readonly T_BYTE: BasicType;
            readonly T_CHAR: BasicType;
            readonly T_CONFLICT: BasicType;
            readonly T_DOUBLE: BasicType;
            readonly T_FLOAT: BasicType;
            readonly T_ILLEGAL: BasicType;
            readonly T_INT: BasicType;
            readonly T_LONG: BasicType;
            readonly T_METADATA: BasicType;
            readonly T_NARROWKLASS: BasicType;
            readonly T_NARROWOOP: BasicType;
            readonly T_OBJECT: BasicType;
            readonly T_SHORT: BasicType;
            readonly T_VOID: BasicType;
          }
          let BasicType: _BasicType$$static;
          interface _BasicType {
            getName(): string;
            getType(): int;
            _setType(type: int): void;
            _type: int;
          }
          interface BasicType extends CombineTypes<[_BasicType, java.lang.Object]> {}
          interface _BasicTypeSize$$static extends ClassLike {
            getTArraySize(): int;
            getTBooleanSize(): int;
            getTByteSize(): int;
            getTCharSize(): int;
            getTDoubleSize(): int;
            getTFloatSize(): int;
            getTIntSize(): int;
            getTLongSize(): int;
            getTNarrowKlassSize(): int;
            getTNarrowOopSize(): int;
            getTObjectSize(): int;
            getTShortSize(): int;
            getTVoidSize(): int;
            _initialize(db: hotspot.types.TypeDataBase): void;
            _tArraySize: int;
            _tBooleanSize: int;
            _tByteSize: int;
            _tCharSize: int;
            _tDoubleSize: int;
            _tFloatSize: int;
            _tIntSize: int;
            _tLongSize: int;
            _tNarrowKlassSize: int;
            _tNarrowOopSize: int;
            _tObjectSize: int;
            _tShortSize: int;
            _tVoidSize: int;
            new(): BasicTypeSize;
          }
          let BasicTypeSize: _BasicTypeSize$$static;
          interface _BasicTypeSize {
          }
          interface BasicTypeSize extends CombineTypes<[_BasicTypeSize, java.lang.Object]> {}
          interface _Bytes$$static extends ClassLike {
            new(machDesc: hotspot.debugger.MachineDescription): Bytes;
          }
          let Bytes: _Bytes$$static;
          interface _Bytes {
            swapInt(x: int): int;
            swapLong(x: long): long;
            swapShort(x: short): short;
            _swap: boolean;
          }
          interface Bytes extends CombineTypes<[_Bytes, java.lang.Object]> {}
          interface _ClassConstants$$static extends ClassLike {
            readonly JVM_ACC_ABSTRACT: long;
            readonly JVM_ACC_ANNOTATION: long;
            readonly JVM_ACC_BRIDGE: long;
            readonly JVM_ACC_ENUM: long;
            readonly JVM_ACC_FIELD_FLAGS: long;
            readonly JVM_ACC_FINAL: long;
            readonly JVM_ACC_HAS_FINALIZER: long;
            readonly JVM_ACC_INTERFACE: long;
            readonly JVM_ACC_IS_CLONEABLE: long;
            readonly JVM_ACC_NATIVE: long;
            readonly JVM_ACC_PRIVATE: long;
            readonly JVM_ACC_PROTECTED: long;
            readonly JVM_ACC_PUBLIC: long;
            readonly JVM_ACC_STATIC: long;
            readonly JVM_ACC_STRICT: long;
            readonly JVM_ACC_SUPER: long;
            readonly JVM_ACC_SYNCHRONIZED: long;
            readonly JVM_ACC_SYNTHETIC: long;
            readonly JVM_ACC_TRANSIENT: long;
            readonly JVM_ACC_VARARGS: long;
            readonly JVM_ACC_VOLATILE: long;
            readonly JVM_ACC_WRITTEN_FLAGS: long;
            readonly JVM_CONSTANT_Class: int;
            readonly JVM_CONSTANT_ClassIndex: int;
            readonly JVM_CONSTANT_Double: int;
            readonly JVM_CONSTANT_Dynamic: int;
            readonly JVM_CONSTANT_Fieldref: int;
            readonly JVM_CONSTANT_Float: int;
            readonly JVM_CONSTANT_Integer: int;
            readonly JVM_CONSTANT_InterfaceMethodref: int;
            readonly JVM_CONSTANT_Invalid: int;
            readonly JVM_CONSTANT_InvokeDynamic: int;
            readonly JVM_CONSTANT_Long: int;
            readonly JVM_CONSTANT_MethodHandle: int;
            readonly JVM_CONSTANT_MethodHandleInError: int;
            readonly JVM_CONSTANT_MethodType: int;
            readonly JVM_CONSTANT_MethodTypeInError: int;
            readonly JVM_CONSTANT_Methodref: int;
            readonly JVM_CONSTANT_Module: int;
            readonly JVM_CONSTANT_NameAndType: int;
            readonly JVM_CONSTANT_Package: int;
            readonly JVM_CONSTANT_String: int;
            readonly JVM_CONSTANT_StringIndex: int;
            readonly JVM_CONSTANT_Unicode: int;
            readonly JVM_CONSTANT_UnresolvedClass: int;
            readonly JVM_CONSTANT_UnresolvedClassInError: int;
            readonly JVM_CONSTANT_Utf8: int;
            readonly JVM_RECOGNIZED_CLASS_MODIFIERS: long;
            readonly JVM_RECOGNIZED_FIELD_MODIFIERS: long;
            readonly JVM_RECOGNIZED_METHOD_MODIFIERS: long;
            readonly JVM_REF_getField: int;
            readonly JVM_REF_getStatic: int;
            readonly JVM_REF_invokeInterface: int;
            readonly JVM_REF_invokeSpecial: int;
            readonly JVM_REF_invokeStatic: int;
            readonly JVM_REF_invokeVirtual: int;
            readonly JVM_REF_newInvokeSpecial: int;
            readonly JVM_REF_putField: int;
            readonly JVM_REF_putStatic: int;
            readonly MAJOR_VERSION: short;
            readonly MAJOR_VERSION_OLD: short;
            readonly MINOR_VERSION: short;
            readonly MINOR_VERSION_OLD: short;
          }
          let ClassConstants: _ClassConstants$$static;
          interface _ClassConstants {
          }
          interface ClassConstants extends CombineTypes<[_ClassConstants, java.lang.Object]> {}
          interface _CompiledVFrame$$static extends ClassLike {
            new(fr: Frame, regMap: RegisterMap, thread: JavaThread, scope: hotspot.code.ScopeDesc, mayBeImprecise: boolean): CompiledVFrame;
          }
          let CompiledVFrame: _CompiledVFrame$$static;
          interface _CompiledVFrame {
            _createStackValue(sv: hotspot.code.ScopeValue): StackValue;
            getBCI(): int;
            getCode(): hotspot.code.NMethod;
            getCodeUnsafe(): hotspot.code.NMethod;
            getExpressions(): StackValueCollection;
            getLocals(): StackValueCollection;
            getMethod(): hotspot.oops.Method;
            getMonitors(): java.util.List<MonitorInfo>;
            getRawBCI(): int;
            getScope(): hotspot.code.ScopeDesc;
            isCompiledFrame(): boolean;
            isDeoptimized(): boolean;
            isTop(): boolean;
            mayBeImpreciseDbg(): boolean;
            _resolveMonitorLock(location: hotspot.code.Location): BasicLock;
            sender(): VFrame;
            sender(mayBeImprecise: boolean): VFrame;
            _mayBeImprecise: boolean;
            _scope: hotspot.code.ScopeDesc;
          }
          interface CompiledVFrame extends CombineTypes<[_CompiledVFrame, sun.jvm.hotspot.runtime.JavaVFrame]> {}
          interface _CompilerThread$$static extends ClassLike {
            _initialize(db: hotspot.types.TypeDataBase): void;
            _envField: hotspot.types.AddressField;
            new(addr: hotspot.debugger.Address): CompilerThread;
          }
          let CompilerThread: _CompilerThread$$static;
          interface _CompilerThread {
            env(): hotspot.ci.ciEnv;
            isCompilerThread(): boolean;
            isHiddenFromExternalView(): boolean;
            isJavaThread(): boolean;
            __env: hotspot.ci.ciEnv;
          }
          interface CompilerThread extends CombineTypes<[_CompilerThread, sun.jvm.hotspot.runtime.JavaThread]> {}
          interface _ConcurrentLocksPrinter$$static extends ClassLike {
            new(): ConcurrentLocksPrinter;
          }
          let ConcurrentLocksPrinter: _ConcurrentLocksPrinter$$static;
          interface _ConcurrentLocksPrinter {
            _fillLocks(): void;
            _getOwnerThread(oop: hotspot.oops.Oop): JavaThread;
            print(jthread: JavaThread, tty: java.io.PrintStream): void;
            _locksMap: java.util.Map<JavaThread,java.util.List<hotspot.oops.Oop>>;
          }
          interface ConcurrentLocksPrinter extends CombineTypes<[_ConcurrentLocksPrinter, java.lang.Object]> {}
          interface _ConstructionException$$static extends ClassLike {
            new(): ConstructionException;
            new(message: string): ConstructionException;
            new(e: java.lang.Throwable): ConstructionException;
            new(message: string, e: java.lang.Throwable): ConstructionException;
          }
          let ConstructionException: _ConstructionException$$static;
          interface _ConstructionException {
          }
          interface ConstructionException extends CombineTypes<[_ConstructionException, java.lang.RuntimeException]> {}
          interface _DeadlockDetector$$static extends ClassLike {
            _createThreadTable(): void;
            _dfn(thread: JavaThread): int;
            print(tty: java.io.PrintStream): void;
            print(tty: java.io.PrintStream, concurrentLocks: boolean): void;
            _printOneDeadlock(tty: java.io.PrintStream, thread: JavaThread, concurrentLocks: boolean): void;
            _heap: hotspot.oops.ObjectHeap;
            _threadTable: java.util.HashMap<JavaThread,int>;
            _threads: Threads;
            new(): DeadlockDetector;
          }
          let DeadlockDetector: _DeadlockDetector$$static;
          interface _DeadlockDetector {
          }
          interface DeadlockDetector extends CombineTypes<[_DeadlockDetector, java.lang.Object]> {}
          interface _ExternalVFrame$$static extends ClassLike {
            _new(fr: Frame, regMap: RegisterMap, thread: JavaThread, mayBeImprecise: boolean): ExternalVFrame;
          }
          let ExternalVFrame: _ExternalVFrame$$static;
          interface _ExternalVFrame {
            mayBeImpreciseDbg(): boolean;
            print(): void;
            printOn(tty: java.io.PrintStream): void;
            printValue(): void;
            printValueOn(tty: java.io.PrintStream): void;
            _mayBeImprecise: boolean;
          }
          interface ExternalVFrame extends CombineTypes<[_ExternalVFrame, sun.jvm.hotspot.runtime.VFrame]> {}
          interface _Flags$$static extends ClassLike {
            valueOf(name: string): Flags;
            values(): Flags[];
            readonly ATTACH_ON_DEMAND: Flags;
            readonly COMMAND_LINE: Flags;
            readonly CONFIG_FILE: Flags;
            readonly DEFAULT: Flags;
            readonly ENVIRON_VAR: Flags;
            readonly ERGONOMIC: Flags;
            readonly INTERNAL: Flags;
            readonly JIMAGE_RESOURCE: Flags;
            readonly MANAGEMENT: Flags;
          }
          let Flags: _Flags$$static;
          interface _Flags {
            value(): string;
            _value: string;
          }
          interface Flags extends CombineTypes<[_Flags]> {}
          interface _Frame$$static extends ClassLike {
            _initialize(db: hotspot.types.TypeDataBase): void;
            pcReturnOffset(): int;
            _ConstMethodSize: long;
            _pcReturnOffset: int;
            new(): Frame;
          }
          let Frame: _Frame$$static;
          interface _Frame {
            addressOfInterpreterFrameCPCache(): hotspot.debugger.Address;
            addressOfInterpreterFrameExpressionStack(): hotspot.debugger.Address;
            addressOfInterpreterFrameExpressionStackSlot(slot: int): hotspot.debugger.Address;
            addressOfInterpreterFrameLocal(slot: int): hotspot.debugger.Address;
            addressOfInterpreterFrameLocals(): hotspot.debugger.Address;
            addressOfInterpreterFrameMethod(): hotspot.debugger.Address;
            addressOfInterpreterFrameTOS(): hotspot.debugger.Address;
            addressOfInterpreterFrameTOSAt(a0: int): hotspot.debugger.Address;
            _addressOfSavedOopResult(): hotspot.debugger.Address;
            _addressOfSavedReceiver(): hotspot.debugger.Address;
            addressOfStackSlot(slot: int): hotspot.debugger.Address;
            _bcpToBci(bcp: hotspot.debugger.Address, cm: hotspot.oops.ConstMethod): int;
            _bcpToBci(bcp: hotspot.debugger.Address, m: hotspot.oops.Method): int;
            canBeDeoptimized(): boolean;
            cb(): hotspot.code.CodeBlob;
            clone(): any;
            entryFrameIsFirst(): boolean;
            equals(a0: any): boolean;
            frameSize(): long;
            getEntryFrameCallWrapper(): JavaCallWrapper;
            getFP(): hotspot.debugger.Address;
            getID(): hotspot.debugger.Address;
            getIntAt(slot: int): int;
            getInterpreterFrameBCI(): int;
            getInterpreterFrameCPCache(): hotspot.oops.ConstantPoolCache;
            getInterpreterFrameExpressionStackDirection(): int;
            getInterpreterFrameExpressionStackSize(): int;
            getInterpreterFrameMethod(): hotspot.oops.Method;
            getInterpreterFrameSenderSP(): hotspot.debugger.Address;
            getLink(): hotspot.debugger.Address;
            getOopHandleAt(slot: int): hotspot.debugger.OopHandle;
            getPC(): hotspot.debugger.Address;
            getSP(): hotspot.debugger.Address;
            getSavedOopResult(): hotspot.debugger.OopHandle;
            getSavedReceiver(): hotspot.debugger.OopHandle;
            getSenderPC(): hotspot.debugger.Address;
            getSenderSP(): hotspot.debugger.Address;
            getSignalNameDbg(): string;
            getSignalNumberDbg(): int;
            getUnextendedSP(): hotspot.debugger.Address;
            _hasSenderPD(): boolean;
            interpreterFrameMonitorBegin(): BasicObjectLock;
            interpreterFrameMonitorEnd(): BasicObjectLock;
            interpreterFrameMonitorSize(): int;
            interpreterFramePrintOn(tty: java.io.PrintStream): void;
            isCompiledFrame(): boolean;
            isDeoptimized(): boolean;
            isEntryFrame(): boolean;
            isFirstFrame(): boolean;
            isFirstJavaFrame(): boolean;
            isInterpretedFrame(): boolean;
            isInterpretedFrameValid(): boolean;
            isJavaFrame(): boolean;
            isNativeFrame(): boolean;
            isRuntimeFrame(): boolean;
            isSignalHandlerFrameDbg(): boolean;
            nextMonitorInInterpreterFrame(cur: BasicObjectLock): BasicObjectLock;
            oopMapRegToLocation(reg: VMReg, regMap: RegisterMap): hotspot.debugger.Address;
            _oopsCodeBlobDo(oopVisitor: AddressVisitor, regMap: RegisterMap): void;
            oopsDo(oopVisitor: AddressVisitor, map: RegisterMap): void;
            _oopsEntryDo(oopVisitor: AddressVisitor, regMap: RegisterMap): void;
            oopsInterpretedArgumentsDo(signature: hotspot.oops.Symbol, isStatic: boolean, f: AddressVisitor): void;
            _oopsInterpretedDo(oopVisitor: AddressVisitor, map: RegisterMap): void;
            previousMonitorInInterpreterFrame(cur: BasicObjectLock): BasicObjectLock;
            print(): void;
            printOn(tty: java.io.PrintStream): void;
            printValue(): void;
            printValueOn(tty: java.io.PrintStream): void;
            realSender(map: RegisterMap): Frame;
            sender(a0: RegisterMap, a1: hotspot.code.CodeBlob): Frame;
            sender(map: RegisterMap): Frame;
            setPC(newpc: hotspot.debugger.Address): void;
            shouldBeDeoptimized(): boolean;
            _deoptimized: boolean;
            _pc: hotspot.debugger.Address;
            _raw_sp: hotspot.debugger.Address;
          }
          interface Frame extends CombineTypes<[_Frame, java.lang.Cloneable, java.lang.Object]> {}
          interface _Frame$InterpVisitor$$static extends ClassLike {
            new(oopVisitor: AddressVisitor): Frame$InterpVisitor;
          }
          let Frame$InterpVisitor: _Frame$InterpVisitor$$static;
          interface _Frame$InterpVisitor {
            setAddressVisitor(addressVisitor: AddressVisitor): void;
            visitDerivedOopLocation(baseOopAddr: hotspot.debugger.Address, derivedOopAddr: hotspot.debugger.Address): void;
            visitNarrowOopLocation(compOopAddr: hotspot.debugger.Address): void;
            visitOopLocation(oopAddr: hotspot.debugger.Address): void;
            _addressVisitor: AddressVisitor;
          }
          interface Frame$InterpVisitor extends CombineTypes<[_Frame$InterpVisitor, sun.jvm.hotspot.compiler.OopMapVisitor, java.lang.Object]> {}
          interface _InstanceConstructor$$static<T> extends ClassLike {
            new(): InstanceConstructor<T>;
          }
          let InstanceConstructor: _InstanceConstructor$$static<T>;
          interface _InstanceConstructor<T> {
            instantiateWrapperFor(a0: hotspot.debugger.Address): T;
(a0: hotspot.debugger.Address): T;
            _newWrongTypeException(addr: hotspot.debugger.Address): hotspot.types.WrongTypeException;
          }
          interface InstanceConstructor<T> extends CombineTypes<[_InstanceConstructor<T>, java.lang.Object]> {}
          interface _InterpretedVFrame$$static extends ClassLike {
            _new(fr: Frame, regMap: RegisterMap, thread: JavaThread): InterpretedVFrame;
          }
          let InterpretedVFrame: _InterpretedVFrame$$static;
          interface _InterpretedVFrame {
            _addressOfExpressionStackAt(index: int): hotspot.debugger.Address;
            _addressOfLocalAt(index: int): hotspot.debugger.Address;
            getBCI(): int;
            getExpressions(): StackValueCollection;
            getLocals(): StackValueCollection;
            getMethod(): hotspot.oops.Method;
            getMonitors(): java.util.List<MonitorInfo>;
            isInterpretedFrame(): boolean;
            verify(): void;
          }
          interface InterpretedVFrame extends CombineTypes<[_InterpretedVFrame, sun.jvm.hotspot.runtime.JavaVFrame]> {}
          interface _InterpreterFrameClosure$$static extends ClassLike {
            _DEBUG: boolean;
            _new(fr: Frame, maxLocals: int, maxStack: int, f: AddressVisitor): InterpreterFrameClosure;
          }
          let InterpreterFrameClosure: _InterpreterFrameClosure$$static;
          interface _InterpreterFrameClosure {
            offsetDo(offset: int): void;
            _f: AddressVisitor;
            _fr: Frame;
            _maxLocals: int;
            _maxStack: int;
          }
          interface InterpreterFrameClosure extends CombineTypes<[_InterpreterFrameClosure, sun.jvm.hotspot.interpreter.OffsetClosure, java.lang.Object]> {}
          interface _JNIHandleBlock$$static extends ClassLike {
            _initialize(db: hotspot.types.TypeDataBase): void;
            _blockSizeInOops: int;
            _handlesField: hotspot.types.Field;
            _nextField: hotspot.types.AddressField;
            _topField: hotspot.types.CIntegerField;
            new(addr: hotspot.debugger.Address): JNIHandleBlock;
          }
          let JNIHandleBlock: _JNIHandleBlock$$static;
          interface _JNIHandleBlock {
            blockContainingHandle(jniHandle: hotspot.debugger.Address): JNIHandleBlock;
            getOopHandle(x: int): hotspot.debugger.OopHandle;
            _getOopHandleAddress(x: int): hotspot.debugger.Address;
            indexOfHandle(jniHandle: hotspot.debugger.Address): int;
            next(): JNIHandleBlock;
            oopsDo(visitor: AddressVisitor): void;
            toString(): string;
            top(): int;
          }
          interface JNIHandleBlock extends CombineTypes<[_JNIHandleBlock, sun.jvm.hotspot.runtime.VMObject]> {}
          interface _JNIHandles$$static extends ClassLike {
            _initialize(db: hotspot.types.TypeDataBase): void;
            _globalHandlesField: hotspot.types.AddressField;
            _weakGlobalHandlesField: hotspot.types.AddressField;
            new(): JNIHandles;
          }
          let JNIHandles: _JNIHandles$$static;
          interface _JNIHandles {
            globalHandles(): hotspot.gc.shared.OopStorage;
            weakGlobalHandles(): hotspot.gc.shared.OopStorage;
          }
          interface JNIHandles extends CombineTypes<[_JNIHandles, java.lang.Object]> {}
          interface _JavaCallWrapper$$static extends ClassLike {
            _initialize(db: hotspot.types.TypeDataBase): void;
            _anchorField: hotspot.types.AddressField;
            _lastJavaPCField: hotspot.types.AddressField;
            _lastJavaSPField: hotspot.types.AddressField;
            new(addr: hotspot.debugger.Address): JavaCallWrapper;
          }
          let JavaCallWrapper: _JavaCallWrapper$$static;
          interface _JavaCallWrapper {
            getLastJavaPC(): hotspot.debugger.Address;
            getLastJavaSP(): hotspot.debugger.Address;
          }
          interface JavaCallWrapper extends CombineTypes<[_JavaCallWrapper, sun.jvm.hotspot.runtime.VMObject]> {}
          interface _JavaThread$$static extends ClassLike {
            getAnchorField(): hotspot.types.AddressField;
            _initialize(db: hotspot.types.TypeDataBase): void;
            _ADDRESS_FORMAT: string;
            _BLOCKED: int;
            _BLOCKED_TRANS: int;
            _DEBUG: boolean;
            _EXITING: int;
            _IN_JAVA: int;
            _IN_JAVA_TRANS: int;
            _IN_NATIVE: int;
            _IN_NATIVE_TRANS: int;
            _IN_VM: int;
            _IN_VM_TRANS: int;
            _NEW: int;
            _NEW_TRANS: int;
            _NOT_TERMINATED: int;
            _UNINITIALIZED: int;
            _access: JavaThreadPDAccess;
            _activeHandlesField: hotspot.types.AddressField;
            _anchorField: hotspot.types.AddressField;
            _lastJavaPCField: hotspot.types.AddressField;
            _lastJavaSPField: hotspot.types.AddressField;
            _lockStackBaseOffset: long;
            _lockStackTopOffset: long;
            _oopPtrSize: long;
            _osThreadField: hotspot.types.AddressField;
            _stackBaseField: hotspot.types.AddressField;
            _stackSizeField: hotspot.types.CIntegerField;
            _terminatedField: hotspot.types.CIntegerField;
            _threadObjFieldOffset: long;
            _threadStateField: hotspot.types.CIntegerField;
            new(addr: hotspot.debugger.Address): JavaThread;
          }
          let JavaThread: _JavaThread$$static;
          interface _JavaThread {
            activeHandles(): JNIHandleBlock;
            _cookLastFrame(fr: Frame): Frame;
            getBaseOfStackPointer(): hotspot.debugger.Address;
            getCurrentFrameGuess(): Frame;
            getCurrentParkBlocker(): hotspot.oops.Oop;
            getLastFrame(): Frame;
            _getLastFramePD(): Frame;
            getLastJavaFP(): hotspot.debugger.Address;
            getLastJavaPC(): hotspot.debugger.Address;
            getLastJavaSP(): hotspot.debugger.Address;
            getLastJavaVFrame(regMap: RegisterMap): JavaVFrame;
            getLastJavaVFrameDbg(): JavaVFrame;
            getOSThread(): OSThread;
            getStackBase(): hotspot.debugger.Address;
            getStackBaseValue(): long;
            getStackSize(): long;
            getTerminated(): int;
            getThreadName(): string;
            getThreadObj(): hotspot.oops.Oop;
            getThreadProxy(): hotspot.debugger.ThreadProxy;
            getThreadState(): JavaThreadState;
            hasLastJavaFrame(): boolean;
            isExiting(): boolean;
            isInStack(a: hotspot.debugger.Address): boolean;
            isJavaThread(): boolean;
            isLockOwned(obj: hotspot.debugger.OopHandle): boolean;
            isLockOwned(a: hotspot.debugger.Address): boolean;
            isTerminated(): boolean;
            lastSPDbg(): hotspot.debugger.Address;
            newRegisterMap(updateMap: boolean): RegisterMap;
            oopsDo(oopVisitor: AddressVisitor): void;
            printInfoOn(tty: java.io.PrintStream): void;
            printThreadContextOn(out: java.io.PrintStream, verbose: boolean): void;
            printThreadID(): void;
            printThreadIDOn(tty: java.io.PrintStream): void;
            printThreadInfoOn(out: java.io.PrintStream): void;
            _setThreadPDAccess(access: JavaThreadPDAccess): void;
          }
          interface JavaThread extends CombineTypes<[_JavaThread, sun.jvm.hotspot.runtime.Thread]> {}
          interface _JavaThreadFactory$$static extends ClassLike {
          }
          let JavaThreadFactory: _JavaThreadFactory$$static;
          interface _JavaThreadFactory {
            createJavaThreadWrapper(a0: hotspot.debugger.Address, a1: hotspot.types.TypeDataBase): JavaThread;
(a0: hotspot.debugger.Address, a1: hotspot.types.TypeDataBase): JavaThread;
          }
          interface JavaThreadFactory extends CombineTypes<[_JavaThreadFactory, java.lang.Object]> {}
          interface _JavaThreadPDAccess$$static extends ClassLike {
          }
          let JavaThreadPDAccess: _JavaThreadPDAccess$$static;
          interface _JavaThreadPDAccess {
            getBaseOfStackPointer(a0: hotspot.debugger.Address): hotspot.debugger.Address;
            getCurrentFrameGuess(a0: JavaThread, a1: hotspot.debugger.Address): Frame;
            getLastFramePD(a0: JavaThread, a1: hotspot.debugger.Address): Frame;
            getLastJavaFP(a0: hotspot.debugger.Address): hotspot.debugger.Address;
            getLastJavaPC(a0: hotspot.debugger.Address): hotspot.debugger.Address;
            getLastSP(a0: hotspot.debugger.Address): hotspot.debugger.Address;
            getThreadProxy(a0: hotspot.debugger.Address): hotspot.debugger.ThreadProxy;
            newRegisterMap(a0: JavaThread, a1: boolean): RegisterMap;
            printInfoOn(a0: hotspot.debugger.Address, a1: java.io.PrintStream): void;
            printThreadIDOn(a0: hotspot.debugger.Address, a1: java.io.PrintStream): void;
          }
          interface JavaThreadPDAccess extends CombineTypes<[_JavaThreadPDAccess, java.lang.Object]> {}
          interface _JavaThreadState$$static extends ClassLike {
            readonly BLOCKED: JavaThreadState;
            readonly BLOCKED_TRANS: JavaThreadState;
            readonly IN_JAVA: JavaThreadState;
            readonly IN_JAVA_TRANS: JavaThreadState;
            readonly IN_NATIVE: JavaThreadState;
            readonly IN_NATIVE_TRANS: JavaThreadState;
            readonly IN_VM: JavaThreadState;
            readonly IN_VM_TRANS: JavaThreadState;
            readonly NEW: JavaThreadState;
            readonly NEW_TRANS: JavaThreadState;
            readonly UNINITIALIZED: JavaThreadState;
          }
          let JavaThreadState: _JavaThreadState$$static;
          interface _JavaThreadState {
            toString(): string;
            _stringVal: string;
          }
          interface JavaThreadState extends CombineTypes<[_JavaThreadState, java.lang.Object]> {}
          interface _JavaVFrame$$static extends ClassLike {
            _ADDRESS_FORMAT: string;
            _new(fr: Frame, regMap: RegisterMap, thread: JavaThread): JavaVFrame;
          }
          let JavaVFrame: _JavaVFrame$$static;
          interface _JavaVFrame {
            equals(o: any): boolean;
            getBCI(): int;
            getExpressions(): StackValueCollection;
            getLocals(): StackValueCollection;
            getMethod(): hotspot.oops.Method;
            getMonitors(): java.util.List<MonitorInfo>;
            hashCode(): int;
            _identifyLockState(monitor: MonitorInfo, waitingState: string): string;
            isJavaFrame(): boolean;
            print(): void;
            printActivation(index: int): void;
            printActivationOn(tty: java.io.PrintStream, index: int): void;
            printLockInfo(tty: java.io.PrintStream, frameCount: int): void;
            printLockedObjectClassName(tty: java.io.PrintStream, hobj: hotspot.debugger.OopHandle, lockState: string): void;
            printOn(tty: java.io.PrintStream): void;
            _printStackValuesOn(tty: java.io.PrintStream, title: string, values: StackValueCollection): void;
            structuralCompare(other: JavaVFrame): boolean;
            verify(): void;
          }
          interface JavaVFrame extends CombineTypes<[_JavaVFrame, sun.jvm.hotspot.runtime.VFrame]> {}
          interface _JvmtiAgentThread$$static extends ClassLike {
            new(addr: hotspot.debugger.Address): JvmtiAgentThread;
          }
          let JvmtiAgentThread: _JvmtiAgentThread$$static;
          interface _JvmtiAgentThread {
            isJavaThread(): boolean;
            isJvmtiAgentThread(): boolean;
          }
          interface JvmtiAgentThread extends CombineTypes<[_JvmtiAgentThread, sun.jvm.hotspot.runtime.JavaThread]> {}
          interface _LockingMode$$static extends ClassLike {
            getLegacy(): int;
            getLightweight(): int;
            getMonitor(): int;
            _initialize(db: hotspot.types.TypeDataBase): void;
            _legacy: int;
            _lightweight: int;
            _monitor: int;
            new(): LockingMode;
          }
          let LockingMode: _LockingMode$$static;
          interface _LockingMode {
          }
          interface LockingMode extends CombineTypes<[_LockingMode, java.lang.Object]> {}
          interface _MonitorDeflationThread$$static extends ClassLike {
            new(addr: hotspot.debugger.Address): MonitorDeflationThread;
          }
          let MonitorDeflationThread: _MonitorDeflationThread$$static;
          interface _MonitorDeflationThread {
            isHiddenFromExternalView(): boolean;
            isJavaThread(): boolean;
            isMonitorDeflationThread(): boolean;
          }
          interface MonitorDeflationThread extends CombineTypes<[_MonitorDeflationThread, sun.jvm.hotspot.runtime.JavaThread]> {}
          interface _MonitorInfo$$static extends ClassLike {
            new(owner: hotspot.debugger.OopHandle, lock: BasicLock, eliminated: boolean, ownerIsScalarReplaced: boolean): MonitorInfo;
          }
          let MonitorInfo: _MonitorInfo$$static;
          interface _MonitorInfo {
            eliminated(): boolean;
            lock(): BasicLock;
            owner(): hotspot.debugger.OopHandle;
            ownerIsScalarReplaced(): boolean;
            ownerKlass(): hotspot.debugger.OopHandle;
            _eliminated: boolean;
            _lock: BasicLock;
            _owner: hotspot.debugger.OopHandle;
            _ownerIsScalarReplaced: boolean;
            _ownerKlass: hotspot.debugger.OopHandle;
          }
          interface MonitorInfo extends CombineTypes<[_MonitorInfo, java.lang.Object]> {}
          interface _NativeSignatureIterator$$static extends ClassLike {
            new(method: hotspot.oops.Method): NativeSignatureIterator;
          }
          let NativeSignatureIterator: _NativeSignatureIterator$$static;
          interface _NativeSignatureIterator {
            doArray(begin: int, end: int): void;
            doBool(): void;
            doByte(): void;
            doChar(): void;
            doDouble(): void;
            doFloat(): void;
            doInt(): void;
            doLong(): void;
            doObject(begin: int, end: int): void;
            doShort(): void;
            doVoid(): void;
            isStatic(): boolean;
            iterate(): void;
            jniOffset(): int;
            method(): hotspot.oops.Method;
            offset(): int;
            passDouble(): void;
            passFloat(): void;
            passInt(): void;
            passLong(): void;
            passObject(): void;
            _jni_offset: int;
            _method: hotspot.oops.Method;
            _offset: int;
            _prepended: int;
          }
          interface NativeSignatureIterator extends CombineTypes<[_NativeSignatureIterator, sun.jvm.hotspot.runtime.SignatureIterator]> {}
          interface _NotificationThread$$static extends ClassLike {
            new(addr: hotspot.debugger.Address): NotificationThread;
          }
          let NotificationThread: _NotificationThread$$static;
          interface _NotificationThread {
            isJavaThread(): boolean;
          }
          interface NotificationThread extends CombineTypes<[_NotificationThread, sun.jvm.hotspot.runtime.JavaThread]> {}
          interface _OSThread$$static extends ClassLike {
            _initialize(db: hotspot.types.TypeDataBase): void;
            _ALLOCATED: int;
            _BREAKPOINTED: int;
            _CONDVAR_WAIT: int;
            _INITIALIZED: int;
            _MONITOR_WAIT: int;
            _OBJECT_WAIT: int;
            _RUNNABLE: int;
            _SLEEPING: int;
            _ZOMBIE: int;
            _threadIdField: hotspot.types.Field;
            _threadStateField: hotspot.types.CIntegerField;
            new(addr: hotspot.debugger.Address): OSThread;
          }
          let OSThread: _OSThread$$static;
          interface _OSThread {
            getThreadState(): ThreadState;
            threadId(): int;
          }
          interface OSThread extends CombineTypes<[_OSThread, sun.jvm.hotspot.runtime.VMObject]> {}
          interface _ObjectMonitor$$static extends ClassLike {
            _initialize(db: hotspot.types.TypeDataBase): void;
            _ANONYMOUS_OWNER: long;
            _contentionsField: hotspot.oops.CIntField;
            _headerFieldOffset: long;
            _heap: hotspot.oops.ObjectHeap;
            _nextOMFieldOffset: long;
            _objectFieldOffset: long;
            _ownerFieldOffset: long;
            _recursionsField: hotspot.types.CIntegerField;
            _waitersField: hotspot.oops.CIntField;
            new(addr: hotspot.debugger.Address): ObjectMonitor;
          }
          let ObjectMonitor: _ObjectMonitor$$static;
          interface _ObjectMonitor {
            contentions(): int;
            header(): hotspot.oops.Mark;
            isEntered(current: Thread): boolean;
            isOwnedAnonymous(): boolean;
            nextOM(): hotspot.debugger.Address;
            object(): hotspot.debugger.OopHandle;
            owner(): hotspot.debugger.Address;
            recursions(): long;
            waiters(): int;
          }
          interface ObjectMonitor extends CombineTypes<[_ObjectMonitor, sun.jvm.hotspot.runtime.VMObject]> {}
          interface _ObjectSynchronizer$$static extends ClassLike {
            _initialize(db: hotspot.types.TypeDataBase): void;
            objectMonitorIterator(): java.util.Iterator;
            _inUseList: hotspot.debugger.Address;
            new(): ObjectSynchronizer;
          }
          let ObjectSynchronizer: _ObjectSynchronizer$$static;
          interface _ObjectSynchronizer {
            identityHashValueFor(obj: hotspot.oops.Oop): long;
          }
          interface ObjectSynchronizer extends CombineTypes<[_ObjectSynchronizer, java.lang.Object]> {}
          interface _ObjectSynchronizer$ObjectMonitorIterator$$static extends ClassLike {
            _new(): ObjectSynchronizer$ObjectMonitorIterator;
          }
          let ObjectSynchronizer$ObjectMonitorIterator: _ObjectSynchronizer$ObjectMonitorIterator$$static;
          interface _ObjectSynchronizer$ObjectMonitorIterator {
            hasNext(): boolean;
            next(): any;
            remove(): void;
            _mon: ObjectMonitor;
          }
          interface ObjectSynchronizer$ObjectMonitorIterator extends CombineTypes<[_ObjectSynchronizer$ObjectMonitorIterator, java.util.Iterator, java.lang.Object]> {}
          interface _PerfDataEntry$$static extends ClassLike {
            _initialize(db: hotspot.types.TypeDataBase): void;
            _dataOffsetField: hotspot.types.JIntField;
            _dataTypeField: hotspot.types.JByteField;
            _dataUnitsField: hotspot.types.JByteField;
            _dataVariabilityField: hotspot.types.JByteField;
            _entryLengthField: hotspot.types.JIntField;
            _flagsField: hotspot.types.JByteField;
            _nameOffsetField: hotspot.types.JIntField;
            _vectorLengthField: hotspot.types.JIntField;
            new(addr: hotspot.debugger.Address): PerfDataEntry;
          }
          let PerfDataEntry: _PerfDataEntry$$static;
          interface _PerfDataEntry {
            booleanArrayValue(): boolean[];
            booleanValue(): boolean;
            byteArrayValue(): byte[];
            byteValue(): byte;
            charArrayValue(): char[];
            charValue(): char;
            dataOffset(): int;
            dataType(): int;
            dataUnits(): int;
            dataVariability(): int;
            doubleArrayValue(): double[];
            doubleValue(): double;
            entryLength(): int;
            flags(): byte;
            floatArrayValue(): float[];
            floatValue(): float;
            _getHeap(): hotspot.oops.ObjectHeap;
            intArrayValue(): int[];
            intValue(): int;
            longArrayValue(): long[];
            longValue(): long;
            name(): string;
            nameOffset(): int;
            shortArrayValue(): short[];
            shortValue(): short;
            supported(): boolean;
            valueAsString(): string;
            vectorLength(): int;
          }
          interface PerfDataEntry extends CombineTypes<[_PerfDataEntry, sun.jvm.hotspot.runtime.VMObject]> {}
          interface _PerfDataEntry$PerfDataUnits$$static extends ClassLike {
            _initialize(db: hotspot.types.TypeDataBase): void;
            U_Bytes: int;
            U_Events: int;
            U_Hertz: int;
            U_None: int;
            U_String: int;
            U_Ticks: int;
          }
          let PerfDataEntry$PerfDataUnits: _PerfDataEntry$PerfDataUnits$$static;
          interface _PerfDataEntry$PerfDataUnits {
          }
          interface PerfDataEntry$PerfDataUnits extends CombineTypes<[_PerfDataEntry$PerfDataUnits, java.lang.Object]> {}
          interface _PerfDataPrologue$$static extends ClassLike {
            _initialize(db: hotspot.types.TypeDataBase): void;
            _accessibleField: hotspot.types.JByteField;
            _byteOrderField: hotspot.types.JByteField;
            _entryOffsetField: hotspot.types.JIntField;
            _magicField: hotspot.types.JIntField;
            _majorVersionField: hotspot.types.JByteField;
            _minorVersionField: hotspot.types.JByteField;
            _modTimeStampField: hotspot.types.JLongField;
            _numEntriesField: hotspot.types.JIntField;
            _overflowField: hotspot.types.JIntField;
            _usedField: hotspot.types.JIntField;
            new(addr: hotspot.debugger.Address): PerfDataPrologue;
          }
          let PerfDataPrologue: _PerfDataPrologue$$static;
          interface _PerfDataPrologue {
            accessible(): boolean;
            byteOrder(): byte;
            entryOffset(): int;
            magic(): int;
            majorVersion(): byte;
            modTimeStamp(): long;
            numEntries(): int;
            overflow(): int;
            used(): int;
          }
          interface PerfDataPrologue extends CombineTypes<[_PerfDataPrologue, sun.jvm.hotspot.runtime.VMObject]> {}
          interface _PerfMemory$$static extends ClassLike {
            capacity(): long;
            contains(addr: hotspot.debugger.Address): boolean;
            end(): hotspot.debugger.Address;
            _initialize(db: hotspot.types.TypeDataBase): void;
            initialized(): boolean;
            iterate(visitor: PerfMemory$PerfDataEntryVisitor): void;
            prologue(): PerfDataPrologue;
            start(): hotspot.debugger.Address;
            top(): hotspot.debugger.Address;
            _capacityField: hotspot.types.CIntegerField;
            _endField: hotspot.types.AddressField;
            _initializedField: hotspot.types.CIntegerField;
            _prologueField: hotspot.types.AddressField;
            _startField: hotspot.types.AddressField;
            _topField: hotspot.types.AddressField;
            new(): PerfMemory;
          }
          let PerfMemory: _PerfMemory$$static;
          interface _PerfMemory {
          }
          interface PerfMemory extends CombineTypes<[_PerfMemory, java.lang.Object]> {}
          interface _PerfMemory$PerfDataEntryVisitor$$static extends ClassLike {
          }
          let PerfMemory$PerfDataEntryVisitor: _PerfMemory$PerfDataEntryVisitor$$static;
          interface _PerfMemory$PerfDataEntryVisitor {
            visit(a0: PerfDataEntry): boolean;
(a0: PerfDataEntry): boolean;
          }
          interface PerfMemory$PerfDataEntryVisitor extends CombineTypes<[_PerfMemory$PerfDataEntryVisitor, java.lang.Object]> {}
          interface _RegisterMap$$static extends ClassLike {
            _initialize(db: hotspot.types.TypeDataBase): void;
            _locationValidSize: int;
            _locationValidTypeSize: int;
            _regCount: int;
            _new(thread: JavaThread, updateMap: boolean): RegisterMap;
            _new(map: RegisterMap): RegisterMap;
          }
          let RegisterMap: _RegisterMap$$static;
          interface _RegisterMap {
            clear(): void;
            _clearPD(): void;
            clone(): any;
            copy(): RegisterMap;
            getIncludeArgumentOops(): boolean;
            getLocation(reg: VMReg): hotspot.debugger.Address;
            _getLocationPD(a0: VMReg): hotspot.debugger.Address;
            getThread(): JavaThread;
            getUpdateMap(): boolean;
            _initializeFromPD(a0: RegisterMap): void;
            _initializePD(): void;
            print(): void;
            printOn(tty: java.io.PrintStream): void;
            setIncludeArgumentOops(f: boolean): void;
            setLocation(reg: VMReg, loc: hotspot.debugger.Address): void;
            _includeArgumentOops: boolean;
            _location: hotspot.debugger.Address[];
            _locationValid: long[];
            _thread: JavaThread;
            _updateMap: boolean;
          }
          interface RegisterMap extends CombineTypes<[_RegisterMap, java.lang.Cloneable, java.lang.Object]> {}
          interface _ResultTypeFinder$$static extends ClassLike {
            new(signature: hotspot.oops.Symbol): ResultTypeFinder;
          }
          let ResultTypeFinder: _ResultTypeFinder$$static;
          interface _ResultTypeFinder {
            _set(size: int, type: int): void;
          }
          interface ResultTypeFinder extends CombineTypes<[_ResultTypeFinder, sun.jvm.hotspot.runtime.SignatureInfo]> {}
          interface _ServiceThread$$static extends ClassLike {
            new(addr: hotspot.debugger.Address): ServiceThread;
          }
          let ServiceThread: _ServiceThread$$static;
          interface _ServiceThread {
            isHiddenFromExternalView(): boolean;
            isJavaThread(): boolean;
            isServiceThread(): boolean;
          }
          interface ServiceThread extends CombineTypes<[_ServiceThread, sun.jvm.hotspot.runtime.JavaThread]> {}
          interface _SignatureConverter$$static extends ClassLike {
            new(sig: hotspot.oops.Symbol, buf: SignatureConverter$stringBuffer): SignatureConverter;
          }
          let SignatureConverter: _SignatureConverter$$static;
          interface _SignatureConverter {
            appendComma(): void;
            _appendSubstring(begin: int, end: int): void;
            _arrayInnerBegin(begin: int): int;
            doArray(begin: int, end: int): void;
            doBool(): void;
            doByte(): void;
            doChar(): void;
            doDouble(): void;
            doFloat(): void;
            doInt(): void;
            doLong(): void;
            doObject(begin: int, end: int): void;
            _doObject(begin: int, end: int, comma: boolean): void;
            doShort(): void;
            doVoid(): void;
            _buf: runtime$stringBuffer;
            _first: boolean;
          }
          interface SignatureConverter extends CombineTypes<[_SignatureConverter, sun.jvm.hotspot.runtime.SignatureIterator]> {}
          interface _SignatureInfo$$static extends ClassLike {
            new(signature: hotspot.oops.Symbol): SignatureInfo;
          }
          let SignatureInfo: _SignatureInfo$$static;
          interface _SignatureInfo {
            doArray(begin: int, end: int): void;
            doBool(): void;
            doByte(): void;
            doChar(): void;
            doDouble(): void;
            doFloat(): void;
            doInt(): void;
            doLong(): void;
            doObject(begin: int, end: int): void;
            doShort(): void;
            doVoid(): void;
            _lazyIterate(): void;
            _set(a0: int, a1: int): void;
(a0: int, a1: int): void;
            size(): int;
            type(): int;
            _hasIterated: boolean;
            _size: int;
            _type: int;
          }
          interface SignatureInfo extends CombineTypes<[_SignatureInfo, sun.jvm.hotspot.runtime.SignatureIterator]> {}
          interface _SignatureIterator$$static extends ClassLike {
            new(signature: hotspot.oops.Symbol): SignatureIterator;
          }
          let SignatureIterator: _SignatureIterator$$static;
          interface _SignatureIterator {
            _checkSignatureEnd(): void;
            dispatchField(): void;
            doArray(a0: int, a1: int): void;
            doBool(): void;
            doByte(): void;
            doChar(): void;
            doDouble(): void;
            doFloat(): void;
            doInt(): void;
            doLong(): void;
            doObject(a0: int, a1: int): void;
            doShort(): void;
            doVoid(): void;
            _expect(c: char): void;
            isReturnType(): boolean;
            iterate(): void;
            iterateParameters(): void;
            iterateReturntype(): void;
            parameterIndex(): int;
            _parseType(): int;
            _skipOptionalSize(): void;
            __index: int;
            __parameter_index: int;
            __signature: hotspot.oops.Symbol;
          }
          interface SignatureIterator extends CombineTypes<[_SignatureIterator, java.lang.Object]> {}
          interface _StackFrameInfo$$static extends ClassLike {
            new(vf: JavaVFrame): StackFrameInfo;
          }
          let StackFrameInfo: _StackFrameInfo$$static;
          interface _StackFrameInfo {
            getBCI(): int;
            getMethod(): hotspot.oops.Method;
            _bci: int;
            _classHolder: hotspot.oops.Oop;
            _method: hotspot.oops.Method;
          }
          interface StackFrameInfo extends CombineTypes<[_StackFrameInfo, java.lang.Object]> {}
          interface _StackFrameStream$$static extends ClassLike {
            new(thread: JavaThread): StackFrameStream;
            new(thread: JavaThread, update: boolean): StackFrameStream;
          }
          let StackFrameStream: _StackFrameStream$$static;
          interface _StackFrameStream {
            getCurrent(): Frame;
            getRegisterMap(): RegisterMap;
            isDone(): boolean;
            next(): void;
            _fr: Frame;
            _isDone: boolean;
            _regMap: RegisterMap;
          }
          interface StackFrameStream extends CombineTypes<[_StackFrameStream, java.lang.Object]> {}
          interface _StackValue$$static extends ClassLike {
            new(): StackValue;
            new(h: hotspot.debugger.OopHandle, scalar_replaced: long): StackValue;
            new(i: long): StackValue;
          }
          let StackValue: _StackValue$$static;
          interface _StackValue {
            equals(arg: any): boolean;
            getInteger(): long;
            getObject(): hotspot.debugger.OopHandle;
            getType(): int;
            hashCode(): int;
            _objIsScalarReplaced(): boolean;
            print(): void;
            printOn(tty: java.io.PrintStream): void;
            _handleValue: hotspot.debugger.OopHandle;
            _integerValue: long;
            _type: int;
          }
          interface StackValue extends CombineTypes<[_StackValue, java.lang.Object]> {}
          interface _StackValueCollection$$static extends ClassLike {
            new(): StackValueCollection;
            new(length: int): StackValueCollection;
          }
          let StackValueCollection: _StackValueCollection$$static;
          interface _StackValueCollection {
            add(val: StackValue): void;
            booleanAt(slot: int): boolean;
            byteAt(slot: int): byte;
            charAt(slot: int): char;
            doubleAt(slot: int): double;
            floatAt(slot: int): float;
            get(i: int): StackValue;
            intAt(slot: int): int;
            isEmpty(): boolean;
            longAt(slot: int): long;
            oopHandleAt(slot: int): hotspot.debugger.OopHandle;
            shortAt(slot: int): short;
            size(): int;
            _list: java.util.List<StackValue>;
          }
          interface StackValueCollection extends CombineTypes<[_StackValueCollection, java.lang.Object]> {}
          interface _StaticBaseConstructor$$static<T> extends ClassLike {
            new(t: java.lang.Class<T>): StaticBaseConstructor<T>;
          }
          let StaticBaseConstructor: _StaticBaseConstructor$$static<T>;
          interface _StaticBaseConstructor<T> {
            instantiateWrapperFor(addr: hotspot.debugger.Address): T;
            instantiateWrapperFor(a0: hotspot.debugger.Address): any;
            _staticType: java.lang.Class<T>;
          }
          interface StaticBaseConstructor<T> extends CombineTypes<[_StaticBaseConstructor<T>, InstanceConstructor<T>]> {}
          interface _StringDedupThread$$static extends ClassLike {
            new(addr: hotspot.debugger.Address): StringDedupThread;
          }
          let StringDedupThread: _StringDedupThread$$static;
          interface _StringDedupThread {
            isHiddenFromExternalView(): boolean;
            isJavaThread(): boolean;
          }
          interface StringDedupThread extends CombineTypes<[_StringDedupThread, sun.jvm.hotspot.runtime.JavaThread]> {}
          interface _StubRoutines$$static extends ClassLike {
            _initialize(db: hotspot.types.TypeDataBase): void;
            _callStubReturnAddressField: hotspot.types.AddressField;
            new(): StubRoutines;
          }
          let StubRoutines: _StubRoutines$$static;
          interface _StubRoutines {
            returnsToCallStub(returnPC: hotspot.debugger.Address): boolean;
          }
          interface StubRoutines extends CombineTypes<[_StubRoutines, java.lang.Object]> {}
          interface _Thread$$static extends ClassLike {
            _initialize(db: hotspot.types.TypeDataBase): void;
            _allocatedBytesField: hotspot.types.JLongField;
            _currentPendingMonitorField: hotspot.types.AddressField;
            _currentWaitingMonitorField: hotspot.types.AddressField;
            _suspendFlagsField: hotspot.types.CIntegerField;
            _tlabFieldOffset: long;
            new(addr: hotspot.debugger.Address): Thread;
          }
          let Thread: _Thread$$static;
          interface _Thread {
            allocatedBytes(): long;
            getCurrentPendingMonitor(): ObjectMonitor;
            getCurrentWaitingMonitor(): ObjectMonitor;
            isCodeCacheSweeperThread(): boolean;
            isCompilerThread(): boolean;
            isHiddenFromExternalView(): boolean;
            isInStack(a: hotspot.debugger.Address): boolean;
            isJavaThread(): boolean;
            isJvmtiAgentThread(): boolean;
            isLockOwned(lock: hotspot.debugger.Address): boolean;
            isMonitorDeflationThread(): boolean;
            isServiceThread(): boolean;
            isVMThread(): boolean;
            isWatcherThread(): boolean;
            oopsDo(oopVisitor: AddressVisitor): void;
            suspendFlags(): int;
            _threadObjectAddress(): hotspot.debugger.Address;
            tlab(): ThreadLocalAllocBuffer;
          }
          interface Thread extends CombineTypes<[_Thread, sun.jvm.hotspot.runtime.VMObject]> {}
          interface _ThreadLocalAllocBuffer$$static extends ClassLike {
            _initialize(db: hotspot.types.TypeDataBase): void;
            _desired_sizeField: hotspot.types.CIntegerField;
            _endField: hotspot.types.AddressField;
            _startField: hotspot.types.AddressField;
            _topField: hotspot.types.AddressField;
            new(addr: hotspot.debugger.Address): ThreadLocalAllocBuffer;
          }
          let ThreadLocalAllocBuffer: _ThreadLocalAllocBuffer$$static;
          interface _ThreadLocalAllocBuffer {
            _alignmentReserve(): long;
            contains(p: hotspot.debugger.Address): boolean;
            end(): hotspot.debugger.Address;
            _endReserve(): long;
            hardEnd(): hotspot.debugger.Address;
            nextOopHandle(handle: hotspot.debugger.OopHandle, size: long): hotspot.debugger.OopHandle;
            print(): void;
            printOn(tty: java.io.PrintStream): void;
            start(): hotspot.debugger.Address;
            startAsOopHandle(): hotspot.debugger.OopHandle;
            top(): hotspot.debugger.Address;
          }
          interface ThreadLocalAllocBuffer extends CombineTypes<[_ThreadLocalAllocBuffer, sun.jvm.hotspot.runtime.VMObject]> {}
          interface _ThreadStackTrace$$static extends ClassLike {
            new(t: JavaThread): ThreadStackTrace;
          }
          let ThreadStackTrace: _ThreadStackTrace$$static;
          interface _ThreadStackTrace {
            dumpStack(maxDepth: int): void;
            getStackDepth(): int;
            stackFrameAt(index: int): StackFrameInfo;
            _depth: int;
            _frames: java.util.ArrayList<StackFrameInfo>;
            _thread: JavaThread;
          }
          interface ThreadStackTrace extends CombineTypes<[_ThreadStackTrace, java.lang.Object]> {}
          interface _ThreadState$$static extends ClassLike {
            readonly ALLOCATED: ThreadState;
            readonly BREAKPOINTED: ThreadState;
            readonly CONDVAR_WAIT: ThreadState;
            readonly INITIALIZED: ThreadState;
            readonly MONITOR_WAIT: ThreadState;
            readonly OBJECT_WAIT: ThreadState;
            readonly RUNNABLE: ThreadState;
            readonly SLEEPING: ThreadState;
            readonly ZOMBIE: ThreadState;
          }
          let ThreadState: _ThreadState$$static;
          interface _ThreadState {
            getPrintVal(): string;
            _printVal: string;
          }
          interface ThreadState extends CombineTypes<[_ThreadState, java.lang.Object]> {}
          interface _Threads$$static extends ClassLike {
            _initialize(db: hotspot.types.TypeDataBase): void;
            __list: ThreadsList;
            _access: JavaThreadPDAccess;
            _threadFactory: JavaThreadFactory;
            _threadListField: hotspot.types.AddressField;
            _virtualConstructor: VirtualConstructor;
            new(): Threads;
          }
          let Threads: _Threads$$static;
          interface _Threads {
            createJavaThreadWrapper(threadAddr: hotspot.debugger.Address): JavaThread;
            getJavaThreadAt(i: int): JavaThread;
            getNumberOfThreads(): int;
            getPendingThreads(monitor: ObjectMonitor): java.util.List<JavaThread>;
            getWaitingThreads(monitor: ObjectMonitor): java.util.List<JavaThread>;
            oopsDo(oopVisitor: AddressVisitor): void;
            owningThreadFromMonitor(o: hotspot.debugger.Address): JavaThread;
            owningThreadFromMonitor(monitor: ObjectMonitor): JavaThread;
          }
          interface Threads extends CombineTypes<[_Threads, java.lang.Object]> {}
          interface _ThreadsList$$static extends ClassLike {
            _initialize(db: hotspot.types.TypeDataBase): void;
            _lengthField: hotspot.types.CIntegerField;
            _threadsField: hotspot.types.AddressField;
            new(addr: hotspot.debugger.Address): ThreadsList;
          }
          let ThreadsList: _ThreadsList$$static;
          interface _ThreadsList {
            getJavaThreadAddressAt(i: int): hotspot.debugger.Address;
            length(): long;
          }
          interface ThreadsList extends CombineTypes<[_ThreadsList, sun.jvm.hotspot.runtime.VMObject]> {}
          interface _VFrame$$static extends ClassLike {
            newVFrame(f: Frame, regMap: RegisterMap, thread: JavaThread, unsafe: boolean, mayBeImprecise: boolean): VFrame;
            newVFrame(f: Frame, regMap: RegisterMap, thread: JavaThread): VFrame;
            _new(f: Frame, regMap: RegisterMap, thread: JavaThread): VFrame;
          }
          let VFrame: _VFrame$$static;
          interface _VFrame {
            getFrame(): Frame;
            getRegisterMap(): RegisterMap;
            getThread(): JavaThread;
            isCompiledFrame(): boolean;
            isDeoptimized(): boolean;
            isEntryFrame(): boolean;
            isInterpretedFrame(): boolean;
            isJavaFrame(): boolean;
            isTop(): boolean;
            javaSender(): JavaVFrame;
            mayBeImpreciseDbg(): boolean;
            print(): void;
            printOn(tty: java.io.PrintStream): void;
            printValue(): void;
            printValueOn(tty: java.io.PrintStream): void;
            sender(): VFrame;
            sender(mayBeImprecise: boolean): VFrame;
            top(): VFrame;
            _fr: Frame;
            _regMap: RegisterMap;
            _thread: JavaThread;
          }
          interface VFrame extends CombineTypes<[_VFrame, java.lang.Object]> {}
          interface _VM$$static extends ClassLike {
            _checkVMVersion(vmRelease: string): void;
            getAddressValue(addr: hotspot.debugger.Address): long;
            getVM(): VM;
            initialize(db: hotspot.types.TypeDataBase, isBigEndian: boolean): void;
            initialize(db: hotspot.types.TypeDataBase, debugger: hotspot.debugger.JVMDebugger): void;
            registerVMInitializedObserver(o: hotspot.utilities.Observer): void;
            shutdown(): void;
            Flags_ATTACH_ON_DEMAND: int;
            Flags_COMMAND_LINE: int;
            Flags_CONFIG_FILE: int;
            Flags_DEFAULT: int;
            Flags_ENVIRON_VAR: int;
            Flags_ERGONOMIC: int;
            Flags_INTERNAL: int;
            Flags_JIMAGE_RESOURCE: int;
            Flags_MANAGEMENT: int;
            _Flags_VALUE_ORIGIN_MASK: int;
            _Flags_WAS_SET_ON_COMMAND_LINE: int;
            _boolType: hotspot.types.CIntegerType;
            _cmdFlagTypes: string[];
            _disableDerivedPointerTableCheck: boolean;
            _intType: hotspot.types.Type;
            _intxType: hotspot.types.Type;
            _saProps: java.util.Properties;
            _sizetType: hotspot.types.Type;
            _soleInstance: VM;
            _uint64tType: hotspot.types.Type;
            _uintType: hotspot.types.Type;
            _uintxType: hotspot.types.Type;
            _vmInitializedObservers: java.util.List<hotspot.utilities.Observer>;
          }
          let VM: _VM$$static;
          interface _VM {
            alignDown(size: long, a1: long): long;
            alignUp(size: long, a1: long): long;
            buildIntFromShorts(low: short, high: short): int;
            buildLongFromIntsPD(oneHalf: int, otherHalf: int): long;
            fireVMResumed(): void;
            fireVMSuspended(): void;
            getAddressSize(): long;
            getBytes(): Bytes;
            getBytesPerLong(): int;
            getBytesPerWord(): int;
            getCPU(): string;
            getClassLoaderDataGraph(): hotspot.classfile.ClassLoaderDataGraph;
            getCodeCache(): hotspot.code.CodeCache;
            getCommandLineBooleanFlag(name: string): boolean;
            getCommandLineFlag(name: string): VM$Flag;
            getCommandLineFlags(): VM$Flag[];
            getDebugger(): hotspot.debugger.JVMDebugger;
            getFileMapInfo(): hotspot.memory.FileMapInfo;
            _getFlagTypeAsString(typeIndex: int): string;
            getHeapOopSize(): int;
            getHeapWordSize(): int;
            getIntSize(): long;
            getInterpreter(): hotspot.interpreter.Interpreter;
            getInvocationEntryBCI(): int;
            getJNIHandles(): JNIHandles;
            getKlassPtrSize(): int;
            getLogAddressSize(): long;
            getLogBytesPerWord(): int;
            getLogMinObjAlignmentInBytes(): int;
            getMinObjAlignmentInBytes(): int;
            getOS(): string;
            getObjectAlignmentInBytes(): int;
            getObjectHeap(): hotspot.oops.ObjectHeap;
            getObjectSynchronizer(): ObjectSynchronizer;
            getOopSize(): long;
            getReserveForAllocationPrefetch(): int;
            getRevPtrs(): hotspot.utilities.ReversePtrs;
            getRuntime1(): hotspot.c1.Runtime1;
            getStubRoutines(): StubRoutines;
            getSystemDictionary(): hotspot.memory.SystemDictionary;
            getSystemProperties(): java.util.Properties;
            getSystemProperty(key: string): string;
            getThreads(): Threads;
            getTypeDataBase(): hotspot.types.TypeDataBase;
            getUniverse(): hotspot.memory.Universe;
            getUseTLAB(): boolean;
            getVMInternalInfo(): string;
            getVMRegImplInfo(): hotspot.code.VMRegImpl;
            getVMRelease(): string;
            isBigEndian(): boolean;
            isClientCompiler(): boolean;
            isCompressedKlassPointersEnabled(): boolean;
            isCompressedOopsEnabled(): boolean;
            isCore(): boolean;
            isDebugging(): boolean;
            isJavaPCDbg(addr: hotspot.debugger.Address): boolean;
            isJvmtiSupported(): boolean;
            isLP64(): boolean;
            isServerCompiler(): boolean;
            isSharingEnabled(): boolean;
            lookupIntConstant(name: string): int;
            lookupType(cTypeName: string): hotspot.types.Type;
            _readCommandLineFlags(): void;
            _readSystemProperties(): void;
            registerVMResumedObserver(o: hotspot.utilities.Observer): void;
            registerVMSuspendedObserver(o: hotspot.utilities.Observer): void;
            setRevPtrs(rp: hotspot.utilities.ReversePtrs): void;
            useDerivedPointerTable(): boolean;
            wizardMode(): boolean;
            _bytes: Bytes;
            _bytesPerLong: int;
            _bytesPerWord: int;
            _cldGraph: hotspot.classfile.ClassLoaderDataGraph;
            _codeCache: hotspot.code.CodeCache;
            _commandLineFlags: VM$Flag[];
            _compressedKlassPointersEnabled: boolean;
            _compressedOopsEnabled: boolean;
            _db: hotspot.types.TypeDataBase;
            _debugger: hotspot.debugger.JVMDebugger;
            _dict: hotspot.memory.SystemDictionary;
            _fileMapInfo: hotspot.memory.FileMapInfo;
            _flagsMap: java.util.Map<string,VM$Flag>;
            _handles: JNIHandles;
            _heap: hotspot.oops.ObjectHeap;
            _heapOopSize: int;
            _heapWordSize: int;
            _interpreter: hotspot.interpreter.Interpreter;
            _invocationEntryBCI: int;
            _isBigEndian: boolean;
            _isJvmtiSupported: boolean;
            _isLP64: boolean;
            _klassPtrSize: int;
            _logAddressSize: long;
            _logBytesPerWord: int;
            _logMinObjAlignmentInBytes: int;
            _minObjAlignmentInBytes: int;
            _objectAlignmentInBytes: int;
            _oopSize: int;
            _reserveForAllocationPrefetch: int;
            _revPtrs: hotspot.utilities.ReversePtrs;
            _runtime1: hotspot.c1.Runtime1;
            _sharingEnabled: boolean;
            _stubRoutines: StubRoutines;
            _synchronizer: ObjectSynchronizer;
            _sysProps: java.util.Properties;
            _threads: Threads;
            _universe: hotspot.memory.Universe;
            _usingClientCompiler: boolean;
            _usingServerCompiler: boolean;
            _vmInternalInfo: string;
            _vmRelease: string;
            _vmResumedObservers: java.util.List<hotspot.utilities.Observer>;
            _vmSuspendedObservers: java.util.List<hotspot.utilities.Observer>;
            _vmregImpl: hotspot.code.VMRegImpl;
          }
          interface VM extends CombineTypes<[_VM, java.lang.Object]> {}
          interface _VM$Flag$$static extends ClassLike {
          }
          let VM$Flag: _VM$Flag$$static;
          interface _VM$Flag {
            getAddress(): hotspot.debugger.Address;
            getBool(): boolean;
            getCcstr(): string;
            getCcstrlist(): string;
            getDouble(): double;
            getInt(): long;
            getIntx(): long;
            getName(): string;
            getOrigin(): int;
            getOriginString(): string;
            getSizet(): long;
            getType(): string;
            getUInt(): long;
            getUIntx(): long;
            getUint64t(): long;
            getValue(): string;
            isBool(): boolean;
            isCcstr(): boolean;
            isCcstrlist(): boolean;
            isDouble(): boolean;
            isInt(): boolean;
            isIntx(): boolean;
            isSizet(): boolean;
            isUInt(): boolean;
            isUIntx(): boolean;
            isUint64t(): boolean;
            _addr: hotspot.debugger.Address;
            _flags: int;
            _name: string;
            _type: string;
          }
          interface VM$Flag extends CombineTypes<[_VM$Flag, java.lang.Object]> {}
          interface _VMObject$$static extends ClassLike {
            new(addr: hotspot.debugger.Address): VMObject;
          }
          let VMObject: _VMObject$$static;
          interface _VMObject {
            equals(arg: any): boolean;
            getAddress(): hotspot.debugger.Address;
            hashCode(): int;
            toString(): string;
            _addr: hotspot.debugger.Address;
          }
          interface VMObject extends CombineTypes<[_VMObject, java.lang.Object]> {}
          interface _VMObjectFactory$$static<T> extends ClassLike {
            newObject<T>(clazz: java.lang.Class<T>, addr: hotspot.debugger.Address): T;
            new(): VMObjectFactory<T>;
          }
          let VMObjectFactory: _VMObjectFactory$$static<T>;
          interface _VMObjectFactory<T> {
          }
          interface VMObjectFactory<T> extends CombineTypes<[_VMObjectFactory<T>, java.lang.Object]> {}
          interface _VMReg$$static extends ClassLike {
            _initialize(db: hotspot.types.TypeDataBase): void;
            matcherRegEncodeAddr: hotspot.debugger.Address;
            new(i: int): VMReg;
          }
          let VMReg: _VMReg$$static;
          interface _VMReg {
            equals(arg: any): boolean;
            getValue(): int;
            greaterThan(arg: VMReg): boolean;
            greaterThanOrEqual(arg: VMReg): boolean;
            lessThan(arg: VMReg): boolean;
            lessThanOrEqual(arg: VMReg): boolean;
            minus(arg: VMReg): int;
            reg2Stack(): int;
            regEncode(): int;
            _value: int;
          }
          interface VMReg extends CombineTypes<[_VMReg, java.lang.Object]> {}
          interface _VMVersionMismatchException$$static extends ClassLike {
            new(supported: java.lang.Runtime$Version, target: java.lang.Runtime$Version): VMVersionMismatchException;
          }
          let VMVersionMismatchException: _VMVersionMismatchException$$static;
          interface _VMVersionMismatchException {
            getMessage(): string;
            getSupportedVersions(): java.lang.Runtime$Version;
            getTargetVersion(): java.lang.Runtime$Version;
            _supportedVersions: java.lang.Runtime$Version;
            _targetVersion: java.lang.Runtime$Version;
          }
          interface VMVersionMismatchException extends CombineTypes<[_VMVersionMismatchException, java.lang.RuntimeException]> {}
          interface _VirtualBaseConstructor$$static<T> extends ClassLike {
            new(db: hotspot.types.TypeDataBase, baseType: hotspot.types.Type, packageName: string, unknownTypeHandler: java.lang.Class<T>): VirtualBaseConstructor<T>;
          }
          let VirtualBaseConstructor: _VirtualBaseConstructor$$static<T>;
          interface _VirtualBaseConstructor<T> {
            addMapping(cTypeName: string, clazz: java.lang.Class<T>): boolean;
            instantiateWrapperFor(addr: hotspot.debugger.Address): T;
            _baseType: hotspot.types.Type;
            _db: hotspot.types.TypeDataBase;
            _map: java.util.Map<string,java.lang.Class<T>>;
            _unknownTypeHandler: java.lang.Class<T>;
          }
          interface VirtualBaseConstructor<T> extends CombineTypes<[_VirtualBaseConstructor<T>, InstanceConstructor<T>]> {}
          interface _VirtualConstructor$$static extends ClassLike {
            new(db: hotspot.types.TypeDataBase): VirtualConstructor;
          }
          let VirtualConstructor: _VirtualConstructor$$static;
          interface _VirtualConstructor {
            addMapping(cTypeName: string, clazz: java.lang.Class<VMObject>): boolean;
            instantiateWrapperFor(addr: hotspot.debugger.Address): VMObject;
            instantiateWrapperFor(a0: hotspot.debugger.Address): any;
            _db: hotspot.types.TypeDataBase;
            _map: java.util.Map<string,java.lang.Class<VMObject>>;
          }
          interface VirtualConstructor extends CombineTypes<[_VirtualConstructor, InstanceConstructor<VMObject>]> {}
          interface _WatcherThread$$static extends ClassLike {
            new(addr: hotspot.debugger.Address): WatcherThread;
          }
          let WatcherThread: _WatcherThread$$static;
          interface _WatcherThread {
            isWatcherThread(): boolean;
          }
          interface WatcherThread extends CombineTypes<[_WatcherThread, sun.jvm.hotspot.runtime.Thread]> {}
          interface _vmSymbols$$static extends ClassLike {
            _initialize(db: hotspot.types.TypeDataBase): void;
            symbolAt(id: int): hotspot.oops.Symbol;
            _FIRST_SID: int;
            _SID_LIMIT: int;
            _symbolsAddress: hotspot.debugger.Address;
            new(): vmSymbols;
          }
          let vmSymbols: _vmSymbols$$static;
          interface _vmSymbols {
          }
          interface vmSymbols extends CombineTypes<[_vmSymbols, java.lang.Object]> {}
        }
        module tools {
          module jcore {
            interface _ByteCodeRewriter$$static extends ClassLike {
              _writeShort(buf: byte[], index: int, value: short): void;
              readonly DEBUG: boolean;
              _jintSize: int;
              new(method: hotspot.oops.Method, cpool: hotspot.oops.ConstantPool, code: byte[]): ByteCodeRewriter;
            }
            let ByteCodeRewriter: _ByteCodeRewriter$$static;
            interface _ByteCodeRewriter {
              _debugMessage(message: string): void;
              _getConstantPoolIndex(rawcode: int, bci: int): short;
              _getConstantPoolIndexFromRefMap(rawcode: int, bci: int): short;
              rewrite(): void;
              _bytes: hotspot.runtime.Bytes;
              _code: byte[];
              _cpCache: hotspot.oops.ConstantPoolCache;
              _cpool: hotspot.oops.ConstantPool;
              _method: hotspot.oops.Method;
            }
            interface ByteCodeRewriter extends CombineTypes<[_ByteCodeRewriter, java.lang.Object]> {}
            interface _ClassDump$$static extends ClassLike {
              main(args: string[]): void;
              new(): ClassDump;
              new(d: hotspot.debugger.JVMDebugger, pkgList: string): ClassDump;
            }
            let ClassDump: _ClassDump$$static;
            interface _ClassDump {
              _dumpKlass(kls: hotspot.oops.InstanceKlass): void;
              getName(): string;
              run(): void;
              setClassFilter(cf: ClassFilter): void;
              setJarOutput(jarFileName: string): void;
              setOutputDirectory(od: string): void;
              _classFilter: ClassFilter;
              _jarStream: java.util.jar.JarOutputStream;
              _outputDirectory: string;
              _pkgList: string;
            }
            interface ClassDump extends CombineTypes<[_ClassDump, sun.jvm.hotspot.tools.Tool]> {}
            interface _ClassFilter$$static extends ClassLike {
            }
            let ClassFilter: _ClassFilter$$static;
            interface _ClassFilter {
              canInclude(a0: hotspot.oops.InstanceKlass): boolean;
(a0: hotspot.oops.InstanceKlass): boolean;
            }
            interface ClassFilter extends CombineTypes<[_ClassFilter, java.lang.Object]> {}
            interface _ClassWriter$$static extends ClassLike {
              _extractHighShortFromInt(val: int): int;
              _extractLowShortFromInt(val: int): int;
              readonly DEBUG: boolean;
              new(kls: hotspot.oops.InstanceKlass, os: java.io.OutputStream): ClassWriter;
            }
            let ClassWriter: _ClassWriter$$static;
            interface _ClassWriter {
              _debugMessage(message: string): void;
              _hasSyntheticAttribute(accessFlags: short): boolean;
              _isSynthetic(accessFlags: short): boolean;
              _rewriteByteCode(m: hotspot.oops.Method, code: byte[]): void;
              write(): void;
              _writeClassAccessFlags(): void;
              _writeClassAttributes(): void;
              _writeConstantPool(): void;
              _writeFields(): void;
              _writeGenericSignature(signature: string): void;
              _writeIndex(index: int): void;
              _writeInterfaces(): void;
              _writeMethod(m: hotspot.oops.Method): void;
              _writeMethods(): void;
              _writeSuperClass(): void;
              _writeSynthetic(): void;
              _writeThisClass(): void;
              _writeVersion(): void;
              __codeIndex: short;
              __constantValueIndex: short;
              __deprecatedIndex: short;
              __exceptionsIndex: short;
              __innerClassesIndex: short;
              __lineNumberTableIndex: short;
              __localVariableTableIndex: short;
              __signatureIndex: short;
              __sourceFileIndex: short;
              __syntheticIndex: short;
              _classToIndex: java.util.Map<string,short>;
              _cpool: hotspot.oops.ConstantPool;
              _dos: java.io.DataOutputStream;
              _klass: hotspot.oops.InstanceKlass;
              _utf8ToIndex: java.util.Map<string,short>;
            }
            interface ClassWriter extends CombineTypes<[_ClassWriter, sun.jvm.hotspot.runtime.ClassConstants, java.lang.Object]> {}
            interface _NameFilter$$static extends ClassLike {
              new(): NameFilter;
              new(pattern: string): NameFilter;
            }
            let NameFilter: _NameFilter$$static;
            interface _NameFilter {
              canInclude(kls: hotspot.oops.InstanceKlass): boolean;
              includePattern: java.util.regex.Pattern;
            }
            interface NameFilter extends CombineTypes<[_NameFilter, sun.jvm.hotspot.tools.jcore.ClassFilter, java.lang.Object]> {}
            interface _PackageNameFilter$$static extends ClassLike {
              new(): PackageNameFilter;
              new(pattern: string): PackageNameFilter;
            }
            let PackageNameFilter: _PackageNameFilter$$static;
            interface _PackageNameFilter {
              canInclude(kls: hotspot.oops.InstanceKlass): boolean;
              pkgList: string[];
            }
            interface PackageNameFilter extends CombineTypes<[_PackageNameFilter, sun.jvm.hotspot.tools.jcore.ClassFilter, java.lang.Object]> {}
          }
          interface _ClassLoaderStats$$static extends ClassLike {
            _arraySize(arr: hotspot.utilities.GenericArray): long;
            main(args: string[]): void;
            _objectSize(oop: hotspot.oops.Oop): long;
            new(): ClassLoaderStats;
            new(d: hotspot.debugger.JVMDebugger): ClassLoaderStats;
          }
          let ClassLoaderStats: _ClassLoaderStats$$static;
          interface _ClassLoaderStats {
            _computeSize(k: hotspot.oops.InstanceKlass): long;
            getName(): string;
            _printClassLoaderStatistics(): void;
            run(): void;
            _verbose: boolean;
          }
          interface ClassLoaderStats extends CombineTypes<[_ClassLoaderStats, sun.jvm.hotspot.tools.Tool]> {}
          interface _ClassLoaderStats$ClassData$$static extends ClassLike {
            _new(klass: hotspot.oops.Klass, size: long): ClassLoaderStats$ClassData;
          }
          let ClassLoaderStats$ClassData: _ClassLoaderStats$ClassData$$static;
          interface _ClassLoaderStats$ClassData {
            _klass: hotspot.oops.Klass;
            _size: long;
          }
          interface ClassLoaderStats$ClassData extends CombineTypes<[_ClassLoaderStats$ClassData, java.lang.Object]> {}
          interface _ClassLoaderStats$LoaderData$$static extends ClassLike {
          }
          let ClassLoaderStats$LoaderData: _ClassLoaderStats$LoaderData$$static;
          interface _ClassLoaderStats$LoaderData {
            _classDetail: java.util.List<ClassLoaderStats$ClassData>;
            _classSize: long;
            _numClasses: long;
          }
          interface ClassLoaderStats$LoaderData extends CombineTypes<[_ClassLoaderStats$LoaderData, java.lang.Object]> {}
          interface _FinalizerInfo$$static extends ClassLike {
            main(args: string[]): void;
            new(): FinalizerInfo;
            new(d: hotspot.debugger.JVMDebugger): FinalizerInfo;
          }
          let FinalizerInfo: _FinalizerInfo$$static;
          interface _FinalizerInfo {
            getName(): string;
            run(): void;
          }
          interface FinalizerInfo extends CombineTypes<[_FinalizerInfo, sun.jvm.hotspot.tools.Tool]> {}
          interface _FlagDumper$$static extends ClassLike {
            main(args: string[]): void;
            new(): FlagDumper;
            new(d: hotspot.debugger.JVMDebugger): FlagDumper;
          }
          let FlagDumper: _FlagDumper$$static;
          interface _FlagDumper {
            run(): void;
          }
          interface FlagDumper extends CombineTypes<[_FlagDumper, sun.jvm.hotspot.tools.Tool]> {}
          interface _HeapDumper$$static extends ClassLike {
            main(args: string[]): void;
            _DEFAULT_DUMP_FILE: string;
            new(): HeapDumper;
            new(dumpFile: string): HeapDumper;
            new(dumpFile: string, d: hotspot.debugger.JVMDebugger): HeapDumper;
          }
          let HeapDumper: _HeapDumper$$static;
          interface _HeapDumper {
            getName(): string;
            _printFlagsUsage(): void;
            run(): void;
            runWithArgs(args: string[]): void;
            runWithArgs(...args: string[]): void;
            _dumpFile: string;
          }
          interface HeapDumper extends CombineTypes<[_HeapDumper, sun.jvm.hotspot.tools.Tool]> {}
          interface _HeapSummary$$static extends ClassLike {
            main(args: string[]): void;
            _FACTOR: double;
            _alignment: string;
            new(): HeapSummary;
            new(d: hotspot.debugger.JVMDebugger): HeapSummary;
          }
          let HeapSummary: _HeapSummary$$static;
          interface _HeapSummary {
            _getFlagValue(name: string, flagMap: java.util.Map): long;
            getName(): string;
            printG1HeapSummary(g1h: hotspot.gc.g1.G1CollectedHeap): void;
            printG1HeapSummary(tty: java.io.PrintStream, g1h: hotspot.gc.g1.G1CollectedHeap): void;
            _printG1Space(tty: java.io.PrintStream, spaceName: string, regionNum: long, a3: long, used: long): void;
            _printGCAlgorithm(flagMap: java.util.Map): void;
            _printGen(gen: hotspot.gc.shared.Generation): void;
            _printMutableSpace(space: hotspot.gc.parallel.MutableSpace): void;
            _printPSYoungGen(youngGen: hotspot.gc.parallel.PSYoungGen): void;
            _printSpace(space: hotspot.gc.shared.ContiguousSpace): void;
            _printValMB(title: string, value: long): void;
            _printValMB(tty: java.io.PrintStream, title: string, value: long): void;
            _printValue(title: string, value: long): void;
            _printValue(tty: java.io.PrintStream, title: string, value: long): void;
            run(): void;
          }
          interface HeapSummary extends CombineTypes<[_HeapSummary, sun.jvm.hotspot.tools.Tool]> {}
          interface _JInfo$$static extends ClassLike {
            main(args: string[]): void;
            readonly MODE_BOTH: int;
            readonly MODE_FLAGS: int;
            readonly MODE_SYSPROPS: int;
            new(): JInfo;
            new(m: int): JInfo;
            new(d: hotspot.debugger.JVMDebugger): JInfo;
          }
          let JInfo: _JInfo$$static;
          interface _JInfo {
            getName(): string;
            _needsJavaPrefix(): boolean;
            _printFlagsUsage(): void;
            _printVMFlags(): void;
            run(): void;
            runWithArgs(args: string[]): void;
            runWithArgs(...args: string[]): void;
            _mode: int;
          }
          interface JInfo extends CombineTypes<[_JInfo, sun.jvm.hotspot.tools.Tool]> {}
          interface _JMap$$static extends ClassLike {
            main(args: string[]): void;
            readonly MODE_CLSTATS: int;
            readonly MODE_FINALIZERINFO: int;
            readonly MODE_HEAP_GRAPH_GXL: int;
            readonly MODE_HEAP_GRAPH_HPROF_BIN: int;
            readonly MODE_HEAP_SUMMARY: int;
            readonly MODE_HISTOGRAM: int;
            readonly MODE_PMAP: int;
            _dumpfile: string;
            _gzLevel: int;
            new(m: int): JMap;
            new(): JMap;
            new(d: hotspot.debugger.JVMDebugger): JMap;
          }
          let JMap: _JMap$$static;
          interface _JMap {
            _getCommandFlags(): string;
            getName(): string;
            _needsJavaPrefix(): boolean;
            _printFlagsUsage(): void;
            run(): void;
            _writeHeapGXL(fileName: string): boolean;
            writeHeapGXL(): boolean;
            writeHeapHprofBin(fileName: string, gzLevel: int): boolean;
            writeHeapHprofBin(): boolean;
            _mode: int;
          }
          interface JMap extends CombineTypes<[_JMap, sun.jvm.hotspot.tools.Tool]> {}
          interface _JSnap$$static extends ClassLike {
            main(args: string[]): void;
            new(): JSnap;
            new(d: hotspot.debugger.JVMDebugger): JSnap;
          }
          let JSnap: _JSnap$$static;
          interface _JSnap {
            _printFlagsUsage(): void;
            run(): void;
            _all: boolean;
          }
          interface JSnap extends CombineTypes<[_JSnap, sun.jvm.hotspot.tools.Tool]> {}
          interface _JStack$$static extends ClassLike {
            main(args: string[]): void;
            new(mixedMode: boolean, concurrentLocks: boolean): JStack;
            new(): JStack;
            new(d: hotspot.debugger.JVMDebugger): JStack;
          }
          let JStack: _JStack$$static;
          interface _JStack {
            getName(): string;
            _needsJavaPrefix(): boolean;
            _printFlagsUsage(): void;
            run(): void;
            runWithArgs(args: string[]): void;
            runWithArgs(...args: string[]): void;
            _concurrentLocks: boolean;
            _mixedMode: boolean;
          }
          interface JStack extends CombineTypes<[_JStack, sun.jvm.hotspot.tools.Tool]> {}
          interface _ObjectHistogram$$static extends ClassLike {
            main(args: string[]): void;
            new(): ObjectHistogram;
            new(d: hotspot.debugger.JVMDebugger): ObjectHistogram;
          }
          let ObjectHistogram: _ObjectHistogram$$static;
          interface _ObjectHistogram {
            getName(): string;
            run(): void;
            run(out: java.io.PrintStream, err: java.io.PrintStream): void;
          }
          interface ObjectHistogram extends CombineTypes<[_ObjectHistogram, sun.jvm.hotspot.tools.Tool]> {}
          interface _PMap$$static extends ClassLike {
            main(args: string[]): void;
            new(): PMap;
            new(d: hotspot.debugger.JVMDebugger): PMap;
            new(agent: HotSpotAgent): PMap;
          }
          let PMap: _PMap$$static;
          interface _PMap {
            getName(): string;
            run(): void;
            run(out: java.io.PrintStream): void;
            run(out: java.io.PrintStream, dbg: hotspot.debugger.Debugger): void;
          }
          interface PMap extends CombineTypes<[_PMap, sun.jvm.hotspot.tools.Tool]> {}
          interface _PStack$$static extends ClassLike {
            main(args: string[]): void;
            new(v: boolean, concurrentLocks: boolean, agent: HotSpotAgent): PStack;
            new(v: boolean, concurrentLocks: boolean): PStack;
            new(): PStack;
            new(d: hotspot.debugger.JVMDebugger): PStack;
          }
          let PStack: _PStack$$static;
          interface _PStack {
            _getJavaNames(th: hotspot.debugger.ThreadProxy, fp: hotspot.debugger.Address): string[];
            _initJFrameCache(): void;
            _printUnknown(out: java.io.PrintStream): void;
            run(): void;
            run(out: java.io.PrintStream): void;
            run(out: java.io.PrintStream, dbg: hotspot.debugger.Debugger): void;
            setConcurrentLocks(concurrentLocks: boolean): void;
            setVerbose(verbose: boolean): void;
            _concurrentLocks: boolean;
            _jframeCache: java.util.Map<hotspot.debugger.ThreadProxy,hotspot.runtime.JavaVFrame[]>;
            _out: java.io.PrintStream;
            _proxyToThread: java.util.Map<hotspot.debugger.ThreadProxy,hotspot.runtime.JavaThread>;
            _verbose: boolean;
          }
          interface PStack extends CombineTypes<[_PStack, sun.jvm.hotspot.tools.Tool]> {}
          interface _StackTrace$$static extends ClassLike {
            main(args: string[]): void;
            new(v: boolean, concurrentLocks: boolean): StackTrace;
            new(): StackTrace;
            new(d: hotspot.debugger.JVMDebugger): StackTrace;
            new(d: hotspot.debugger.JVMDebugger, v: boolean, concurrentLocks: boolean): StackTrace;
          }
          let StackTrace: _StackTrace$$static;
          interface _StackTrace {
            run(): void;
            run(tty: java.io.PrintStream): void;
            _concurrentLocks: boolean;
            _verbose: boolean;
          }
          interface StackTrace extends CombineTypes<[_StackTrace, sun.jvm.hotspot.tools.Tool]> {}
          interface _SysPropsDumper$$static extends ClassLike {
            main(args: string[]): void;
            new(): SysPropsDumper;
            new(d: hotspot.debugger.JVMDebugger): SysPropsDumper;
          }
          let SysPropsDumper: _SysPropsDumper$$static;
          interface _SysPropsDumper {
            run(): void;
          }
          interface SysPropsDumper extends CombineTypes<[_SysPropsDumper, sun.jvm.hotspot.tools.Tool]> {}
          interface _Tool$$static extends ClassLike {
            _DEBUGEE_CORE: int;
            _DEBUGEE_PID: int;
            _DEBUGEE_REMOTE: int;
            new(): Tool;
            new(d: hotspot.debugger.JVMDebugger): Tool;
            new(agent: HotSpotAgent): Tool;
          }
          let Tool: _Tool$$static;
          interface _Tool {
            _execute(args: string[]): void;
            _getAgent(): HotSpotAgent;
            _getDebugeeType(): int;
            getName(): string;
            _needsJavaPrefix(): boolean;
            _printFlagsUsage(): void;
            _printUsage(): void;
            _setAgent(a: HotSpotAgent): void;
            _setDebugeeType(dt: int): void;
            _start(args: string[]): int;
            start(): void;
            _startInternal(): void;
            stop(): void;
            _usage(): void;
            _agent: HotSpotAgent;
            _debugeeType: int;
            _jvmDebugger: hotspot.debugger.JVMDebugger;
          }
          interface Tool extends CombineTypes<[_Tool, java.lang.Object, java.lang.Runnable]> {}
        }
        module types {
          module basic {
            interface _BasicAddressFieldWrapper$$static extends ClassLike {
              new(field: Field): BasicAddressFieldWrapper;
            }
            let BasicAddressFieldWrapper: _BasicAddressFieldWrapper$$static;
            interface _BasicAddressFieldWrapper {
              getValue(addr: hotspot.debugger.Address): hotspot.debugger.Address;
              getValue(): hotspot.debugger.Address;
            }
            interface BasicAddressFieldWrapper extends CombineTypes<[_BasicAddressFieldWrapper, sun.jvm.hotspot.types.AddressField, sun.jvm.hotspot.types.basic.BasicFieldWrapper]> {}
            interface _BasicCIntegerField$$static extends ClassLike {
              new(db: BasicTypeDataBase, containingType: Type, name: string, type: Type, isStatic: boolean, offset: long, a6: hotspot.debugger.Address): BasicCIntegerField;
            }
            let BasicCIntegerField: _BasicCIntegerField$$static;
            interface _BasicCIntegerField {
              getValue(addr: hotspot.debugger.Address): long;
              getValue(): long;
              isUnsigned(): boolean;
              _intType: CIntegerType;
            }
            interface BasicCIntegerField extends CombineTypes<[_BasicCIntegerField, sun.jvm.hotspot.types.basic.BasicField, sun.jvm.hotspot.types.CIntegerField]> {}
            interface _BasicCIntegerType$$static extends ClassLike {
              new(db: BasicTypeDataBase, name: string, isUnsigned: boolean): BasicCIntegerType;
            }
            let BasicCIntegerType: _BasicCIntegerType$$static;
            interface _BasicCIntegerType {
              equals(obj: any): boolean;
              isCIntegerType(): boolean;
              isUnsigned(): boolean;
              maxValue(): long;
              minValue(): long;
              setIsUnsigned(isUnsigned: boolean): void;
              toString(): string;
              _isUnsigned: boolean;
            }
            interface BasicCIntegerType extends CombineTypes<[_BasicCIntegerType, sun.jvm.hotspot.types.CIntegerType, sun.jvm.hotspot.types.basic.BasicType]> {}
            interface _BasicField$$static extends ClassLike {
              new(fld: Field): BasicField;
              new(db: BasicTypeDataBase, containingType: Type, name: string, type: Type, isStatic: boolean, offsetInBytes: long, a6: hotspot.debugger.Address): BasicField;
            }
            let BasicField: _BasicField$$static;
            interface _BasicField {
              getAddress(addr: hotspot.debugger.Address): hotspot.debugger.Address;
              getAddress(): hotspot.debugger.Address;
              getCInteger(addr: hotspot.debugger.Address, type: CIntegerType): long;
              getCInteger(type: CIntegerType): long;
              getJBoolean(addr: hotspot.debugger.Address): boolean;
              getJBoolean(): boolean;
              getJByte(addr: hotspot.debugger.Address): byte;
              getJByte(): byte;
              getJChar(addr: hotspot.debugger.Address): char;
              getJChar(): char;
              getJDouble(addr: hotspot.debugger.Address): double;
              getJDouble(): double;
              getJFloat(addr: hotspot.debugger.Address): float;
              getJFloat(): float;
              getJInt(addr: hotspot.debugger.Address): int;
              getJInt(): int;
              getJLong(addr: hotspot.debugger.Address): long;
              getJLong(): long;
              getJShort(addr: hotspot.debugger.Address): short;
              getJShort(): short;
              getName(): string;
              getNarrowOopHandle(addr: hotspot.debugger.Address): hotspot.debugger.OopHandle;
              getNarrowOopHandle(): hotspot.debugger.OopHandle;
              getOffset(): long;
              getOopHandle(addr: hotspot.debugger.Address): hotspot.debugger.OopHandle;
              getOopHandle(): hotspot.debugger.OopHandle;
              getSize(): long;
              getStaticFieldAddress(): hotspot.debugger.Address;
              getType(): Type;
              isStatic(): boolean;
              _containingType: Type;
              _db: BasicTypeDataBase;
              _isStatic: boolean;
              _name: string;
              _offset: long;
              _size: long;
              _staticFieldAddress: hotspot.debugger.Address;
              _type: Type;
            }
            interface BasicField extends CombineTypes<[_BasicField, java.lang.Object, sun.jvm.hotspot.types.Field]> {}
            interface _BasicFieldWrapper$$static extends ClassLike {
              new(field: Field): BasicFieldWrapper;
            }
            let BasicFieldWrapper: _BasicFieldWrapper$$static;
            interface _BasicFieldWrapper {
              getAddress(addr: hotspot.debugger.Address): hotspot.debugger.Address;
              getAddress(): hotspot.debugger.Address;
              getCInteger(addr: hotspot.debugger.Address, type: CIntegerType): long;
              getCInteger(type: CIntegerType): long;
              getJBoolean(addr: hotspot.debugger.Address): boolean;
              getJBoolean(): boolean;
              getJByte(addr: hotspot.debugger.Address): byte;
              getJByte(): byte;
              getJChar(addr: hotspot.debugger.Address): char;
              getJChar(): char;
              getJDouble(addr: hotspot.debugger.Address): double;
              getJDouble(): double;
              getJFloat(addr: hotspot.debugger.Address): float;
              getJFloat(): float;
              getJInt(addr: hotspot.debugger.Address): int;
              getJInt(): int;
              getJLong(addr: hotspot.debugger.Address): long;
              getJLong(): long;
              getJShort(addr: hotspot.debugger.Address): short;
              getJShort(): short;
              getName(): string;
              getNarrowOopHandle(addr: hotspot.debugger.Address): hotspot.debugger.OopHandle;
              getNarrowOopHandle(): hotspot.debugger.OopHandle;
              getOffset(): long;
              getOopHandle(addr: hotspot.debugger.Address): hotspot.debugger.OopHandle;
              getOopHandle(): hotspot.debugger.OopHandle;
              getSize(): long;
              getStaticFieldAddress(): hotspot.debugger.Address;
              getType(): Type;
              isStatic(): boolean;
              _field: Field;
            }
            interface BasicFieldWrapper extends CombineTypes<[_BasicFieldWrapper, java.lang.Object, sun.jvm.hotspot.types.Field]> {}
            interface _BasicJBooleanField$$static extends ClassLike {
              new(db: BasicTypeDataBase, containingType: Type, name: string, type: Type, isStatic: boolean, offset: long, a6: hotspot.debugger.Address): BasicJBooleanField;
            }
            let BasicJBooleanField: _BasicJBooleanField$$static;
            interface _BasicJBooleanField {
              getValue(addr: hotspot.debugger.Address): boolean;
              getValue(): boolean;
            }
            interface BasicJBooleanField extends CombineTypes<[_BasicJBooleanField, sun.jvm.hotspot.types.basic.BasicField, sun.jvm.hotspot.types.JBooleanField]> {}
            interface _BasicJByteField$$static extends ClassLike {
              new(db: BasicTypeDataBase, containingType: Type, name: string, type: Type, isStatic: boolean, offset: long, a6: hotspot.debugger.Address): BasicJByteField;
            }
            let BasicJByteField: _BasicJByteField$$static;
            interface _BasicJByteField {
              getValue(addr: hotspot.debugger.Address): byte;
              getValue(): byte;
            }
            interface BasicJByteField extends CombineTypes<[_BasicJByteField, sun.jvm.hotspot.types.basic.BasicField, sun.jvm.hotspot.types.JByteField]> {}
            interface _BasicJCharField$$static extends ClassLike {
              new(db: BasicTypeDataBase, containingType: Type, name: string, type: Type, isStatic: boolean, offset: long, a6: hotspot.debugger.Address): BasicJCharField;
            }
            let BasicJCharField: _BasicJCharField$$static;
            interface _BasicJCharField {
              getValue(addr: hotspot.debugger.Address): char;
              getValue(): char;
            }
            interface BasicJCharField extends CombineTypes<[_BasicJCharField, sun.jvm.hotspot.types.basic.BasicField, sun.jvm.hotspot.types.JCharField]> {}
            interface _BasicJDoubleField$$static extends ClassLike {
              new(db: BasicTypeDataBase, containingType: Type, name: string, type: Type, isStatic: boolean, offset: long, a6: hotspot.debugger.Address): BasicJDoubleField;
            }
            let BasicJDoubleField: _BasicJDoubleField$$static;
            interface _BasicJDoubleField {
              getValue(addr: hotspot.debugger.Address): double;
              getValue(): double;
            }
            interface BasicJDoubleField extends CombineTypes<[_BasicJDoubleField, sun.jvm.hotspot.types.basic.BasicField, sun.jvm.hotspot.types.JDoubleField]> {}
            interface _BasicJFloatField$$static extends ClassLike {
              new(db: BasicTypeDataBase, containingType: Type, name: string, type: Type, isStatic: boolean, offset: long, a6: hotspot.debugger.Address): BasicJFloatField;
            }
            let BasicJFloatField: _BasicJFloatField$$static;
            interface _BasicJFloatField {
              getValue(addr: hotspot.debugger.Address): float;
              getValue(): float;
            }
            interface BasicJFloatField extends CombineTypes<[_BasicJFloatField, sun.jvm.hotspot.types.basic.BasicField, sun.jvm.hotspot.types.JFloatField]> {}
            interface _BasicJIntField$$static extends ClassLike {
              new(db: BasicTypeDataBase, containingType: Type, name: string, type: Type, isStatic: boolean, offset: long, a6: hotspot.debugger.Address): BasicJIntField;
            }
            let BasicJIntField: _BasicJIntField$$static;
            interface _BasicJIntField {
              getValue(addr: hotspot.debugger.Address): int;
              getValue(): int;
            }
            interface BasicJIntField extends CombineTypes<[_BasicJIntField, sun.jvm.hotspot.types.basic.BasicField, sun.jvm.hotspot.types.JIntField]> {}
            interface _BasicJLongField$$static extends ClassLike {
              new(db: BasicTypeDataBase, containingType: Type, name: string, type: Type, isStatic: boolean, offset: long, a6: hotspot.debugger.Address): BasicJLongField;
            }
            let BasicJLongField: _BasicJLongField$$static;
            interface _BasicJLongField {
              getValue(addr: hotspot.debugger.Address): long;
              getValue(): long;
            }
            interface BasicJLongField extends CombineTypes<[_BasicJLongField, sun.jvm.hotspot.types.basic.BasicField, sun.jvm.hotspot.types.JLongField]> {}
            interface _BasicJShortField$$static extends ClassLike {
              new(db: BasicTypeDataBase, containingType: Type, name: string, type: Type, isStatic: boolean, offset: long, a6: hotspot.debugger.Address): BasicJShortField;
            }
            let BasicJShortField: _BasicJShortField$$static;
            interface _BasicJShortField {
              getValue(addr: hotspot.debugger.Address): short;
              getValue(): short;
            }
            interface BasicJShortField extends CombineTypes<[_BasicJShortField, sun.jvm.hotspot.types.basic.BasicField, sun.jvm.hotspot.types.JShortField]> {}
            interface _BasicNarrowOopField$$static extends ClassLike {
              _DEBUG: boolean;
              new(oopf: OopField): BasicNarrowOopField;
              new(db: BasicTypeDataBase, containingType: Type, name: string, type: Type, isStatic: boolean, offset: long, a6: hotspot.debugger.Address): BasicNarrowOopField;
            }
            let BasicNarrowOopField: _BasicNarrowOopField$$static;
            interface _BasicNarrowOopField {
              getValue(addr: hotspot.debugger.Address): hotspot.debugger.OopHandle;
              getValue(): hotspot.debugger.OopHandle;
            }
            interface BasicNarrowOopField extends CombineTypes<[_BasicNarrowOopField, sun.jvm.hotspot.types.NarrowOopField, sun.jvm.hotspot.types.basic.BasicOopField]> {}
            interface _BasicOopField$$static extends ClassLike {
              new(oopf: OopField): BasicOopField;
              new(db: BasicTypeDataBase, containingType: Type, name: string, type: Type, isStatic: boolean, offset: long, a6: hotspot.debugger.Address): BasicOopField;
            }
            let BasicOopField: _BasicOopField$$static;
            interface _BasicOopField {
              getValue(addr: hotspot.debugger.Address): hotspot.debugger.OopHandle;
              getValue(): hotspot.debugger.OopHandle;
            }
            interface BasicOopField extends CombineTypes<[_BasicOopField, sun.jvm.hotspot.types.basic.BasicField, sun.jvm.hotspot.types.OopField]> {}
            interface _BasicPointerType$$static extends ClassLike {
              new(db: BasicTypeDataBase, name: string, targetType: Type): BasicPointerType;
            }
            let BasicPointerType: _BasicPointerType$$static;
            interface _BasicPointerType {
              getTargetType(): Type;
              isPointerType(): boolean;
              _targetType: Type;
            }
            interface BasicPointerType extends CombineTypes<[_BasicPointerType, sun.jvm.hotspot.types.basic.BasicType, sun.jvm.hotspot.types.PointerType]> {}
            interface _BasicType$$static extends ClassLike {
              new(db: BasicTypeDataBase, name: string, superclass: Type): BasicType;
              new(db: BasicTypeDataBase, name: string): BasicType;
            }
            let BasicType: _BasicType$$static;
            interface _BasicType {
              addField(field: Field): void;
              equals(obj: any): boolean;
              getAddressField(fieldName: string): AddressField;
              getCIntegerField(fieldName: string): CIntegerField;
              getField(fieldName: string, searchSuperclassFields: boolean, throwExceptionIfNotFound: boolean): Field;
              getField(fieldName: string, searchSuperclassFields: boolean): Field;
              getField(fieldName: string): Field;
              getField(fieldName: string, declaredType: Type, searchSuperclassFields: boolean): Field;
              getField(fieldName: string, declaredType: Type): Field;
              getFields(): java.util.Iterator;
              getJBooleanField(fieldName: string): JBooleanField;
              getJByteField(fieldName: string): JByteField;
              getJCharField(fieldName: string): JCharField;
              getJDoubleField(fieldName: string): JDoubleField;
              getJFloatField(fieldName: string): JFloatField;
              getJIntField(fieldName: string): JIntField;
              getJLongField(fieldName: string): JLongField;
              getJShortField(fieldName: string): JShortField;
              getName(): string;
              getNarrowOopField(fieldName: string): NarrowOopField;
              getOopField(fieldName: string): OopField;
              getSize(): long;
              getSuperclass(): Type;
              hashCode(): int;
              isCIntegerType(): boolean;
              isCStringType(): boolean;
              isJavaPrimitiveType(): boolean;
              isOopType(): boolean;
              isPointerType(): boolean;
              removeField(field: Field): void;
              setIsJavaPrimitiveType(isJavaPrimitiveType: boolean): void;
              setIsOopType(isOopType: boolean): void;
              setSize(sizeInBytes: long): void;
              setSuperclass(superclass: Type): void;
              toString(): string;
              _db: BasicTypeDataBase;
              _fieldList: java.util.List<Field>;
              _isJavaPrimitiveType: boolean;
              _isOopType: boolean;
              _name: string;
              _nameToFieldMap: java.util.Map<string,Field>;
              _size: long;
              _superclass: Type;
            }
            interface BasicType extends CombineTypes<[_BasicType, sun.jvm.hotspot.types.Type, java.lang.Object]> {}
            interface _BasicTypeDataBase$$static extends ClassLike {
              _DEBUG: boolean;
              new(machDesc: hotspot.debugger.MachineDescription, vtblAccess: VtblAccess): BasicTypeDataBase;
            }
            let BasicTypeDataBase: _BasicTypeDataBase$$static;
            interface _BasicTypeDataBase {
              addIntConstant(name: string, value: int): void;
              addLongConstant(name: string, value: long): void;
              addType(type: Type): void;
              addressTypeIsEqualToType(addr: hotspot.debugger.Address, type: Type): boolean;
              cIntegerTypeMaxValue(sizeInBytes: long, a1: boolean): long;
              cIntegerTypeMinValue(sizeInBytes: long, a1: boolean): long;
              findDynamicTypeForAddress(addr: hotspot.debugger.Address, baseType: Type): Type;
              getAddressSize(): long;
              getIntConstants(): java.util.Iterator;
              getJBooleanType(): Type;
              getJByteType(): Type;
              getJCharType(): Type;
              getJDoubleType(): Type;
              getJFloatType(): Type;
              getJIntType(): Type;
              getJLongType(): Type;
              getJShortType(): Type;
              getLongConstants(): java.util.Iterator;
              getOopSize(): long;
              getTypes(): java.util.Iterator;
              guessTypeForAddress(addr: hotspot.debugger.Address): Type;
              lookupIntConstant(constantName: string): int;
              lookupIntConstant(constantName: string, throwException: boolean): int;
              lookupLongConstant(constantName: string): long;
              lookupLongConstant(constantName: string, throwException: boolean): long;
              lookupType(cTypeName: string): Type;
              lookupType(cTypeName: string, throwException: boolean): Type;
              removeIntConstant(name: string): void;
              removeLongConstant(name: string): void;
              removeType(type: Type): void;
              setJBooleanType(type: Type): void;
              setJByteType(type: Type): void;
              setJCharType(type: Type): void;
              setJDoubleType(type: Type): void;
              setJFloatType(type: Type): void;
              setJIntType(type: Type): void;
              setJLongType(type: Type): void;
              setJShortType(type: Type): void;
              vtblForType(type: Type): hotspot.debugger.Address;
              _jbooleanType: Type;
              _jbyteType: Type;
              _jcharType: Type;
              _jdoubleType: Type;
              _jfloatType: Type;
              _jintType: Type;
              _jlongType: Type;
              _jshortType: Type;
              _machDesc: hotspot.debugger.MachineDescription;
              _nameToIntConstantMap: java.util.Map<string,int>;
              _nameToLongConstantMap: java.util.Map<string,long>;
              _nameToTypeMap: java.util.Map<string,Type>;
              _typeToVtbl: java.util.Map<Type,hotspot.debugger.Address>;
              _vtblAccess: VtblAccess;
            }
            interface BasicTypeDataBase extends CombineTypes<[_BasicTypeDataBase, sun.jvm.hotspot.types.TypeDataBase, java.lang.Object]> {}
            interface _BasicVtblAccess$$static extends ClassLike {
              _nullAddress: any;
              new(symbolLookup: hotspot.debugger.SymbolLookup, dllNames: string[]): BasicVtblAccess;
            }
            let BasicVtblAccess: _BasicVtblAccess$$static;
            interface _BasicVtblAccess {
              clearCaches(): void;
              getVtblForType(type: Type): hotspot.debugger.Address;
              _vtblSymbolForType(a0: Type): string;
(a0: Type): string;
              _dllNames: string[];
              _symbolLookup: hotspot.debugger.SymbolLookup;
              _typeToVtblMap: java.util.Map<Type,any>;
            }
            interface BasicVtblAccess extends CombineTypes<[_BasicVtblAccess, java.lang.Object, sun.jvm.hotspot.types.basic.VtblAccess]> {}
            interface _VtblAccess$$static extends ClassLike {
            }
            let VtblAccess: _VtblAccess$$static;
            interface _VtblAccess {
              clearCaches(): void;
              getVtblForType(a0: Type): hotspot.debugger.Address;
            }
            interface VtblAccess extends CombineTypes<[_VtblAccess, java.lang.Object]> {}
          }
          interface _AddressField$$static extends ClassLike {
          }
          let AddressField: _AddressField$$static;
          interface _AddressField {
            getValue(a0: hotspot.debugger.Address): hotspot.debugger.Address;
            getValue(): hotspot.debugger.Address;
          }
          interface AddressField extends CombineTypes<[_AddressField, java.lang.Object, sun.jvm.hotspot.types.Field]> {}
          interface _CIntegerField$$static extends ClassLike {
          }
          let CIntegerField: _CIntegerField$$static;
          interface _CIntegerField {
            getValue(a0: hotspot.debugger.Address): long;
            getValue(): long;
            isUnsigned(): boolean;
          }
          interface CIntegerField extends CombineTypes<[_CIntegerField, java.lang.Object, sun.jvm.hotspot.types.Field]> {}
          interface _CIntegerType$$static extends ClassLike {
          }
          let CIntegerType: _CIntegerType$$static;
          interface _CIntegerType {
            isUnsigned(): boolean;
            maxValue(): long;
            minValue(): long;
          }
          interface CIntegerType extends CombineTypes<[_CIntegerType, sun.jvm.hotspot.types.Type, java.lang.Object]> {}
          interface _Field$$static extends ClassLike {
          }
          let Field: _Field$$static;
          interface _Field {
            getAddress(a0: hotspot.debugger.Address): hotspot.debugger.Address;
            getAddress(): hotspot.debugger.Address;
            getCInteger(a0: hotspot.debugger.Address, a1: CIntegerType): long;
            getCInteger(a0: CIntegerType): long;
            getJBoolean(a0: hotspot.debugger.Address): boolean;
            getJBoolean(): boolean;
            getJByte(a0: hotspot.debugger.Address): byte;
            getJByte(): byte;
            getJChar(a0: hotspot.debugger.Address): char;
            getJChar(): char;
            getJDouble(a0: hotspot.debugger.Address): double;
            getJDouble(): double;
            getJFloat(a0: hotspot.debugger.Address): float;
            getJFloat(): float;
            getJInt(a0: hotspot.debugger.Address): int;
            getJInt(): int;
            getJLong(a0: hotspot.debugger.Address): long;
            getJLong(): long;
            getJShort(a0: hotspot.debugger.Address): short;
            getJShort(): short;
            getName(): string;
            getNarrowOopHandle(a0: hotspot.debugger.Address): hotspot.debugger.OopHandle;
            getNarrowOopHandle(): hotspot.debugger.OopHandle;
            getOffset(): long;
            getOopHandle(a0: hotspot.debugger.Address): hotspot.debugger.OopHandle;
            getOopHandle(): hotspot.debugger.OopHandle;
            getSize(): long;
            getStaticFieldAddress(): hotspot.debugger.Address;
            getType(): Type;
            isStatic(): boolean;
          }
          interface Field extends CombineTypes<[_Field, java.lang.Object]> {}
          interface _JBooleanField$$static extends ClassLike {
          }
          let JBooleanField: _JBooleanField$$static;
          interface _JBooleanField {
            getValue(a0: hotspot.debugger.Address): boolean;
            getValue(): boolean;
          }
          interface JBooleanField extends CombineTypes<[_JBooleanField, java.lang.Object, sun.jvm.hotspot.types.Field]> {}
          interface _JByteField$$static extends ClassLike {
          }
          let JByteField: _JByteField$$static;
          interface _JByteField {
            getValue(a0: hotspot.debugger.Address): byte;
            getValue(): byte;
          }
          interface JByteField extends CombineTypes<[_JByteField, java.lang.Object, sun.jvm.hotspot.types.Field]> {}
          interface _JCharField$$static extends ClassLike {
          }
          let JCharField: _JCharField$$static;
          interface _JCharField {
            getValue(a0: hotspot.debugger.Address): char;
            getValue(): char;
          }
          interface JCharField extends CombineTypes<[_JCharField, java.lang.Object, sun.jvm.hotspot.types.Field]> {}
          interface _JDoubleField$$static extends ClassLike {
          }
          let JDoubleField: _JDoubleField$$static;
          interface _JDoubleField {
            getValue(a0: hotspot.debugger.Address): double;
            getValue(): double;
          }
          interface JDoubleField extends CombineTypes<[_JDoubleField, java.lang.Object, sun.jvm.hotspot.types.Field]> {}
          interface _JFloatField$$static extends ClassLike {
          }
          let JFloatField: _JFloatField$$static;
          interface _JFloatField {
            getValue(a0: hotspot.debugger.Address): float;
            getValue(): float;
          }
          interface JFloatField extends CombineTypes<[_JFloatField, java.lang.Object, sun.jvm.hotspot.types.Field]> {}
          interface _JIntField$$static extends ClassLike {
          }
          let JIntField: _JIntField$$static;
          interface _JIntField {
            getValue(a0: hotspot.debugger.Address): int;
            getValue(): int;
          }
          interface JIntField extends CombineTypes<[_JIntField, java.lang.Object, sun.jvm.hotspot.types.Field]> {}
          interface _JLongField$$static extends ClassLike {
          }
          let JLongField: _JLongField$$static;
          interface _JLongField {
            getValue(a0: hotspot.debugger.Address): long;
            getValue(): long;
          }
          interface JLongField extends CombineTypes<[_JLongField, java.lang.Object, sun.jvm.hotspot.types.Field]> {}
          interface _JShortField$$static extends ClassLike {
          }
          let JShortField: _JShortField$$static;
          interface _JShortField {
            getValue(a0: hotspot.debugger.Address): short;
            getValue(): short;
          }
          interface JShortField extends CombineTypes<[_JShortField, java.lang.Object, sun.jvm.hotspot.types.Field]> {}
          interface _NarrowOopField$$static extends ClassLike {
          }
          let NarrowOopField: _NarrowOopField$$static;
          interface _NarrowOopField {
            getValue(a0: hotspot.debugger.Address): hotspot.debugger.OopHandle;
            getValue(): hotspot.debugger.OopHandle;
          }
          interface NarrowOopField extends CombineTypes<[_NarrowOopField, sun.jvm.hotspot.types.OopField, java.lang.Object]> {}
          interface _OopField$$static extends ClassLike {
          }
          let OopField: _OopField$$static;
          interface _OopField {
            getValue(a0: hotspot.debugger.Address): hotspot.debugger.OopHandle;
            getValue(): hotspot.debugger.OopHandle;
          }
          interface OopField extends CombineTypes<[_OopField, java.lang.Object, sun.jvm.hotspot.types.Field]> {}
          interface _PointerType$$static extends ClassLike {
          }
          let PointerType: _PointerType$$static;
          interface _PointerType {
            getTargetType(): Type;
(): Type;
          }
          interface PointerType extends CombineTypes<[_PointerType, sun.jvm.hotspot.types.Type, java.lang.Object]> {}
          interface _Type$$static extends ClassLike {
          }
          let Type: _Type$$static;
          interface _Type {
            getAddressField(a0: string): AddressField;
            getCIntegerField(a0: string): CIntegerField;
            getField(a0: string, a1: boolean, a2: boolean): Field;
            getField(a0: string, a1: boolean): Field;
            getField(a0: string): Field;
            getField(a0: string, a1: Type, a2: boolean): Field;
            getField(a0: string, a1: Type): Field;
            getFields(): java.util.Iterator;
            getJBooleanField(a0: string): JBooleanField;
            getJByteField(a0: string): JByteField;
            getJCharField(a0: string): JCharField;
            getJDoubleField(a0: string): JDoubleField;
            getJFloatField(a0: string): JFloatField;
            getJIntField(a0: string): JIntField;
            getJLongField(a0: string): JLongField;
            getJShortField(a0: string): JShortField;
            getName(): string;
            getNarrowOopField(a0: string): NarrowOopField;
            getOopField(a0: string): OopField;
            getSize(): long;
            getSuperclass(): Type;
            isCIntegerType(): boolean;
            isCStringType(): boolean;
            isJavaPrimitiveType(): boolean;
            isOopType(): boolean;
            isPointerType(): boolean;
          }
          interface Type extends CombineTypes<[_Type, java.lang.Object]> {}
          interface _TypeDataBase$$static extends ClassLike {
          }
          let TypeDataBase: _TypeDataBase$$static;
          interface _TypeDataBase {
            addressTypeIsEqualToType(a0: hotspot.debugger.Address, a1: Type): boolean;
            findDynamicTypeForAddress(a0: hotspot.debugger.Address, a1: Type): Type;
            getAddressSize(): long;
            getIntConstants(): java.util.Iterator;
            getJBooleanType(): Type;
            getJByteType(): Type;
            getJCharType(): Type;
            getJDoubleType(): Type;
            getJFloatType(): Type;
            getJIntType(): Type;
            getJLongType(): Type;
            getJShortType(): Type;
            getLongConstants(): java.util.Iterator;
            getOopSize(): long;
            getTypes(): java.util.Iterator;
            guessTypeForAddress(a0: hotspot.debugger.Address): Type;
            lookupIntConstant(a0: string): int;
            lookupIntConstant(a0: string, a1: boolean): int;
            lookupLongConstant(a0: string): long;
            lookupLongConstant(a0: string, a1: boolean): long;
            lookupType(a0: string): Type;
            lookupType(a0: string, a1: boolean): Type;
          }
          interface TypeDataBase extends CombineTypes<[_TypeDataBase, java.lang.Object]> {}
          interface _WrongTypeException$$static extends ClassLike {
            new(): WrongTypeException;
            new(detail: string): WrongTypeException;
          }
          let WrongTypeException: _WrongTypeException$$static;
          interface _WrongTypeException {
          }
          interface WrongTypeException extends CombineTypes<[_WrongTypeException, java.lang.RuntimeException]> {}
        }
        module ui {
          module action {
            interface _FindAction$$static extends ClassLike {
              readonly VALUE_COMMAND: string;
              readonly VALUE_LONG_DESCRIPTION: string;
              readonly VALUE_MNEMONIC: int;
              readonly VALUE_NAME: string;
              readonly VALUE_SHORT_DESCRIPTION: string;
              readonly VALUE_SMALL_ICON: string;
              new(): FindAction;
            }
            let FindAction: _FindAction$$static;
            interface _FindAction {
            }
            interface FindAction extends CombineTypes<[_FindAction, com.sun.java.swing.action.DelegateAction]> {}
            interface _FindClassesAction$$static extends ClassLike {
              readonly VALUE_COMMAND: string;
              readonly VALUE_LONG_DESCRIPTION: string;
              readonly VALUE_MNEMONIC: int;
              readonly VALUE_NAME: string;
              readonly VALUE_SHORT_DESCRIPTION: string;
              readonly VALUE_SMALL_ICON: string;
              new(): FindClassesAction;
            }
            let FindClassesAction: _FindClassesAction$$static;
            interface _FindClassesAction {
            }
            interface FindClassesAction extends CombineTypes<[_FindClassesAction, com.sun.java.swing.action.DelegateAction]> {}
            interface _FindCrashesAction$$static extends ClassLike {
              readonly VALUE_COMMAND: string;
              readonly VALUE_LARGE_ICON: string;
              readonly VALUE_LONG_DESCRIPTION: string;
              readonly VALUE_MNEMONIC: int;
              readonly VALUE_NAME: string;
              readonly VALUE_SHORT_DESCRIPTION: string;
              readonly VALUE_SMALL_ICON: string;
              new(): FindCrashesAction;
            }
            let FindCrashesAction: _FindCrashesAction$$static;
            interface _FindCrashesAction {
            }
            interface FindCrashesAction extends CombineTypes<[_FindCrashesAction, com.sun.java.swing.action.DelegateAction]> {}
            interface _HSDBActionManager$$static extends ClassLike {
              getInstance(): com.sun.java.swing.action.ActionManager;
              new(): HSDBActionManager;
            }
            let HSDBActionManager: _HSDBActionManager$$static;
            interface _HSDBActionManager {
              _addActions(): void;
            }
            interface HSDBActionManager extends CombineTypes<[_HSDBActionManager, com.sun.java.swing.action.ActionManager]> {}
            interface _InspectAction$$static extends ClassLike {
              readonly VALUE_COMMAND: string;
              readonly VALUE_LARGE_ICON: string;
              readonly VALUE_LONG_DESCRIPTION: string;
              readonly VALUE_MNEMONIC: int;
              readonly VALUE_NAME: string;
              readonly VALUE_SHORT_DESCRIPTION: string;
              readonly VALUE_SMALL_ICON: string;
              new(): InspectAction;
            }
            let InspectAction: _InspectAction$$static;
            interface _InspectAction {
            }
            interface InspectAction extends CombineTypes<[_InspectAction, com.sun.java.swing.action.DelegateAction]> {}
            interface _JavaStackTraceAction$$static extends ClassLike {
              readonly VALUE_COMMAND: string;
              readonly VALUE_LARGE_ICON: string;
              readonly VALUE_LONG_DESCRIPTION: string;
              readonly VALUE_MNEMONIC: int;
              readonly VALUE_NAME: string;
              readonly VALUE_SHORT_DESCRIPTION: string;
              readonly VALUE_SMALL_ICON: string;
              new(): JavaStackTraceAction;
            }
            let JavaStackTraceAction: _JavaStackTraceAction$$static;
            interface _JavaStackTraceAction {
            }
            interface JavaStackTraceAction extends CombineTypes<[_JavaStackTraceAction, com.sun.java.swing.action.DelegateAction]> {}
            interface _MemoryAction$$static extends ClassLike {
              readonly VALUE_COMMAND: string;
              readonly VALUE_LARGE_ICON: string;
              readonly VALUE_LONG_DESCRIPTION: string;
              readonly VALUE_MNEMONIC: int;
              readonly VALUE_NAME: string;
              readonly VALUE_SHORT_DESCRIPTION: string;
              readonly VALUE_SMALL_ICON: string;
              new(): MemoryAction;
            }
            let MemoryAction: _MemoryAction$$static;
            interface _MemoryAction {
            }
            interface MemoryAction extends CombineTypes<[_MemoryAction, com.sun.java.swing.action.DelegateAction]> {}
            interface _ShowAction$$static extends ClassLike {
              readonly VALUE_COMMAND: string;
              readonly VALUE_LONG_DESCRIPTION: string;
              readonly VALUE_MNEMONIC: int;
              readonly VALUE_NAME: string;
              readonly VALUE_SHORT_DESCRIPTION: string;
              readonly VALUE_SMALL_ICON: string;
              new(): ShowAction;
            }
            let ShowAction: _ShowAction$$static;
            interface _ShowAction {
            }
            interface ShowAction extends CombineTypes<[_ShowAction, com.sun.java.swing.action.DelegateAction]> {}
            interface _ThreadInfoAction$$static extends ClassLike {
              readonly VALUE_COMMAND: string;
              readonly VALUE_LARGE_ICON: string;
              readonly VALUE_LONG_DESCRIPTION: string;
              readonly VALUE_MNEMONIC: int;
              readonly VALUE_NAME: string;
              readonly VALUE_SHORT_DESCRIPTION: string;
              readonly VALUE_SMALL_ICON: string;
              new(): ThreadInfoAction;
            }
            let ThreadInfoAction: _ThreadInfoAction$$static;
            interface _ThreadInfoAction {
            }
            interface ThreadInfoAction extends CombineTypes<[_ThreadInfoAction, com.sun.java.swing.action.StateChangeAction]> {}
          }
          module classbrowser {
            interface _ClassBrowserPanel$$static extends ClassLike {
              new(): ClassBrowserPanel;
            }
            let ClassBrowserPanel: _ClassBrowserPanel$$static;
            interface _ClassBrowserPanel {
              actionPerformed(evt: java.awt.event.ActionEvent): void;
              _findClasses(): void;
              _registerAction(actionName: string): void;
              _registerActions(): void;
              setClassesText(text: string): void;
              setContentText(text: string): void;
              _classesEditor: SAEditorPane;
              _contentEditor: SAEditorPane;
              _htmlGen: HTMLGenerator;
              _splitPane: javax.swing.JSplitPane;
              _statusBar: com.sun.java.swing.ui.StatusBar;
              _toolBar: ClassBrowserPanel$ClassBrowserToolBar;
            }
            interface ClassBrowserPanel extends CombineTypes<[_ClassBrowserPanel, java.awt.event.ActionListener, javax.swing.JPanel]> {}
            interface _ClassBrowserPanel$ClassBrowserToolBar$$static extends ClassLike {
              new(a0: ClassBrowserPanel, status: com.sun.java.swing.ui.StatusBar): ClassBrowserPanel$ClassBrowserToolBar;
            }
            let ClassBrowserPanel$ClassBrowserToolBar: _ClassBrowserPanel$ClassBrowserToolBar$$static;
            interface _ClassBrowserPanel$ClassBrowserToolBar {
              _addComponents(): void;
              getFindText(): string;
              _searchTF: javax.swing.JTextField;
              _this$0: ClassBrowserPanel;
            }
            interface ClassBrowserPanel$ClassBrowserToolBar extends CombineTypes<[_ClassBrowserPanel$ClassBrowserToolBar, com.sun.java.swing.ui.CommonToolBar]> {}
            interface _CodeViewerPanel$$static extends ClassLike {
              new(): CodeViewerPanel;
            }
            let CodeViewerPanel: _CodeViewerPanel$$static;
            interface _CodeViewerPanel {
              _viewAddress(): void;
              viewAddress(addr: hotspot.debugger.Address): void;
              _address: HistoryComboBox;
              _contentEditor: SAEditorPane;
              _htmlGen: HTMLGenerator;
              _scrollPane: javax.swing.JScrollPane;
            }
            interface CodeViewerPanel extends CombineTypes<[_CodeViewerPanel, javax.swing.JPanel]> {}
            interface _HTMLGenerator$$static extends ClassLike {
              _DUMP_KLASS_OUTPUT_DIR: string;
              _NATIVE_CODE_SIZE: int;
              new(): HTMLGenerator;
              new(html: boolean): HTMLGenerator;
            }
            let HTMLGenerator: _HTMLGenerator$$static;
            interface _HTMLGenerator {
              _addressToLong(addr: hotspot.debugger.Address): long;
              _createBytecodeDisassembler(m: hotspot.oops.Method): hotspot.interpreter.BytecodeDisassembler;
              _createSymbolFinder(): hotspot.asm.SymbolFinder;
              _dumpKlass(kls: hotspot.oops.InstanceKlass): void;
              _escapeHTMLSpecialChars(value: string): string;
              _genBaseHref(): string;
              genCodeBlobTitle(blob: hotspot.code.CodeBlob): string;
              _genConstantPoolHref(cpool: hotspot.oops.ConstantPool): string;
              _genConstantPoolLink(cpool: hotspot.oops.ConstantPool): string;
              _genConstantPoolTitle(cpool: hotspot.oops.ConstantPool): string;
              genDumpKlass(kls: hotspot.oops.InstanceKlass): string;
              _genDumpKlassHref(klass: hotspot.oops.InstanceKlass): string;
              _genDumpKlassLink(klass: hotspot.oops.InstanceKlass): string;
              _genDumpKlassesHref(klasses: hotspot.oops.InstanceKlass[]): string;
              _genDumpKlassesLink(klasses: hotspot.oops.InstanceKlass[]): string;
              _genDumpKlassesTitle(klasses: hotspot.oops.InstanceKlass[]): string;
              _genFieldModifierString(acc: hotspot.oops.AccessFlags): string;
              genHTML(cpool: hotspot.oops.ConstantPool): string;
              genHTML(method: hotspot.oops.Method): string;
              genHTML(pc: hotspot.debugger.Address): string;
              genHTML(nmethod: hotspot.code.NMethod): string;
              genHTML(blob: hotspot.code.CodeBlob): string;
              genHTML(codelet: hotspot.interpreter.InterpreterCodelet): string;
              genHTML(klass: hotspot.oops.InstanceKlass): string;
              genHTMLErrorMessage(exp: java.lang.Exception): string;
              genHTMLForAddress(addrStr: string): string;
              _genHTMLForExpressions(sd: hotspot.code.ScopeDesc, expressions: java.util.List<hotspot.code.ScopeValue>): string;
              genHTMLForFieldNames(klass: hotspot.oops.InstanceKlass): string;
              genHTMLForHyperlink(href: string): string;
              genHTMLForJavaStackTrace(thread: hotspot.runtime.JavaThread): string;
              genHTMLForKlassHierarchy(klass: hotspot.oops.InstanceKlass): string;
              genHTMLForKlassNames(klasses: hotspot.oops.InstanceKlass[]): string;
              _genHTMLForLocals(sd: hotspot.code.ScopeDesc, locals: java.util.List<hotspot.code.ScopeValue>): string;
              genHTMLForMessage(message: string): string;
              genHTMLForMethodNames(klass: hotspot.oops.InstanceKlass): string;
              _genHTMLForMonitors(sd: hotspot.code.ScopeDesc, monitors: java.util.List<hotspot.code.MonitorValue>): string;
              _genHTMLForOopMap(map: hotspot.compiler.ImmutableOopMap): string;
              genHTMLForRawDisassembly(startPc: hotspot.debugger.Address, size: int): string;
              _genHTMLForRawDisassembly(startPc: hotspot.debugger.Address, prevPCs: string): string;
              _genHTMLForRawDisassembly(addr: hotspot.debugger.Address, size: int, prevPCs: string): string;
              _genHTMLForScopeValues(sd: hotspot.code.ScopeDesc, locals: boolean, values: java.util.List<hotspot.code.ScopeValue>): string;
              genHTMLForWait(message: string): string;
              _genHTMLListForFields(klass: hotspot.oops.InstanceKlass): string;
              _genHTMLListForInterfaces(klass: hotspot.oops.InstanceKlass): string;
              _genHTMLListForKlassNames(klasses: hotspot.oops.InstanceKlass[]): string;
              _genHTMLListForMethods(klass: hotspot.oops.InstanceKlass): string;
              _genHTMLListForSubKlasses(klass: hotspot.oops.InstanceKlass): string;
              _genHTMLTableForConstantPool(cpool: hotspot.oops.ConstantPool): string;
              _genInterpreterCodeletLinkPageHref(stubq: hotspot.code.StubQueue): string;
              genInterpreterCodeletLinksPage(): string;
              _genInterpreterCodeletTitle(codelet: hotspot.interpreter.InterpreterCodelet): string;
              _genJavaStackTraceTitle(thread: hotspot.runtime.JavaThread): string;
              _genKlassHierarchyHref(klass: hotspot.oops.InstanceKlass): string;
              _genKlassHierarchyLink(klass: hotspot.oops.InstanceKlass): string;
              _genKlassHierarchyTitle(klass: hotspot.oops.InstanceKlass): string;
              _genKlassHref(klass: hotspot.oops.InstanceKlass): string;
              _genKlassLink(klass: hotspot.oops.InstanceKlass): string;
              _genKlassTitle(klass: hotspot.oops.InstanceKlass): string;
              _genListOfShort(values: short[]): string;
              _genLowHighShort(val: int): string;
              _genMethodAndKlassLink(m: hotspot.oops.Method): string;
              _genMethodHref(m: hotspot.oops.Method): string;
              _genMethodLink(m: hotspot.oops.Method): string;
              _genMethodModifierString(acc: hotspot.oops.AccessFlags): string;
              _genMethodNameAndSignature(method: hotspot.oops.Method): string;
              _genMethodTitle(method: hotspot.oops.Method): string;
              _genMultPCHref(pcs: string): string;
              _genNMethodHref(nm: hotspot.code.NMethod): string;
              _genNMethodLink(nm: hotspot.code.NMethod): string;
              genNMethodTitle(nmethod: hotspot.code.NMethod): string;
              _genOopMapInfo(nmethod: hotspot.code.NMethod, pcDesc: hotspot.code.PCDesc): string;
              _genOopMapInfo(map: hotspot.compiler.ImmutableOopMap): string;
              _genPCHref(targetPc: long): string;
              _genPCHref(addr: hotspot.debugger.Address): string;
              _genSafepointInfo(nm: hotspot.code.NMethod, sd: hotspot.code.ScopeDesc): string;
              _genScObjInfo(buf: HTMLGenerator$Formatter, tabs: HTMLGenerator$Formatter, sd: hotspot.code.ScopeDesc): void;
              _genScope(buf: HTMLGenerator$Formatter, tabs: HTMLGenerator$Formatter, sd: hotspot.code.ScopeDesc): void;
              _getConstantPoolAtAddress(address: string): hotspot.oops.ConstantPool;
              _getKlassAtAddress(address: string): hotspot.oops.Klass;
              _getMethodAtAddress(address: string): hotspot.oops.Method;
              _getOopAtAddress(addr: hotspot.debugger.Address): hotspot.oops.Oop;
              _getOopAtAddress(address: string): hotspot.oops.Oop;
              _locationAsString(loc: hotspot.code.Location): string;
              _longToAddress(addr: long): hotspot.debugger.Address;
              _parseAddress(address: string): hotspot.debugger.Address;
              _scopeValueAsString(sd: hotspot.code.ScopeDesc, sv: hotspot.code.ScopeValue): string;
              _genHTML: boolean;
              _spaces: string;
              _tab: string;
            }
            interface HTMLGenerator extends CombineTypes<[_HTMLGenerator, sun.jvm.hotspot.runtime.ClassConstants, java.lang.Object]> {}
            interface _HTMLGenerator$Formatter$$static extends ClassLike {
              _new(h: boolean): HTMLGenerator$Formatter;
            }
            let HTMLGenerator$Formatter: _HTMLGenerator$Formatter$$static;
            interface _HTMLGenerator$Formatter {
              _append(s: string): void;
              _append(s: int): void;
              _append(s: char): void;
              _append(s: HTMLGenerator$Formatter$stringBuffer): void;
              _append(s: HTMLGenerator$Formatter): void;
              _beginList(): void;
              _beginListItem(): void;
              _beginTable(border: int): void;
              _beginTag(s: string): void;
              _bold(s: string): void;
              _br(): void;
              _cell(s: string): void;
              _endList(): void;
              _endListItem(): void;
              _endTable(): void;
              _endTag(s: string): void;
              _genEmptyHTML(): void;
              _genHTMLEpilogue(): void;
              _genHTMLPrologue(): void;
              _genHTMLPrologue(title: string): void;
              _getBuffer(): HTMLGenerator$Formatter$stringBuffer;
              _h1(s: string): void;
              _h2(s: string): void;
              _h3(s: string): void;
              _h4(s: string): void;
              _headerCell(s: string): void;
              _li(s: string): void;
              _link(href: string, text: string): void;
              _nl(): void;
              toString(): string;
              _wrap(tag: string, text: string): void;
              _wrap(before: string, after: string, text: string): void;
              _buf: classbrowser$stringBuffer;
              _html: boolean;
            }
            interface HTMLGenerator$Formatter extends CombineTypes<[_HTMLGenerator$Formatter, java.lang.Object]> {}
            interface _HTMLGenerator$HTMLDisassembler$$static extends ClassLike {
              _new(this$0: HTMLGenerator, buf: HTMLGenerator$Formatter, blob: hotspot.code.CodeBlob): HTMLGenerator$HTMLDisassembler;
            }
            let HTMLGenerator$HTMLDisassembler: _HTMLGenerator$HTMLDisassembler$$static;
            interface _HTMLGenerator$HTMLDisassembler {
              beginInstruction(currentPc: long): void;
              endInstruction(endPc: long): void;
              epilogue(): void;
              getInstructionSize(): int;
              print(s: string): void;
              printAddress(address: long): void;
              prologue(): void;
              _blob: hotspot.code.CodeBlob;
              _buf: HTMLGenerator$Formatter;
              _instrSize: int;
              _nmethod: hotspot.code.NMethod;
              _oms: hotspot.compiler.ImmutableOopMapSet;
              _pc: long;
              _symFinder: hotspot.asm.SymbolFinder;
              _this$0: HTMLGenerator;
            }
            interface HTMLGenerator$HTMLDisassembler extends CombineTypes<[_HTMLGenerator$HTMLDisassembler, sun.jvm.hotspot.asm.InstructionVisitor, java.lang.Object]> {}
          }
          module table {
            interface _LongCellRenderer$$static extends ClassLike {
              new(): LongCellRenderer;
            }
            let LongCellRenderer: _LongCellRenderer$$static;
            interface _LongCellRenderer {
              getTableCellRendererComponent(table: javax.swing.JTable, value: any, isSelected: boolean, hasFocus: boolean, row: int, column: int): java.awt.Component;
              _textField: javax.swing.JFormattedTextField;
            }
            interface LongCellRenderer extends CombineTypes<[_LongCellRenderer, javax.swing.table.DefaultTableCellRenderer]> {}
            interface _SortHeaderCellRenderer$$static extends ClassLike {
              new(header: javax.swing.table.JTableHeader, model: SortableTableModel): SortHeaderCellRenderer;
            }
            let SortHeaderCellRenderer: _SortHeaderCellRenderer$$static;
            interface _SortHeaderCellRenderer {
              getIcon(name: string): javax.swing.ImageIcon;
              getTableCellRendererComponent(table: javax.swing.JTable, value: any, isSelected: boolean, hasFocus: boolean, row: int, column: int): java.awt.Component;
              _ascendingIcon: javax.swing.Icon;
              _descendingIcon: javax.swing.Icon;
              _model: SortableTableModel;
            }
            interface SortHeaderCellRenderer extends CombineTypes<[_SortHeaderCellRenderer, javax.swing.table.DefaultTableCellRenderer]> {}
            interface _SortHeaderMouseAdapter$$static extends ClassLike {
              new(table: javax.swing.JTable, model: SortableTableModel): SortHeaderMouseAdapter;
            }
            let SortHeaderMouseAdapter: _SortHeaderMouseAdapter$$static;
            interface _SortHeaderMouseAdapter {
              mouseClicked(evt: java.awt.event.MouseEvent): void;
              _model: SortableTableModel;
              _table: javax.swing.JTable;
            }
            interface SortHeaderMouseAdapter extends CombineTypes<[_SortHeaderMouseAdapter, java.awt.event.MouseAdapter]> {}
            interface _SortableTableModel$$static<T> extends ClassLike {
              new(): SortableTableModel<T>;
            }
            let SortableTableModel: _SortableTableModel$$static<T>;
            interface _SortableTableModel<T> {
              getColumn(): int;
              isAscending(): boolean;
              setComparator(comparator: TableModelComparator): void;
              sortByColumn(column: int, ascending: boolean): void;
              _comparator: TableModelComparator;
              _elements: java.util.List<T>;
            }
            interface SortableTableModel<T> extends CombineTypes<[_SortableTableModel<T>, javax.swing.table.AbstractTableModel]> {}
            interface _TableModelComparator$$static extends ClassLike {
              new(model: javax.swing.table.TableModel): TableModelComparator;
            }
            let TableModelComparator: _TableModelComparator$$static;
            interface _TableModelComparator {
              addColumn(column: int): void;
              compare(row1: any, row2: any): int;
              getColumn(): int;
              getValueForColumn(a0: any, a1: int): java.lang.Comparable<any>;
(a0: any, a1: int): java.lang.Comparable<any>;
              isAscending(): boolean;
              setAscending(ascending: boolean): void;
              _ascending: boolean;
              _columns: int[];
              _model: javax.swing.table.TableModel;
            }
            interface TableModelComparator extends CombineTypes<[_TableModelComparator, java.util.Comparator<any>, java.lang.Object]> {}
          }
          module tree {
            interface _BadAddressTreeNodeAdapter$$static extends ClassLike {
              _generateMessage(addr: long, a1: string): string;
              new(addr: hotspot.debugger.Address, field: hotspot.oops.MetadataField, treeTableMode: boolean): BadAddressTreeNodeAdapter;
              new(addr: hotspot.debugger.Address, field: hotspot.oops.OopField, treeTableMode: boolean): BadAddressTreeNodeAdapter;
              new(addr: hotspot.debugger.OopHandle, id: hotspot.oops.FieldIdentifier, treeTableMode: boolean): BadAddressTreeNodeAdapter;
              new(addr: long, a1: hotspot.oops.FieldIdentifier, id: boolean): BadAddressTreeNodeAdapter;
            }
            let BadAddressTreeNodeAdapter: _BadAddressTreeNodeAdapter$$static;
            interface _BadAddressTreeNodeAdapter {
              getChild(index: int): SimpleTreeNode;
              getChildCount(): int;
              getIndexOfChild(child: SimpleTreeNode): int;
              getValue(): string;
              isLeaf(): boolean;
              _message: string;
            }
            interface BadAddressTreeNodeAdapter extends CombineTypes<[_BadAddressTreeNodeAdapter, sun.jvm.hotspot.ui.tree.FieldTreeNodeAdapter]> {}
            interface _BooleanTreeNodeAdapter$$static extends ClassLike {
              new(val: boolean, id: hotspot.oops.FieldIdentifier): BooleanTreeNodeAdapter;
              new(val: boolean, id: hotspot.oops.FieldIdentifier, treeTableMode: boolean): BooleanTreeNodeAdapter;
            }
            let BooleanTreeNodeAdapter: _BooleanTreeNodeAdapter$$static;
            interface _BooleanTreeNodeAdapter {
              getChild(index: int): SimpleTreeNode;
              getChildCount(): int;
              getIndexOfChild(child: SimpleTreeNode): int;
              getValue(): string;
              isLeaf(): boolean;
              _val: boolean;
            }
            interface BooleanTreeNodeAdapter extends CombineTypes<[_BooleanTreeNodeAdapter, sun.jvm.hotspot.ui.tree.FieldTreeNodeAdapter]> {}
            interface _CStringTreeNodeAdapter$$static extends ClassLike {
              new(val: string, id: hotspot.oops.FieldIdentifier): CStringTreeNodeAdapter;
              new(val: string, id: hotspot.oops.FieldIdentifier, treeTableMode: boolean): CStringTreeNodeAdapter;
            }
            let CStringTreeNodeAdapter: _CStringTreeNodeAdapter$$static;
            interface _CStringTreeNodeAdapter {
              getChild(index: int): SimpleTreeNode;
              getChildCount(): int;
              getIndexOfChild(child: SimpleTreeNode): int;
              getValue(): string;
              isLeaf(): boolean;
              _val: string;
            }
            interface CStringTreeNodeAdapter extends CombineTypes<[_CStringTreeNodeAdapter, sun.jvm.hotspot.ui.tree.FieldTreeNodeAdapter]> {}
            interface _CTypeTreeNodeAdapter$$static extends ClassLike {
              new(a: hotspot.debugger.Address, t: hotspot.types.Type, id: hotspot.oops.FieldIdentifier): CTypeTreeNodeAdapter;
              new(a: hotspot.debugger.Address, t: hotspot.types.Type, id: hotspot.oops.FieldIdentifier, treeTableMode: boolean): CTypeTreeNodeAdapter;
              new(t: hotspot.types.Type): CTypeTreeNodeAdapter;
              new(types: java.util.Iterator): CTypeTreeNodeAdapter;
            }
            let CTypeTreeNodeAdapter: _CTypeTreeNodeAdapter$$static;
            interface _CTypeTreeNodeAdapter {
              _collectFields(type: hotspot.types.Type, list: java.util.ArrayList<CTypeTreeNodeAdapter$CTypeFieldIdentifier>, statics: boolean, recurse: boolean): void;
              getChild(index: int): SimpleTreeNode;
              getChildCount(): int;
              _getFields(): CTypeTreeNodeAdapter$CTypeFieldIdentifier[];
              getIndexOfChild(child: SimpleTreeNode): int;
              getValue(): string;
              isLeaf(): boolean;
              _addr: hotspot.debugger.Address;
              _fields: CTypeTreeNodeAdapter$CTypeFieldIdentifier[];
              _type: hotspot.types.Type;
            }
            interface CTypeTreeNodeAdapter extends CombineTypes<[_CTypeTreeNodeAdapter, sun.jvm.hotspot.ui.tree.FieldTreeNodeAdapter]> {}
            interface _CTypeTreeNodeAdapter$CTypeFieldIdentifier$$static extends ClassLike {
              _new(t: hotspot.types.Type, f: hotspot.types.Field): CTypeTreeNodeAdapter$CTypeFieldIdentifier;
            }
            let CTypeTreeNodeAdapter$CTypeFieldIdentifier: _CTypeTreeNodeAdapter$CTypeFieldIdentifier$$static;
            interface _CTypeTreeNodeAdapter$CTypeFieldIdentifier {
              getField(): hotspot.types.Field;
              getName(): string;
              _field: hotspot.types.Field;
              _holder: hotspot.types.Type;
            }
            interface CTypeTreeNodeAdapter$CTypeFieldIdentifier extends CombineTypes<[_CTypeTreeNodeAdapter$CTypeFieldIdentifier, sun.jvm.hotspot.oops.FieldIdentifier]> {}
            interface _CharTreeNodeAdapter$$static extends ClassLike {
              new(val: char, id: hotspot.oops.FieldIdentifier): CharTreeNodeAdapter;
              new(val: char, id: hotspot.oops.FieldIdentifier, treeTableMode: boolean): CharTreeNodeAdapter;
            }
            let CharTreeNodeAdapter: _CharTreeNodeAdapter$$static;
            interface _CharTreeNodeAdapter {
              getChild(index: int): SimpleTreeNode;
              getChildCount(): int;
              getIndexOfChild(child: SimpleTreeNode): int;
              getValue(): string;
              isLeaf(): boolean;
              _val: char;
            }
            interface CharTreeNodeAdapter extends CombineTypes<[_CharTreeNodeAdapter, sun.jvm.hotspot.ui.tree.FieldTreeNodeAdapter]> {}
            interface _DoubleTreeNodeAdapter$$static extends ClassLike {
              new(val: double, a1: hotspot.oops.FieldIdentifier): DoubleTreeNodeAdapter;
              new(val: double, a1: hotspot.oops.FieldIdentifier, id: boolean): DoubleTreeNodeAdapter;
            }
            let DoubleTreeNodeAdapter: _DoubleTreeNodeAdapter$$static;
            interface _DoubleTreeNodeAdapter {
              getChild(index: int): SimpleTreeNode;
              getChildCount(): int;
              getIndexOfChild(child: SimpleTreeNode): int;
              getValue(): string;
              isLeaf(): boolean;
              _val: double;
            }
            interface DoubleTreeNodeAdapter extends CombineTypes<[_DoubleTreeNodeAdapter, sun.jvm.hotspot.ui.tree.FieldTreeNodeAdapter]> {}
            interface _FieldTreeNodeAdapter$$static extends ClassLike {
              new(id: hotspot.oops.FieldIdentifier, treeTableMode: boolean): FieldTreeNodeAdapter;
            }
            let FieldTreeNodeAdapter: _FieldTreeNodeAdapter$$static;
            interface _FieldTreeNodeAdapter {
              getID(): hotspot.oops.FieldIdentifier;
              getName(): string;
              getTreeTableMode(): boolean;
              toString(): string;
              _id: hotspot.oops.FieldIdentifier;
              _treeTableMode: boolean;
            }
            interface FieldTreeNodeAdapter extends CombineTypes<[_FieldTreeNodeAdapter, sun.jvm.hotspot.ui.tree.SimpleTreeNode, java.lang.Object]> {}
            interface _FloatTreeNodeAdapter$$static extends ClassLike {
              new(val: float, id: hotspot.oops.FieldIdentifier): FloatTreeNodeAdapter;
              new(val: float, id: hotspot.oops.FieldIdentifier, treeTableMode: boolean): FloatTreeNodeAdapter;
            }
            let FloatTreeNodeAdapter: _FloatTreeNodeAdapter$$static;
            interface _FloatTreeNodeAdapter {
              getChild(index: int): SimpleTreeNode;
              getChildCount(): int;
              getIndexOfChild(child: SimpleTreeNode): int;
              getValue(): string;
              isLeaf(): boolean;
              _val: float;
            }
            interface FloatTreeNodeAdapter extends CombineTypes<[_FloatTreeNodeAdapter, sun.jvm.hotspot.ui.tree.FieldTreeNodeAdapter]> {}
            interface _LongTreeNodeAdapter$$static extends ClassLike {
              new(val: long, a1: hotspot.oops.FieldIdentifier): LongTreeNodeAdapter;
              new(val: long, a1: hotspot.oops.FieldIdentifier, id: boolean): LongTreeNodeAdapter;
            }
            let LongTreeNodeAdapter: _LongTreeNodeAdapter$$static;
            interface _LongTreeNodeAdapter {
              getChild(index: int): SimpleTreeNode;
              getChildCount(): int;
              getHexFormat(): boolean;
              getIndexOfChild(child: SimpleTreeNode): int;
              getValue(): string;
              isLeaf(): boolean;
              setHexFormat(hexFormat: boolean): void;
              _hexFormat: boolean;
              _val: long;
            }
            interface LongTreeNodeAdapter extends CombineTypes<[_LongTreeNodeAdapter, sun.jvm.hotspot.ui.tree.FieldTreeNodeAdapter]> {}
            interface _MetadataTreeNodeAdapter$$static extends ClassLike {
              new(metadata: hotspot.oops.Metadata, id: hotspot.oops.FieldIdentifier): MetadataTreeNodeAdapter;
              new(metadata: hotspot.oops.Metadata, id: hotspot.oops.FieldIdentifier, treeTableMode: boolean): MetadataTreeNodeAdapter;
            }
            let MetadataTreeNodeAdapter: _MetadataTreeNodeAdapter$$static;
            interface _MetadataTreeNodeAdapter {
              getChild(index: int): SimpleTreeNode;
              getChildCount(): int;
              getIndexOfChild(child: SimpleTreeNode): int;
              getMetadata(): hotspot.oops.Metadata;
              getValue(): string;
              isLeaf(): boolean;
              _metadata: hotspot.oops.Metadata;
            }
            interface MetadataTreeNodeAdapter extends CombineTypes<[_MetadataTreeNodeAdapter, sun.jvm.hotspot.ui.tree.FieldTreeNodeAdapter]> {}
            interface _MetadataTreeNodeAdapter$Counter$$static extends ClassLike {
              _new(): MetadataTreeNodeAdapter$Counter;
            }
            let MetadataTreeNodeAdapter$Counter: _MetadataTreeNodeAdapter$Counter$$static;
            interface _MetadataTreeNodeAdapter$Counter {
              doBoolean(field: hotspot.oops.BooleanField, isVMField: boolean): void;
              doByte(field: hotspot.oops.ByteField, isVMField: boolean): void;
              doCInt(field: hotspot.oops.CIntField, isVMField: boolean): void;
              doChar(field: hotspot.oops.CharField, isVMField: boolean): void;
              doDouble(field: hotspot.oops.DoubleField, isVMField: boolean): void;
              doFloat(field: hotspot.oops.FloatField, isVMField: boolean): void;
              doInt(field: hotspot.oops.IntField, isVMField: boolean): void;
              doLong(field: hotspot.oops.LongField, isVMField: boolean): void;
              doMetadata(field: hotspot.oops.MetadataField, isVMField: boolean): void;
              doOop(field: hotspot.oops.OopField, isVMField: boolean): void;
              doShort(field: hotspot.oops.ShortField, isVMField: boolean): void;
              getNumFields(): int;
              prologue(): void;
              _numFields: int;
            }
            interface MetadataTreeNodeAdapter$Counter extends CombineTypes<[_MetadataTreeNodeAdapter$Counter, sun.jvm.hotspot.oops.DefaultMetadataVisitor]> {}
            interface _MetadataTreeNodeAdapter$Fetcher$$static extends ClassLike {
              new(this$0: MetadataTreeNodeAdapter, index: int): MetadataTreeNodeAdapter$Fetcher;
            }
            let MetadataTreeNodeAdapter$Fetcher: _MetadataTreeNodeAdapter$Fetcher$$static;
            interface _MetadataTreeNodeAdapter$Fetcher {
              doBoolean(field: hotspot.oops.BooleanField, isVMField: boolean): void;
              doByte(field: hotspot.oops.ByteField, isVMField: boolean): void;
              doCInt(field: hotspot.oops.CIntField, isVMField: boolean): void;
              doChar(field: hotspot.oops.CharField, isVMField: boolean): void;
              doDouble(field: hotspot.oops.DoubleField, isVMField: boolean): void;
              doFloat(field: hotspot.oops.FloatField, isVMField: boolean): void;
              doInt(field: hotspot.oops.IntField, isVMField: boolean): void;
              doLong(field: hotspot.oops.LongField, isVMField: boolean): void;
              doMetadata(field: hotspot.oops.MetadataField, isVMField: boolean): void;
              doOop(field: hotspot.oops.OopField, isVMField: boolean): void;
              doShort(field: hotspot.oops.ShortField, isVMField: boolean): void;
              getChild(): SimpleTreeNode;
              prologue(): void;
              _child: SimpleTreeNode;
              _curField: int;
              _index: int;
              _this$0: MetadataTreeNodeAdapter;
            }
            interface MetadataTreeNodeAdapter$Fetcher extends CombineTypes<[_MetadataTreeNodeAdapter$Fetcher, sun.jvm.hotspot.oops.DefaultMetadataVisitor]> {}
            interface _MetadataTreeNodeAdapter$Finder$$static extends ClassLike {
              new(id: hotspot.oops.FieldIdentifier): MetadataTreeNodeAdapter$Finder;
            }
            let MetadataTreeNodeAdapter$Finder: _MetadataTreeNodeAdapter$Finder$$static;
            interface _MetadataTreeNodeAdapter$Finder {
              doBoolean(field: hotspot.oops.BooleanField, isVMField: boolean): void;
              doByte(field: hotspot.oops.ByteField, isVMField: boolean): void;
              doCInt(field: hotspot.oops.CIntField, isVMField: boolean): void;
              doChar(field: hotspot.oops.CharField, isVMField: boolean): void;
              doDouble(field: hotspot.oops.DoubleField, isVMField: boolean): void;
              doFloat(field: hotspot.oops.FloatField, isVMField: boolean): void;
              doInt(field: hotspot.oops.IntField, isVMField: boolean): void;
              doLong(field: hotspot.oops.LongField, isVMField: boolean): void;
              doMetadata(field: hotspot.oops.MetadataField, isVMField: boolean): void;
              doOop(field: hotspot.oops.OopField, isVMField: boolean): void;
              doShort(field: hotspot.oops.ShortField, isVMField: boolean): void;
              getIndex(): int;
              prologue(): void;
              _curField: int;
              _id: hotspot.oops.FieldIdentifier;
              _index: int;
            }
            interface MetadataTreeNodeAdapter$Finder extends CombineTypes<[_MetadataTreeNodeAdapter$Finder, sun.jvm.hotspot.oops.DefaultMetadataVisitor]> {}
            interface _OopTreeNodeAdapter$$static extends ClassLike {
              new(oop: hotspot.oops.Oop, id: hotspot.oops.FieldIdentifier): OopTreeNodeAdapter;
              new(oop: hotspot.oops.Oop, id: hotspot.oops.FieldIdentifier, treeTableMode: boolean): OopTreeNodeAdapter;
            }
            let OopTreeNodeAdapter: _OopTreeNodeAdapter$$static;
            interface _OopTreeNodeAdapter {
              getChild(index: int): SimpleTreeNode;
              getChildCount(): int;
              getIndexOfChild(child: SimpleTreeNode): int;
              getOop(): hotspot.oops.Oop;
              getValue(): string;
              isLeaf(): boolean;
              _oop: hotspot.oops.Oop;
            }
            interface OopTreeNodeAdapter extends CombineTypes<[_OopTreeNodeAdapter, sun.jvm.hotspot.ui.tree.FieldTreeNodeAdapter]> {}
            interface _OopTreeNodeAdapter$Counter$$static extends ClassLike {
              _new(): OopTreeNodeAdapter$Counter;
            }
            let OopTreeNodeAdapter$Counter: _OopTreeNodeAdapter$Counter$$static;
            interface _OopTreeNodeAdapter$Counter {
              doBoolean(field: hotspot.oops.BooleanField, isVMField: boolean): void;
              doByte(field: hotspot.oops.ByteField, isVMField: boolean): void;
              doCInt(field: hotspot.oops.CIntField, isVMField: boolean): void;
              doChar(field: hotspot.oops.CharField, isVMField: boolean): void;
              doDouble(field: hotspot.oops.DoubleField, isVMField: boolean): void;
              doFloat(field: hotspot.oops.FloatField, isVMField: boolean): void;
              doInt(field: hotspot.oops.IntField, isVMField: boolean): void;
              doLong(field: hotspot.oops.LongField, isVMField: boolean): void;
              doMetadata(field: hotspot.oops.MetadataField, isVMField: boolean): void;
              doOop(field: hotspot.oops.OopField, isVMField: boolean): void;
              doShort(field: hotspot.oops.ShortField, isVMField: boolean): void;
              getNumFields(): int;
              prologue(): void;
              _numFields: int;
            }
            interface OopTreeNodeAdapter$Counter extends CombineTypes<[_OopTreeNodeAdapter$Counter, sun.jvm.hotspot.oops.DefaultOopVisitor]> {}
            interface _OopTreeNodeAdapter$Fetcher$$static extends ClassLike {
              new(this$0: OopTreeNodeAdapter, index: int): OopTreeNodeAdapter$Fetcher;
            }
            let OopTreeNodeAdapter$Fetcher: _OopTreeNodeAdapter$Fetcher$$static;
            interface _OopTreeNodeAdapter$Fetcher {
              doBoolean(field: hotspot.oops.BooleanField, isVMField: boolean): void;
              doByte(field: hotspot.oops.ByteField, isVMField: boolean): void;
              doCInt(field: hotspot.oops.CIntField, isVMField: boolean): void;
              doChar(field: hotspot.oops.CharField, isVMField: boolean): void;
              doDouble(field: hotspot.oops.DoubleField, isVMField: boolean): void;
              doFloat(field: hotspot.oops.FloatField, isVMField: boolean): void;
              doInt(field: hotspot.oops.IntField, isVMField: boolean): void;
              doLong(field: hotspot.oops.LongField, isVMField: boolean): void;
              doMetadata(field: hotspot.oops.MetadataField, isVMField: boolean): void;
              doOop(field: hotspot.oops.OopField, isVMField: boolean): void;
              doShort(field: hotspot.oops.ShortField, isVMField: boolean): void;
              getChild(): SimpleTreeNode;
              prologue(): void;
              _child: SimpleTreeNode;
              _curField: int;
              _index: int;
              _this$0: OopTreeNodeAdapter;
            }
            interface OopTreeNodeAdapter$Fetcher extends CombineTypes<[_OopTreeNodeAdapter$Fetcher, sun.jvm.hotspot.oops.DefaultOopVisitor]> {}
            interface _OopTreeNodeAdapter$Finder$$static extends ClassLike {
              new(id: hotspot.oops.FieldIdentifier): OopTreeNodeAdapter$Finder;
            }
            let OopTreeNodeAdapter$Finder: _OopTreeNodeAdapter$Finder$$static;
            interface _OopTreeNodeAdapter$Finder {
              doBoolean(field: hotspot.oops.BooleanField, isVMField: boolean): void;
              doByte(field: hotspot.oops.ByteField, isVMField: boolean): void;
              doCInt(field: hotspot.oops.CIntField, isVMField: boolean): void;
              doChar(field: hotspot.oops.CharField, isVMField: boolean): void;
              doDouble(field: hotspot.oops.DoubleField, isVMField: boolean): void;
              doFloat(field: hotspot.oops.FloatField, isVMField: boolean): void;
              doInt(field: hotspot.oops.IntField, isVMField: boolean): void;
              doLong(field: hotspot.oops.LongField, isVMField: boolean): void;
              doOop(field: hotspot.oops.OopField, isVMField: boolean): void;
              doShort(field: hotspot.oops.ShortField, isVMField: boolean): void;
              getIndex(): int;
              prologue(): void;
              _curField: int;
              _id: hotspot.oops.FieldIdentifier;
              _index: int;
            }
            interface OopTreeNodeAdapter$Finder extends CombineTypes<[_OopTreeNodeAdapter$Finder, sun.jvm.hotspot.oops.DefaultOopVisitor]> {}
            interface _RevPtrsTreeNodeAdapter$$static extends ClassLike {
              _fid: hotspot.oops.FieldIdentifier;
              new(oop: hotspot.oops.Oop): RevPtrsTreeNodeAdapter;
              new(oop: hotspot.oops.Oop, treeTableMode: boolean): RevPtrsTreeNodeAdapter;
            }
            let RevPtrsTreeNodeAdapter: _RevPtrsTreeNodeAdapter$$static;
            interface _RevPtrsTreeNodeAdapter {
              getChild(index: int): SimpleTreeNode;
              getChildCount(): int;
              getIndexOfChild(child: SimpleTreeNode): int;
              getName(): string;
              getValue(): string;
              isLeaf(): boolean;
              _children: java.util.List<hotspot.utilities.LivenessPathElement>;
            }
            interface RevPtrsTreeNodeAdapter extends CombineTypes<[_RevPtrsTreeNodeAdapter, sun.jvm.hotspot.ui.tree.FieldTreeNodeAdapter]> {}
            interface _RootTreeNodeAdapter$$static extends ClassLike {
              new(val: string, id: hotspot.oops.FieldIdentifier): RootTreeNodeAdapter;
              new(val: string, id: hotspot.oops.FieldIdentifier, treeTableMode: boolean): RootTreeNodeAdapter;
            }
            let RootTreeNodeAdapter: _RootTreeNodeAdapter$$static;
            interface _RootTreeNodeAdapter {
              getChild(index: int): SimpleTreeNode;
              getChildCount(): int;
              getIndexOfChild(child: SimpleTreeNode): int;
              getValue(): string;
              isLeaf(): boolean;
              _val: string;
            }
            interface RootTreeNodeAdapter extends CombineTypes<[_RootTreeNodeAdapter, sun.jvm.hotspot.ui.tree.FieldTreeNodeAdapter]> {}
            interface _SimpleTreeGroupNode$$static extends ClassLike {
              new(): SimpleTreeGroupNode;
            }
            let SimpleTreeGroupNode: _SimpleTreeGroupNode$$static;
            interface _SimpleTreeGroupNode {
              addChild(child: SimpleTreeNode): void;
              getChild(index: int): SimpleTreeNode;
              getChildCount(): int;
              getIndexOfChild(child: SimpleTreeNode): int;
              getName(): string;
              getValue(): string;
              isLeaf(): boolean;
              removeAllChildren(): void;
              removeChild(index: int): SimpleTreeNode;
              _children: java.util.List<SimpleTreeNode>;
            }
            interface SimpleTreeGroupNode extends CombineTypes<[_SimpleTreeGroupNode, sun.jvm.hotspot.ui.tree.SimpleTreeNode, java.lang.Object]> {}
            interface _SimpleTreeModel$$static extends ClassLike {
              _singletonNullRoot: SimpleTreeNode;
              new(): SimpleTreeModel;
            }
            let SimpleTreeModel: _SimpleTreeModel$$static;
            interface _SimpleTreeModel {
              addTreeModelListener(l: javax.swing.event.TreeModelListener): void;
              fireTreeStructureChanged(): void;
              getChild(parent: any, index: int): any;
              getChildCount(parent: any): int;
              getIndexOfChild(parent: any, child: any): int;
              getRoot(): any;
              isLeaf(node: any): boolean;
              removeTreeModelListener(l: javax.swing.event.TreeModelListener): void;
              setRoot(node: SimpleTreeNode): void;
              valueForPathChanged(path: javax.swing.tree.TreePath, newValue: any): void;
              _listeners: java.util.List<javax.swing.event.TreeModelListener>;
              _root: SimpleTreeNode;
            }
            interface SimpleTreeModel extends CombineTypes<[_SimpleTreeModel, javax.swing.tree.TreeModel, java.lang.Object]> {}
            interface _SimpleTreeNode$$static extends ClassLike {
            }
            let SimpleTreeNode: _SimpleTreeNode$$static;
            interface _SimpleTreeNode {
              getChild(a0: int): SimpleTreeNode;
              getChildCount(): int;
              getIndexOfChild(a0: SimpleTreeNode): int;
              getName(): string;
              getValue(): string;
              isLeaf(): boolean;
            }
            interface SimpleTreeNode extends CombineTypes<[_SimpleTreeNode, java.lang.Object]> {}
          }
          module treetable {
            interface _AbstractTreeTableModel$$static extends ClassLike {
              new(root: any): AbstractTreeTableModel;
            }
            let AbstractTreeTableModel: _AbstractTreeTableModel$$static;
            interface _AbstractTreeTableModel {
              addTreeModelListener(l: javax.swing.event.TreeModelListener): void;
              _fireTreeNodesChanged(source: any, path: any[], childIndices: int[], children: any[]): void;
              _fireTreeNodesInserted(source: any, path: any[], childIndices: int[], children: any[]): void;
              _fireTreeNodesRemoved(source: any, path: any[], childIndices: int[], children: any[]): void;
              _fireTreeStructureChanged(source: any, path: any[], childIndices: int[], children: any[]): void;
              getColumnClass(column: int): java.lang.Class;
              getIndexOfChild(parent: any, child: any): int;
              getRoot(): any;
              isCellEditable(node: any, column: int): boolean;
              isLeaf(node: any): boolean;
              removeTreeModelListener(l: javax.swing.event.TreeModelListener): void;
              setValueAt(aValue: any, node: any, column: int): void;
              valueForPathChanged(path: javax.swing.tree.TreePath, newValue: any): void;
              _listenerList: javax.swing.event.EventListenerList;
              _root: any;
            }
            interface AbstractTreeTableModel extends CombineTypes<[_AbstractTreeTableModel, sun.jvm.hotspot.ui.treetable.TreeTableModel, java.lang.Object]> {}
            interface _JTreeTable$$static extends ClassLike {
              new(treeTableModel: TreeTableModel): JTreeTable;
            }
            let JTreeTable: _JTreeTable$$static;
            interface _JTreeTable {
              editCellAt(row: int, column: int, e: java.util.EventObject): boolean;
              getEditingRow(): int;
              getShowsIcons(): boolean;
              getShowsRootHandles(): boolean;
              getTree(): javax.swing.JTree;
              getTreeEditable(): boolean;
              _realEditingRow(): int;
              setRootVisible(visible: boolean): void;
              setRowHeight(rowHeight: int): void;
              setShowsIcons(show: boolean): void;
              setShowsRootHandles(newValue: boolean): void;
              setTreeEditable(editable: boolean): void;
              sizeColumnsToFit(resizingColumn: int): void;
              updateUI(): void;
              _showsIcons: boolean;
              _tree: JTreeTable$TreeTableCellRenderer;
              _treeEditable: boolean;
            }
            interface JTreeTable extends CombineTypes<[_JTreeTable, javax.swing.JTable]> {}
            interface _JTreeTable$JTreeTableCellRenderer$$static extends ClassLike {
              _new(this$0: JTreeTable): JTreeTable$JTreeTableCellRenderer;
            }
            let JTreeTable$JTreeTableCellRenderer: _JTreeTable$JTreeTableCellRenderer$$static;
            interface _JTreeTable$JTreeTableCellRenderer {
              getClosedIcon(): javax.swing.Icon;
              getDefaultClosedIcon(): javax.swing.Icon;
              getDefaultLeafIcon(): javax.swing.Icon;
              getDefaultOpenIcon(): javax.swing.Icon;
              getLeafIcon(): javax.swing.Icon;
              getOpenIcon(): javax.swing.Icon;
              _this$0: JTreeTable;
            }
            interface JTreeTable$JTreeTableCellRenderer extends CombineTypes<[_JTreeTable$JTreeTableCellRenderer, javax.swing.tree.DefaultTreeCellRenderer]> {}
            interface _JTreeTable$ListToTreeSelectionModelWrapper$$static extends ClassLike {
              new(this$0: JTreeTable): JTreeTable$ListToTreeSelectionModelWrapper;
            }
            let JTreeTable$ListToTreeSelectionModelWrapper: _JTreeTable$ListToTreeSelectionModelWrapper$$static;
            interface _JTreeTable$ListToTreeSelectionModelWrapper {
              _createListSelectionListener(): javax.swing.event.ListSelectionListener;
              _getListSelectionModel(): javax.swing.ListSelectionModel;
              resetRowSelection(): void;
              _updateSelectedPathsFromSelectedRows(): void;
              _this$0: JTreeTable;
              _updatingListSelectionModel: boolean;
            }
            interface JTreeTable$ListToTreeSelectionModelWrapper extends CombineTypes<[_JTreeTable$ListToTreeSelectionModelWrapper, javax.swing.tree.DefaultTreeSelectionModel]> {}
            interface _JTreeTable$ListToTreeSelectionModelWrapper$ListSelectionHandler$$static extends ClassLike {
              _new(this$1: JTreeTable$ListToTreeSelectionModelWrapper): JTreeTable$ListToTreeSelectionModelWrapper$ListSelectionHandler;
            }
            let JTreeTable$ListToTreeSelectionModelWrapper$ListSelectionHandler: _JTreeTable$ListToTreeSelectionModelWrapper$ListSelectionHandler$$static;
            interface _JTreeTable$ListToTreeSelectionModelWrapper$ListSelectionHandler {
              valueChanged(e: javax.swing.event.ListSelectionEvent): void;
              _this$1: JTreeTable$ListToTreeSelectionModelWrapper;
            }
            interface JTreeTable$ListToTreeSelectionModelWrapper$ListSelectionHandler extends CombineTypes<[_JTreeTable$ListToTreeSelectionModelWrapper$ListSelectionHandler, java.lang.Object, javax.swing.event.ListSelectionListener]> {}
            interface _JTreeTable$TreeTableCellEditor$$static extends ClassLike {
              new(this$0: JTreeTable): JTreeTable$TreeTableCellEditor;
            }
            let JTreeTable$TreeTableCellEditor: _JTreeTable$TreeTableCellEditor$$static;
            interface _JTreeTable$TreeTableCellEditor {
              getTableCellEditorComponent(table: javax.swing.JTable, value: any, isSelected: boolean, r: int, c: int): java.awt.Component;
              isCellEditable(e: java.util.EventObject): boolean;
              _this$0: JTreeTable;
            }
            interface JTreeTable$TreeTableCellEditor extends CombineTypes<[_JTreeTable$TreeTableCellEditor, javax.swing.DefaultCellEditor]> {}
            interface _JTreeTable$TreeTableCellRenderer$$static extends ClassLike {
              new(this$0: JTreeTable, model: javax.swing.tree.TreeModel): JTreeTable$TreeTableCellRenderer;
            }
            let JTreeTable$TreeTableCellRenderer: _JTreeTable$TreeTableCellRenderer$$static;
            interface _JTreeTable$TreeTableCellRenderer {
              getTableCellRendererComponent(table: javax.swing.JTable, value: any, isSelected: boolean, hasFocus: boolean, row: int, column: int): java.awt.Component;
              paint(g: java.awt.Graphics): void;
              setBounds(x: int, y: int, w: int, h: int): void;
              setRowHeight(rowHeight: int): void;
              updateUI(): void;
              _highlightBorder: javax.swing.border.Border;
              _this$0: JTreeTable;
              _visibleRow: int;
            }
            interface JTreeTable$TreeTableCellRenderer extends CombineTypes<[_JTreeTable$TreeTableCellRenderer, javax.swing.JTree, javax.swing.table.TableCellRenderer]> {}
            interface _JTreeTable$TreeTableTextField$$static extends ClassLike {
              _new(): JTreeTable$TreeTableTextField;
            }
            let JTreeTable$TreeTableTextField: _JTreeTable$TreeTableTextField$$static;
            interface _JTreeTable$TreeTableTextField {
              setBounds(x: int, y: int, w: int, h: int): void;
              offset: int;
            }
            interface JTreeTable$TreeTableTextField extends CombineTypes<[_JTreeTable$TreeTableTextField, javax.swing.JTextField]> {}
            interface _SimpleTreeTableModel$$static extends ClassLike {
              new(): SimpleTreeTableModel;
            }
            let SimpleTreeTableModel: _SimpleTreeTableModel$$static;
            interface _SimpleTreeTableModel {
              getColumnClass(column: int): java.lang.Class;
              getColumnCount(): int;
              getColumnName(column: int): string;
              getValueAt(node: any, column: int): any;
              getValuesEditable(): boolean;
              isCellEditable(node: any, column: int): boolean;
              setValueAt(aValue: any, node: any, column: int): void;
              setValuesEditable(val: boolean): void;
              _valuesEditable: boolean;
            }
            interface SimpleTreeTableModel extends CombineTypes<[_SimpleTreeTableModel, sun.jvm.hotspot.ui.tree.SimpleTreeModel, sun.jvm.hotspot.ui.treetable.TreeTableModel]> {}
            interface _TreeTableModel$$static extends ClassLike {
            }
            let TreeTableModel: _TreeTableModel$$static;
            interface _TreeTableModel {
              getColumnClass(a0: int): java.lang.Class;
              getColumnCount(): int;
              getColumnName(a0: int): string;
              getValueAt(a0: any, a1: int): any;
              isCellEditable(a0: any, a1: int): boolean;
              setValueAt(a0: any, a1: any, a2: int): void;
            }
            interface TreeTableModel extends CombineTypes<[_TreeTableModel, javax.swing.tree.TreeModel, java.lang.Object]> {}
            interface _TreeTableModelAdapter$$static extends ClassLike {
              new(treeTableModel: TreeTableModel, tree: javax.swing.JTree): TreeTableModelAdapter;
            }
            let TreeTableModelAdapter: _TreeTableModelAdapter$$static;
            interface _TreeTableModelAdapter {
              _delayedFireTableDataChanged(): void;
              getColumnClass(column: int): java.lang.Class;
              getColumnCount(): int;
              getColumnName(column: int): string;
              getRowCount(): int;
              getValueAt(row: int, column: int): any;
              isCellEditable(row: int, column: int): boolean;
              _nodeForRow(row: int): any;
              setValueAt(value: any, row: int, column: int): void;
              _tree: javax.swing.JTree;
              _treeTableModel: TreeTableModel;
            }
            interface TreeTableModelAdapter extends CombineTypes<[_TreeTableModelAdapter, javax.swing.table.AbstractTableModel]> {}
          }
          interface _AnnotatedMemoryPanel$$static extends ClassLike {
            _defaultMemoryHigh(is64Bit: boolean): java.math.BigInteger;
            _defaultMemoryLocation(is64Bit: boolean): java.math.BigInteger;
            _defaultMemoryLow(is64Bit: boolean): java.math.BigInteger;
            main(args: string[]): void;
            _colors: java.awt.Color[];
            new(debugger: hotspot.debugger.Debugger): AnnotatedMemoryPanel;
            new(debugger: hotspot.debugger.Debugger, is64Bit: boolean, addrValue: hotspot.debugger.Address, addrLow: hotspot.debugger.Address, addrHigh: hotspot.debugger.Address): AnnotatedMemoryPanel;
            new(debugger: hotspot.debugger.Debugger, is64Bit: boolean): AnnotatedMemoryPanel;
          }
          let AnnotatedMemoryPanel: _AnnotatedMemoryPanel$$static;
          interface _AnnotatedMemoryPanel {
            addAnnotation(annotation: Annotation): void;
            _addressToBigInt(a: hotspot.debugger.Address): java.math.BigInteger;
            _addressToString(a: hotspot.debugger.Address): string;
            _bigIntToAddress(i: java.math.BigInteger): hotspot.debugger.Address;
            _bigIntToHexString(bi: java.math.BigInteger): string;
            _findColorIndex(c: java.awt.Color): int;
            _init(debugger: hotspot.debugger.Debugger, is64Bit: boolean, addrValue: java.math.BigInteger, addrLow: java.math.BigInteger, addrHigh: java.math.BigInteger): void;
            _layoutAfter(anno: Annotation, constraintAnno: Annotation, g: java.awt.Graphics, x: int, startAddr: hotspot.debugger.Address, lineHeight: int): void;
            _layoutAnnotations(va: java.util.List<hotspot.utilities.IntervalNode>, g: java.awt.Graphics, x: int, startAddr: hotspot.debugger.Address, lineHeight: int): void;
            _layoutBefore(anno: Annotation, constraintAnno: Annotation, g: java.awt.Graphics, x: int, startAddr: hotspot.debugger.Address, lineHeight: int): void;
            makeVisible(addr: hotspot.debugger.Address): void;
            _nextColor(c: java.awt.Color): java.awt.Color;
            paintComponent(g: java.awt.Graphics): void;
            _prevColor(c: java.awt.Color): java.awt.Color;
            print(): void;
            printOn(tty: java.io.PrintStream): void;
            _scrollAnnotations(y: int): void;
            _setupScrollBar(value: java.math.BigInteger, min: java.math.BigInteger, max: java.math.BigInteger): void;
            _setupScrollBar(): void;
            _addressSize: long;
            _annotations: hotspot.utilities.IntervalTree;
            _bytesPerLine: int;
            _debugger: hotspot.debugger.Debugger;
            _font: java.awt.Font;
            _is64Bit: boolean;
            _lastStartAddr: hotspot.debugger.Address;
            _paintCount: int;
            _scrollBar: HighPrecisionJScrollBar;
            _unmappedAddrString: string;
            _visibleAnnotations: java.util.List<Annotation>;
          }
          interface AnnotatedMemoryPanel extends CombineTypes<[_AnnotatedMemoryPanel, javax.swing.JPanel]> {}
          interface _AnnotatedMemoryPanel$AnnoX$$static extends ClassLike {
            new(lineX: int, highBound: hotspot.debugger.Address): AnnotatedMemoryPanel$AnnoX;
          }
          let AnnotatedMemoryPanel$AnnoX: _AnnotatedMemoryPanel$AnnoX$$static;
          interface _AnnotatedMemoryPanel$AnnoX {
            _highBound: hotspot.debugger.Address;
            _lineX: int;
          }
          interface AnnotatedMemoryPanel$AnnoX extends CombineTypes<[_AnnotatedMemoryPanel$AnnoX, java.lang.Object]> {}
          interface _Annotation$$static extends ClassLike {
            new(lowAddress: hotspot.debugger.Address, highAddress: hotspot.debugger.Address, s: string): Annotation;
          }
          let Annotation: _Annotation$$static;
          interface _Annotation {
            computeWidthAndHeight(g: java.awt.Graphics): void;
            draw(g: java.awt.Graphics): void;
            getBounds(): java.awt.Rectangle;
            getColor(): java.awt.Color;
            getHeight(): int;
            getHighAddress(): hotspot.debugger.Address;
            getInterval(): hotspot.utilities.Interval;
            getLowAddress(): hotspot.debugger.Address;
            getWidth(): int;
            getX(): int;
            getY(): int;
            setColor(c: java.awt.Color): void;
            setX(x: int): void;
            setXAndY(x: int, y: int): void;
            setY(y: int): void;
            toString(): string;
            _baseColor: java.awt.Color;
            _height: int;
            _heights: java.util.List<int>;
            _interval: hotspot.utilities.Interval;
            _strings: java.util.List<string>;
            _width: int;
            _x: int;
            _y: int;
          }
          interface Annotation extends CombineTypes<[_Annotation, java.lang.Object]> {}
          interface _CommandProcessorPanel$$static extends ClassLike {
            main(args: string[]): void;
            _DEBUGGING: boolean;
            new(cp: CommandProcessor): CommandProcessorPanel;
          }
          let CommandProcessorPanel: _CommandProcessorPanel$$static;
          interface _CommandProcessorPanel {
            _beginUpdate(): void;
            clear(): void;
            _endUpdate(): void;
            getMarkedText(): string;
            _insertContains(e: javax.swing.event.DocumentEvent, c: char): boolean;
            requestFocus(): void;
            setMark(): void;
            _trimContinuations(text: string): string;
            _baos: java.io.ByteArrayOutputStream;
            _commands: CommandProcessor;
            _curText: string;
            _editor: javax.swing.JTextArea;
            _mark: int;
            _updating: boolean;
          }
          interface CommandProcessorPanel extends CombineTypes<[_CommandProcessorPanel, javax.swing.JPanel]> {}
          interface _DeadlockDetectionPanel$$static extends ClassLike {
            new(): DeadlockDetectionPanel;
          }
          let DeadlockDetectionPanel: _DeadlockDetectionPanel$$static;
          interface _DeadlockDetectionPanel {
            _printDeadlocks(tty: java.io.PrintStream): void;
          }
          interface DeadlockDetectionPanel extends CombineTypes<[_DeadlockDetectionPanel, javax.swing.JPanel]> {}
          interface _DebuggerConsolePanel$$static extends ClassLike {
            main(args: string[]): void;
            _DEBUGGING: boolean;
            new(debugger: hotspot.debugger.Debugger): DebuggerConsolePanel;
          }
          let DebuggerConsolePanel: _DebuggerConsolePanel$$static;
          interface _DebuggerConsolePanel {
            _beginUpdate(): void;
            clear(): void;
            _endUpdate(): void;
            getMarkedText(): string;
            _insertContains(e: javax.swing.event.DocumentEvent, c: char): boolean;
            _print(s: string): void;
            _printPrompt(): void;
            requestFocus(): void;
            setMark(): void;
            _trimContinuations(text: string): string;
            _curText: string;
            _debugger: hotspot.debugger.Debugger;
            _editor: javax.swing.text.JTextComponent;
            _mark: int;
            _updating: boolean;
          }
          interface DebuggerConsolePanel extends CombineTypes<[_DebuggerConsolePanel, javax.swing.JPanel]> {}
          interface _EditableAtEndDocument$$static extends ClassLike {
            new(): EditableAtEndDocument;
          }
          let EditableAtEndDocument: _EditableAtEndDocument$$static;
          interface _EditableAtEndDocument {
            clear(): void;
            getMarkedText(): string;
            insertString(offset: int, text: string, a: javax.swing.text.AttributeSet): void;
            remove(offs: int, len: int): void;
            setMark(): void;
            _mark: int;
          }
          interface EditableAtEndDocument extends CombineTypes<[_EditableAtEndDocument, javax.swing.text.PlainDocument]> {}
          interface _Editor$$static extends ClassLike {
          }
          let Editor: _Editor$$static;
          interface _Editor {
            clearBreakpointAtLine(a0: int): void;
            clearBreakpoints(): void;
            getCurrentLineNumber(): int;
            getSourceFileName(): string;
            getUserData(): any;
            hasBreakpointAtLine(a0: int): boolean;
            highlightLineNumber(a0: int): void;
            setUserData(a0: any): void;
            showBreakpointAtLine(a0: int): void;
            showLineNumber(a0: int): void;
            toFront(): void;
          }
          interface Editor extends CombineTypes<[_Editor, java.lang.Object]> {}
          interface _EditorCommands$$static extends ClassLike {
          }
          let EditorCommands: _EditorCommands$$static;
          interface _EditorCommands {
            toggleBreakpointAtLine(a0: Editor, a1: int): void;
            windowClosed(a0: Editor): void;
          }
          interface EditorCommands extends CombineTypes<[_EditorCommands, java.lang.Object]> {}
          interface _EditorFactory$$static extends ClassLike {
          }
          let EditorFactory: _EditorFactory$$static;
          interface _EditorFactory {
            getCurrentEditor(): Editor;
            openFile(a0: string, a1: EditorCommands): Editor;
          }
          interface EditorFactory extends CombineTypes<[_EditorFactory, java.lang.Object]> {}
          interface _FindInCodeCachePanel$$static extends ClassLike {
            new(): FindInCodeCachePanel;
          }
          let FindInCodeCachePanel: _FindInCodeCachePanel$$static;
          interface _FindInCodeCachePanel {
            _clearResultWindow(): void;
            _reportResult(result: FindInCodeCachePanel$stringBuffer, blob: hotspot.code.CodeBlob): void;
            _updateProgressBar(result: FindInCodeCachePanel$stringBuffer): void;
            _addressField: HistoryComboBox;
            _contentEditor: SAEditorPane;
            _findButton: javax.swing.JButton;
            _iterated: long;
            _iterator: FindInCodeCachePanel$Visitor;
            _progressBar: ProgressBarPanel;
            _usedSize: long;
            _value: hotspot.debugger.Address;
          }
          interface FindInCodeCachePanel extends CombineTypes<[_FindInCodeCachePanel, sun.jvm.hotspot.ui.SAPanel]> {}
          interface _FindInCodeCachePanel$Visitor$$static extends ClassLike {
            _new(this$0: FindInCodeCachePanel): FindInCodeCachePanel$Visitor;
          }
          let FindInCodeCachePanel$Visitor: _FindInCodeCachePanel$Visitor$$static;
          interface _FindInCodeCachePanel$Visitor {
            cleanup(): void;
            epilogue(): void;
            prologue(start: hotspot.debugger.Address, end: hotspot.debugger.Address): void;
            _search(): void;
            visit(blob: hotspot.code.CodeBlob): void;
            _base: hotspot.debugger.Address;
            _result: ui$stringBuffer;
            _searching: boolean;
            _this$0: FindInCodeCachePanel;
          }
          interface FindInCodeCachePanel$Visitor extends CombineTypes<[_FindInCodeCachePanel$Visitor, sun.jvm.hotspot.code.CodeCacheVisitor, java.lang.Object]> {}
          interface _FindInHeapPanel$$static extends ClassLike {
            _minUpdateFraction: double;
            new(): FindInHeapPanel;
          }
          let FindInHeapPanel: _FindInHeapPanel$$static;
          interface _FindInHeapPanel {
            _clearResultWindow(): void;
            _invokeInDispatchThread(runnable: java.lang.Runnable): void;
            _reportResult(addr: hotspot.debugger.Address): boolean;
            _updateProgressBar(): void;
            _updateResultWindow(): void;
            _addressField: HistoryComboBox;
            _addressSize: long;
            _findButton: javax.swing.JButton;
            _iterated: long;
            _iterator: hotspot.oops.RawHeapVisitor;
            _lastFrac: double;
            _pendingUpdate: boolean;
            _progressBar: ProgressBarPanel;
            _textArea: javax.swing.JTextArea;
            _updates: java.util.ArrayList<string>;
            _usedSize: long;
            _value: hotspot.debugger.Address;
          }
          interface FindInHeapPanel extends CombineTypes<[_FindInHeapPanel, javax.swing.JPanel]> {}
          interface _FindPanel$$static extends ClassLike {
            new(): FindPanel;
          }
          let FindPanel: _FindPanel$$static;
          interface _FindPanel {
            _clear(): void;
            _addressField: javax.swing.JTextField;
            _statusLabel: javax.swing.JLabel;
            _textArea: javax.swing.JTextArea;
          }
          interface FindPanel extends CombineTypes<[_FindPanel, javax.swing.JPanel]> {}
          interface _FrameWrapper$$static extends ClassLike {
          }
          let FrameWrapper: _FrameWrapper$$static;
          interface _FrameWrapper {
            dispose(): void;
            getComponent(): java.awt.Component;
            getContentPane(): java.awt.Container;
            pack(): void;
            setActivatedActionListener(a0: java.awt.event.ActionListener): void;
            setBackground(a0: java.awt.Color): void;
            setClosable(a0: boolean): void;
            setClosingActionListener(a0: java.awt.event.ActionListener): void;
            setResizable(a0: boolean): void;
            setSize(a0: int, a1: int): void;
            setVisible(a0: boolean): void;
            toFront(): void;
          }
          interface FrameWrapper extends CombineTypes<[_FrameWrapper, java.lang.Object]> {}
          interface _GraphicsUtilities$$static extends ClassLike {
            centerInContainer(c: java.awt.Component): void;
            centerInContainer(component: java.awt.Component, containerDimension: java.awt.Dimension): void;
            constrainToSize(component: java.awt.Component, containerDimension: java.awt.Dimension): void;
            getMonospacedFont(): java.awt.Font;
            getStringBounds(s: string, g: java.awt.Graphics): java.awt.geom.Rectangle2D;
            getStringWidth(s: string, fm: java.awt.FontMetrics): int;
            moveToInContainer(component: java.awt.Component, relativeX: float, relativeY: float, minX: int, minY: int): void;
            newBorder(size: int): javax.swing.border.Border;
            randomLocation(c: java.awt.Component): void;
            randomLocation(component: java.awt.Component, containerDimension: java.awt.Dimension): void;
            reshapeToAspectRatio(component: java.awt.Component, aspectRatio: float, fillRatio: float, containerDimension: java.awt.Dimension): void;
            _FONT_SIZE: int;
            _random: java.util.Random;
            new(): GraphicsUtilities;
          }
          let GraphicsUtilities: _GraphicsUtilities$$static;
          interface _GraphicsUtilities {
          }
          interface GraphicsUtilities extends CombineTypes<[_GraphicsUtilities, java.lang.Object]> {}
          interface _HeapParametersPanel$$static extends ClassLike {
            new(): HeapParametersPanel;
          }
          let HeapParametersPanel: _HeapParametersPanel$$static;
          interface _HeapParametersPanel {
          }
          interface HeapParametersPanel extends CombineTypes<[_HeapParametersPanel, javax.swing.JPanel]> {}
          interface _HighPrecisionJScrollBar$$static extends ClassLike {
            main(args: string[]): void;
            _BIG_RANGE: int;
            _BLOCK_INCREMENT: int;
            _MAXIMUM: int;
            _MINIMUM: int;
            _SCALE: int;
            _UNIT_INCREMENT: int;
            new(): HighPrecisionJScrollBar;
            new(orientation: int): HighPrecisionJScrollBar;
            new(orientation: int, value: java.math.BigInteger, minimum: java.math.BigInteger, maximum: java.math.BigInteger): HighPrecisionJScrollBar;
          }
          let HighPrecisionJScrollBar: _HighPrecisionJScrollBar$$static;
          interface _HighPrecisionJScrollBar {
            addChangeListener(l: javax.swing.event.ChangeListener): void;
            _beginUpdate(): void;
            _endUpdate(): void;
            _fireStateChanged(): void;
            getBlockIncrementHP(): java.math.BigInteger;
            getMaximumHP(): java.math.BigInteger;
            getMinimumHP(): java.math.BigInteger;
            _getScaleFactor(): java.math.BigDecimal;
            getUnitIncrementHP(): java.math.BigInteger;
            getValueHP(): java.math.BigInteger;
            getVisibleAmountHP(): java.math.BigInteger;
            _initialize(value: java.math.BigInteger, minimum: java.math.BigInteger, maximum: java.math.BigInteger): void;
            _initialize(): void;
            _installListener(): void;
            pageDownOrRight(): void;
            pageUpOrLeft(): void;
            removeChangeListener(l: javax.swing.event.ChangeListener): void;
            _scaleToHP(i: int): java.math.BigInteger;
            _scaleToUnderlying(i: java.math.BigInteger): int;
            scrollDownOrRight(): void;
            scrollUpOrLeft(): void;
            setBlockIncrementHP(blockIncrement: java.math.BigInteger): void;
            setMaximumHP(maximum: java.math.BigInteger): void;
            setMinimumHP(minimum: java.math.BigInteger): void;
            _setRange(minimum: java.math.BigInteger, maximum: java.math.BigInteger): void;
            setUnitIncrementHP(unitIncrement: java.math.BigInteger): void;
            setValueHP(value: java.math.BigInteger): void;
            setVisibleAmountHP(visibleAmount: java.math.BigInteger): void;
            _toHPRange(i: int): java.math.BigInteger;
            _toUnderlyingRange(i: java.math.BigInteger): int;
            _updateScrollBarValues(): void;
            _blockIncrementHP: java.math.BigInteger;
            _changeListeners: java.util.List<javax.swing.event.ChangeListener>;
            _down: boolean;
            _lastValueSeen: int;
            _maximumHP: java.math.BigInteger;
            _minimumHP: java.math.BigInteger;
            _rangeHP: java.math.BigInteger;
            _scaleFactor: java.math.BigDecimal;
            _unitIncrementHP: java.math.BigInteger;
            _updating: boolean;
            _valueHP: java.math.BigInteger;
            _visibleHP: java.math.BigInteger;
          }
          interface HighPrecisionJScrollBar extends CombineTypes<[_HighPrecisionJScrollBar, javax.swing.JScrollBar]> {}
          interface _HistoryComboBox$$static extends ClassLike {
            _HISTORY_LENGTH: int;
            new(): HistoryComboBox;
          }
          let HistoryComboBox: _HistoryComboBox$$static;
          interface _HistoryComboBox {
            getText(): string;
            setText(text: string): void;
          }
          interface HistoryComboBox extends CombineTypes<[_HistoryComboBox, javax.swing.JComboBox<string>]> {}
          interface _Inspector$$static extends ClassLike {
            _computeLivenessText: string;
            _showLivenessText: string;
            new(): Inspector;
            new(root: ui.tree.SimpleTreeNode): Inspector;
          }
          let Inspector: _Inspector$$static;
          interface _Inspector {
            _fireComputeLiveness(): void;
            _fireShowLiveness(): void;
            _setRoot(root: ui.tree.SimpleTreeNode): void;
            _addressField: HistoryComboBox;
            _currentOop: hotspot.oops.Oop;
            _list: hotspot.utilities.LivenessPathList;
            _liveStatus: javax.swing.JLabel;
            _livenessButton: javax.swing.JButton;
            _livenessButtonListener: java.awt.event.ActionListener;
            _model: tree.SimpleTreeModel;
            _showLivenessListener: java.awt.event.ActionListener;
            _statusLabel: javax.swing.JLabel;
            _tree: javax.swing.JTree;
          }
          interface Inspector extends CombineTypes<[_Inspector, sun.jvm.hotspot.ui.SAPanel]> {}
          interface _JFrameWrapper$$static extends ClassLike {
            new(frame: javax.swing.JFrame): JFrameWrapper;
          }
          let JFrameWrapper: _JFrameWrapper$$static;
          interface _JFrameWrapper {
            dispose(): void;
            getComponent(): java.awt.Component;
            getContentPane(): java.awt.Container;
            _maybeInstallWindowListener(): void;
            pack(): void;
            setActivatedActionListener(l: java.awt.event.ActionListener): void;
            setBackground(color: java.awt.Color): void;
            setClosable(closable: boolean): void;
            setClosingActionListener(l: java.awt.event.ActionListener): void;
            setResizable(resizable: boolean): void;
            setSize(x: int, y: int): void;
            setVisible(visible: boolean): void;
            show(): void;
            toFront(): void;
            _activatedActionListener: java.awt.event.ActionListener;
            _closingActionListener: java.awt.event.ActionListener;
            _frame: javax.swing.JFrame;
            _hasWindowListener: boolean;
          }
          interface JFrameWrapper extends CombineTypes<[_JFrameWrapper, java.lang.Object, sun.jvm.hotspot.ui.FrameWrapper]> {}
          interface _JInternalFrameWrapper$$static extends ClassLike {
            new(frame: javax.swing.JInternalFrame): JInternalFrameWrapper;
          }
          let JInternalFrameWrapper: _JInternalFrameWrapper$$static;
          interface _JInternalFrameWrapper {
            dispose(): void;
            getComponent(): java.awt.Component;
            getContentPane(): java.awt.Container;
            _maybeInstallWindowListener(): void;
            pack(): void;
            setActivatedActionListener(l: java.awt.event.ActionListener): void;
            setBackground(color: java.awt.Color): void;
            setClosable(closable: boolean): void;
            setClosingActionListener(l: java.awt.event.ActionListener): void;
            setResizable(resizable: boolean): void;
            setSize(x: int, y: int): void;
            setVisible(visible: boolean): void;
            show(): void;
            toFront(): void;
            _activatedActionListener: java.awt.event.ActionListener;
            _closingActionListener: java.awt.event.ActionListener;
            _frame: javax.swing.JInternalFrame;
            _hasWindowListener: boolean;
          }
          interface JInternalFrameWrapper extends CombineTypes<[_JInternalFrameWrapper, java.lang.Object, sun.jvm.hotspot.ui.FrameWrapper]> {}
          interface _JavaStackTracePanel$$static extends ClassLike {
            new(): JavaStackTracePanel;
          }
          let JavaStackTracePanel: _JavaStackTracePanel$$static;
          interface _JavaStackTracePanel {
            _initUI(): void;
            _setContentText(text: string): void;
            setJavaThread(thread: hotspot.runtime.JavaThread): void;
            _setStackTraceText(text: string): void;
            _contentEditor: SAEditorPane;
            _htmlGen: classbrowser.HTMLGenerator;
            _splitPane: javax.swing.JSplitPane;
            _stackTraceEditor: SAEditorPane;
          }
          interface JavaStackTracePanel extends CombineTypes<[_JavaStackTracePanel, javax.swing.JPanel]> {}
          interface _JavaThreadsPanel$$static extends ClassLike {
            _initialize(db: hotspot.types.TypeDataBase): void;
            _crashThread: hotspot.types.AddressField;
            new(): JavaThreadsPanel;
          }
          let JavaThreadsPanel: _JavaThreadsPanel$$static;
          interface _JavaThreadsPanel {
            actionPerformed(evt: java.awt.event.ActionEvent): void;
            _cache(): void;
            _decache(): void;
            _fireShowJavaStackTrace(): void;
            _fireShowThreadCrashes(): boolean;
            _fireShowThreadInfo(): void;
            _fireShowThreadOopInspector(): void;
            _fireShowThreadStackMemory(): void;
            _registerAction(actionName: string): void;
            _registerActions(): void;
            _cachedThreads: java.util.List<JavaThreadsPanel$CachedThread>;
            _dataModel: JavaThreadsPanel$JavaThreadsTableModel;
            _statusBar: com.sun.java.swing.ui.StatusBar;
            _threadTable: javax.swing.JTable;
          }
          interface JavaThreadsPanel extends CombineTypes<[_JavaThreadsPanel, java.awt.event.ActionListener, sun.jvm.hotspot.ui.SAPanel]> {}
          interface _JavaThreadsPanel$CachedThread$$static extends ClassLike {
            new(a0: JavaThreadsPanel, thread: hotspot.runtime.JavaThread): JavaThreadsPanel$CachedThread;
          }
          let JavaThreadsPanel$CachedThread: _JavaThreadsPanel$CachedThread$$static;
          interface _JavaThreadsPanel$CachedThread {
            _compute(): void;
            getThread(): hotspot.runtime.JavaThread;
            getThreadID(): string;
            getThreadName(): string;
            _computed: boolean;
            _thread: hotspot.runtime.JavaThread;
            _threadID: string;
            _threadName: string;
          }
          interface JavaThreadsPanel$CachedThread extends CombineTypes<[_JavaThreadsPanel$CachedThread, java.lang.Object]> {}
          interface _JavaThreadsPanel$JavaThreadsColumnModel$$static extends ClassLike {
            new(a0: JavaThreadsPanel): JavaThreadsPanel$JavaThreadsColumnModel;
          }
          let JavaThreadsPanel$JavaThreadsColumnModel: _JavaThreadsPanel$JavaThreadsColumnModel$$static;
          interface _JavaThreadsPanel$JavaThreadsColumnModel {
            _columnNames: string[];
            _this$0: JavaThreadsPanel;
          }
          interface JavaThreadsPanel$JavaThreadsColumnModel extends CombineTypes<[_JavaThreadsPanel$JavaThreadsColumnModel, javax.swing.table.DefaultTableColumnModel]> {}
          interface _JavaThreadsPanel$JavaThreadsTableModel$$static extends ClassLike {
            new(a0: java.util.List<JavaThreadsPanel$CachedThread>): JavaThreadsPanel$JavaThreadsTableModel;
          }
          let JavaThreadsPanel$JavaThreadsTableModel: _JavaThreadsPanel$JavaThreadsTableModel$$static;
          interface _JavaThreadsPanel$JavaThreadsTableModel {
            getColumnCount(): int;
            getColumnName(col: int): string;
            getJavaThread(index: int): hotspot.runtime.JavaThread;
            _getRow(row: int): JavaThreadsPanel$CachedThread;
            getRowCount(): int;
            getValueAt(row: int, col: int): any;
            _threadIDAt(index: int): string;
            _threadNameAt(index: int): string;
            _columnNames: string[];
            _elements: java.util.List<JavaThreadsPanel$CachedThread>;
            _this$0: JavaThreadsPanel;
          }
          interface JavaThreadsPanel$JavaThreadsTableModel extends CombineTypes<[_JavaThreadsPanel$JavaThreadsTableModel, javax.swing.table.AbstractTableModel]> {}
          interface _JavaThreadsPanel$JavaThreadsToolBar$$static extends ClassLike {
            new(a0: JavaThreadsPanel, status: com.sun.java.swing.ui.StatusBar): JavaThreadsPanel$JavaThreadsToolBar;
          }
          let JavaThreadsPanel$JavaThreadsToolBar: _JavaThreadsPanel$JavaThreadsToolBar$$static;
          interface _JavaThreadsPanel$JavaThreadsToolBar {
            _addComponents(): void;
            _this$0: JavaThreadsPanel;
          }
          interface JavaThreadsPanel$JavaThreadsToolBar extends CombineTypes<[_JavaThreadsPanel$JavaThreadsToolBar, com.sun.java.swing.ui.CommonToolBar]> {}
          interface _JavaThreadsPanel$ThreadPanel$$static extends ClassLike {
            new(a0: JavaThreadsPanel, table: javax.swing.JTable): JavaThreadsPanel$ThreadPanel;
          }
          let JavaThreadsPanel$ThreadPanel: _JavaThreadsPanel$ThreadPanel$$static;
          interface _JavaThreadsPanel$ThreadPanel {
            _hideOutputPane(): void;
            _isInfoVisible(): boolean;
            _setActionsEnabled(enabled: boolean): void;
            _showCurrentThreadInfo(): void;
            _showOutputPane(): void;
            _actionsEnabled: boolean;
            _dividerLocation: int;
            _dividerSize: int;
            _splitPane: javax.swing.JSplitPane;
            _this$0: JavaThreadsPanel;
            _threadInfo: ThreadInfoPanel;
            _threadTable: javax.swing.JTable;
          }
          interface JavaThreadsPanel$ThreadPanel extends CombineTypes<[_JavaThreadsPanel$ThreadPanel, javax.swing.JPanel]> {}
          interface _MemoryPanel$$static extends ClassLike {
            _installActionWrapper(map: javax.swing.ActionMap, actionName: string, wrapper: MemoryPanel$ActionWrapper): void;
            new(debugger: hotspot.debugger.Debugger, isAnnotated: boolean, is64Bit: boolean): MemoryPanel;
          }
          let MemoryPanel: _MemoryPanel$$static;
          interface _MemoryPanel {
            _addressToBigInt(a: hotspot.debugger.Address): java.math.BigInteger;
            _addressToString(a: hotspot.debugger.Address): string;
            _beginUpdate(): void;
            _bigIntToAddress(i: java.math.BigInteger): hotspot.debugger.Address;
            _bigIntToHexString(bi: java.math.BigInteger): string;
            _clamp(val: int, min: int, max: int): int;
            _clearSelection(): void;
            _constrain(): void;
            _endUpdate(): void;
            _getColAnchor(): int;
            _getColLead(): int;
            _getRowAnchor(): int;
            _getRowLead(): int;
            _haveAnchor(): boolean;
            _haveLead(): boolean;
            _haveSelection(): boolean;
            makeVisible(addr: hotspot.debugger.Address): void;
            _maybeGrabSelection(): void;
            _modifySelection(amount: int): void;
            _printSelection(): void;
            _recomputeNumVisibleRows(): void;
            _setAnchor(row: int, col: int): void;
            _setAnchorFromTable(): void;
            _setLead(row: int, col: int): void;
            _setLeadFromTable(): void;
            _setSelection(rowAnchor: int, rowLead: int, colAnchor: int, colLead: int): void;
            _setupScrollBar(): void;
            _shouldIgnore(e: java.awt.event.MouseEvent): boolean;
            _updateFromScrollBar(): void;
            _updating(): boolean;
            _addressSize: int;
            _colAnchorIndex: int;
            _colLeadIndex: int;
            _debugger: hotspot.debugger.Debugger;
            _haveAnchor: boolean;
            _haveLead: boolean;
            _is64Bit: boolean;
            _isAnnotated: boolean;
            _model: javax.swing.table.AbstractTableModel;
            _numUsableRows: int;
            _numVisibleRows: int;
            _rowAnchorIndex: int;
            _rowLeadIndex: int;
            _scrollBar: HighPrecisionJScrollBar;
            _startVal: java.math.BigInteger;
            _table: javax.swing.JTable;
            _unmappedAddrString: string;
            _updateLevel: int;
          }
          interface MemoryPanel extends CombineTypes<[_MemoryPanel, javax.swing.JPanel]> {}
          interface _MemoryPanel$ActionWrapper$$static extends ClassLike {
            _new(this$0: MemoryPanel): MemoryPanel$ActionWrapper;
          }
          let MemoryPanel$ActionWrapper: _MemoryPanel$ActionWrapper$$static;
          interface _MemoryPanel$ActionWrapper {
            actionPerformed(e: java.awt.event.ActionEvent): void;
            _getParent(): javax.swing.Action;
            _setParent(parent: javax.swing.Action): void;
            _parent: javax.swing.Action;
            _this$0: MemoryPanel;
          }
          interface MemoryPanel$ActionWrapper extends CombineTypes<[_MemoryPanel$ActionWrapper, javax.swing.AbstractAction]> {}
          interface _MemoryViewer$$static extends ClassLike {
            new(debugger: hotspot.debugger.Debugger, isAnnotated: boolean, is64Bit: boolean): MemoryViewer;
          }
          let MemoryViewer: _MemoryViewer$$static;
          interface _MemoryViewer {
          }
          interface MemoryViewer extends CombineTypes<[_MemoryViewer, javax.swing.JPanel]> {}
          interface _MonitorCacheDumpPanel$$static extends ClassLike {
            _dumpMonitor(tty: java.io.PrintStream, mon: hotspot.runtime.ObjectMonitor, raw: boolean): void;
            _heap: hotspot.oops.ObjectHeap;
            _threads: hotspot.runtime.Threads;
            new(): MonitorCacheDumpPanel;
          }
          let MonitorCacheDumpPanel: _MonitorCacheDumpPanel$$static;
          interface _MonitorCacheDumpPanel {
            _dumpOn(tty: java.io.PrintStream): void;
          }
          interface MonitorCacheDumpPanel extends CombineTypes<[_MonitorCacheDumpPanel, javax.swing.JPanel]> {}
          interface _ObjectHistogramPanel$$static extends ClassLike {
            main(args: string[]): void;
            new(histo: hotspot.oops.ObjectHistogram): ObjectHistogramPanel;
          }
          let ObjectHistogramPanel: _ObjectHistogramPanel$$static;
          interface _ObjectHistogramPanel {
            actionPerformed(evt: java.awt.event.ActionEvent): void;
            addPanelListener(listener: ObjectHistogramPanel$Listener): void;
            _findObject(): void;
            _fireShowObjectsOfType(): void;
            _registerAction(actionName: string): void;
            _registerActions(): void;
            removePanelListener(listener: ObjectHistogramPanel$Listener): void;
            _dataModel: ObjectHistogramPanel$ObjectHistogramTableModel;
            _listeners: java.util.List<ObjectHistogramPanel$Listener>;
            _statusBar: com.sun.java.swing.ui.StatusBar;
            _table: javax.swing.JTable;
            _toolbar: ObjectHistogramPanel$ObjectHistogramToolBar;
          }
          interface ObjectHistogramPanel extends CombineTypes<[_ObjectHistogramPanel, java.awt.event.ActionListener, javax.swing.JPanel]> {}
          interface _ObjectHistogramPanel$Listener$$static extends ClassLike {
          }
          let ObjectHistogramPanel$Listener: _ObjectHistogramPanel$Listener$$static;
          interface _ObjectHistogramPanel$Listener {
            showObjectsOfType(a0: hotspot.oops.Klass): void;
(a0: hotspot.oops.Klass): void;
          }
          interface ObjectHistogramPanel$Listener extends CombineTypes<[_ObjectHistogramPanel$Listener, java.lang.Object]> {}
          interface _ObjectHistogramPanel$ObjectHistogramColummModel$$static extends ClassLike {
            new(a0: ObjectHistogramPanel): ObjectHistogramPanel$ObjectHistogramColummModel;
          }
          let ObjectHistogramPanel$ObjectHistogramColummModel: _ObjectHistogramPanel$ObjectHistogramColummModel$$static;
          interface _ObjectHistogramPanel$ObjectHistogramColummModel {
            _LABEL_COUNT: string;
            _LABEL_DESC: string;
            _LABEL_SIZE: string;
            _this$0: ObjectHistogramPanel;
          }
          interface ObjectHistogramPanel$ObjectHistogramColummModel extends CombineTypes<[_ObjectHistogramPanel$ObjectHistogramColummModel, javax.swing.table.DefaultTableColumnModel]> {}
          interface _ObjectHistogramPanel$ObjectHistogramTableModel$$static extends ClassLike {
            new(a0: ObjectHistogramPanel, histo: hotspot.oops.ObjectHistogram): ObjectHistogramPanel$ObjectHistogramTableModel;
          }
          let ObjectHistogramPanel$ObjectHistogramTableModel: _ObjectHistogramPanel$ObjectHistogramTableModel$$static;
          interface _ObjectHistogramPanel$ObjectHistogramTableModel {
            getColumnClass(col: int): java.lang.Class;
            getColumnCount(): int;
            getColumnName(col: int): string;
            getElement(index: int): hotspot.oops.ObjectHistogramElement;
            getRowCount(): int;
            getValueAt(row: int, col: int): any;
            getValueForColumn(obj: any, col: int): java.lang.Comparable<any>;
            _columnClasses: java.lang.Class[];
            _columnNames: string[];
            _this$0: ObjectHistogramPanel;
          }
          interface ObjectHistogramPanel$ObjectHistogramTableModel extends CombineTypes<[_ObjectHistogramPanel$ObjectHistogramTableModel, table.SortableTableModel<hotspot.oops.ObjectHistogramElement>]> {}
          interface _ObjectHistogramPanel$ObjectHistogramTableModel$ObjectHistogramComparator$$static extends ClassLike {
            new(a0: ObjectHistogramPanel$ObjectHistogramTableModel, model: ObjectHistogramPanel$ObjectHistogramTableModel): ObjectHistogramPanel$ObjectHistogramTableModel$ObjectHistogramComparator;
          }
          let ObjectHistogramPanel$ObjectHistogramTableModel$ObjectHistogramComparator: _ObjectHistogramPanel$ObjectHistogramTableModel$ObjectHistogramComparator$$static;
          interface _ObjectHistogramPanel$ObjectHistogramTableModel$ObjectHistogramComparator {
            getValueForColumn(obj: any, column: int): java.lang.Comparable<any>;
          }
          interface ObjectHistogramPanel$ObjectHistogramTableModel$ObjectHistogramComparator extends CombineTypes<[_ObjectHistogramPanel$ObjectHistogramTableModel$ObjectHistogramComparator, sun.jvm.hotspot.ui.table.TableModelComparator]> {}
          interface _ObjectHistogramPanel$ObjectHistogramToolBar$$static extends ClassLike {
            new(a0: ObjectHistogramPanel, status: com.sun.java.swing.ui.StatusBar): ObjectHistogramPanel$ObjectHistogramToolBar;
          }
          let ObjectHistogramPanel$ObjectHistogramToolBar: _ObjectHistogramPanel$ObjectHistogramToolBar$$static;
          interface _ObjectHistogramPanel$ObjectHistogramToolBar {
            _addComponents(): void;
            getFindText(): string;
            _searchTF: javax.swing.JTextField;
            _this$0: ObjectHistogramPanel;
          }
          interface ObjectHistogramPanel$ObjectHistogramToolBar extends CombineTypes<[_ObjectHistogramPanel$ObjectHistogramToolBar, com.sun.java.swing.ui.CommonToolBar]> {}
          interface _ObjectListPanel$$static extends ClassLike {
            _showLivenessText: string;
            new(els: java.util.List<hotspot.oops.Oop>, thunk: hotspot.utilities.HeapProgressThunk): ObjectListPanel;
          }
          let ObjectListPanel: _ObjectListPanel$$static;
          interface _ObjectListPanel {
            _checkForArrays(): void;
            _computeNumColumns(): void;
            _fireComputeLiveness(): void;
            _fireShowInspector(): void;
            _fireShowLiveness(): void;
            _checkedForArrays: boolean;
            _dataModel: ObjectListPanel$ObjectListTableModel;
            _elements: java.util.List<hotspot.oops.Oop>;
            _hasArrays: boolean;
            _livenessButton: javax.swing.JButton;
            _livenessButtonListener: java.awt.event.ActionListener;
            _numColumns: int;
            _table: javax.swing.JTable;
            _thunk: hotspot.utilities.HeapProgressThunk;
          }
          interface ObjectListPanel extends CombineTypes<[_ObjectListPanel, sun.jvm.hotspot.ui.SAPanel]> {}
          interface _ObjectListPanel$AddressWrapper$$static extends ClassLike {
          }
          let ObjectListPanel$AddressWrapper: _ObjectListPanel$AddressWrapper$$static;
          interface _ObjectListPanel$AddressWrapper {
            compareTo(wrapper: ObjectListPanel$AddressWrapper): int;
            compareTo(a0: any): int;
            toString(): string;
            _address: hotspot.debugger.Address;
          }
          interface ObjectListPanel$AddressWrapper extends CombineTypes<[_ObjectListPanel$AddressWrapper, java.lang.Comparable<ObjectListPanel$AddressWrapper>, java.lang.Object]> {}
          interface _ObjectListPanel$ObjectListTableModel$$static extends ClassLike {
            new(a0: ObjectListPanel): ObjectListPanel$ObjectListTableModel;
          }
          let ObjectListPanel$ObjectListTableModel: _ObjectListPanel$ObjectListTableModel$$static;
          interface _ObjectListPanel$ObjectListTableModel {
            getColumnCount(): int;
            getColumnName(col: int): string;
            getRowCount(): int;
            getValueAt(row: int, col: int): any;
            getValueForColumn(oop: hotspot.oops.Oop, col: int): java.lang.Comparable<any>;
            _this$0: ObjectListPanel;
          }
          interface ObjectListPanel$ObjectListTableModel extends CombineTypes<[_ObjectListPanel$ObjectListTableModel, table.SortableTableModel<hotspot.oops.Oop>]> {}
          interface _ObjectListPanel$ObjectListTableModel$ObjectListComparator$$static extends ClassLike {
            new(a0: ObjectListPanel$ObjectListTableModel, model: ObjectListPanel$ObjectListTableModel): ObjectListPanel$ObjectListTableModel$ObjectListComparator;
          }
          let ObjectListPanel$ObjectListTableModel$ObjectListComparator: _ObjectListPanel$ObjectListTableModel$ObjectListComparator$$static;
          interface _ObjectListPanel$ObjectListTableModel$ObjectListComparator {
            getValueForColumn(obj: any, column: int): java.lang.Comparable<any>;
          }
          interface ObjectListPanel$ObjectListTableModel$ObjectListComparator extends CombineTypes<[_ObjectListPanel$ObjectListTableModel$ObjectListComparator, sun.jvm.hotspot.ui.table.TableModelComparator]> {}
          interface _ProcessListPanel$$static extends ClassLike {
            new(dbg: hotspot.debugger.Debugger): ProcessListPanel;
          }
          let ProcessListPanel: _ProcessListPanel$$static;
          interface _ProcessListPanel {
            _findPid(els: java.util.List<hotspot.debugger.ProcessInfo>, pid: int): int;
            _getPid(els: java.util.List<hotspot.debugger.ProcessInfo>, index: int): int;
            getSelectedProcess(): hotspot.debugger.ProcessInfo;
            _getTimer(): javax.swing.Timer;
            setAutoUpdateInterval(millis: int): void;
            _sort(els: java.util.List<hotspot.debugger.ProcessInfo>): void;
            start(): void;
            stop(): void;
            update(): void;
            _dataModel: javax.swing.table.AbstractTableModel;
            _dbg: hotspot.debugger.Debugger;
            _els: java.util.List<hotspot.debugger.ProcessInfo>;
            _sortByName: boolean;
            _sortReversed: boolean;
            _table: javax.swing.JTable;
            _timer: javax.swing.Timer;
          }
          interface ProcessListPanel extends CombineTypes<[_ProcessListPanel, javax.swing.JPanel]> {}
          interface _ProgressBarPanel$$static extends ClassLike {
            readonly HORIZONTAL: int;
            _MAX: int;
            readonly VERTICAL: int;
            new(): ProgressBarPanel;
            new(layoutType: int): ProgressBarPanel;
            new(text: string): ProgressBarPanel;
            new(layoutType: int, text: string): ProgressBarPanel;
          }
          let ProgressBarPanel: _ProgressBarPanel$$static;
          interface _ProgressBarPanel {
            setIndeterminate(value: boolean): void;
            setText(text: string): void;
            setValue(val: double): void;
            _bar: javax.swing.JProgressBar;
            _text: javax.swing.JLabel;
          }
          interface ProgressBarPanel extends CombineTypes<[_ProgressBarPanel, javax.swing.JPanel]> {}
          interface _SAEditorPane$$static extends ClassLike {
            new(): SAEditorPane;
          }
          let SAEditorPane: _SAEditorPane$$static;
          interface _SAEditorPane {
            getSelectedText(): string;
            setText(text: string): void;
          }
          interface SAEditorPane extends CombineTypes<[_SAEditorPane, javax.swing.JEditorPane]> {}
          interface _SAListener$$static extends ClassLike {
          }
          let SAListener: _SAListener$$static;
          interface _SAListener {
            showCodeViewer(a0: hotspot.debugger.Address): void;
            showInspector(a0: ui.tree.SimpleTreeNode): void;
            showJavaStackTrace(a0: hotspot.runtime.JavaThread): void;
            showLiveness(a0: hotspot.oops.Oop, a1: hotspot.utilities.LivenessPathList): void;
            showThreadInfo(a0: hotspot.runtime.JavaThread): void;
            showThreadOopInspector(a0: hotspot.runtime.JavaThread): void;
            showThreadStackMemory(a0: hotspot.runtime.JavaThread): void;
          }
          interface SAListener extends CombineTypes<[_SAListener, java.lang.Object]> {}
          interface _SAPanel$$static extends ClassLike {
            new(): SAPanel;
          }
          let SAPanel: _SAPanel$$static;
          interface _SAPanel {
            addPanelListener(listener: SAListener): void;
            removePanelListener(listener: SAListener): void;
            showCodeViewer(address: hotspot.debugger.Address): void;
            showInspector(oop: hotspot.oops.Oop): void;
            showInspector(node: ui.tree.SimpleTreeNode): void;
            showJavaStackTrace(t: hotspot.runtime.JavaThread): void;
            showThreadInfo(t: hotspot.runtime.JavaThread): void;
            showThreadOopInspector(t: hotspot.runtime.JavaThread): void;
            showThreadStackMemory(t: hotspot.runtime.JavaThread): void;
            _listeners: java.util.List<SAListener>;
          }
          interface SAPanel extends CombineTypes<[_SAPanel, javax.swing.JPanel]> {}
          interface _SourceCodePanel$$static extends ClassLike {
            _ICON_SIZE: int;
            _LINE_NO_SPACE: int;
            _breakpoint: javax.swing.Icon;
            _lowerFrameCurLine: javax.swing.Icon;
            _topFrameCurLine: javax.swing.Icon;
            new(): SourceCodePanel;
          }
          let SourceCodePanel: _SourceCodePanel$$static;
          interface _SourceCodePanel {
            clearBreakpointAtLine(lineNo: int): void;
            clearBreakpoints(): void;
            getCurrentLineNumber(): int;
            getShowLineNumbers(): boolean;
            getSourceFileName(): string;
            hasBreakpointAtLine(lineNo: int): boolean;
            highlightLineNumber(lineNo: int): void;
            _loadIcon(which: string): javax.swing.Icon;
            _maybeLoadIcons(): void;
            openFile(filename: string): boolean;
            requestFocus(): void;
            setEditorCommands(comm: EditorCommands, parent: Editor): void;
            setFont(f: java.awt.Font): void;
            setShowLineNumbers(val: boolean): void;
            showBreakpointAtLine(lineNo: int): void;
            showLineNumber(lineNo: int): void;
            _breakpoints: java.util.Set<int>;
            _comm: EditorCommands;
            _filename: string;
            _header: SourceCodePanel$RowHeader;
            _highlightedLine: int;
            _parent: Editor;
            _source: javax.swing.JTextArea;
          }
          interface SourceCodePanel extends CombineTypes<[_SourceCodePanel, javax.swing.JPanel]> {}
          interface _SourceCodePanel$RowHeader$$static extends ClassLike {
            new(this$0: SourceCodePanel): SourceCodePanel$RowHeader;
          }
          let SourceCodePanel$RowHeader: _SourceCodePanel$RowHeader$$static;
          interface _SourceCodePanel$RowHeader {
            getShowLineNumbers(): boolean;
            paint(g: java.awt.Graphics): void;
            _recomputeSize(): void;
            setFont(f: java.awt.Font): void;
            setShowLineNumbers(val: boolean): void;
            _setViewport(view: javax.swing.JViewport): void;
            _initted: boolean;
            _rowHeight: int;
            _showLineNumbers: boolean;
            _this$0: SourceCodePanel;
            _view: javax.swing.JViewport;
            _width: int;
          }
          interface SourceCodePanel$RowHeader extends CombineTypes<[_SourceCodePanel$RowHeader, javax.swing.JPanel]> {}
          interface _StringTransferable$$static extends ClassLike {
            _supported: java.awt.datatransfer.DataFlavor[];
            new(str: string): StringTransferable;
          }
          let StringTransferable: _StringTransferable$$static;
          interface _StringTransferable {
            getTransferData(flavor: java.awt.datatransfer.DataFlavor): any;
            getTransferDataFlavors(): java.awt.datatransfer.DataFlavor[];
            isDataFlavorSupported(flavor: java.awt.datatransfer.DataFlavor): boolean;
            _str: string;
          }
          interface StringTransferable extends CombineTypes<[_StringTransferable, java.awt.datatransfer.Transferable, java.lang.Object]> {}
          interface _SysPropsPanel$$static extends ClassLike {
            new(): SysPropsPanel;
          }
          let SysPropsPanel: _SysPropsPanel$$static;
          interface _SysPropsPanel {
            _getFlags(): string;
            _initUI(): void;
            _flagsPane: SAEditorPane;
          }
          interface SysPropsPanel extends CombineTypes<[_SysPropsPanel, javax.swing.JPanel]> {}
          interface _ThreadInfoPanel$$static extends ClassLike {
            new(): ThreadInfoPanel;
            new(thread: hotspot.runtime.JavaThread): ThreadInfoPanel;
          }
          let ThreadInfoPanel: _ThreadInfoPanel$$static;
          interface _ThreadInfoPanel {
            _initUI(): void;
            setJavaThread(thread: hotspot.runtime.JavaThread): void;
            _textArea: javax.swing.JTextArea;
          }
          interface ThreadInfoPanel extends CombineTypes<[_ThreadInfoPanel, javax.swing.JPanel]> {}
          interface _VMFlagsPanel$$static extends ClassLike {
            new(): VMFlagsPanel;
          }
          let VMFlagsPanel: _VMFlagsPanel$$static;
          interface _VMFlagsPanel {
            _getFlags(): string;
            _initUI(): void;
            _flagsPane: javax.swing.JEditorPane;
          }
          interface VMFlagsPanel extends CombineTypes<[_VMFlagsPanel, javax.swing.JPanel]> {}
          interface _VMVersionInfoPanel$$static extends ClassLike {
            new(): VMVersionInfoPanel;
          }
          let VMVersionInfoPanel: _VMVersionInfoPanel$$static;
          interface _VMVersionInfoPanel {
            _getVersionInfo(): string;
            _initUI(): void;
            _versionPane: javax.swing.JEditorPane;
          }
          interface VMVersionInfoPanel extends CombineTypes<[_VMVersionInfoPanel, javax.swing.JPanel]> {}
        }
        module utilities {
          module memo {
            interface _MemoizedBoolean$$static extends ClassLike {
              new(): MemoizedBoolean;
            }
            let MemoizedBoolean: _MemoizedBoolean$$static;
            interface _MemoizedBoolean {
              _computeValue(): boolean;
(): boolean;
              getValue(): boolean;
              _computed: boolean;
              _value: boolean;
            }
            interface MemoizedBoolean extends CombineTypes<[_MemoizedBoolean, java.lang.Object]> {}
            interface _MemoizedByte$$static extends ClassLike {
              new(): MemoizedByte;
            }
            let MemoizedByte: _MemoizedByte$$static;
            interface _MemoizedByte {
              _computeValue(): byte;
(): byte;
              getValue(): byte;
              _computed: boolean;
              _value: byte;
            }
            interface MemoizedByte extends CombineTypes<[_MemoizedByte, java.lang.Object]> {}
            interface _MemoizedChar$$static extends ClassLike {
              new(): MemoizedChar;
            }
            let MemoizedChar: _MemoizedChar$$static;
            interface _MemoizedChar {
              _computeValue(): char;
(): char;
              getValue(): char;
              _computed: boolean;
              _value: char;
            }
            interface MemoizedChar extends CombineTypes<[_MemoizedChar, java.lang.Object]> {}
            interface _MemoizedDouble$$static extends ClassLike {
              new(): MemoizedDouble;
            }
            let MemoizedDouble: _MemoizedDouble$$static;
            interface _MemoizedDouble {
              _computeValue(): double;
(): double;
              getValue(): double;
              _computed: boolean;
              _value: double;
            }
            interface MemoizedDouble extends CombineTypes<[_MemoizedDouble, java.lang.Object]> {}
            interface _MemoizedFloat$$static extends ClassLike {
              new(): MemoizedFloat;
            }
            let MemoizedFloat: _MemoizedFloat$$static;
            interface _MemoizedFloat {
              _computeValue(): float;
(): float;
              getValue(): float;
              _computed: boolean;
              _value: float;
            }
            interface MemoizedFloat extends CombineTypes<[_MemoizedFloat, java.lang.Object]> {}
            interface _MemoizedInt$$static extends ClassLike {
              new(): MemoizedInt;
            }
            let MemoizedInt: _MemoizedInt$$static;
            interface _MemoizedInt {
              _computeValue(): int;
(): int;
              getValue(): int;
              _computed: boolean;
              _value: int;
            }
            interface MemoizedInt extends CombineTypes<[_MemoizedInt, java.lang.Object]> {}
            interface _MemoizedLong$$static extends ClassLike {
              new(): MemoizedLong;
            }
            let MemoizedLong: _MemoizedLong$$static;
            interface _MemoizedLong {
              _computeValue(): long;
(): long;
              getValue(): long;
              _computed: boolean;
              _value: long;
            }
            interface MemoizedLong extends CombineTypes<[_MemoizedLong, java.lang.Object]> {}
            interface _MemoizedObject$$static extends ClassLike {
              new(): MemoizedObject;
            }
            let MemoizedObject: _MemoizedObject$$static;
            interface _MemoizedObject {
              _computeValue(): any;
(): any;
              getValue(): any;
              _computed: boolean;
              _value: any;
            }
            interface MemoizedObject extends CombineTypes<[_MemoizedObject, java.lang.Object]> {}
            interface _MemoizedShort$$static extends ClassLike {
              new(): MemoizedShort;
            }
            let MemoizedShort: _MemoizedShort$$static;
            interface _MemoizedShort {
              _computeValue(): short;
(): short;
              getValue(): short;
              _computed: boolean;
              _value: short;
            }
            interface MemoizedShort extends CombineTypes<[_MemoizedShort, java.lang.Object]> {}
          }
          interface _AbstractHeapGraphWriter$$static extends ClassLike {
            new(): AbstractHeapGraphWriter;
          }
          let AbstractHeapGraphWriter: _AbstractHeapGraphWriter$$static;
          interface _AbstractHeapGraphWriter {
            _calculateOopDumpRecordSize(a0: hotspot.oops.Oop): int;
(a0: hotspot.oops.Oop): int;
            _handleRuntimeException(re: java.lang.RuntimeException): void;
            _isJavaVisible(oop: hotspot.oops.Oop): boolean;
            _write(): void;
            _writeBooleanField(oop: hotspot.oops.Oop, field: hotspot.oops.BooleanField): void;
            _writeByteField(oop: hotspot.oops.Oop, field: hotspot.oops.ByteField): void;
            _writeCharField(oop: hotspot.oops.Oop, field: hotspot.oops.CharField): void;
            _writeClass(instance: hotspot.oops.Instance): void;
            _writeDoubleField(oop: hotspot.oops.Oop, field: hotspot.oops.DoubleField): void;
            _writeFloatField(oop: hotspot.oops.Oop, field: hotspot.oops.FloatField): void;
            _writeGlobalJNIHandle(handleAddr: hotspot.debugger.Address): void;
            _writeGlobalJNIHandles(): void;
            _writeHeapFooter(): void;
            _writeHeapHeader(): void;
            _writeHeapRecordEpilogue(): void;
            _writeHeapRecordPrologue(): void;
            _writeHeapRecordPrologue(size: int): void;
            _writeInstance(instance: hotspot.oops.Instance): void;
            _writeIntField(oop: hotspot.oops.Oop, field: hotspot.oops.IntField): void;
            _writeInternalObject(oop: hotspot.oops.Oop): void;
            _writeJavaThread(jt: hotspot.runtime.JavaThread, index: int): void;
            _writeJavaThreads(): void;
            _writeLongField(oop: hotspot.oops.Oop, field: hotspot.oops.LongField): void;
            _writeObject(oop: hotspot.oops.Oop): void;
            _writeObjectArray(array: hotspot.oops.ObjArray): void;
            _writeObjectFields(oop: hotspot.oops.Oop): void;
            _writeObjectFields(oop: hotspot.oops.InstanceKlass): void;
            _writeObjectFooter(oop: hotspot.oops.Oop): void;
            _writeObjectHeader(oop: hotspot.oops.Oop): void;
            _writePrimitiveArray(array: hotspot.oops.TypeArray): void;
            _writeReferenceField(oop: hotspot.oops.Oop, field: hotspot.oops.OopField): void;
            _writeShortField(oop: hotspot.oops.Oop, field: hotspot.oops.ShortField): void;
            _writeString(instance: hotspot.oops.Instance): void;
            _writeThread(instance: hotspot.oops.Instance): void;
            _javaLangClass: string;
            _javaLangString: string;
            _javaLangThread: string;
          }
          interface AbstractHeapGraphWriter extends CombineTypes<[_AbstractHeapGraphWriter, java.lang.Object, sun.jvm.hotspot.utilities.HeapGraphWriter]> {}
          interface _AddressOps$$static extends ClassLike {
            equal(a1: hotspot.debugger.Address, a2: hotspot.debugger.Address): boolean;
            greaterThan(a1: hotspot.debugger.Address, a2: hotspot.debugger.Address): boolean;
            greaterThanOrEqual(a1: hotspot.debugger.Address, a2: hotspot.debugger.Address): boolean;
            gt(a1: hotspot.debugger.Address, a2: hotspot.debugger.Address): boolean;
            gte(a1: hotspot.debugger.Address, a2: hotspot.debugger.Address): boolean;
            lessThan(a1: hotspot.debugger.Address, a2: hotspot.debugger.Address): boolean;
            lessThanOrEqual(a1: hotspot.debugger.Address, a2: hotspot.debugger.Address): boolean;
            lt(a1: hotspot.debugger.Address, a2: hotspot.debugger.Address): boolean;
            lte(a1: hotspot.debugger.Address, a2: hotspot.debugger.Address): boolean;
            max(a1: hotspot.debugger.Address, a2: hotspot.debugger.Address): hotspot.debugger.Address;
            min(a1: hotspot.debugger.Address, a2: hotspot.debugger.Address): hotspot.debugger.Address;
            new(): AddressOps;
          }
          let AddressOps: _AddressOps$$static;
          interface _AddressOps {
          }
          interface AddressOps extends CombineTypes<[_AddressOps, java.lang.Object]> {}
          interface _AltPlatformInfo$$static extends ClassLike {
          }
          let AltPlatformInfo: _AltPlatformInfo$$static;
          interface _AltPlatformInfo {
            getCPU(a0: string): string;
            knownCPU(a0: string): boolean;
          }
          interface AltPlatformInfo extends CombineTypes<[_AltPlatformInfo, java.lang.Object]> {}
          interface _Assert$$static extends ClassLike {
            that(test: boolean, message: string): void;
            ASSERTS_ENABLED: boolean;
            new(): Assert;
          }
          let Assert: _Assert$$static;
          interface _Assert {
          }
          interface Assert extends CombineTypes<[_Assert, java.lang.Object]> {}
          interface _AssertionFailure$$static extends ClassLike {
            new(): AssertionFailure;
            new(message: string): AssertionFailure;
          }
          let AssertionFailure: _AssertionFailure$$static;
          interface _AssertionFailure {
          }
          interface AssertionFailure extends CombineTypes<[_AssertionFailure, java.lang.RuntimeException]> {}
          interface _BitMap$$static extends ClassLike {
            _bitsPerWord: int;
            _bytesPerWord: int;
            new(sizeInBits: int): BitMap;
          }
          let BitMap: _BitMap$$static;
          interface _BitMap {
            at(offset: int): boolean;
            atPut(offset: int, value: boolean): void;
            _bitInWord(offset: int): int;
            clear(): void;
            getNextOneOffset(l_offset: int, r_offset: int): int;
            _indexFor(offset: int): int;
            isSame(other: BitMap): boolean;
            iterate(blk: BitMapClosure): void;
            setDifference(other: BitMap): boolean;
            setFrom(other: BitMap): void;
            setIntersection(other: BitMap): void;
            setUnion(other: BitMap): boolean;
            set_map(addr: hotspot.debugger.Address): void;
            set_size(value: int): void;
            size(): int;
            _sizeInWords(): int;
            _wordFor(offset: int): int;
            _data: int[];
            _size: int;
          }
          interface BitMap extends CombineTypes<[_BitMap, java.lang.Object]> {}
          interface _BitMapClosure$$static extends ClassLike {
          }
          let BitMapClosure: _BitMapClosure$$static;
          interface _BitMapClosure {
            doBit(a0: int): void;
(a0: int): void;
          }
          interface BitMapClosure extends CombineTypes<[_BitMapClosure, java.lang.Object]> {}
          interface _BitMapInterface$$static extends ClassLike {
          }
          let BitMapInterface: _BitMapInterface$$static;
          interface _BitMapInterface {
            at(a0: long): boolean;
            atPut(a0: long, a1: boolean): void;
            clear(): void;
          }
          interface BitMapInterface extends CombineTypes<[_BitMapInterface, java.lang.Object]> {}
          interface _BitMapSegmented$$static extends ClassLike {
            _SegmentSize: int;
            _SegmentSizeBits: int;
            new(sizeInBits: long): BitMapSegmented;
          }
          let BitMapSegmented: _BitMapSegmented$$static;
          interface _BitMapSegmented {
            at(offset: long): boolean;
            atPut(offset: long, a1: boolean): void;
            clear(): void;
            _segmentIndex(offset: long): int;
            _segmentOffset(offset: long): int;
            size(): long;
            _segmentBitMaps: BitMap[];
            _size: long;
          }
          interface BitMapSegmented extends CombineTypes<[_BitMapSegmented, sun.jvm.hotspot.utilities.BitMapInterface, java.lang.Object]> {}
          interface _Bits$$static extends ClassLike {
            clearBits(x: int, m: int): int;
            clearNthBit(x: int, n: int): int;
            isSetNthBit(word: int, n: int): boolean;
            maskBits(x: int, m: int): int;
            maskBitsLong(x: long, a1: long): long;
            nthBit(n: int): int;
            rightNBits(n: int): int;
            roundTo(x: int, s: int): int;
            setBits(x: int, m: int): int;
            setNthBit(x: int, n: int): int;
            readonly AllBits: int;
            readonly BitsPerByte: int;
            readonly BitsPerInt: int;
            readonly LogBytesPerInt: int;
            readonly LogBytesPerLong: int;
            readonly NoBits: int;
            readonly OneBit: int;
            new(): Bits;
          }
          let Bits: _Bits$$static;
          interface _Bits {
          }
          interface Bits extends CombineTypes<[_Bits, java.lang.Object]> {}
          interface _CPPExpressions$$static extends ClassLike {
            parseCast(expr: string): CPPExpressions$CastExpr;
            parseStaticField(expr: string): CPPExpressions$StaticFieldExpr;
            _castPattern: java.util.regex.Pattern;
            new(): CPPExpressions;
          }
          let CPPExpressions: _CPPExpressions$$static;
          interface _CPPExpressions {
          }
          interface CPPExpressions extends CombineTypes<[_CPPExpressions, java.lang.Object]> {}
          interface _CPPExpressions$CastExpr$$static extends ClassLike {
          }
          let CPPExpressions$CastExpr: _CPPExpressions$CastExpr$$static;
          interface _CPPExpressions$CastExpr {
            getAddress(): string;
            getType(): string;
            _address: string;
            _type: string;
          }
          interface CPPExpressions$CastExpr extends CombineTypes<[_CPPExpressions$CastExpr, java.lang.Object]> {}
          interface _CPPExpressions$StaticFieldExpr$$static extends ClassLike {
          }
          let CPPExpressions$StaticFieldExpr: _CPPExpressions$StaticFieldExpr$$static;
          interface _CPPExpressions$StaticFieldExpr {
            getContainingType(): string;
            getFieldName(): string;
            _containingType: string;
            _fieldName: string;
          }
          interface CPPExpressions$StaticFieldExpr extends CombineTypes<[_CPPExpressions$StaticFieldExpr, java.lang.Object]> {}
          interface _CStringUtilities$$static extends ClassLike {
            getString(addr: hotspot.debugger.Address): string;
            getString(addr: hotspot.debugger.Address, charset: java.nio.charset.Charset): string;
            getStringLength(addr: hotspot.debugger.Address): int;
            _encoding: string;
            new(): CStringUtilities;
          }
          let CStringUtilities: _CStringUtilities$$static;
          interface _CStringUtilities {
          }
          interface CStringUtilities extends CombineTypes<[_CStringUtilities, java.lang.Object]> {}
          interface _CompactHashTable$$static extends ClassLike {
            _initialize(db: hotspot.types.TypeDataBase): void;
            _BUCKET_OFFSET_MASK: int;
            _BUCKET_TYPE_SHIFT: int;
            _VALUE_ONLY_BUCKET_TYPE: int;
            _baseAddressField: hotspot.types.AddressField;
            _bucketCountField: hotspot.types.CIntegerField;
            _bucketsField: hotspot.types.AddressField;
            _entriesField: hotspot.types.AddressField;
            _entryCountField: hotspot.types.CIntegerField;
            _uintSize: long;
            new(addr: hotspot.debugger.Address): CompactHashTable;
          }
          let CompactHashTable: _CompactHashTable$$static;
          interface _CompactHashTable {
            _bucketCount(): int;
            _bucketOffset(bucket_info: int): int;
            _isValueOnlyBucket(bucket_info: int): boolean;
            probe(name: byte[], hash: long): hotspot.oops.Symbol;
            symbolsDo(visitor: CompactHashTable$SymbolVisitor): void;
          }
          interface CompactHashTable extends CombineTypes<[_CompactHashTable, sun.jvm.hotspot.runtime.VMObject]> {}
          interface _CompactHashTable$SymbolVisitor$$static extends ClassLike {
          }
          let CompactHashTable$SymbolVisitor: _CompactHashTable$SymbolVisitor$$static;
          interface _CompactHashTable$SymbolVisitor {
            visit(a0: hotspot.oops.Symbol): void;
(a0: hotspot.oops.Symbol): void;
          }
          interface CompactHashTable$SymbolVisitor extends CombineTypes<[_CompactHashTable$SymbolVisitor, java.lang.Object]> {}
          interface _ConstIterator$$static extends ClassLike {
            new(iter: java.util.Iterator): ConstIterator;
          }
          let ConstIterator: _ConstIterator$$static;
          interface _ConstIterator {
            hasNext(): boolean;
            next(): any;
            remove(): void;
            _iter: java.util.Iterator;
          }
          interface ConstIterator extends CombineTypes<[_ConstIterator, java.util.Iterator, java.lang.Object]> {}
          interface _ConstantTag$$static extends ClassLike {
            _JVM_CONSTANT_Class: int;
            _JVM_CONSTANT_ClassIndex: int;
            _JVM_CONSTANT_Double: int;
            _JVM_CONSTANT_Dynamic: int;
            _JVM_CONSTANT_Fieldref: int;
            _JVM_CONSTANT_Float: int;
            _JVM_CONSTANT_Integer: int;
            _JVM_CONSTANT_InterfaceMethodref: int;
            _JVM_CONSTANT_Invalid: int;
            _JVM_CONSTANT_InvokeDynamic: int;
            _JVM_CONSTANT_Long: int;
            _JVM_CONSTANT_MethodHandle: int;
            _JVM_CONSTANT_MethodHandleInError: int;
            _JVM_CONSTANT_MethodType: int;
            _JVM_CONSTANT_MethodTypeInError: int;
            _JVM_CONSTANT_Methodref: int;
            _JVM_CONSTANT_NameAndType: int;
            _JVM_CONSTANT_String: int;
            _JVM_CONSTANT_StringIndex: int;
            _JVM_CONSTANT_Unicode: int;
            _JVM_CONSTANT_UnresolvedClass: int;
            _JVM_CONSTANT_UnresolvedClassInError: int;
            _JVM_CONSTANT_Utf8: int;
            _JVM_REF_getField: int;
            _JVM_REF_getStatic: int;
            _JVM_REF_invokeInterface: int;
            _JVM_REF_invokeSpecial: int;
            _JVM_REF_invokeStatic: int;
            _JVM_REF_invokeVirtual: int;
            _JVM_REF_newInvokeSpecial: int;
            _JVM_REF_putField: int;
            _JVM_REF_putStatic: int;
            new(tag: byte): ConstantTag;
          }
          let ConstantTag: _ConstantTag$$static;
          interface _ConstantTag {
            basicType(): hotspot.runtime.BasicType;
            isDouble(): boolean;
            isDynamicConstant(): boolean;
            isField(): boolean;
            isFieldOrMethod(): boolean;
            isFloat(): boolean;
            isInt(): boolean;
            isInterfaceMethod(): boolean;
            isInvalid(): boolean;
            isInvokeDynamic(): boolean;
            isKlass(): boolean;
            isKlassIndex(): boolean;
            isKlassReference(): boolean;
            isLong(): boolean;
            isMethod(): boolean;
            isMethodHandle(): boolean;
            isMethodType(): boolean;
            isNameAndType(): boolean;
            isString(): boolean;
            isStringIndex(): boolean;
            isSymbol(): boolean;
            isUnresolveKlassInError(): boolean;
            isUnresolvedKlass(): boolean;
            isUtf8(): boolean;
            toString(): string;
            value(): int;
            _tag: byte;
          }
          interface ConstantTag extends CombineTypes<[_ConstantTag, java.lang.Object]> {}
          interface _FindObjectByType$$static extends ClassLike {
            new(type: hotspot.oops.Klass): FindObjectByType;
          }
          let FindObjectByType: _FindObjectByType$$static;
          interface _FindObjectByType {
            doObj(obj: hotspot.oops.Oop): boolean;
            epilogue(): void;
            getResults(): java.util.List<hotspot.oops.Oop>;
            prologue(size: long): void;
            _results: java.util.List<hotspot.oops.Oop>;
            _type: hotspot.oops.Klass;
          }
          interface FindObjectByType extends CombineTypes<[_FindObjectByType, java.lang.Object, sun.jvm.hotspot.oops.HeapVisitor]> {}
          interface _GenericArray$$static extends ClassLike {
            _initialize(db: hotspot.types.TypeDataBase): void;
            _lengthField: hotspot.oops.CIntField;
            _sizeOfArray: long;
            new(addr: hotspot.debugger.Address, dataOffset: long): GenericArray;
          }
          let GenericArray: _GenericArray$$static;
          interface _GenericArray {
            _byteSizeof(length: int): long;
            _getAddressAt(index: int): hotspot.debugger.Address;
            getDataStart(): hotspot.debugger.Address;
            getElemType(): hotspot.types.Type;
(): hotspot.types.Type;
            _getIntegerAt(index: int): long;
            getLength(): int;
            getSize(): long;
            length(): int;
            _dataFieldOffset: long;
          }
          interface GenericArray extends CombineTypes<[_GenericArray, sun.jvm.hotspot.runtime.VMObject]> {}
          interface _GenericGrowableArray$$static extends ClassLike {
            _initialize(db: hotspot.types.TypeDataBase): void;
            __capacity_field: hotspot.oops.CIntField;
            __len_field: hotspot.oops.CIntField;
            new(addr: hotspot.debugger.Address): GenericGrowableArray;
          }
          let GenericGrowableArray: _GenericGrowableArray$$static;
          interface _GenericGrowableArray {
            capacity(): int;
            length(): int;
          }
          interface GenericGrowableArray extends CombineTypes<[_GenericGrowableArray, sun.jvm.hotspot.runtime.VMObject]> {}
          interface _GrowableArray$$static<T> extends ClassLike {
            create<S>(addr: hotspot.debugger.Address, v: hotspot.runtime.InstanceConstructor<S>): GrowableArray<S>;
            _initialize(db: hotspot.types.TypeDataBase): void;
            _dataField: hotspot.types.AddressField;
          }
          let GrowableArray: _GrowableArray$$static<T>;
          interface _GrowableArray<T> {
            at(i: int): T;
            getData(): hotspot.debugger.Address;
            _virtualConstructor: hotspot.runtime.InstanceConstructor<T>;
          }
          interface GrowableArray<T> extends CombineTypes<[_GrowableArray<T>, GenericGrowableArray]> {}
          interface _HeapGXLWriter$$static extends ClassLike {
            _escapeXMLChars(s: string): string;
            _getID(oop: hotspot.oops.Oop): string;
            _identifierToXMLName(name: string): string;
            _ENCODING: string;
            new(): HeapGXLWriter;
          }
          let HeapGXLWriter: _HeapGXLWriter$$static;
          interface _HeapGXLWriter {
            _calculateOopDumpRecordSize(oop: hotspot.oops.Oop): int;
            write(fileName: string): void;
            _writeArrayLength(array: hotspot.oops.Array): void;
            _writeAttribute(name: string, type: string, value: string): void;
            _writeBooleanField(oop: hotspot.oops.Oop, field: hotspot.oops.BooleanField): void;
            _writeByteField(oop: hotspot.oops.Oop, field: hotspot.oops.ByteField): void;
            _writeCharField(oop: hotspot.oops.Oop, field: hotspot.oops.CharField): void;
            _writeClass(instance: hotspot.oops.Instance): void;
            _writeDoubleField(oop: hotspot.oops.Oop, field: hotspot.oops.DoubleField): void;
            _writeEdge(from: hotspot.oops.Oop, to: hotspot.oops.Oop, name: string): void;
            _writeField(field: hotspot.oops.Field, type: string, kind: string, value: string): void;
            _writeFloatField(oop: hotspot.oops.Oop, field: hotspot.oops.FloatField): void;
            _writeHeapFooter(): void;
            _writeHeapHeader(): void;
            _writeIntField(oop: hotspot.oops.Oop, field: hotspot.oops.IntField): void;
            _writeLongField(oop: hotspot.oops.Oop, field: hotspot.oops.LongField): void;
            _writeObjectArray(array: hotspot.oops.ObjArray): void;
            _writeObjectFooter(oop: hotspot.oops.Oop): void;
            _writeObjectHeader(oop: hotspot.oops.Oop): void;
            _writePrimitiveArray(array: hotspot.oops.TypeArray): void;
            _writeReferenceField(oop: hotspot.oops.Oop, field: hotspot.oops.OopField): void;
            _writeShortField(oop: hotspot.oops.Oop, field: hotspot.oops.ShortField): void;
            _writeVMInfo(): void;
            _isArray: boolean;
            _out: java.io.PrintWriter;
            _refFields: java.util.List<hotspot.oops.OopField>;
          }
          interface HeapGXLWriter extends CombineTypes<[_HeapGXLWriter, sun.jvm.hotspot.utilities.AbstractHeapGraphWriter]> {}
          interface _HeapGraphWriter$$static extends ClassLike {
          }
          let HeapGraphWriter: _HeapGraphWriter$$static;
          interface _HeapGraphWriter {
            write(a0: string): void;
(a0: string): void;
          }
          interface HeapGraphWriter extends CombineTypes<[_HeapGraphWriter, java.lang.Object]> {}
          interface _HeapHprofBinWriter$$static extends ClassLike {
            _genByteArrayFromInt(value: int): byte[];
            _getInstanceFields(ik: hotspot.oops.InstanceKlass): java.util.List<hotspot.oops.Field>;
            signatureToHprofKind(ch: char): int;
            _DUMMY_STACK_TRACE_ID: int;
            _EMPTY_FRAME_DEPTH: int;
            _HPROF_ALLOC_SITES: int;
            _HPROF_ARRAY_OBJECT: int;
            _HPROF_BOOLEAN: int;
            _HPROF_BYTE: int;
            _HPROF_CHAR: int;
            _HPROF_CONTROL_SETTINGS: int;
            _HPROF_CPU_SAMPLES: int;
            _HPROF_DOUBLE: int;
            _HPROF_END_THREAD: int;
            _HPROF_FLOAT: int;
            _HPROF_FRAME: int;
            _HPROF_GC_CLASS_DUMP: int;
            _HPROF_GC_INSTANCE_DUMP: int;
            _HPROF_GC_OBJ_ARRAY_DUMP: int;
            _HPROF_GC_PRIM_ARRAY_DUMP: int;
            _HPROF_GC_ROOT_JAVA_FRAME: int;
            _HPROF_GC_ROOT_JNI_GLOBAL: int;
            _HPROF_GC_ROOT_JNI_LOCAL: int;
            _HPROF_GC_ROOT_MONITOR_USED: int;
            _HPROF_GC_ROOT_NATIVE_STACK: int;
            _HPROF_GC_ROOT_STICKY_CLASS: int;
            _HPROF_GC_ROOT_THREAD_BLOCK: int;
            _HPROF_GC_ROOT_THREAD_OBJ: int;
            _HPROF_GC_ROOT_UNKNOWN: int;
            _HPROF_HEADER_1_0_2: string;
            _HPROF_HEAP_DUMP: int;
            _HPROF_HEAP_DUMP_END: int;
            _HPROF_HEAP_DUMP_SEGMENT: int;
            _HPROF_HEAP_SUMMARY: int;
            _HPROF_INT: int;
            _HPROF_LOAD_CLASS: int;
            _HPROF_LONG: int;
            _HPROF_NORMAL_OBJECT: int;
            _HPROF_SEGMENTED_HEAP_DUMP_SEGMENT_SIZE: long;
            _HPROF_SEGMENTED_HEAP_DUMP_THRESHOLD: long;
            _HPROF_SHORT: int;
            _HPROF_START_THREAD: int;
            _HPROF_TRACE: int;
            _HPROF_UNLOAD_CLASS: int;
            _HPROF_UTF8: int;
            _JVM_SIGNATURE_ARRAY: int;
            _JVM_SIGNATURE_BOOLEAN: int;
            _JVM_SIGNATURE_BYTE: int;
            _JVM_SIGNATURE_CHAR: int;
            _JVM_SIGNATURE_CLASS: int;
            _JVM_SIGNATURE_DOUBLE: int;
            _JVM_SIGNATURE_FLOAT: int;
            _JVM_SIGNATURE_INT: int;
            _JVM_SIGNATURE_LONG: int;
            _JVM_SIGNATURE_SHORT: int;
            _MAX_U4_VALUE: long;
            new(): HeapHprofBinWriter;
            new(gzLevel: int): HeapHprofBinWriter;
          }
          let HeapHprofBinWriter: _HeapHprofBinWriter$$static;
          interface _HeapHprofBinWriter {
            _calculateArrayMaxLength(originalArrayLength: long, a1: int, headerSize: long, typeSize: string): int;
            _calculateClassDumpRecordSize(k: hotspot.oops.Klass): int;
            _calculateClassInstanceDumpRecordSize(instance: hotspot.oops.Instance): int;
            _calculateFieldDescriptorsDumpRecordSize(fields: java.util.List<hotspot.oops.Field>, ik: hotspot.oops.InstanceKlass): int;
            _calculateInstanceDumpRecordSize(instance: hotspot.oops.Instance): int;
            _calculateObjectArrayDumpRecordSize(array: hotspot.oops.ObjArray): int;
            _calculateOopDumpRecordSize(oop: hotspot.oops.Oop): int;
            _calculatePrimitiveArrayDumpRecordSize(array: hotspot.oops.TypeArray): int;
            _dumpStackFrame(frameSN: int, classSN: int, m: hotspot.oops.Method, bci: int): void;
            _dumpStackTraces(): void;
            _fillInHeapRecordLength(): void;
            _getAddressValue(addr: hotspot.debugger.Address): long;
            _getArrayHeaderSize(isObjectAarray: boolean): int;
            _getSizeForField(field: hotspot.oops.Field): int;
            _getSizeForFields(fields: java.util.List<hotspot.oops.Field>): int;
            _getSizeForType(type: int): int;
            _isCompression(): boolean;
            write(fileName: string): void;
            _writeBooleanArray(array: hotspot.oops.TypeArray, length: int): void;
            _writeByteArray(array: hotspot.oops.TypeArray, length: int): void;
            _writeCharArray(array: hotspot.oops.TypeArray, length: int): void;
            _writeClass(instance: hotspot.oops.Instance): void;
            _writeClassDumpRecord(k: hotspot.oops.Klass): void;
            _writeClassDumpRecords(): void;
            _writeClassSymbols(k: hotspot.oops.Klass): void;
            _writeClasses(): void;
            _writeDoubleArray(array: hotspot.oops.TypeArray, length: int): void;
            _writeDummyTrace(): void;
            _writeField(field: hotspot.oops.Field, oop: hotspot.oops.Oop): void;
            _writeFieldDescriptors(fields: java.util.List<hotspot.oops.Field>, ik: hotspot.oops.InstanceKlass): void;
            _writeFileHeader(): void;
            _writeFloatArray(array: hotspot.oops.TypeArray, length: int): void;
            _writeGlobalJNIHandle(handleAddr: hotspot.debugger.Address): void;
            _writeHeader(tag: int, len: int): void;
            _writeHeapRecordPrologue(size: int): void;
            _writeInstance(instance: hotspot.oops.Instance): void;
            _writeIntArray(array: hotspot.oops.TypeArray, length: int): void;
            _writeJavaThread(jt: hotspot.runtime.JavaThread, index: int): void;
            _writeLocalJNIHandles(jt: hotspot.runtime.JavaThread, index: int): void;
            _writeLongArray(array: hotspot.oops.TypeArray, length: int): void;
            _writeObjectArray(array: hotspot.oops.ObjArray): void;
            _writeObjectID(oop: hotspot.oops.Oop): void;
            _writeObjectID(address: long): void;
            _writePrimitiveArray(array: hotspot.oops.TypeArray): void;
            _writeShortArray(array: hotspot.oops.TypeArray, length: int): void;
            _writeSymbol(sym: hotspot.oops.Symbol): void;
            _writeSymbolID(sym: hotspot.oops.Symbol): void;
            _writeSymbols(): void;
            _BOOLEAN_BASE_OFFSET: long;
            _BOOLEAN_SIZE: int;
            _BYTE_BASE_OFFSET: long;
            _BYTE_SIZE: int;
            _CHAR_BASE_OFFSET: long;
            _CHAR_SIZE: int;
            _DOUBLE_BASE_OFFSET: long;
            _DOUBLE_SIZE: int;
            _FLOAT_BASE_OFFSET: long;
            _FLOAT_SIZE: int;
            _INT_BASE_OFFSET: long;
            _INT_SIZE: int;
            _KlassMap: java.util.ArrayList<hotspot.oops.Klass>;
            _LONG_BASE_OFFSET: long;
            _LONG_SIZE: int;
            _OBJECT_BASE_OFFSET: long;
            _OBJ_ID_SIZE: int;
            _SHORT_BASE_OFFSET: long;
            _SHORT_SIZE: int;
            _classDataCache: java.util.Map<hotspot.oops.InstanceKlass,HeapHprofBinWriter$ClassData>;
            _currentSegmentStart: long;
            _dbg: hotspot.debugger.Debugger;
            _fos: java.io.FileOutputStream;
            _gzLevel: int;
            _hprofBufferedOut: java.io.OutputStream;
            _names: java.util.HashSet<hotspot.oops.Symbol>;
            _objectHeap: hotspot.oops.ObjectHeap;
            _out: java.io.DataOutputStream;
            _serialNum: int;
            _useSegmentedHeapDump: boolean;
          }
          interface HeapHprofBinWriter extends CombineTypes<[_HeapHprofBinWriter, sun.jvm.hotspot.utilities.AbstractHeapGraphWriter]> {}
          interface _HeapHprofBinWriter$ClassData$$static extends ClassLike {
            _new(instSize: int, fields: java.util.List<hotspot.oops.Field>): HeapHprofBinWriter$ClassData;
          }
          let HeapHprofBinWriter$ClassData: _HeapHprofBinWriter$ClassData$$static;
          interface _HeapHprofBinWriter$ClassData {
            _fields: java.util.List<hotspot.oops.Field>;
            _instSize: int;
          }
          interface HeapHprofBinWriter$ClassData extends CombineTypes<[_HeapHprofBinWriter$ClassData, java.lang.Object]> {}
          interface _HeapProgressThunk$$static extends ClassLike {
          }
          let HeapProgressThunk: _HeapProgressThunk$$static;
          interface _HeapProgressThunk {
            heapIterationComplete(): void;
            heapIterationFractionUpdate(a0: double): void;
          }
          interface HeapProgressThunk extends CombineTypes<[_HeapProgressThunk, java.lang.Object]> {}
          interface _IntArray$$static extends ClassLike {
            _initialize(db: hotspot.types.TypeDataBase): void;
            _dataFieldOffset: long;
            _elemType: hotspot.types.Type;
            new(addr: hotspot.debugger.Address): IntArray;
          }
          let IntArray: _IntArray$$static;
          interface _IntArray {
            at(i: int): int;
            getElemType(): hotspot.types.Type;
          }
          interface IntArray extends CombineTypes<[_IntArray, sun.jvm.hotspot.utilities.GenericArray]> {}
          interface _IntegerEnum$$static extends ClassLike {
            _new(value: int): IntegerEnum;
          }
          let IntegerEnum: _IntegerEnum$$static;
          interface _IntegerEnum {
            getValue(): int;
            _value: int;
          }
          interface IntegerEnum extends CombineTypes<[_IntegerEnum, java.lang.Object]> {}
          interface _Interval$$static extends ClassLike {
            new(lowEndpoint: any, highEndpoint: any): Interval;
          }
          let Interval: _Interval$$static;
          interface _Interval {
            getHighEndpoint(): any;
            getLowEndpoint(): any;
            overlaps(arg: Interval, endpointComparator: java.util.Comparator<any>): boolean;
            overlaps(otherLowEndpoint: any, otherHighEndpoint: any, endpointComparator: java.util.Comparator<any>): boolean;
            toString(): string;
            _highEndpoint: any;
            _lowEndpoint: any;
          }
          interface Interval extends CombineTypes<[_Interval, java.lang.Object]> {}
          interface _IntervalNode$$static extends ClassLike {
            new(interval: Interval, endpointComparator: java.util.Comparator<any>, data: any): IntervalNode;
          }
          let IntervalNode: _IntervalNode$$static;
          interface _IntervalNode {
            computeMaxEndpoint(): any;
            computeMinEndpoint(): any;
            copyFrom(arg: RBNode): void;
            getInterval(): Interval;
            getMaxEndpoint(): any;
            getMinEndpoint(): any;
            toString(): string;
            update(): boolean;
            _endpointComparator: java.util.Comparator<any>;
            _interval: Interval;
            _maxEndpoint: any;
            _minEndpoint: any;
          }
          interface IntervalNode extends CombineTypes<[_IntervalNode, sun.jvm.hotspot.utilities.RBNode]> {}
          interface _IntervalTree$$static extends ClassLike {
            new(endpointComparator: java.util.Comparator<any>): IntervalTree;
          }
          let IntervalTree: _IntervalTree$$static;
          interface _IntervalTree {
            findAllNodesIntersecting(interval: Interval): java.util.List<IntervalNode>;
            _getNodeValue(node: RBNode): any;
            insert(interval: Interval, data: any): void;
            print(): void;
            _printFromNode(node: RBNode, tty: java.io.PrintStream, indentDepth: int): void;
            printOn(tty: java.io.PrintStream): void;
            _searchForIntersectingNodesFrom(node: IntervalNode, interval: Interval, resultList: java.util.List<IntervalNode>): void;
            _verify(): void;
            _verifyFromNode(node: RBNode): void;
            _endpointComparator: java.util.Comparator<any>;
          }
          interface IntervalTree extends CombineTypes<[_IntervalTree, sun.jvm.hotspot.utilities.RBTree]> {}
          interface _IntervalTree$IntervalComparator$$static extends ClassLike {
            new(endpointComparator: java.util.Comparator<any>): IntervalTree$IntervalComparator;
          }
          let IntervalTree$IntervalComparator: _IntervalTree$IntervalComparator$$static;
          interface _IntervalTree$IntervalComparator {
            compare(o1: any, o2: any): int;
            _endpointComparator: java.util.Comparator<any>;
          }
          interface IntervalTree$IntervalComparator extends CombineTypes<[_IntervalTree$IntervalComparator, java.util.Comparator<any>, java.lang.Object]> {}
          interface _KlassArray$$static extends ClassLike {
            _initialize(db: hotspot.types.TypeDataBase): void;
            _dataFieldOffset: long;
            _elemType: hotspot.types.Type;
            new(addr: hotspot.debugger.Address): KlassArray;
          }
          let KlassArray: _KlassArray$$static;
          interface _KlassArray {
            getAt(i: int): hotspot.oops.Klass;
            getElemType(): hotspot.types.Type;
          }
          interface KlassArray extends CombineTypes<[_KlassArray, sun.jvm.hotspot.utilities.GenericArray]> {}
          interface _LivenessAnalysis$$static extends ClassLike {
            computeAllLivenessPaths(target: hotspot.oops.Oop): LivenessPathList;
            _computeAllLivenessPaths(target: hotspot.oops.Oop, trimPathsThroughPopularObjects: boolean): LivenessPathList;
            _DEBUG: boolean;
          }
          let LivenessAnalysis: _LivenessAnalysis$$static;
          interface _LivenessAnalysis {
          }
          interface LivenessAnalysis extends CombineTypes<[_LivenessAnalysis, java.lang.Object]> {}
          interface _LivenessPath$$static extends ClassLike {
            _new(): LivenessPath;
          }
          let LivenessPath: _LivenessPath$$static;
          interface _LivenessPath {
            _copy(): LivenessPath;
            get(index: int): LivenessPathElement;
            _isComplete(): boolean;
            _peek(): LivenessPathElement;
            _pop(): void;
            printOn(tty: java.io.PrintStream): void;
            _push(el: LivenessPathElement): void;
            size(): int;
            _stack: java.util.Stack<LivenessPathElement>;
          }
          interface LivenessPath extends CombineTypes<[_LivenessPath, java.lang.Object]> {}
          interface _LivenessPathElement$$static extends ClassLike {
            _new(obj: hotspot.oops.Oop, id: hotspot.oops.FieldIdentifier): LivenessPathElement;
          }
          let LivenessPathElement: _LivenessPathElement$$static;
          interface _LivenessPathElement {
            getField(): hotspot.oops.FieldIdentifier;
            getObj(): hotspot.oops.Oop;
            isRoot(): boolean;
            isTerminal(): boolean;
            _id: hotspot.oops.FieldIdentifier;
            _obj: hotspot.oops.Oop;
          }
          interface LivenessPathElement extends CombineTypes<[_LivenessPathElement, java.lang.Object]> {}
          interface _LivenessPathList$$static extends ClassLike {
            new(): LivenessPathList;
          }
          let LivenessPathList: _LivenessPathList$$static;
          interface _LivenessPathList {
            _add(path: LivenessPath): void;
            get(i: int): LivenessPath;
            _remove(path: LivenessPath): void;
            size(): int;
            _list: java.util.ArrayList<LivenessPath>;
          }
          interface LivenessPathList extends CombineTypes<[_LivenessPathList, java.lang.Object]> {}
          interface _MarkBits$$static extends ClassLike {
            new(heap: hotspot.gc.shared.CollectedHeap): MarkBits;
          }
          let MarkBits: _MarkBits$$static;
          interface _MarkBits {
            clear(): void;
            clear(obj: hotspot.oops.Oop): void;
            mark(obj: hotspot.oops.Oop): boolean;
            _bits: BitMapInterface;
            _end: hotspot.debugger.Address;
            _start: hotspot.debugger.Address;
          }
          interface MarkBits extends CombineTypes<[_MarkBits, java.lang.Object]> {}
          interface _MessageQueue$$static extends ClassLike {
          }
          let MessageQueue: _MessageQueue$$static;
          interface _MessageQueue {
            readMessage(): any;
            readMessageWithTimeout(a0: long): any;
            writeMessage(a0: any): void;
          }
          interface MessageQueue extends CombineTypes<[_MessageQueue, java.lang.Object]> {}
          interface _MessageQueueBackend$$static extends ClassLike {
            new(): MessageQueueBackend;
          }
          let MessageQueueBackend: _MessageQueueBackend$$static;
          interface _MessageQueueBackend {
            getFirstQueue(): MessageQueue;
            getSecondQueue(): MessageQueue;
            _leftRightQueue: MessageQueueBackend$MessageQueueImpl;
            _rightLeftQueue: MessageQueueBackend$MessageQueueImpl;
          }
          interface MessageQueueBackend extends CombineTypes<[_MessageQueueBackend, java.lang.Object]> {}
          interface _MessageQueueBackend$MessageQueueImpl$$static extends ClassLike {
            new(a0: java.util.LinkedList<any>, listToReadFrom: java.util.LinkedList<any>): MessageQueueBackend$MessageQueueImpl;
          }
          let MessageQueueBackend$MessageQueueImpl: _MessageQueueBackend$MessageQueueImpl$$static;
          interface _MessageQueueBackend$MessageQueueImpl {
            readMessage(): any;
            readMessageWithTimeout(millis: long): any;
            writeMessage(obj: any): void;
            _readList: java.util.LinkedList<any>;
            _writeList: java.util.LinkedList<any>;
          }
          interface MessageQueueBackend$MessageQueueImpl extends CombineTypes<[_MessageQueueBackend$MessageQueueImpl, java.lang.Object, sun.jvm.hotspot.utilities.MessageQueue]> {}
          interface _MethodArray$$static extends ClassLike {
            _initialize(db: hotspot.types.TypeDataBase): void;
            _dataFieldOffset: long;
            _elemType: hotspot.types.Type;
            new(addr: hotspot.debugger.Address): MethodArray;
          }
          let MethodArray: _MethodArray$$static;
          interface _MethodArray {
            at(i: int): hotspot.oops.Method;
            getElemType(): hotspot.types.Type;
          }
          interface MethodArray extends CombineTypes<[_MethodArray, sun.jvm.hotspot.utilities.GenericArray]> {}
          interface _ObjectReader$$static extends ClassLike {
            _debugPrintStackTrace(exp: java.lang.Exception): void;
            _debugPrintln(msg: string): void;
            _DEBUG: boolean;
            new(cl: java.lang.ClassLoader): ObjectReader;
            new(): ObjectReader;
          }
          let ObjectReader: _ObjectReader$$static;
          interface _ObjectReader {
            _getDefaultPrimitiveValue(clz: java.lang.Class): any;
            _getFromObjTable(oop: hotspot.oops.Oop): any;
            _getFromObjTable(oop: hotspot.oops.Metadata): any;
            _getHashtable(oop: hotspot.oops.Instance): any;
            _getParamTypes(signature: hotspot.oops.Symbol): java.lang.Class[];
            _getProperties(oop: hotspot.oops.Instance): java.util.Properties;
            _isRobust(handle: hotspot.debugger.OopHandle): boolean;
            _javaLangString(): string;
            _javaUtilHashtable(): string;
            _javaUtilHashtableEntry(): string;
            _javaUtilProperties(): string;
            _putIntoObjTable(oop: hotspot.oops.Oop, obj: any): void;
            _putIntoObjTable(oop: hotspot.oops.Metadata, obj: any): void;
            readClass(kls: hotspot.oops.InstanceKlass): java.lang.Class;
            readConstructor(m: hotspot.oops.Method): java.lang.reflect.Constructor;
            readField(f: hotspot.oops.Field): java.lang.reflect.Field;
            readInstance(oop: hotspot.oops.Instance): any;
            readMethod(m: hotspot.oops.Method): java.lang.reflect.Method;
            readMethodOrConstructor(m: hotspot.oops.Method): any;
            readObject(oop: hotspot.oops.Oop): any;
            readObjectArray(array: hotspot.oops.ObjArray): any;
            readPrimitiveArray(array: hotspot.oops.TypeArray): any;
            _setHashtableEntry(p: java.util.Hashtable<any,any>, oop: hotspot.oops.Oop): void;
            _setPropertiesEntry(p: java.util.Properties, oop: hotspot.oops.Oop): void;
            _cl: java.lang.ClassLoader;
            _fieldMap: java.util.Map<hotspot.oops.Field,java.lang.reflect.Field>;
            _javaLangString: string;
            _javaUtilHashtable: string;
            _javaUtilHashtableEntry: string;
            _javaUtilProperties: string;
            _oopToObjMap: java.util.Map<any,any>;
          }
          interface ObjectReader extends CombineTypes<[_ObjectReader, java.lang.Object]> {}
          interface _ObjectReader$FieldSetter$$static extends ClassLike {
            new(this$0: ObjectReader, obj: any): ObjectReader$FieldSetter;
          }
          let ObjectReader$FieldSetter: _ObjectReader$FieldSetter$$static;
          interface _ObjectReader$FieldSetter {
            doBoolean(field: hotspot.oops.BooleanField, isVMField: boolean): void;
            doByte(field: hotspot.oops.ByteField, isVMField: boolean): void;
            doCInt(field: hotspot.oops.CIntField, isVMField: boolean): void;
            doChar(field: hotspot.oops.CharField, isVMField: boolean): void;
            doDouble(field: hotspot.oops.DoubleField, isVMField: boolean): void;
            doFloat(field: hotspot.oops.FloatField, isVMField: boolean): void;
            doInt(field: hotspot.oops.IntField, isVMField: boolean): void;
            doLong(field: hotspot.oops.LongField, isVMField: boolean): void;
            doOop(field: hotspot.oops.OopField, isVMField: boolean): void;
            doShort(field: hotspot.oops.ShortField, isVMField: boolean): void;
            _printFieldSetError(f: java.lang.reflect.Field, ex: java.lang.Exception): void;
            _obj: any;
            _this$0: ObjectReader;
          }
          interface ObjectReader$FieldSetter extends CombineTypes<[_ObjectReader$FieldSetter, sun.jvm.hotspot.oops.DefaultOopVisitor]> {}
          interface _ObjectReader$SignatureParser$$static extends ClassLike {
            new(this$0: ObjectReader, s: hotspot.oops.Symbol): ObjectReader$SignatureParser;
          }
          let ObjectReader$SignatureParser: _ObjectReader$SignatureParser$$static;
          interface _ObjectReader$SignatureParser {
            _arrayInnerBegin(begin: int): int;
            doArray(begin: int, end: int): void;
            doBool(): void;
            doByte(): void;
            doChar(): void;
            doDouble(): void;
            doFloat(): void;
            doInt(): void;
            doLong(): void;
            doObject(begin: int, end: int): void;
            doShort(): void;
            doVoid(): void;
            _getClass(begin: int, end: int): java.lang.Class;
            _getClassName(begin: int, end: int): string;
            getNumParams(): int;
            getParamTypes(): java.util.Enumeration;
            _this$0: ObjectReader;
            _tmp: java.util.Vector<java.lang.Class<any>>;
          }
          interface ObjectReader$SignatureParser extends CombineTypes<[_ObjectReader$SignatureParser, sun.jvm.hotspot.runtime.SignatureIterator]> {}
          interface _Observable$$static extends ClassLike {
            new(): Observable;
          }
          let Observable: _Observable$$static;
          interface _Observable {
          }
          interface Observable extends CombineTypes<[_Observable, java.util.Observable]> {}
          interface _Observer$$static extends ClassLike {
          }
          let Observer: _Observer$$static;
          interface _Observer {
            update(a0: Observable, a1: any): void;
(a0: Observable, a1: any): void;
          }
          interface Observer extends CombineTypes<[_Observer, java.lang.Object]> {}
          interface _PlatformInfo$$static extends ClassLike {
            getCPU(): string;
            getOS(): string;
            knownCPU(cpu: string): boolean;
            main(args: string[]): void;
            new(): PlatformInfo;
          }
          let PlatformInfo: _PlatformInfo$$static;
          interface _PlatformInfo {
          }
          interface PlatformInfo extends CombineTypes<[_PlatformInfo, java.lang.Object]> {}
          interface _PointerFinder$$static extends ClassLike {
            find(a: hotspot.debugger.Address): PointerLocation;
            new(): PointerFinder;
          }
          let PointerFinder: _PointerFinder$$static;
          interface _PointerFinder {
          }
          interface PointerFinder extends CombineTypes<[_PointerFinder, java.lang.Object]> {}
          interface _PointerLocation$$static extends ClassLike {
            new(addr: hotspot.debugger.Address): PointerLocation;
          }
          let PointerLocation: _PointerLocation$$static;
          interface _PointerLocation {
            getCodeBlob(): hotspot.code.CodeBlob;
            getGeneration(): hotspot.gc.shared.Generation;
            getInterpreterCodelet(): hotspot.interpreter.InterpreterCodelet;
            getJNIHandleBlock(): hotspot.runtime.JNIHandleBlock;
            getJNIHandleThread(): hotspot.runtime.Thread;
            getTLAB(): hotspot.runtime.ThreadLocalAllocBuffer;
            getTLABThread(): hotspot.runtime.JavaThread;
            inOtherGen(): boolean;
            isCtype(): boolean;
            isInBlobCode(): boolean;
            isInBlobData(): boolean;
            isInBlobOops(): boolean;
            isInBlobUnknownLocation(): boolean;
            isInCodeCache(): boolean;
            isInHeap(): boolean;
            isInInterpreter(): boolean;
            isInJavaStack(): boolean;
            isInLocalJNIHandleBlock(): boolean;
            isInNewGen(): boolean;
            isInOldGen(): boolean;
            isInStrongGlobalJNIHandles(): boolean;
            isInTLAB(): boolean;
            isInWeakGlobalJNIHandles(): boolean;
            isMetadata(): boolean;
            isNativeSymbol(): boolean;
            isUnknown(): boolean;
            print(): void;
            print(printAddress: boolean, verbose: boolean): void;
            printOn(tty: java.io.PrintStream): void;
            printOn(tty: java.io.PrintStream, printAddress: boolean, verbose: boolean): void;
            toString(): string;
            _addr: hotspot.debugger.Address;
            _blob: hotspot.code.CodeBlob;
            _ctype: hotspot.types.Type;
            _gen: hotspot.gc.shared.Generation;
            _handleBlock: hotspot.runtime.JNIHandleBlock;
            _handleThread: hotspot.runtime.Thread;
            _heap: hotspot.gc.shared.CollectedHeap;
            _inBlobCode: boolean;
            _inBlobData: boolean;
            _inBlobOops: boolean;
            _inBlobUnknownLocation: boolean;
            _inCodeCache: boolean;
            _inInterpreter: boolean;
            _inLocalJNIHandleBlock: boolean;
            _inStrongGlobalJNIHandles: boolean;
            _inTLAB: boolean;
            _inWeakGlobalJNIHandles: boolean;
            _interpreterCodelet: hotspot.interpreter.InterpreterCodelet;
            _loadObject: hotspot.debugger.cdbg.LoadObject;
            _metadata: hotspot.oops.Metadata;
            _nativeSymbol: hotspot.debugger.cdbg.ClosestSymbol;
            _stackThread: hotspot.runtime.JavaThread;
            _tlab: hotspot.runtime.ThreadLocalAllocBuffer;
            _tlabThread: hotspot.runtime.JavaThread;
          }
          interface PointerLocation extends CombineTypes<[_PointerLocation, java.lang.Object]> {}
          interface _ProcImageClassLoader$$static extends ClassLike {
            new(parent: java.lang.ClassLoader): ProcImageClassLoader;
            new(): ProcImageClassLoader;
          }
          let ProcImageClassLoader: _ProcImageClassLoader$$static;
          interface _ProcImageClassLoader {
            _findClass(className: string): java.lang.Class;
          }
          interface ProcImageClassLoader extends CombineTypes<[_ProcImageClassLoader, java.lang.ClassLoader]> {}
          interface _ProgressiveHeapVisitor$$static extends ClassLike {
            _MINIMUM_NOTIFICATION_FRACTION: double;
            new(userHeapVisitor: hotspot.oops.HeapVisitor, thunk: HeapProgressThunk): ProgressiveHeapVisitor;
          }
          let ProgressiveHeapVisitor: _ProgressiveHeapVisitor$$static;
          interface _ProgressiveHeapVisitor {
            doObj(obj: hotspot.oops.Oop): boolean;
            epilogue(): void;
            prologue(usedSize: long): void;
            _lastNotificationFraction: double;
            _thunk: HeapProgressThunk;
            _usedSize: long;
            _userHeapVisitor: hotspot.oops.HeapVisitor;
            _visitedSize: long;
          }
          interface ProgressiveHeapVisitor extends CombineTypes<[_ProgressiveHeapVisitor, java.lang.Object, sun.jvm.hotspot.oops.HeapVisitor]> {}
          interface _RBColor$$static extends ClassLike {
            readonly BLACK: RBColor;
            readonly RED: RBColor;
          }
          let RBColor: _RBColor$$static;
          interface _RBColor {
            getName(): string;
            _name: string;
          }
          interface RBColor extends CombineTypes<[_RBColor, java.lang.Object]> {}
          interface _RBNode$$static extends ClassLike {
            new(data: any): RBNode;
          }
          let RBNode: _RBNode$$static;
          interface _RBNode {
            copyFrom(arg: RBNode): void;
            getColor(): RBColor;
            getData(): any;
            getLeft(): RBNode;
            getParent(): RBNode;
            getRight(): RBNode;
            setColor(color: RBColor): void;
            setLeft(left: RBNode): void;
            setParent(parent: RBNode): void;
            setRight(right: RBNode): void;
            update(): boolean;
            _color: RBColor;
            _data: any;
            _left: RBNode;
            _parent: RBNode;
            _right: RBNode;
          }
          interface RBNode extends CombineTypes<[_RBNode, java.lang.Object]> {}
          interface _RBTree$$static extends ClassLike {
            main(args: string[]): void;
            _DEBUGGING: boolean;
            _REALLY_VERBOSE: boolean;
            _VERBOSE: boolean;
            new(comparator: java.util.Comparator<any>): RBTree;
          }
          let RBTree: _RBTree$$static;
          interface _RBTree {
            _deleteFixup(x: RBNode, xParent: RBNode): void;
            deleteNode(z: RBNode): void;
            _getNodeValue(node: RBNode): any;
            getRoot(): RBNode;
            insertNode(x: RBNode): void;
            _leftRotate(x: RBNode): boolean;
            print(): void;
            _printFromNode(node: RBNode, tty: java.io.PrintStream, indentDepth: int): void;
            printOn(tty: java.io.PrintStream): void;
            _rightRotate(y: RBNode): boolean;
            _treeInsert(z: RBNode): void;
            _treeMinimum(x: RBNode): RBNode;
            _treeSuccessor(x: RBNode): RBNode;
            _verify(): void;
            _verifyFromNode(node: RBNode): int;
            _comparator: java.util.Comparator<any>;
            _root: RBNode;
          }
          interface RBTree extends CombineTypes<[_RBTree, java.lang.Object]> {}
          interface _ReversePtrs$$static extends ClassLike {
            new(): ReversePtrs;
          }
          let ReversePtrs: _ReversePtrs$$static;
          interface _ReversePtrs {
            get(obj: hotspot.oops.Oop): java.util.ArrayList<LivenessPathElement>;
            put(from: LivenessPathElement, to: hotspot.oops.Oop): void;
            _rp: java.util.HashMap<hotspot.oops.Oop,java.util.ArrayList<LivenessPathElement>>;
          }
          interface ReversePtrs extends CombineTypes<[_ReversePtrs, java.lang.Object]> {}
          interface _ReversePtrsAnalysis$$static extends ClassLike {
            _DEBUG: boolean;
            _MINIMUM_NOTIFICATION_FRACTION: double;
            new(): ReversePtrsAnalysis;
          }
          let ReversePtrsAnalysis: _ReversePtrsAnalysis$$static;
          interface _ReversePtrsAnalysis {
            _doJNIHandleBlock(handles: hotspot.runtime.JNIHandleBlock, oopVisitor: hotspot.runtime.AddressVisitor): void;
            _doOopStorage(oopSet: hotspot.gc.shared.OopStorage, oopVisitor: hotspot.runtime.AddressVisitor): void;
            _doStack(thread: hotspot.runtime.JavaThread, oopVisitor: hotspot.runtime.AddressVisitor): void;
            _markAndTraverse(handle: hotspot.debugger.OopHandle): void;
            _markAndTraverse(obj: hotspot.oops.Oop): void;
            _printHeader(): void;
            run(): void;
            setHeapProgressThunk(thunk: HeapProgressThunk): void;
            _depth: int;
            _heap: hotspot.oops.ObjectHeap;
            _lastNotificationFraction: double;
            _markBits: MarkBits;
            _progressThunk: HeapProgressThunk;
            _rp: ReversePtrs;
            _usedSize: long;
            _visitedSize: long;
          }
          interface ReversePtrsAnalysis extends CombineTypes<[_ReversePtrsAnalysis, java.lang.Object]> {}
          interface _ReversePtrsAnalysis$RootVisitor$$static extends ClassLike {
            _new(this$0: ReversePtrsAnalysis, baseRootDescription: string): ReversePtrsAnalysis$RootVisitor;
          }
          let ReversePtrsAnalysis$RootVisitor: _ReversePtrsAnalysis$RootVisitor$$static;
          interface _ReversePtrsAnalysis$RootVisitor {
            visitAddress(addr: hotspot.debugger.Address): void;
            visitCompOopAddress(addr: hotspot.debugger.Address): void;
            _baseRootDescription: string;
            _this$0: ReversePtrsAnalysis;
          }
          interface ReversePtrsAnalysis$RootVisitor extends CombineTypes<[_ReversePtrsAnalysis$RootVisitor, sun.jvm.hotspot.runtime.AddressVisitor, java.lang.Object]> {}
          interface _RobustOopDeterminator$$static extends ClassLike {
            _initialize(db: hotspot.types.TypeDataBase): void;
            oopLooksValid(oop: hotspot.debugger.OopHandle): boolean;
            _klassField: hotspot.types.AddressField;
            new(): RobustOopDeterminator;
          }
          let RobustOopDeterminator: _RobustOopDeterminator$$static;
          interface _RobustOopDeterminator {
          }
          interface RobustOopDeterminator extends CombineTypes<[_RobustOopDeterminator, java.lang.Object]> {}
          interface _StreamMonitor$$static extends ClassLike {
            new(istr: java.io.InputStream): StreamMonitor;
            new(istr: java.io.InputStream, prefixString: string, printContents: boolean): StreamMonitor;
          }
          let StreamMonitor: _StreamMonitor$$static;
          interface _StreamMonitor {
            addTrigger(str: string, value: int): boolean;
            addTrigger(strs: string[], value: int): boolean;
            getTriggersSeen(): java.util.List<int>;
            removeTrigger(str: string): boolean;
            removeTrigger(strs: string[]): boolean;
            run(): void;
            startCapture(): void;
            stopCapture(): string;
            waitFor(str: string, millis: long): boolean;
            _captureBuffer: utilities$stringBuffer;
            _input: java.io.BufferedReader;
            _prefixString: string;
            _printContents: boolean;
            _printStreamContents: boolean;
            _triggers: java.util.List<StreamMonitor$Trigger>;
            _triggersSeen: java.util.List<int>;
            _waitString: string;
            _waitStringSeen: boolean;
          }
          interface StreamMonitor extends CombineTypes<[_StreamMonitor, java.lang.Object, java.lang.Runnable]> {}
          interface _StreamMonitor$Trigger$$static extends ClassLike {
            _new(this$0: StreamMonitor, str: string, val: int): StreamMonitor$Trigger;
            _new(this$0: StreamMonitor, strs: string[], val: int): StreamMonitor$Trigger;
          }
          let StreamMonitor$Trigger: _StreamMonitor$Trigger$$static;
          interface _StreamMonitor$Trigger {
            _equals(strs: string[]): boolean;
            _matches(str: string): boolean;
            _triggerStrings: string[];
            _triggerVal: int;
          }
          interface StreamMonitor$Trigger extends CombineTypes<[_StreamMonitor$Trigger, java.lang.Object]> {}
          interface _SystemDictionaryHelper$$static extends ClassLike {
            findInstanceKlass(className: string): hotspot.oops.InstanceKlass;
            findInstanceKlasses(namePart: string): hotspot.oops.InstanceKlass[];
            getAllInstanceKlasses(): hotspot.oops.InstanceKlass[];
            _initialize(): void;
            _klasses: hotspot.oops.InstanceKlass[];
            new(): SystemDictionaryHelper;
          }
          let SystemDictionaryHelper: _SystemDictionaryHelper$$static;
          interface _SystemDictionaryHelper {
          }
          interface SystemDictionaryHelper extends CombineTypes<[_SystemDictionaryHelper, java.lang.Object]> {}
          interface _U1Array$$static extends ClassLike {
            _initialize(db: hotspot.types.TypeDataBase): void;
            _dataFieldOffset: long;
            _elemType: hotspot.types.Type;
            new(addr: hotspot.debugger.Address): U1Array;
          }
          let U1Array: _U1Array$$static;
          interface _U1Array {
            at(i: int): byte;
            getElemType(): hotspot.types.Type;
          }
          interface U1Array extends CombineTypes<[_U1Array, sun.jvm.hotspot.utilities.GenericArray]> {}
          interface _U2Array$$static extends ClassLike {
            _initialize(db: hotspot.types.TypeDataBase): void;
            _dataFieldOffset: long;
            _elemType: hotspot.types.Type;
            new(addr: hotspot.debugger.Address): U2Array;
          }
          let U2Array: _U2Array$$static;
          interface _U2Array {
            at(i: int): short;
            getElemType(): hotspot.types.Type;
          }
          interface U2Array extends CombineTypes<[_U2Array, sun.jvm.hotspot.utilities.GenericArray]> {}
          interface _Unsigned5$$static extends ClassLike {
            decodeSign(value: int): int;
            encodeSign(value: int): int;
            readUint<ARR>(base: ARR, position: int, getByte: Unsigned5$GetByte<ARR>, setPosition: Unsigned5$SetPosition<ARR>): long;
            readonly BitsPerByte: int;
            _H: int;
            _L: int;
            readonly LogBitsPerByte: int;
            readonly MAX_LENGTH: int;
            _MAX_b: int;
            _X: int;
            _lg_H: int;
            new(base: hotspot.debugger.Address): Unsigned5;
            new(base: hotspot.debugger.Address, limit: int): Unsigned5;
          }
          let Unsigned5: _Unsigned5$$static;
          interface _Unsigned5 {
            base(): hotspot.debugger.Address;
            dump(count: int): void;
            dump(): void;
            dumpOn(tty: java.io.PrintStream, count: int): void;
            getByte(pos: int): short;
            _hasNext(pos: int): boolean;
            print(): void;
            printOn(tty: java.io.PrintStream): void;
            readUint(pos: int): long;
            _base: hotspot.debugger.Address;
            _limit: int;
          }
          interface Unsigned5 extends CombineTypes<[_Unsigned5, java.lang.Object]> {}
          interface _Unsigned5$GetByte$$static<ARR> extends ClassLike {
          }
          let Unsigned5$GetByte: _Unsigned5$GetByte$$static<ARR>;
          interface _Unsigned5$GetByte<ARR> {
            getByte(a0: ARR, a1: int): short;
(a0: ARR, a1: int): short;
          }
          interface Unsigned5$GetByte<ARR> extends CombineTypes<[_Unsigned5$GetByte<ARR>, java.lang.Object]> {}
          interface _Unsigned5$Reader$$static extends ClassLike {
            new(this$0: Unsigned5): Unsigned5$Reader;
          }
          let Unsigned5$Reader: _Unsigned5$Reader$$static;
          interface _Unsigned5$Reader {
            _getByte(pos: int): short;
            hasNext(): boolean;
            nextUint(): long;
            position(): int;
            setPosition(pos: int): void;
            _position: int;
            _this$0: Unsigned5;
          }
          interface Unsigned5$Reader extends CombineTypes<[_Unsigned5$Reader, java.lang.Object]> {}
          interface _Unsigned5$SetPosition$$static<ARR> extends ClassLike {
          }
          let Unsigned5$SetPosition: _Unsigned5$SetPosition$$static<ARR>;
          interface _Unsigned5$SetPosition<ARR> {
            setPosition(a0: ARR, a1: int): void;
(a0: ARR, a1: int): void;
          }
          interface Unsigned5$SetPosition<ARR> extends CombineTypes<[_Unsigned5$SetPosition<ARR>, java.lang.Object]> {}
          interface _UnsupportedPlatformException$$static extends ClassLike {
            new(): UnsupportedPlatformException;
            new(message: string): UnsupportedPlatformException;
          }
          let UnsupportedPlatformException: _UnsupportedPlatformException$$static;
          interface _UnsupportedPlatformException {
          }
          interface UnsupportedPlatformException extends CombineTypes<[_UnsupportedPlatformException, java.lang.RuntimeException]> {}
          interface _WorkerThread$$static extends ClassLike {
            new(): WorkerThread;
          }
          let WorkerThread: _WorkerThread$$static;
          interface _WorkerThread {
            invokeLater(runnable: java.lang.Runnable): void;
            shutdown(): void;
            _done: boolean;
            _mq: MessageQueue;
            _mqb: MessageQueueBackend;
          }
          interface WorkerThread extends CombineTypes<[_WorkerThread, java.lang.Object]> {}
          interface _WorkerThread$MainLoop$$static extends ClassLike {
            new(this$0: WorkerThread): WorkerThread$MainLoop;
          }
          let WorkerThread$MainLoop: _WorkerThread$MainLoop$$static;
          interface _WorkerThread$MainLoop {
            run(): void;
            _myMq: MessageQueue;
            _this$0: WorkerThread;
          }
          interface WorkerThread$MainLoop extends CombineTypes<[_WorkerThread$MainLoop, java.lang.Object, java.lang.Runnable]> {}
        }
        interface _BsdVtblAccess$$static extends ClassLike {
          new(symbolLookup: hotspot.debugger.SymbolLookup, dllNames: string[]): BsdVtblAccess;
        }
        let BsdVtblAccess: _BsdVtblAccess$$static;
        interface _BsdVtblAccess {
          _vtblSymbolForType(type: hotspot.types.Type): string;
          _vt: string;
        }
        interface BsdVtblAccess extends CombineTypes<[_BsdVtblAccess, sun.jvm.hotspot.types.basic.BasicVtblAccess]> {}
        interface _CLHSDB$$static extends ClassLike {
          main(args: string[]): void;
          new(d: hotspot.debugger.JVMDebugger): CLHSDB;
        }
        let CLHSDB: _CLHSDB$$static;
        interface _CLHSDB {
          _attachDebugger(d: hotspot.debugger.JVMDebugger): void;
          _attachDebugger(pid: int): void;
          _attachDebugger(executablePath: string, corePath: string): void;
          _connect(debugServerName: string): void;
          _detach(): void;
          _detachDebugger(): void;
          _doUsage(): void;
          _formatMessage(message: string, charsPerLine: int): string;
          run(): void;
          _agent: HotSpotAgent;
          _attached: boolean;
          _coreFilename: string;
          _debugServerName: string;
          _execPath: string;
          _jvmDebugger: debugger.JVMDebugger;
          _pid: int;
        }
        interface CLHSDB extends CombineTypes<[_CLHSDB, java.lang.Object]> {}
        interface _CommandProcessor$$static extends ClassLike {
          _historyPattern: java.util.regex.Pattern;
          new(debugger: CommandProcessor$DebuggerInterface, _in: java.io.BufferedReader, out: java.io.PrintStream, err: java.io.PrintStream): CommandProcessor;
        }
        let CommandProcessor: _CommandProcessor$$static;
        interface _CommandProcessor {
          _dumpFields(type: hotspot.types.Type): void;
          _dumpFields(type: hotspot.types.Type, allowStatic: boolean): void;
          _dumpType(type: hotspot.types.Type): void;
          executeCommand(ln: string, putInHistory: boolean): void;
          _executeCommand(args: CommandProcessor$Tokens): void;
          _fillHexString(a: hotspot.debugger.Address, width: int): string;
          _findCommand(key: string): CommandProcessor$Command;
          _lookup(symbol: string): hotspot.debugger.Address;
          _parseAddress(addr: string): hotspot.debugger.Address;
          _parseAddressRange(arg: string, formatSize: int): CommandProcessor$AddressRange;
          _parseHeapDumpCompressionLevel(option: string): int;
          _postAttach(): void;
          _preAttach(): void;
          printPrompt(): void;
          _quote(s: string): void;
          run(prompt: boolean): void;
          setErr(e: java.io.PrintStream): void;
          setOutput(o: java.io.PrintStream): void;
          _agent: HotSpotAgent;
          _commandList: CommandProcessor$Command[];
          _commands: java.util.HashMap<string,CommandProcessor$Command>;
          _debugger: CommandProcessor$DebuggerInterface;
          _doEcho: boolean;
          _err: java.io.PrintStream;
          _history: java.util.ArrayList<string>;
          _in: java.io.BufferedReader;
          _out: java.io.PrintStream;
          _quit: boolean;
          _verboseExceptions: boolean;
        }
        interface CommandProcessor extends CombineTypes<[_CommandProcessor, java.lang.Object]> {}
        interface _CommandProcessor$AddressRange$$static extends ClassLike {
          _new(this$0: CommandProcessor, start: hotspot.debugger.Address, end: hotspot.debugger.Address): CommandProcessor$AddressRange;
        }
        let CommandProcessor$AddressRange: _CommandProcessor$AddressRange$$static;
        interface _CommandProcessor$AddressRange {
          _getEnd(): hotspot.debugger.Address;
          _getStart(): hotspot.debugger.Address;
          _end: debugger.Address;
          _start: debugger.Address;
        }
        interface CommandProcessor$AddressRange extends CombineTypes<[_CommandProcessor$AddressRange, java.lang.Object]> {}
        interface _CommandProcessor$BootFilter$$static extends ClassLike {
          new(): CommandProcessor$BootFilter;
        }
        let CommandProcessor$BootFilter: _CommandProcessor$BootFilter$$static;
        interface _CommandProcessor$BootFilter {
          canInclude(kls: hotspot.oops.InstanceKlass): boolean;
        }
        interface CommandProcessor$BootFilter extends CombineTypes<[_CommandProcessor$BootFilter, sun.jvm.hotspot.tools.jcore.ClassFilter, java.lang.Object]> {}
        interface _CommandProcessor$Command$$static extends ClassLike {
          _new(this$0: CommandProcessor, n: string, u: string, ok: boolean): CommandProcessor$Command;
          _new(this$0: CommandProcessor, n: string, ok: boolean): CommandProcessor$Command;
        }
        let CommandProcessor$Command: _CommandProcessor$Command$$static;
        interface _CommandProcessor$Command {
          _doit(a0: CommandProcessor$Tokens): void;
(a0: CommandProcessor$Tokens): void;
          _printNode(node: hotspot.ui.tree.SimpleTreeNode): void;
          _usage(): void;
          _name: string;
          _okIfDisconnected: boolean;
          _this$0: CommandProcessor;
          _usage: string;
        }
        interface CommandProcessor$Command extends CombineTypes<[_CommandProcessor$Command, java.lang.Object]> {}
        interface _CommandProcessor$DebuggerInterface$$static extends ClassLike {
          new(): CommandProcessor$DebuggerInterface;
        }
        let CommandProcessor$DebuggerInterface: _CommandProcessor$DebuggerInterface$$static;
        interface _CommandProcessor$DebuggerInterface {
          attach(a0: int): void;
          attach(a0: string, a1: string): void;
          attach(a0: string): void;
          detach(): void;
          getAgent(): HotSpotAgent;
          isAttached(): boolean;
          reattach(): void;
        }
        interface CommandProcessor$DebuggerInterface extends CombineTypes<[_CommandProcessor$DebuggerInterface, java.lang.Object]> {}
        interface _CommandProcessor$NonBootFilter$$static extends ClassLike {
          new(): CommandProcessor$NonBootFilter;
        }
        let CommandProcessor$NonBootFilter: _CommandProcessor$NonBootFilter$$static;
        interface _CommandProcessor$NonBootFilter {
          canInclude(kls: hotspot.oops.InstanceKlass): boolean;
          _emitted: java.util.HashMap<oops.Symbol,oops.InstanceKlass>;
        }
        interface CommandProcessor$NonBootFilter extends CombineTypes<[_CommandProcessor$NonBootFilter, sun.jvm.hotspot.tools.jcore.ClassFilter, java.lang.Object]> {}
        interface _CommandProcessor$Tokens$$static extends ClassLike {
          _new(cmd: string): CommandProcessor$Tokens;
        }
        let CommandProcessor$Tokens: _CommandProcessor$Tokens$$static;
        interface _CommandProcessor$Tokens {
          _add(s: string, t: java.util.ArrayList<string>): void;
          _at(i: int): string;
          _countTokens(): int;
          _hasMoreTokens(): boolean;
          _join(sep: string): string;
          _nextToken(): string;
          _splitWhitespace(cmd: string): string[];
          _trim(n: int): void;
          _i: int;
          _input: string;
          _length: int;
          _tokens: string[];
        }
        interface CommandProcessor$Tokens extends CombineTypes<[_CommandProcessor$Tokens, java.lang.Object]> {}
        interface _DebugServer$$static extends ClassLike {
          main(args: string[]): void;
          new(): DebugServer;
        }
        let DebugServer: _DebugServer$$static;
        interface _DebugServer {
          _run(args: string[]): void;
          _usage(): void;
        }
        interface DebugServer extends CombineTypes<[_DebugServer, java.lang.Object]> {}
        interface _HSDB$$static extends ClassLike {
          _createMenuItem(name: string, l: java.awt.event.ActionListener): javax.swing.JMenuItem;
          _dumpStack(cur: hotspot.runtime.JavaThread): void;
          _getLastJavaVFrame(cur: hotspot.runtime.JavaThread): hotspot.runtime.JavaVFrame;
          main(args: string[]): void;
          new(d: hotspot.debugger.JVMDebugger): HSDB;
        }
        let HSDB: _HSDB$$static;
        interface _HSDB {
          _attach(d: hotspot.debugger.JVMDebugger): void;
          _attach(pid: int): void;
          _attach(executablePath: string, corePath: string): void;
          _connect(debugServerName: string): void;
          _detach(): void;
          _detachDebugger(): void;
          _doHeapIteration(frameTitle: string, progressBarText: string, visitor: hotspot.oops.HeapVisitor, cleanup: HSDB$CleanupThunk): void;
          _doUsage(): void;
          _fireComputeReversePtrs(): void;
          _formatMessage(message: string, charsPerLine: int): string;
          run(): void;
          _setMenuItemsEnabled(items: java.util.List<javax.swing.JMenuItem>, enabled: boolean): void;
          showAnnotatedMemoryViewer(): void;
          _showAttachDialog(): void;
          showClassBrowser(): void;
          showCodeViewer(): void;
          showCodeViewer(address: hotspot.debugger.Address): void;
          showCommandLineFlags(): void;
          _showConnectDialog(): void;
          _showConsole(): void;
          _showDeadlockDetectionPanel(): void;
          _showDebuggerConsole(): void;
          _showFindInCodeCachePanel(): void;
          _showFindInHeapPanel(): void;
          _showFindPanel(): void;
          _showHeapParametersPanel(): void;
          showInspector(adapter: hotspot.ui.tree.SimpleTreeNode): void;
          showJavaStackTrace(thread: hotspot.runtime.JavaThread): void;
          showLiveness(oop: hotspot.oops.Oop, liveness: hotspot.utilities.LivenessPathList): void;
          showMemoryViewer(): void;
          _showMonitorCacheDumpPanel(): void;
          _showObjectHistogram(): void;
          showObjectsOfType(type: hotspot.oops.Klass): void;
          _showOpenCoreFileDialog(): void;
          _showPanel(name: string, panel: javax.swing.JPanel): void;
          _showPanel(name: string, panel: javax.swing.JPanel, aspectRatio: float, fillRatio: float): void;
          showSystemProperties(): void;
          showThreadInfo(thread: hotspot.runtime.JavaThread): void;
          showThreadOopInspector(thread: hotspot.runtime.JavaThread): void;
          showThreadStackMemory(thread: hotspot.runtime.JavaThread): void;
          _showThreadsDialog(): void;
          showVMVersion(): void;
          _agent: HotSpotAgent;
          _argError: boolean;
          _attachMenuItems: java.util.List<javax.swing.JMenuItem>;
          _attachWaitDialog: javax.swing.JInternalFrame;
          _attached: boolean;
          _computeRevPtrsMenuItem: javax.swing.JMenuItem;
          _consoleFrame: javax.swing.JInternalFrame;
          _coreFilename: string;
          _debugServerName: string;
          _desktop: javax.swing.JDesktopPane;
          _detachMenuItems: java.util.List<javax.swing.JMenuItem>;
          _execPath: string;
          _frame: javax.swing.JFrame;
          _jvmDebugger: debugger.JVMDebugger;
          _pid: int;
          _showDbgConsoleMenuItem: javax.swing.JMenuItem;
          _threadsFrame: javax.swing.JInternalFrame;
          _toolsMenu: javax.swing.JMenu;
          _workerThread: utilities.WorkerThread;
        }
        interface HSDB extends CombineTypes<[_HSDB, sun.jvm.hotspot.ui.ObjectHistogramPanel$Listener, sun.jvm.hotspot.ui.SAListener, java.lang.Object]> {}
        interface _HSDB$CleanupThunk$$static extends ClassLike {
        }
        let HSDB$CleanupThunk: _HSDB$CleanupThunk$$static;
        interface _HSDB$CleanupThunk {
          heapIterationComplete(): void;
(): void;
        }
        interface HSDB$CleanupThunk extends CombineTypes<[_HSDB$CleanupThunk, java.lang.Object]> {}
        interface _HSDB$CloseUI$$static extends ClassLike {
        }
        let HSDB$CloseUI: _HSDB$CloseUI$$static;
        interface _HSDB$CloseUI {
          windowClosing(e: java.awt.event.WindowEvent): void;
          _this$0: HSDB;
        }
        interface HSDB$CloseUI extends CombineTypes<[_HSDB$CloseUI, java.awt.event.WindowAdapter]> {}
        interface _HSDB$FindObjectByTypeCleanupThunk$$static extends ClassLike {
          _new(this$0: HSDB, finder: hotspot.utilities.FindObjectByType): HSDB$FindObjectByTypeCleanupThunk;
        }
        let HSDB$FindObjectByTypeCleanupThunk: _HSDB$FindObjectByTypeCleanupThunk$$static;
        interface _HSDB$FindObjectByTypeCleanupThunk {
          heapIterationComplete(): void;
          _finder: utilities.FindObjectByType;
          _this$0: HSDB;
        }
        interface HSDB$FindObjectByTypeCleanupThunk extends CombineTypes<[_HSDB$FindObjectByTypeCleanupThunk, java.lang.Object, sun.jvm.hotspot.HSDB$CleanupThunk]> {}
        interface _HSDB$HeapProgress$$static extends ClassLike {
          _new(this$0: HSDB, windowTitle: string): HSDB$HeapProgress;
          _new(this$0: HSDB, windowTitle: string, progressBarTitle: string): HSDB$HeapProgress;
          _new(this$0: HSDB, windowTitle: string, progressBarTitle: string, cleanup: HSDB$CleanupThunk): HSDB$HeapProgress;
        }
        let HSDB$HeapProgress: _HSDB$HeapProgress$$static;
        interface _HSDB$HeapProgress {
          heapIterationComplete(): void;
          heapIterationFractionUpdate(fractionOfHeapVisited: double): void;
          _bar: ui.ProgressBarPanel;
          _cleanup: HSDB$CleanupThunk;
          _frame: javax.swing.JInternalFrame;
          _progressBarTitle: string;
          _this$0: HSDB;
          _windowTitle: string;
        }
        interface HSDB$HeapProgress extends CombineTypes<[_HSDB$HeapProgress, sun.jvm.hotspot.utilities.HeapProgressThunk, java.lang.Object]> {}
        interface _HSDB$ObjectHistogramCleanupThunk$$static extends ClassLike {
          _new(this$0: HSDB, histo: hotspot.oops.ObjectHistogram): HSDB$ObjectHistogramCleanupThunk;
        }
        let HSDB$ObjectHistogramCleanupThunk: _HSDB$ObjectHistogramCleanupThunk$$static;
        interface _HSDB$ObjectHistogramCleanupThunk {
          heapIterationComplete(): void;
          _histo: oops.ObjectHistogram;
          _this$0: HSDB;
        }
        interface HSDB$ObjectHistogramCleanupThunk extends CombineTypes<[_HSDB$ObjectHistogramCleanupThunk, java.lang.Object, sun.jvm.hotspot.HSDB$CleanupThunk]> {}
        interface _HSDB$SignalInfo$$static extends ClassLike {
          _new(this$0: HSDB): HSDB$SignalInfo;
        }
        let HSDB$SignalInfo: _HSDB$SignalInfo$$static;
        interface _HSDB$SignalInfo {
          sigName: string;
          sigNum: int;
        }
        interface HSDB$SignalInfo extends CombineTypes<[_HSDB$SignalInfo, java.lang.Object]> {}
        interface _HSDB$StackWalker$$static extends ClassLike {
          _new(this$0: HSDB, vf: hotspot.runtime.JavaVFrame, annoPanel: hotspot.ui.AnnotatedMemoryPanel): HSDB$StackWalker;
        }
        let HSDB$StackWalker: _HSDB$StackWalker$$static;
        interface _HSDB$StackWalker {
          _annoPanel: ui.AnnotatedMemoryPanel;
          _vf: runtime.JavaVFrame;
        }
        interface HSDB$StackWalker extends CombineTypes<[_HSDB$StackWalker, java.lang.Object, java.lang.Runnable]> {}
        interface _HSDB$VisitHeap$$static extends ClassLike {
          _new(this$0: HSDB, visitor: hotspot.oops.HeapVisitor): HSDB$VisitHeap;
        }
        let HSDB$VisitHeap: _HSDB$VisitHeap$$static;
        interface _HSDB$VisitHeap {
          run(): void;
          _visitor: oops.HeapVisitor;
        }
        interface HSDB$VisitHeap extends CombineTypes<[_HSDB$VisitHeap, java.lang.Object, java.lang.Runnable]> {}
        interface _HelloWorld$$static extends ClassLike {
          _a(): int;
          _b(): int;
          _c(): int;
          _d(x: string): int;
          e(): int;
          fib(n: int): int;
          main(args: string[]): void;
          _helloWorldString: string;
          _helloWorldTrigger: int;
          _lock: any;
          _useMethodInvoke: boolean;
          new(): HelloWorld;
        }
        let HelloWorld: _HelloWorld$$static;
        interface _HelloWorld {
        }
        interface HelloWorld extends CombineTypes<[_HelloWorld, java.lang.Object]> {}
        interface _HotSpotAgent$$static extends ClassLike {
          _showUsage(): void;
          readonly CORE_FILE_MODE: int;
          readonly PROCESS_MODE: int;
          readonly REMOTE_MODE: int;
          new(): HotSpotAgent;
        }
        let HotSpotAgent: _HotSpotAgent$$static;
        interface _HotSpotAgent {
          attach(processID: int): void;
          attach(javaExecutableName: string, coreFileName: string): void;
          attach(d: hotspot.debugger.JVMDebugger): void;
          attach(remoteServerID: string): void;
          _attachDebugger(): void;
          _connectRemoteDebugger(): void;
          detach(): boolean;
          _detachInternal(): boolean;
          getDebugger(): hotspot.debugger.JVMDebugger;
          getStartupMode(): int;
          getTypeDataBase(): hotspot.types.TypeDataBase;
          _go(): void;
          _setupDebugger(): void;
          _setupDebuggerAlternate(alternateName: string): void;
          _setupDebuggerBsd(): void;
          _setupDebuggerDarwin(): void;
          _setupDebuggerExisting(): void;
          _setupDebuggerLinux(): void;
          _setupDebuggerWin32(): void;
          _setupJVMLibNames(os: string): void;
          _setupJVMLibNamesBsd(): void;
          _setupJVMLibNamesDarwin(): void;
          _setupJVMLibNamesLinux(): void;
          _setupJVMLibNamesWin32(): void;
          _setupVM(): void;
          shutdownServer(): boolean;
          startServer(processID: int, serverID: string, serverName: string, rmiPort: int): void;
          startServer(processID: int, serverID: string, serverName: string): void;
          startServer(processID: int): void;
          startServer(javaExecutableName: string, coreFileName: string, serverID: string, serverName: string, rmiPort: int): void;
          startServer(javaExecutableName: string, coreFileName: string, serverID: string, serverName: string): void;
          startServer(javaExecutableName: string, coreFileName: string): void;
          _coreFileName: string;
          _cpu: string;
          _db: types.TypeDataBase;
          _debugServerID: string;
          _debugger: debugger.JVMDebugger;
          _isServer: boolean;
          _javaExecutableName: string;
          _jvmLibNames: string[];
          _machDesc: debugger.MachineDescription;
          _os: string;
          _pid: int;
          _rmiPort: int;
          _serverID: string;
          _serverName: string;
          _startupMode: int;
        }
        interface HotSpotAgent extends CombineTypes<[_HotSpotAgent, java.lang.Object]> {}
        interface _HotSpotTypeDataBase$$static extends ClassLike {
          _C_INT32_SIZE: int;
          _C_INT64_SIZE: int;
          _C_INT8_SIZE: int;
          _DEBUG: boolean;
          _MAX_DUPLICATE_DEFINITIONS: int;
          _UNINITIALIZED_SIZE: int;
          _pointerSize: int;
          new(machDesc: hotspot.debugger.MachineDescription, vtblAccess: hotspot.types.basic.VtblAccess, symbolLookup: hotspot.debugger.Debugger, jvmLibNames: string[]): HotSpotTypeDataBase;
        }
        let HotSpotTypeDataBase: _HotSpotTypeDataBase$$static;
        interface _HotSpotTypeDataBase {
          _createBasicType(typeName: string, isOopType: boolean, isIntegerType: boolean, isUnsigned: boolean): hotspot.types.basic.BasicType;
          createField(containingType: hotspot.types.basic.BasicType, name: string, type: hotspot.types.Type, isStatic: boolean, offset: long, a5: hotspot.debugger.Address): void;
          createType(typeName: string, superclassName: string, isOopType: boolean, isIntegerType: boolean, isUnsigned: boolean, size: long): void;
          _dumpMemory(addr: hotspot.debugger.Address, len: int): void;
          _getLongValueFromProcess(symbol: string): long;
          _initializePrimitiveTypes(): void;
          _internalCreateField(containingType: hotspot.types.basic.BasicType, name: string, type: hotspot.types.Type, isStatic: boolean, offset: long, a5: hotspot.debugger.Address): hotspot.types.Field;
          _lookupInProcess(symbol: string): hotspot.debugger.Address;
          _lookupOrCreateClass(typeName: string, isOopType: boolean, isIntegerType: boolean, isUnsigned: boolean): hotspot.types.basic.BasicType;
          _lookupOrFail(typeName: string): hotspot.types.basic.BasicType;
          _lookupPrimitiveType(typeName: string): hotspot.types.Type;
          lookupType(cTypeName: string, throwException: boolean): hotspot.types.Type;
          _readExternalDefinitions(): void;
          _readVMIntConstants(): void;
          _readVMLongConstants(): void;
          _readVMStructs(): void;
          _readVMTypes(): void;
          _recursiveCreateBasicPointerType(typeName: string): hotspot.types.basic.BasicPointerType;
          _typeNameIsPointerType(typeName: string): boolean;
          _duplicateDefCount: int;
          _jvmLibNames: string[];
          _symbolLookup: debugger.Debugger;
        }
        interface HotSpotTypeDataBase extends CombineTypes<[_HotSpotTypeDataBase, sun.jvm.hotspot.types.basic.BasicTypeDataBase]> {}
        interface _LinuxVtblAccess$$static extends ClassLike {
          new(symbolLookup: hotspot.debugger.SymbolLookup, dllNames: string[]): LinuxVtblAccess;
        }
        let LinuxVtblAccess: _LinuxVtblAccess$$static;
        interface _LinuxVtblAccess {
          _vtblSymbolForType(type: hotspot.types.Type): string;
          _vt: string;
        }
        interface LinuxVtblAccess extends CombineTypes<[_LinuxVtblAccess, sun.jvm.hotspot.types.basic.BasicVtblAccess]> {}
        interface _ObjectHistogram$$static extends ClassLike {
          main(args: string[]): void;
          new(): ObjectHistogram;
        }
        let ObjectHistogram: _ObjectHistogram$$static;
        interface _ObjectHistogram {
        }
        interface ObjectHistogram extends CombineTypes<[_ObjectHistogram, java.lang.Object]> {}
        interface _RMIHelper$$static extends ClassLike {
          _getName(serverID: string, serverName: string): string;
          lookup(connectionString: string): java.rmi.Remote;
          rebind(serverID: string, serverName: string, object: java.rmi.Remote): void;
          unbind(serverID: string, serverName: string): void;
          _CONNECT_PATTERN: java.util.regex.Pattern;
          _DEFAULT_RMI_OBJECT_NAME: string;
          _port: int;
          _startRegistry: boolean;
          new(): RMIHelper;
        }
        let RMIHelper: _RMIHelper$$static;
        interface _RMIHelper {
        }
        interface RMIHelper extends CombineTypes<[_RMIHelper, java.lang.Object]> {}
        interface _SAGetopt$$static extends ClassLike {
          new(args: string[]): SAGetopt;
        }
        let SAGetopt: _SAGetopt$$static;
        interface _SAGetopt {
          _extractOptarg(opt: string): void;
          getOptarg(): string;
          getOptind(): int;
          next(optStr: string, longOptStr: string[]): string;
          _processLongOptions(carg: string, longOptStr: string[]): string;
          __argv: string[];
          __optarg: string;
          __optind: int;
          __optopt: int;
          __optreset: boolean;
        }
        interface SAGetopt extends CombineTypes<[_SAGetopt, java.lang.Object]> {}
        interface _SAGetoptException$$static extends ClassLike {
          new(message: string): SAGetoptException;
        }
        let SAGetoptException: _SAGetoptException$$static;
        interface _SAGetoptException {
        }
        interface SAGetoptException extends CombineTypes<[_SAGetoptException, java.lang.IllegalArgumentException]> {}
        interface _SALauncher$$static extends ClassLike {
          _buildAttachArgs(newArgMap: java.util.Map<string,string>, allowEmpty: boolean): string[];
          _commonHelp(mode: string): boolean;
          _commonHelp(mode: string, canConnectToRemote: boolean): boolean;
          _commonHelpWithConnect(mode: string): boolean;
          _debugdHelp(): boolean;
          _jinfoHelp(): boolean;
          _jmapHelp(): boolean;
          _jsnapHelp(): boolean;
          _jstackHelp(): boolean;
          _launcherHelp(): boolean;
          main(args: string[]): void;
          _parseOptions(oldArgs: string[], longOptsMap: java.util.Map<string,string>): java.util.Map<string,string>;
          _runCLHSDB(oldArgs: string[]): void;
          _runDEBUGD(args: string[]): void;
          _runHSDB(oldArgs: string[]): void;
          _runJINFO(oldArgs: string[]): void;
          _runJMAP(oldArgs: string[]): void;
          _runJSNAP(oldArgs: string[]): void;
          _runJSTACK(oldArgs: string[]): void;
          _toolHelp(toolName: string): boolean;
          _NO_REMOTE: string;
          _toolMap: java.util.Map<string,java.util.function.Consumer<string[]>>;
          new(): SALauncher;
        }
        let SALauncher: _SALauncher$$static;
        interface _SALauncher {
        }
        interface SALauncher extends CombineTypes<[_SALauncher, java.lang.Object]> {}
        interface _SALauncherLoader$$static extends ClassLike {
          _getClassPath(): java.net.URL[];
          _getClassPath(cp: string): java.io.File[];
          _getFileURL(file: java.io.File): java.net.URL;
          _pathToURLs(path: java.io.File[]): java.net.URL[];
          new(parent: java.lang.ClassLoader): SALauncherLoader;
        }
        let SALauncherLoader: _SALauncherLoader$$static;
        interface _SALauncherLoader {
          findLibrary(name: string): string;
          _getPermissions(codesource: java.security.CodeSource): java.security.PermissionCollection;
          loadClass(name: string, resolve: boolean): java.lang.Class;
          _libpaths: string[];
        }
        interface SALauncherLoader extends CombineTypes<[_SALauncherLoader, java.net.URLClassLoader]> {}
        interface _StackTrace$$static extends ClassLike {
          main(args: string[]): void;
          new(): StackTrace;
        }
        let StackTrace: _StackTrace$$static;
        interface _StackTrace {
        }
        interface StackTrace extends CombineTypes<[_StackTrace, java.lang.Object]> {}
        interface _Win32VtblAccess$$static extends ClassLike {
          new(symbolLookup: hotspot.debugger.SymbolLookup, dllNames: string[]): Win32VtblAccess;
        }
        let Win32VtblAccess: _Win32VtblAccess$$static;
        interface _Win32VtblAccess {
          _vtblSymbolForType(type: hotspot.types.Type): string;
        }
        interface Win32VtblAccess extends CombineTypes<[_Win32VtblAccess, sun.jvm.hotspot.types.basic.BasicVtblAccess]> {}
      }
    }
  }
}
